version: '{build}.{branch}'

skip_branch_with_pr: true

clone_folder: c:\dummy
clone_depth: 1

environment:
  APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017
  DENO_BUILD_MODE: debug
  MOUNT_DIR: c:\image
  DENO_BUILD_PATH: c:\image\deno\out\debug
  DENO_THIRD_PARTY_PATH: c:\image\deno\third_party
  CARGO_HOME: c:\image\cargo
  RUSTUP_HOME: c:\image\rustup

  # Appveyor uses 7zip to pack cache directories. We use these options:
  #   -t7z  : Use '7z' format. The default is 'zip' which can't store symlinks.
  #   -snl  : Store symlinks.
  #   -mtc  : Use UTC timestamps. This is required for incremental builds.
  #   -mx=1 : Fast compression.
  APPVEYOR_CACHE_ENTRY_ZIP_ARGS: -tzip -mx=0

  # Define some PowerShell helper functions which are used in the scripts below.
  # They're defined in an environment variable to reduce noise in the build log.
  PS_UTILS: |-
      # `Exec` runs a regular executable. It looks at the process' exit code,
      # rather than its stderr output, to tell if a command has failed.
      function Exec([ScriptBlock] $Command, [switch] $NoNewLines) {
        "$Command".TrimStart(" &") | Write-Host              # Echo command.
        & $Command 2>&1 | Write-Host -NoNewLine:$NoNewLines  # Execute command.
        if ($NoNewLines) { Write-Host }                      # Write newline.
        if ($LastExitCode -ne 0) { throw "Failure. Exit code: $LastExitCode" }
      }

      # Get-Tree does the same thing as Get-ChildItem. The only difference is
      # that the latter follows symbolic links, and Get-Tree doesn't.
      function Get-Tree([string[]] $Path, [switch] $Recurse, [switch] $Force) {
        function Get-SubDirs([string[]] $Path) {
          Get-ChildItem -Path:$Path -Force:$Force `
                        -Attributes Directory+!ReparsePoint |
            ForEach-Object { $_.FullName }                  |
            ForEach-Object { $_; Get-SubDirs -Path $_ }
        }
        if ($Recurse) { $Path += Get-SubDirs -Path:$Path }
        Get-ChildItem -Path:$Path -Force:$Force @args
      }

      # `Delete-Tree` is a simple wrapper around Remove-Item. It doesn't set
      # an error status if one of the paths to be deleted doesn't exist.
      function Delete-Tree([string[]] $Path) {
        $Path | ForEach-Object {
          "Deleting '$_'" | Write-Host -NoNewLine
          if (Test-Path -Path $_) {
            Remove-Item -Path $_ -Recurse -Force -ErrorAction Ignore
            $(if ($?) { " - ok" } else { " - failed" }) | Write-Host
          } else {
            " - not found" | Write-Host
          }
        }
      }

      # A date in the distant past, used for file usage tracking.
      $never_accessed = Get-Date -Date "1984-01-11T00:00:00Z"  # A good year.
     
      # Start file tracking in order to avoid hoarding old build products.
      function Begin-AntiHoarding([string[]] $Path) {
        # Don't enable if the cache won't be saved.
        if (-not (Get-SaveCache)) { return }
        # Tell Windows to keep track of file access times.
        Exec { & fsutil behavior set DisableLastAccess 0 }
        # If the build directory doesn't exist, it could be that it wasn't
        # restored from the cache. Don't error on nonexisting paths.
        $roots = $Path           |
          Where-Object   { Test-Path -Path $_ }       |
          ForEach-Object { Get-Item -Path $_ -Force } |
          ForEach-Object { $_.FullName }
        # Don't enable if none of the paths subject to anti-hoarding exists.
        if ($roots.Count -eq 0) { return }
        if (-not $global:anti_hoarding_enabled) {
          $global:anti_hoarding_enabled = $true
          $global:stale_files = @{}
          $global:anti_hoarding_roots = @()
        }
        # Store all tracked files in a hash map using their full path as key.
        # Set all tracked files' last access time to very long ago.
        $global:anti_hoarding_roots += $roots
        $roots                                |
          ForEach-Object { Get-Tree -Path $_ -Recurse -Force -File } |
          ForEach-Object { $_.LastAccessTime = $never_accessed
                           $global:stale_files.Add($_.FullName, $true) }
        Write-Host "Now tracking $($global:stale_files.Count) files."
      }

      # Marks files as "not stale".
      #   -Path paths[] : Unconditionally mark files as current. Paths can
      #                   also be provided as pipeline input.
      #   -Auto         : Mark all tracked files for which the last access time
      #                   has changed as current.
      #   -Reason text  : Optional reason, written to the build log.
      function Mark-Current {
        param (
          [parameter(ValueFromPipeLine=$true)][string[]] $Path,
          [switch] $Auto,
          [string] $Reason
        )
        begin {
          $counts = 0, 0  # Tuple of (path_count, auto_count).
          function Mark-Helper([string[]] $Path, [switch] $CheckAccessTime) {
            # Bail out early if anti-hoarding is off.
            if (-not $global:anti_hoarding_enabled) { return }
            $Path                                                             |
              Where-Object   { Test-Path -Path $_ -PathType Leaf }            |
              ForEach-Object { Get-Item -Path $_ -Force }                     |
              Where-Object   { -not $CheckAccessTime -or
                               $_.LastAccessTime -ne $never_accessed }        |
              Where-Object   { $global:stale_files.ContainsKey($_.FullName) } |
              ForEach-Object { $global:stale_files.Remove($_.FullName)
                               $counts[$CheckAccessTime.ToBool()] += 1 }
          }
          # Mark accessed files.
          if ($Auto) {
            Mark-Helper -Path $global:stale_files.Keys -CheckAccessTime
          }
        }
        process {
          # Mark unconditional paths.
          if ($Path) { Mark-Helper -Path:$Path }
        }
        end {
          # Summarily log what we just did.
          $r = if ($Reason) { $Reason + ": " } else { "" }
          $counts[0] | Where-Object { $_ -gt 0 } | ForEach-Object {
            Write-Host "$($r)$_ files explicitly marked current."
          }
          $counts[1] | Where-Object { $_ -gt 0 } | ForEach-Object {
            Write-Host "$($r)$_ files accessed and therefore marked current."
          }
        }
      }

      # Clean up stale files and end file tracking.
      function End-AntiHoarding {
        # If anti-hoarding is off, this is a no-op.
        if (-not $global:anti_hoarding_enabled) { return }
        # Look for files that had their atime changed, and mark them current.
        Mark-Current -Auto -Reason "Tracking ends"
        # Make a list of all files to delete.
        $files = $global:stale_files.Keys |
                 Where-Object { Test-Path -Path $_ -PathType Leaf }
        # Compute the total size of all the to-be-deleted files.
        $size_info = $files | Get-Item | Measure-Object -Property Length -Sum
        $size_mb = "{0:N1}" -f ($size_info.Sum / (1024 * 1024))
        # Delete stale files.
        $files | Remove-Item -Force
        # Delete empty directories.
        $dirs = Get-Tree -Path $global:anti_hoarding_roots `
                         -Attributes Directory+!ReparsePoint `
                         -Recurse -Force                   |
                Sort-Object -Property FullName -Descending |
                ForEach-Object { try { $_.Delete(); $_ } catch {} }
        # Log summary.
        Write-Host "Deleted $($files.Count) stale files and",
                   "$($dirs.Count) directories ($size_mb MB)."
        $files | Write-Host
        $dirs.FullName | Write-Host
        $global:anti_hoarding_enabled = $false
      }

      # Get-SaveCache returns $true if the cache will be saved at the end.
      function Get-SaveCache {
        -not $env:APPVEYOR_PULL_REQUEST_NUMBER -and
        -not $env:APPVEYOR_CACHE_SKIP_SAVE -eq "true"
      }
      
      $env:DENO_DISK_IMAGE = "c:\image.wim"
      
      function MountDiskImage {
        if (-not (Test-Path $env:DENO_DISK_IMAGE)) {
          mkdir c:\dummy -force
          "x" > c:\dummy\.dummy
          New-WindowsImage -ImagePath $env:DENO_DISK_IMAGE -CapturePath c:\dummy -Name image -CompressionType maximum
        }
        mkdir -f $env:MOUNT_DIR
        Mount-WindowsImage -Path $env:MOUNT_DIR -ImagePath $env:DENO_DISK_IMAGE -Name image -Optimize
      }
      
      function UnmountDiskImage {
        set-location c:\
        Dismount-WindowsImage -Path $env:MOUNT_DIR -Save
      }
      
      function CloneRepo {
        $env:appveyor_build_folder = "$env:MOUNT_DIR\deno"
        if (-not (Test-Path $env:appveyor_build_folder)) {
          git init $env:appveyor_build_folder
        }
        
        set-location $env:appveyor_build_folder
        
        $remote = "https://github.com/$env:appveyor_repo_name.git"
        $ref = if (-not $env:appveyor_pull_request_number) {
                 "$env:appveyor_repo_branch"
               } else {
                 "refs/pull/$env:appveyor_pull_request_number/merge"
               }
               
        git fetch --depth=1 $remote "$ref`:"
        git checkout -qf FETCH_HEAD
      }

for:
  # Do no save the build cache for feature branches. TODO: Once we have multiple
  # permanent branches, use a build matrix so each branch has it's own cache.
  - branches:
      except:
        - master
        - try
    environment:
      APPVEYOR_CACHE_SKIP_SAVE: true

cache:
  ## Python packages installed with `pip --user` and Pip cache.
  - c:\deno.wim
  ## Rust stuff.
  #- $(CARGO_HOME)
  #- $(RUSTUP_HOME)
  ## Cache the third_party submodule to preserve binaries downloaded by setup.py,
  ## and to make incremental builds work.
  #- $(APPVEYOR_BUILD_FOLDER)\.git\modules\third_party
  #- $(APPVEYOR_BUILD_FOLDER)\third_party
  ## Build incrementally.
  #- $(DENO_BUILD_PATH)

init:
  # Load utility functions
  - ps: Invoke-Expression $env:PS_UTILS

clone_script:
  # Make git check out symlinks (not placeholder text files).
  # Actual cloning happens in the install phase, after restoring the cache.
  - git config --global core.symlinks true

install:
  - ps: |-
     $env:APPVEYOR_BUILD_FOLDER = "c:\image\deno"
     MountDiskImage
     CloneRepo
    
  # Clone the third_party submodule.
  - ps: |-
      try {
        Exec { & git submodule update --init --force --depth 1 }
      } catch {
        # Git will fail if the `third_party` directory was restored from cache,
        # but the `.git/modules` directory wasn't. Rebuild it from scratch.
        Delete-Tree -Path $env:DENO_THIRD_PARTY_PATH
        Exec -NoNewLines { & git submodule update --init --force --depth 1 }
      }

  # Prune and pack git objects. Thus when we upload `.git/modules/` to the
  # Appveyor cache, it'll include only objects that were actually needed.
  # This step is skipped if the cache is not going to be saved.
  - ps: |-
      if (Get-SaveCache) {
        Push-Location -Path $env:DENO_THIRD_PARTY_PATH
        Exec { & git gc --prune=all }
        Pop-Location
      }

  # Configure depot_tools and add it to the search path. This is necessary
  # because, later in this script, we need to invoke ninja directly.
  - ps: |-
      $env:PATH = "$env:DENO_THIRD_PARTY_PATH\depot_tools;$env:PATH"
      $env:DEPOT_TOOLS_WIN_TOOLCHAIN = "0"

  # Install a recent Node.js version.
  - ps: Install-Product -Product node -Version 10 -Platform x64
  
  #
  - ps: |-
      "$env:APPDATA\Python", "$env:LOCALAPPDATA\pip" | foreach {
        $real_dir = "c:\image\" + (split-path $_ -leaf)
        mkdir $real_dir -force
        if (test-path $_) { move-item $_ $env:TEMP -force }
        new-item -ItemType Junction -path $_ -target $real_dir              
      } | Out-Null

  # Make sure the right Python version is in PATH, and others are not.
  - ps: |-
      # Remove the wrong Python version(s) from PATH.
      $p = $env:PATH -split ";" | Where-Object {
             -not (Test-Path -Path "$_\python.exe") -and
             -not (Test-Path -Path "$_\pip.exe")
           }
      # Add binary dir for `pip --user` packages.
      $p += "$env:APPDATA\Python\Scripts"
      # Add python27-x64.
      $p += "c:\Python27-x64"
      $p += "c:\Python27-x64\Scripts"
      $env:PATH = $p -join ";"

  # Pip on Appveyor is too old. Install a recent version in our user dir.
  - python -m pip install --upgrade --user pip

  # Install Python packages.
  - pip install --upgrade --user pywin32 yapf

  # Add Rust/Cargo to PATH.
  - ps: $env:PATH += ";$env:CARGO_HOME\bin"

  # Look for Rust updates.
  # * If there are no updates, rustup will exit cleanly.
  # * If there are updates, rustup will attempt to install them, and then blow
  #   up because we removed the 'rust-docs' component.
  # * The actual update is done by removing and reinstalling with rustup-init.
  - ps: |-
      function UpdateRust {
        if (Get-SaveCache -and (Test-Path -Path $env:CARGO_HOME)) {
          try {
            Exec -NoNewLines { & rustup update stable-x86_64-pc-windows-msvc }
          } catch {
            Delete-Tree -Path $env:CARGO_HOME, $env:RUSTUP_HOME
          }
        }
      }
      #Delete-Tree -Path $env:CARGO_HOME, $env:RUSTUP_HOME
      UpdateRust

  # Install or reinstall Rust via rustup-init.
  # * After install/update, the rustup directory is very big, with many files,
  #   slowing down cache save/restore a lot, so we remove unnecessary stuff.
  # * TODO: Use `rustup component remove docs` instead, when this issue
  #   is resolved: https://github.com/rust-lang-nursery/rustup.rs/issues/998.
  # * TODO: Ship Rust in the third_party repo. See issue #386.
  - ps: |-
      if (-not (Test-Path -Path $env:CARGO_HOME)) {
        Invoke-WebRequest -Uri "https://win.rustup.rs" `
                          -OutFile "$env:TEMP\rustup-init.exe"
        Exec -NoNewLines { & "$env:TEMP\rustup-init.exe" -y }
        Delete-Tree -Path @(
          "$env:RUSTUP_HOME\downloads",
          "$env:RUSTUP_HOME\tmp",
          "$env:RUSTUP_HOME\toolchains\stable-x86_64-pc-windows-msvc\share\doc"
        )
      }

  # Log installed Node.js version + processor architecture.
  - node -p "`Node ${process.version} ${process.arch}`"

  # Log installed Python version + processor architecture.
  - ps: |-
      @("from sys import version",
        "print 'Python', version") -join "`n" | & python -

  # Log some more versions.
  - pip --version
  - rustc --version
  - cargo --version

before_build:
  # Mark all files in the build dir 'stale' until proven otherwise.
  # TODO: also track files in third_party that aren't checked into the repo.
  - ps: Begin-AntiHoarding -Path $env:DENO_BUILD_PATH

  # Download clang and gn, generate ninja files.
  - python tools\setup.py
  - ps: Mark-Current -Auto -Reason "Setup finished"

  # Mark files that are produced during the build, and are known to ninja, as
  # current. We obtain this list by dry-running `ninja -t clean`.
  # N.b.: we deliberately do *not* pass `:all` to the clean command. It misses
  # some important files, e.g. executables, .pdb and .ninja files.
  - ps: |-
      ninja -C $env:DENO_BUILD_PATH -n -t clean -g               |
        Where-Object   { $_ -match "^Remove (.*)$" }             |
        ForEach-Object { "$env:DENO_BUILD_PATH\$($Matches[1])" } |
        Mark-Current -Auto -Reason "Build dependency graph"

  # When Chromium's Clang is set up, a bunch of c runtime DLLs are copied to the
  # build dir. Presumably they're there for a reason, so mark them as current.
  - ps: |-
      @("api-ms-win-core-*.dll", "api-ms-win-crt-*.dll", "dbgcore.dll",
        "msvcp*.dll", "ucrtbase*.dll", "vccorlib*.dll", "vcruntime*.dll") |
        ForEach-Object { "$env:DENO_BUILD_PATH\$_" }                      |
        Mark-Current -Reason "C runtime DLLs"

build_script:
  # - python tools\build.py
  - ps: Mark-Current -Auto -Reason "Build finished"
  - ps: $targets = ninja -C out\debug -t targets | ?{ $_ -match "^build_extra/rust:.*(?=:)" } | %{ $Matches[0] } | ?{ $_ -notmatch "rustc$" }
  # - ps: ninja -C out\debug -t clean $targets
  - ps: ninja -C out\debug $targets

test_script:
  - python tools\lint.py
  # - ps: Exec { & python tools\test.py $env:DENO_BUILD_PATH }

after_test:
  # Remove stale files and empty dirs from the build directory.
  - ps: End-AntiHoarding
  #- ps: $blockRdp = $true; iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))
  - ps: UnmountDiskImage
