typedef long long ptrdiff_t;
typedef unsigned long long size_t;
namespace std {
    typedef decltype(nullptr) nullptr_t;
}
using ::std::nullptr_t;
typedef double max_align_t;
extern "C" {
}
extern "C" {
}
extern "C" {
    typedef unsigned long long uintptr_t;
    typedef char *va_list;
    void __va_start(va_list *, ...) throw();
}
extern "C++" {
    template <typename _Ty> struct __vcrt_va_list_is_reference {
        enum  : bool {
            __the_value = false
        };
    };
    template <typename _Ty> struct __vcrt_va_list_is_reference<type-parameter-0-0 &> {
        enum  : bool {
            __the_value = true
        };
    };
    template <typename _Ty> struct __vcrt_va_list_is_reference<type-parameter-0-0 &&> {
        enum  : bool {
            __the_value = true
        };
    };
    template <typename _Ty> struct __vcrt_assert_va_start_is_not_reference {
        static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
    };
}
extern "C" {
    typedef unsigned long long size_t;
    typedef long long ptrdiff_t;
    typedef long long intptr_t;
    typedef bool __vcrt_bool;
    extern "C++" {
        template <typename _CountofType, size_t _SizeOfArray> char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
    }
    void __security_init_cookie();
    void __security_check_cookie(uintptr_t _StackCookie);
    void __report_gsfailure(uintptr_t _StackCookie);
    extern uintptr_t __security_cookie;
}
typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef int int_least32_t;
typedef long long int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long long uint_least64_t;
typedef signed char int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long uint_fast64_t;
typedef long long intmax_t;
typedef unsigned long long uintmax_t;
extern "C" {
    extern "C++" {
        template <bool _Enable, typename _Ty> struct _CrtEnableIf;
        template <typename _Ty> struct _CrtEnableIf<true, _Ty> {
            typedef _Ty _Type;
        };
    }
    typedef bool __crt_bool;
    void _invalid_parameter_noinfo();
    void _invalid_parameter_noinfo_noreturn();
    void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved);
    typedef int errno_t;
    typedef unsigned short wint_t;
    typedef unsigned short wctype_t;
    typedef long __time32_t;
    typedef long long __time64_t;
    typedef struct __crt_locale_data_public {
        const unsigned short *_locale_pctype;
        int _locale_mb_cur_max;
        unsigned int _locale_lc_codepage;
    } __crt_locale_data_public;
    typedef struct __crt_locale_pointers {
        struct __crt_locale_data *locinfo;
        struct __crt_multibyte_data *mbcinfo;
    } __crt_locale_pointers;
    typedef __crt_locale_pointers *_locale_t;
    typedef struct _Mbstatet {
        unsigned long _Wchar;
        unsigned short _Byte;
        unsigned short _State;
    } _Mbstatet;
    typedef _Mbstatet mbstate_t;
    typedef __time64_t time_t;
    typedef size_t rsize_t;
}
extern "C" {
    inline unsigned long long *__local_stdio_printf_options() __declspec(noinline)     {
        static unsigned long long _OptionsStorage;
        return &_OptionsStorage;
    }
    inline unsigned long long *__local_stdio_scanf_options() __declspec(noinline)     {
        static unsigned long long _OptionsStorage;
        return &_OptionsStorage;
    }
}
;
extern "C" {
    typedef struct _iobuf {
        void *_Placeholder;
    } FILE;
    FILE *__acrt_iob_func(unsigned int _Ix);
    wint_t fgetwc(FILE *_Stream);
    wint_t _fgetwchar();
    wint_t fputwc(wchar_t _Character, FILE *_Stream);
    wint_t _fputwchar(wchar_t _Character);
    wint_t getwc(FILE *_Stream);
    wint_t getwchar();
    wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream);
    int fputws(const wchar_t *_Buffer, FILE *_Stream);
    wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount);
    extern "C++" {
        template <size_t _Size> inline wchar_t *_getws_s(wchar_t (&_Buffer)[_Size]) throw()         {
            return _getws_s(_Buffer, _Size);
        }
    }
    wint_t putwc(wchar_t _Character, FILE *_Stream);
    wint_t putwchar(wchar_t _Character);
    int _putws(const wchar_t *_Buffer);
    wint_t ungetwc(wint_t _Character, FILE *_Stream);
    FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode);
    FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode) __declspec(deprecated("This function or variable may be unsafe. Consider using _wfopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode);
    FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream) __declspec(deprecated("This function or variable may be unsafe. Consider using _wfreopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream);
    FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag);
    void _wperror(const wchar_t *_ErrorMessage);
    FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode);
    int _wremove(const wchar_t *_FileName);
    wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix);
    errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount);
    extern "C++" {
        template <size_t _Size> inline errno_t _wtmpnam_s(wchar_t (&_Buffer)[_Size]) throw()         {
            return _wtmpnam_s(_Buffer, _Size);
        }
    }
    wchar_t *_wtmpnam(wchar_t *_Buffer) __declspec(deprecated("This function or variable may be unsafe. Consider using _wtmpnam_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    wint_t _fgetwc_nolock(FILE *_Stream);
    wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream);
    wint_t _getwc_nolock(FILE *_Stream);
    wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream);
    wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream);
    int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vfwprintf_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    inline int vfwprintf(FILE *const _Stream, const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vfwprintf_s_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    inline int vfwprintf_s(FILE *const _Stream, const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vfwprintf_p_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    inline int _vfwprintf_p(FILE *const _Stream, const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vwprintf_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    inline int vwprintf(const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    inline int _vwprintf_s_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    inline int vwprintf_s(const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    inline int _vwprintf_p_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    inline int _vwprintf_p(const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    inline int _fwprintf_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int fwprintf(FILE *const _Stream, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _fwprintf_s_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int fwprintf_s(FILE *const _Stream, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _fwprintf_p_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _fwprintf_p(FILE *const _Stream, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _wprintf_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int wprintf(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _wprintf_s_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int wprintf_s(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _wprintf_p_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _wprintf_p(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vfwscanf_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfwscanf((*__local_stdio_scanf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    inline int vfwscanf(FILE *const _Stream, const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vfwscanf_s_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfwscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Stream, _Format, _Locale, _ArgList);
    }
    inline int vfwscanf_s(FILE *const _Stream, const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vwscanf_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    inline int vwscanf(const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    inline int _vwscanf_s_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    inline int vwscanf_s(const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    inline int _fwscanf_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _fwscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int fwscanf(FILE *const _Stream, const wchar_t *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using fwscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _fwscanf_s_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int fwscanf_s(FILE *const _Stream, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _wscanf_l(const wchar_t *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _wscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int wscanf(const wchar_t *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using wscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _wscanf_s_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int wscanf_s(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vsnwprintf_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnwprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        const int _Result = __stdio_common_vswprintf((*__local_stdio_printf_options()) | (1ULL << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vsnwprintf_s_l(wchar_t *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vsnwprintf_s((*__local_stdio_printf_options()), _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vsnwprintf_s(wchar_t *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const wchar_t *const _Format, va_list _ArgList)     {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    inline int _snwprintf(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _snwprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    inline int _vsnwprintf(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, va_list _Args) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnwprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    inline int _vsnwprintf(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, va_list _ArgList) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnwprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    extern "C++" {
        template <size_t _Size> inline int _vsnwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, const wchar_t *_Format, va_list _ArgList) throw()         {
            return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList);
        }
    }
    inline int _vswprintf_c_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vswprintf((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vswprintf_c(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, va_list _ArgList)     {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    inline int _vswprintf_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    inline int __vswprintf_l(wchar_t *const _Buffer, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    inline int _vswprintf(wchar_t *const _Buffer, const wchar_t *const _Format, va_list _ArgList)     {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    inline int vswprintf(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, va_list _ArgList)     {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    inline int _vswprintf_s_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vswprintf_s((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int vswprintf_s(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, va_list _ArgList)     {
        return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    extern "C++" {
        template <size_t _Size> inline int vswprintf_s(wchar_t (&_Buffer)[_Size], const wchar_t *_Format, va_list _ArgList) throw()         {
            return vswprintf_s(_Buffer, _Size, _Format, _ArgList);
        }
    }
    inline int _vswprintf_p_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vswprintf_p((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vswprintf_p(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, va_list _ArgList)     {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    inline int _vscwprintf_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vswprintf((*__local_stdio_printf_options()) | (1ULL << 1), 0, 0, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vscwprintf(const wchar_t *const _Format, va_list _ArgList)     {
        return _vscwprintf_l(_Format, 0, _ArgList);
    }
    inline int _vscwprintf_p_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vswprintf_p((*__local_stdio_printf_options()) | (1ULL << 1), 0, 0, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vscwprintf_p(const wchar_t *const _Format, va_list _ArgList)     {
        return _vscwprintf_p_l(_Format, 0, _ArgList);
    }
    inline int __swprintf_l(wchar_t *const _Buffer, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _swprintf_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _swprintf(wchar_t *const _Buffer, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int swprintf(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int __swprintf_l(wchar_t *_Buffer, const wchar_t *_Format, _locale_t _Locale, ...);
    inline int __vswprintf_l(wchar_t *_Buffer, const wchar_t *_Format, _locale_t _Locale, va_list _Args);
    inline int _swprintf(wchar_t *_Buffer, const wchar_t *_Format, ...);
    inline int _vswprintf(wchar_t *_Buffer, const wchar_t *_Format, va_list _Args);
    inline int _swprintf_s_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int swprintf_s(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    extern "C++" {
        ;
        template <size_t _Size> inline int swprintf_s(wchar_t (&_Buffer)[_Size], const wchar_t *_Format, ...) throw()         {
            va_list _ArgList;
            __builtin_va_start(_ArgList, _Format);
            return vswprintf_s(_Buffer, _Size, _Format, _ArgList);
        }
        ;
    }
    inline int _swprintf_p_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _swprintf_p(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _swprintf_c_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _swprintf_c(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snwprintf_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _snwprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snwprintf(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snwprintf_s_l(wchar_t *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snwprintf_s(wchar_t *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    extern "C++" {
        ;
        template <size_t _Size> inline int _snwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, const wchar_t *_Format, ...) throw()         {
            va_list _ArgList;
            __builtin_va_start(_ArgList, _Format);
            return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList);
        }
        ;
    }
    inline int _scwprintf_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _scwprintf(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vscwprintf_l(_Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _scwprintf_p_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _scwprintf_p(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    extern "C++" inline int swprintf(wchar_t *const _Buffer, const wchar_t *const _Format, ...) throw() __declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using swprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }

    extern "C++" inline int vswprintf(wchar_t *const _Buffer, const wchar_t *const _Format, va_list _ArgList) throw() __declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using vswprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
    }

    extern "C++" inline int _swprintf_l(wchar_t *const _Buffer, const wchar_t *const _Format, const _locale_t _Locale, ...) throw() __declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _swprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }

    extern "C++" inline int _vswprintf_l(wchar_t *const _Buffer, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList) throw() __declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _vswprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }

    int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vswscanf_l(const wchar_t *const _Buffer, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vswscanf((*__local_stdio_scanf_options()), _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    inline int vswscanf(const wchar_t *_Buffer, const wchar_t *_Format, va_list _ArgList)     {
        return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    inline int _vswscanf_s_l(const wchar_t *const _Buffer, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vswscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    inline int vswscanf_s(const wchar_t *const _Buffer, const wchar_t *const _Format, va_list _ArgList)     {
        return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
    }
    extern "C++" {
        template <size_t _Size> inline int vswscanf_s(wchar_t (&_Buffer)[_Size], const wchar_t *_Format, va_list _ArgList) throw()         {
            return vswscanf_s(_Buffer, _Size, _Format, _ArgList);
        }
    }
    inline int _vsnwscanf_l(const wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnwscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return __stdio_common_vswscanf((*__local_stdio_scanf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    inline int _vsnwscanf_s_l(const wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vswscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    inline int _swscanf_l(const wchar_t *const _Buffer, const wchar_t *const _Format, _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _swscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int swscanf(const wchar_t *const _Buffer, const wchar_t *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using swscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _swscanf_s_l(const wchar_t *const _Buffer, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int swscanf_s(const wchar_t *const _Buffer, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snwscanf_l(const wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _snwscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snwscanf(const wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _snwscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snwscanf_s_l(const wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snwscanf_s(const wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
}
extern "C" {
    typedef long long fpos_t;
    errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count);
    errno_t clearerr_s(FILE *_Stream);
    errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode);
    size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream);
    errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream);
    char *gets_s(char *_Buffer, rsize_t _Size);
    errno_t tmpfile_s(FILE **_Stream);
    errno_t tmpnam_s(char *_Buffer, rsize_t _Size);
    void clearerr(FILE *_Stream);
    int fclose(FILE *_Stream);
    int _fcloseall();
    FILE *_fdopen(int _FileHandle, const char *_Mode);
    int feof(FILE *_Stream);
    int ferror(FILE *_Stream);
    int fflush(FILE *_Stream);
    int fgetc(FILE *_Stream);
    int _fgetchar();
    int fgetpos(FILE *_Stream, fpos_t *_Position);
    char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream);
    int _fileno(FILE *_Stream);
    int _flushall();
    FILE *fopen(const char *_FileName, const char *_Mode) __declspec(deprecated("This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int fputc(int _Character, FILE *_Stream);
    int _fputchar(int _Character);
    int fputs(const char *_Buffer, FILE *_Stream);
    size_t fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream);
    FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream) __declspec(deprecated("This function or variable may be unsafe. Consider using freopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag);
    int fsetpos(FILE *_Stream, const fpos_t *_Position);
    int fseek(FILE *_Stream, long _Offset, int _Origin);
    int _fseeki64(FILE *_Stream, long long _Offset, int _Origin);
    long ftell(FILE *_Stream);
    long long _ftelli64(FILE *_Stream);
    size_t fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream);
    int getc(FILE *_Stream);
    int getchar();
    int _getmaxstdio();
    extern "C++" {
        template <size_t _Size> inline char *gets_s(char (&_Buffer)[_Size]) throw()         {
            return gets_s(_Buffer, _Size);
        }
    }
    int _getw(FILE *_Stream);
    void perror(const char *_ErrorMessage);
    int _pclose(FILE *_Stream);
    FILE *_popen(const char *_Command, const char *_Mode);
    int putc(int _Character, FILE *_Stream);
    int putchar(int _Character);
    int puts(const char *_Buffer);
    int _putw(int _Word, FILE *_Stream);
    int remove(const char *_FileName);
    int rename(const char *_OldFileName, const char *_NewFileName);
    int _unlink(const char *_FileName);
    int unlink(const char *_FileName) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _unlink. See online help for details."));
    void rewind(FILE *_Stream);
    int _rmtmp();
    void setbuf(FILE *_Stream, char *_Buffer) __declspec(deprecated("This function or variable may be unsafe. Consider using setvbuf instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int _setmaxstdio(int _Maximum);
    int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size);
    char *_tempnam(const char *_DirectoryName, const char *_FilePrefix);
    FILE *tmpfile() __declspec(deprecated("This function or variable may be unsafe. Consider using tmpfile_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    extern "C++" {
        template <size_t _Size> inline errno_t tmpnam_s(char (&_Buffer)[_Size]) throw()         {
            return tmpnam_s(_Buffer, _Size);
        }
    }
    char *tmpnam(char *_Buffer) __declspec(deprecated("This function or variable may be unsafe. Consider using tmpnam_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int ungetc(int _Character, FILE *_Stream);
    void _lock_file(FILE *_Stream);
    void _unlock_file(FILE *_Stream);
    int _fclose_nolock(FILE *_Stream);
    int _fflush_nolock(FILE *_Stream);
    int _fgetc_nolock(FILE *_Stream);
    int _fputc_nolock(int _Character, FILE *_Stream);
    size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream);
    size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream);
    int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin);
    int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin);
    long _ftell_nolock(FILE *_Stream);
    long long _ftelli64_nolock(FILE *_Stream);
    size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream);
    int _getc_nolock(FILE *_Stream);
    int _putc_nolock(int _Character, FILE *_Stream);
    int _ungetc_nolock(int _Character, FILE *_Stream);
    int *__p__commode();
    int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vfprintf_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    inline int vfprintf(FILE *const _Stream, const char *const _Format, va_list _ArgList)     {
        return _vfprintf_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vfprintf_s_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    inline int vfprintf_s(FILE *const _Stream, const char *const _Format, va_list _ArgList)     {
        return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vfprintf_p_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    inline int _vfprintf_p(FILE *const _Stream, const char *const _Format, va_list _ArgList)     {
        return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vprintf_l(const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    inline int vprintf(const char *const _Format, va_list _ArgList)     {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    inline int _vprintf_s_l(const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    inline int vprintf_s(const char *const _Format, va_list _ArgList)     {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    inline int _vprintf_p_l(const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    inline int _vprintf_p(const char *const _Format, va_list _ArgList)     {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    inline int _fprintf_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int fprintf(FILE *const _Stream, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int _set_printf_count_output(int _Value);
    int _get_printf_count_output();
    inline int _fprintf_s_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int fprintf_s(FILE *const _Stream, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _fprintf_p_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _fprintf_p(FILE *const _Stream, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _printf_l(const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int printf(const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _printf_s_l(const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int printf_s(const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _printf_p_l(const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _printf_p(const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist);
    inline int _vfscanf_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfscanf((*__local_stdio_scanf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    inline int vfscanf(FILE *const _Stream, const char *const _Format, va_list _ArgList)     {
        return _vfscanf_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vfscanf_s_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Stream, _Format, _Locale, _ArgList);
    }
    inline int vfscanf_s(FILE *const _Stream, const char *const _Format, va_list _ArgList)     {
        return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vscanf_l(const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    inline int vscanf(const char *const _Format, va_list _ArgList)     {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    inline int _vscanf_s_l(const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    inline int vscanf_s(const char *const _Format, va_list _ArgList)     {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    inline int _fscanf_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _fscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int fscanf(FILE *const _Stream, const char *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using fscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _fscanf_s_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int fscanf_s(FILE *const _Stream, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _scanf_l(const char *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _scanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int scanf(const char *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using scanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _scanf_s_l(const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int scanf_s(const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vsnprintf_l(char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, va_list _ArgList) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1ULL << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vsnprintf(char *const _Buffer, const size_t _BufferCount, const char *const _Format, va_list _ArgList)     {
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    inline int vsnprintf(char *const _Buffer, const size_t _BufferCount, const char *const _Format, va_list _ArgList)     {
        const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1ULL << 1), _Buffer, _BufferCount, _Format, 0, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vsprintf_l(char *const _Buffer, const char *const _Format, const _locale_t _Locale, va_list _ArgList) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    inline int vsprintf(char *const _Buffer, const char *const _Format, va_list _ArgList) __declspec(deprecated("This function or variable may be unsafe. Consider using vsprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    inline int _vsprintf_s_l(char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vsprintf_s((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int vsprintf_s(char *const _Buffer, const size_t _BufferCount, const char *const _Format, va_list _ArgList)     {
        return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    extern "C++" {
        template <size_t _Size> inline int vsprintf_s(char (&_Buffer)[_Size], const char *_Format, va_list _ArgList) throw()         {
            return vsprintf_s(_Buffer, _Size, _Format, _ArgList);
        }
    }
    inline int _vsprintf_p_l(char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vsprintf_p((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vsprintf_p(char *const _Buffer, const size_t _BufferCount, const char *const _Format, va_list _ArgList)     {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    inline int _vsnprintf_s_l(char *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vsnprintf_s((*__local_stdio_printf_options()), _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vsnprintf_s(char *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char *const _Format, va_list _ArgList)     {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    extern "C++" {
        template <size_t _Size> inline int _vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, const char *_Format, va_list _ArgList) throw()         {
            return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList);
        }
    }
    inline int vsnprintf_s(char *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char *const _Format, va_list _ArgList)     {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    extern "C++" {
        template <size_t _Size> inline int vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, const char *_Format, va_list _ArgList) throw()         {
            return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList);
        }
    }
    inline int _vscprintf_l(const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1ULL << 1), 0, 0, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vscprintf(const char *const _Format, va_list _ArgList)     {
        return _vscprintf_l(_Format, 0, _ArgList);
    }
    inline int _vscprintf_p_l(const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vsprintf_p((*__local_stdio_printf_options()) | (1ULL << 1), 0, 0, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vscprintf_p(const char *const _Format, va_list _ArgList)     {
        return _vscprintf_p_l(_Format, 0, _ArgList);
    }
    inline int _vsnprintf_c_l(char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vsnprintf_c(char *const _Buffer, const size_t _BufferCount, const char *const _Format, va_list _ArgList)     {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    inline int _sprintf_l(char *const _Buffer, const char *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _sprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int sprintf(char *const _Buffer, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int sprintf(char *_Buffer, const char *_Format, ...);
    int vsprintf(char *_Buffer, const char *_Format, va_list _Args) __declspec(deprecated("This function or variable may be unsafe. Consider using vsprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    inline int _sprintf_s_l(char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int sprintf_s(char *const _Buffer, const size_t _BufferCount, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    extern "C++" {
        ;
        template <size_t _Size> inline int sprintf_s(char (&_Buffer)[_Size], const char *_Format, ...) throw()         {
            va_list _ArgList;
            __builtin_va_start(_ArgList, _Format);
            return vsprintf_s(_Buffer, _Size, _Format, _ArgList);
        }
        ;
    }
    inline int _sprintf_p_l(char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _sprintf_p(char *const _Buffer, const size_t _BufferCount, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snprintf_l(char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _snprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int snprintf(char *const _Buffer, const size_t _BufferCount, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snprintf(char *const _Buffer, const size_t _BufferCount, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int _snprintf(char *_Buffer, size_t _BufferCount, const char *_Format, ...);
    int _vsnprintf(char *_Buffer, size_t _BufferCount, const char *_Format, va_list _Args);
    inline int _snprintf_c_l(char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snprintf_c(char *const _Buffer, const size_t _BufferCount, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snprintf_s_l(char *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snprintf_s(char *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    extern "C++" {
        ;
        template <size_t _Size> inline int _snprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, const char *_Format, ...) throw()         {
            va_list _ArgList;
            __builtin_va_start(_ArgList, _Format);
            return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList);
        }
        ;
    }
    inline int _scprintf_l(const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _scprintf(const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vscprintf_l(_Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _scprintf_p_l(const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _scprintf_p(const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vscprintf_p(_Format, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vsscanf_l(const char *const _Buffer, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vsscanf((*__local_stdio_scanf_options()), _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    inline int vsscanf(const char *const _Buffer, const char *const _Format, va_list _ArgList)     {
        return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    inline int _vsscanf_s_l(const char *const _Buffer, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    inline int vsscanf_s(const char *const _Buffer, const char *const _Format, va_list _ArgList)     {
        return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
    }
    extern "C++" {
        template <size_t _Size> inline int vsscanf_s(const char (&_Buffer)[_Size], const char *_Format, va_list _ArgList) throw()         {
            return vsscanf_s(_Buffer, _Size, _Format, _ArgList);
        }
    }
    inline int _sscanf_l(const char *const _Buffer, const char *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _sscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int sscanf(const char *const _Buffer, const char *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using sscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _sscanf_s_l(const char *const _Buffer, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int sscanf_s(const char *const _Buffer, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = vsscanf_s(_Buffer, _Format, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snscanf_l(const char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _snscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snscanf(const char *const _Buffer, const size_t _BufferCount, const char *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _snscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()), _Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snscanf_s_l(const char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snscanf_s(const char *const _Buffer, const size_t _BufferCount, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    char *tempnam(const char *_Directory, const char *_FilePrefix) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _tempnam. See online help for details."));
    int fcloseall() __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _fcloseall. See online help for details."));
    FILE *fdopen(int _FileHandle, const char *_Format) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _fdopen. See online help for details."));
    int fgetchar() __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _fgetchar. See online help for details."));
    int fileno(FILE *_Stream) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _fileno. See online help for details."));
    int flushall() __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _flushall. See online help for details."));
    int fputchar(int _Ch) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _fputchar. See online help for details."));
    int getw(FILE *_Stream) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _getw. See online help for details."));
    int putw(int _Ch, FILE *_Stream) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _putw. See online help for details."));
    int rmtmp() __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _rmtmp. See online help for details."));
}
extern "C++" {
    namespace std {
        struct nothrow_t {
            explicit nothrow_t() = default
        };
        extern const std::nothrow_t nothrow;
    }
    void *operator new(size_t _Size);
    void *operator new(size_t _Size, const std::nothrow_t &) noexcept;
    void *operator new[](size_t _Size);
    void *operator new[](size_t _Size, const std::nothrow_t &) noexcept;
    void operator delete(void *_Block) noexcept;
    void operator delete(void *_Block, const std::nothrow_t &) noexcept;
    void operator delete[](void *_Block) noexcept;
    void operator delete[](void *_Block, const std::nothrow_t &) noexcept;
    void operator delete(void *_Block, size_t _Size) noexcept;
    void operator delete[](void *_Block, size_t _Size) noexcept;
    inline void *operator new(size_t _Size, void *_Where) noexcept     {
        (void)_Size;
        return _Where;
    }
    inline void operator delete(void *, void *) noexcept     {
        return;
    }
    inline void *operator new[](size_t _Size, void *_Where) noexcept     {
        (void)_Size;
        return _Where;
    }
    inline void operator delete[](void *, void *) noexcept     {
    }
}
extern "C++" {
    void *operator new(size_t _Size, int _BlockUse, const char *_FileName, int _LineNumber);
    void *operator new[](size_t _Size, int _BlockUse, const char *_FileName, int _LineNumber);
    void operator delete(void *_Block, int _BlockUse, const char *_FileName, int _LineNumber) noexcept;
    void operator delete[](void *_Block, int _BlockUse, const char *_FileName, int _LineNumber) noexcept;
}
extern "C" {
    typedef void *_HFILE;
    typedef int (*_CRT_REPORT_HOOK)(int, char *, int *) __attribute__((cdecl));
    typedef int (*_CRT_REPORT_HOOKW)(int, wchar_t *, int *) __attribute__((cdecl));
    typedef int (*_CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int) __attribute__((cdecl));
    typedef void (*_CRT_DUMP_CLIENT)(void *, size_t) __attribute__((cdecl));
    struct _CrtMemBlockHeader;
    typedef struct _CrtMemState {
        struct _CrtMemBlockHeader *pBlockHeader;
        size_t lCounts[5];
        size_t lSizes[5];
        size_t lHighWaterCount;
        size_t lTotalCount;
    } _CrtMemState;
}
;
;
;
;
namespace std {
    enum _Uninitialized {
        _Noinit
    };
    class _Lockit {
    public:
        _Lockit();
        explicit _Lockit(int);
        ~_Lockit() noexcept;
        static void _Lockit_ctor(int);
        static void _Lockit_dtor(int);
    private:
        static void _Lockit_ctor(std::_Lockit *);
        static void _Lockit_ctor(std::_Lockit *, int);
        static void _Lockit_dtor(std::_Lockit *);
    public:
        _Lockit(const std::_Lockit &) = delete
        std::_Lockit &operator=(const std::_Lockit &) = delete
    private:
        int _Locktype;
    };
    class _Init_locks {
    public:
        _Init_locks();
        ~_Init_locks() noexcept;
    private:
        static void _Init_locks_ctor(std::_Init_locks *);
        static void _Init_locks_dtor(std::_Init_locks *);
    };
}
namespace std {
    using ::int8_t;
    using ::int16_t;
    using ::int32_t;
    using ::int64_t;
    using ::uint8_t;
    using ::uint16_t;
    using ::uint32_t;
    using ::uint64_t;
    using ::int_least8_t;
    using ::int_least16_t;
    using ::int_least32_t;
    using ::int_least64_t;
    using ::uint_least8_t;
    using ::uint_least16_t;
    using ::uint_least32_t;
    using ::uint_least64_t;
    using ::int_fast8_t;
    using ::int_fast16_t;
    using ::int_fast32_t;
    using ::int_fast64_t;
    using ::uint_fast8_t;
    using ::uint_fast16_t;
    using ::uint_fast32_t;
    using ::uint_fast64_t;
    using ::intmax_t;
    using ::intptr_t;
    using ::uintmax_t;
    using ::uintptr_t;
    namespace tr1 {
        using ::int8_t;
        using ::int16_t;
        using ::int32_t;
        using ::int64_t;
        using ::uint8_t;
        using ::uint16_t;
        using ::uint32_t;
        using ::uint64_t;
        using ::int_least8_t;
        using ::int_least16_t;
        using ::int_least32_t;
        using ::int_least64_t;
        using ::uint_least8_t;
        using ::uint_least16_t;
        using ::uint_least32_t;
        using ::uint_least64_t;
        using ::int_fast8_t;
        using ::int_fast16_t;
        using ::int_fast32_t;
        using ::int_fast64_t;
        using ::uint_fast8_t;
        using ::uint_fast16_t;
        using ::uint_fast32_t;
        using ::uint_fast64_t;
        using ::intmax_t;
        using ::intptr_t;
        using ::uintmax_t;
        using ::uintptr_t;
    }
}
extern "C" {
    void *_calloc_base(size_t _Count, size_t _Size) __declspec(restrict);
    void *calloc(size_t _Count, size_t _Size) __declspec(restrict);
    int _callnewh(size_t _Size);
    void *_expand(void *_Block, size_t _Size);
    void _free_base(void *_Block);
    void free(void *_Block);
    void *_malloc_base(size_t _Size) __declspec(restrict);
    void *malloc(size_t _Size) __declspec(restrict);
    size_t _msize_base(void *_Block);
    size_t _msize(void *_Block);
    void *_realloc_base(void *_Block, size_t _Size) __declspec(restrict);
    void *realloc(void *_Block, size_t _Size) __declspec(restrict);
    void *_recalloc_base(void *_Block, size_t _Count, size_t _Size) __declspec(restrict);
    void *_recalloc(void *_Block, size_t _Count, size_t _Size) __declspec(restrict);
    void _aligned_free(void *_Block);
    void *_aligned_malloc(size_t _Size, size_t _Alignment) __declspec(restrict);
    void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset) __declspec(restrict);
    size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset);
    void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset) __declspec(restrict);
    void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset) __declspec(restrict);
    void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment) __declspec(restrict);
    void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment) __declspec(restrict);
}
extern "C" {
    typedef int (*_CoreCrtSecureSearchSortCompareFunction)(void *, const void *, const void *) __attribute__((cdecl));
    typedef int (*_CoreCrtNonSecureSearchSortCompareFunction)(const void *, const void *) __attribute__((cdecl));
    void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context);
    void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context);
    void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);
    void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);
    void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context);
    void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);
    void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context);
    void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);
    void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _lfind. See online help for details."));
    void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _lsearch. See online help for details."));
}
extern "C" {
    errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix);
    extern "C++" {
        template <size_t _Size> inline errno_t _itow_s(int _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw()         {
            return _itow_s(_Value, _Buffer, _Size, _Radix);
        }
    }
    wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _itow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix);
    extern "C++" {
        template <size_t _Size> inline errno_t _ltow_s(long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw()         {
            return _ltow_s(_Value, _Buffer, _Size, _Radix);
        }
    }
    wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _ltow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix);
    extern "C++" {
        template <size_t _Size> inline errno_t _ultow_s(unsigned long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw()         {
            return _ultow_s(_Value, _Buffer, _Size, _Radix);
        }
    }
    wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _ultow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    double wcstod(const wchar_t *_String, wchar_t **_EndPtr);
    double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale);
    long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix);
    long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale);
    long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix);
    long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale);
    unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix);
    unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale);
    unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix);
    unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale);
    long double wcstold(const wchar_t *_String, wchar_t **_EndPtr);
    long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale);
    float wcstof(const wchar_t *_String, wchar_t **_EndPtr);
    float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale);
    double _wtof(const wchar_t *_String);
    double _wtof_l(const wchar_t *_String, _locale_t _Locale);
    int _wtoi(const wchar_t *_String);
    int _wtoi_l(const wchar_t *_String, _locale_t _Locale);
    long _wtol(const wchar_t *_String);
    long _wtol_l(const wchar_t *_String, _locale_t _Locale);
    long long _wtoll(const wchar_t *_String);
    long long _wtoll_l(const wchar_t *_String, _locale_t _Locale);
    errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix);
    wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _i64tow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix);
    wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _ui64tow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    long long _wtoi64(const wchar_t *_String);
    long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale);
    long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix);
    long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale);
    unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix);
    unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale);
    wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount);
    errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext);
    extern "C++" {
        template <size_t _Size> inline errno_t _wmakepath_s(wchar_t (&_Buffer)[_Size], const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext) throw()         {
            return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext);
        }
    }
    void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext) __declspec(deprecated("This function or variable may be unsafe. Consider using _wmakepath_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    void _wperror(const wchar_t *_ErrorMessage);
    void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext) __declspec(deprecated("This function or variable may be unsafe. Consider using _wsplitpath_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount);
    extern "C++" {
        template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t _wsplitpath_s(const wchar_t *_Path, wchar_t (&_Drive)[_DriveSize], wchar_t (&_Dir)[_DirSize], wchar_t (&_Name)[_NameSize], wchar_t (&_Ext)[_ExtSize]) throw()         {
            return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize);
        }
    }
    errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName);
    wchar_t *_wgetenv(const wchar_t *_VarName) __declspec(deprecated("This function or variable may be unsafe. Consider using _wdupenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName);
    extern "C++" {
        template <size_t _Size> inline errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t (&_Buffer)[_Size], const wchar_t *_VarName) throw()         {
            return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName);
        }
    }
    int _wputenv(const wchar_t *_EnvString);
    errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value);
    errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount);
    extern "C++" {
        template <size_t _Size> inline errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t (&_ResultPath)[_Size]) throw()         {
            return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size);
        }
    }
    void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath) __declspec(deprecated("This function or variable may be unsafe. Consider using _wsearchenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int _wsystem(const wchar_t *_Command);
}
extern "C" {
}
extern "C" {
    void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes);
    void exit(int _Code);
    void _exit(int _Code);
    void _Exit(int _Code);
    void quick_exit(int _Code);
    void abort();
    unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask);
    typedef int (*_onexit_t)() __attribute__((cdecl));
    int atexit(void (*)() __attribute__((cdecl)));
    _onexit_t _onexit(_onexit_t _Func);
    int at_quick_exit(void (*)() __attribute__((cdecl)));
    typedef void (*_purecall_handler)() __attribute__((cdecl));
    typedef void (*_invalid_parameter_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t) __attribute__((cdecl));
    _purecall_handler _set_purecall_handler(_purecall_handler _Handler);
    _purecall_handler _get_purecall_handler();
    _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler);
    _invalid_parameter_handler _get_invalid_parameter_handler();
    _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler);
    _invalid_parameter_handler _get_thread_local_invalid_parameter_handler();
    int _set_error_mode(int _Mode);
    int *_errno();
    errno_t _set_errno(int _Value);
    errno_t _get_errno(int *_Value);
    unsigned long *__doserrno();
    errno_t _set_doserrno(unsigned long _Value);
    errno_t _get_doserrno(unsigned long *_Value);
    char **__sys_errlist() __declspec(deprecated("This function or variable may be unsafe. Consider using strerror instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int *__sys_nerr() __declspec(deprecated("This function or variable may be unsafe. Consider using strerror instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    void perror(const char *_ErrMsg);
    char **__p__pgmptr() __declspec(deprecated("This function or variable may be unsafe. Consider using _get_pgmptr instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    wchar_t **__p__wpgmptr() __declspec(deprecated("This function or variable may be unsafe. Consider using _get_wpgmptr instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int *__p__fmode() __declspec(deprecated("This function or variable may be unsafe. Consider using _get_fmode instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _get_pgmptr(char **_Value);
    errno_t _get_wpgmptr(wchar_t **_Value);
    errno_t _set_fmode(int _Mode);
    errno_t _get_fmode(int *_PMode);
    typedef struct _div_t {
        int quot;
        int rem;
    } div_t;
    typedef struct _ldiv_t {
        long quot;
        long rem;
    } ldiv_t;
    typedef struct _lldiv_t {
        long long quot;
        long long rem;
    } lldiv_t;
    int abs(int _Number);
    long labs(long _Number);
    long long llabs(long long _Number);
    long long _abs64(long long _Number);
    unsigned short _byteswap_ushort(unsigned short _Number);
    unsigned long _byteswap_ulong(unsigned long _Number);
    unsigned long long _byteswap_uint64(unsigned long long _Number);
    div_t div(int _Numerator, int _Denominator);
    ldiv_t ldiv(long _Numerator, long _Denominator);
    lldiv_t lldiv(long long _Numerator, long long _Denominator);
    unsigned int _rotl(unsigned int _Value, int _Shift) throw();
    unsigned long _lrotl(unsigned long _Value, int _Shift) throw();
    unsigned long long _rotl64(unsigned long long _Value, int _Shift) throw();
    unsigned int _rotr(unsigned int _Value, int _Shift) throw();
    unsigned long _lrotr(unsigned long _Value, int _Shift) throw();
    unsigned long long _rotr64(unsigned long long _Value, int _Shift) throw();
    void srand(unsigned int _Seed);
    int rand();
    extern "C++" {
        inline long abs(const long _X) throw()         {
            return labs(_X);
        }
        inline long long abs(const long long _X) throw()         {
            return llabs(_X);
        }
        inline ldiv_t div(const long _A1, const long _A2) throw()         {
            return ldiv(_A1, _A2);
        }
        inline lldiv_t div(const long long _A1, const long long _A2) throw()         {
            return lldiv(_A1, _A2);
        }
    }
    typedef struct {
        unsigned char ld[10];
    } _LDOUBLE;
    typedef struct {
        double x;
    } _CRT_DOUBLE;
    typedef struct {
        float f;
    } _CRT_FLOAT;
    typedef struct {
        long double x;
    } _LONGDOUBLE;
    typedef struct {
        unsigned char ld12[12];
    } _LDBL12;
    double atof(const char *_String);
    int atoi(const char *_String);
    long atol(const char *_String);
    long long atoll(const char *_String);
    long long _atoi64(const char *_String);
    double _atof_l(const char *_String, _locale_t _Locale);
    int _atoi_l(const char *_String, _locale_t _Locale);
    long _atol_l(const char *_String, _locale_t _Locale);
    long long _atoll_l(const char *_String, _locale_t _Locale);
    long long _atoi64_l(const char *_String, _locale_t _Locale);
    int _atoflt(_CRT_FLOAT *_Result, const char *_String);
    int _atodbl(_CRT_DOUBLE *_Result, char *_String);
    int _atoldbl(_LDOUBLE *_Result, char *_String);
    int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale);
    int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale);
    int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale);
    float strtof(const char *_String, char **_EndPtr);
    float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale);
    double strtod(const char *_String, char **_EndPtr);
    double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale);
    long double strtold(const char *_String, char **_EndPtr);
    long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale);
    long strtol(const char *_String, char **_EndPtr, int _Radix);
    long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale);
    long long strtoll(const char *_String, char **_EndPtr, int _Radix);
    long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale);
    unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix);
    unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale);
    unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix);
    unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale);
    long long _strtoi64(const char *_String, char **_EndPtr, int _Radix);
    long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale);
    unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix);
    unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale);
    errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix);
    extern "C++" {
        template <size_t _Size> inline errno_t _itoa_s(int _Value, char (&_Buffer)[_Size], int _Radix) throw()         {
            return _itoa_s(_Value, _Buffer, _Size, _Radix);
        }
    }
    char *_itoa(int _Value, char *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _itoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix);
    extern "C++" {
        template <size_t _Size> inline errno_t _ltoa_s(long _Value, char (&_Buffer)[_Size], int _Radix) throw()         {
            return _ltoa_s(_Value, _Buffer, _Size, _Radix);
        }
    }
    char *_ltoa(long _Value, char *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _ltoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix);
    extern "C++" {
        template <size_t _Size> inline errno_t _ultoa_s(unsigned long _Value, char (&_Buffer)[_Size], int _Radix) throw()         {
            return _ultoa_s(_Value, _Buffer, _Size, _Radix);
        }
    }
    char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _ultoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix);
    char *_i64toa(long long _Value, char *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _i64toa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix);
    char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _ui64toa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign);
    extern "C++" {
        template <size_t _Size> inline errno_t _ecvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount, int *_PtDec, int *_PtSign) throw()         {
            return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign);
        }
    }
    char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign) __declspec(deprecated("This function or variable may be unsafe. Consider using _ecvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign);
    extern "C++" {
        template <size_t _Size> inline errno_t _fcvt_s(char (&_Buffer)[_Size], double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign) throw()         {
            return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign);
        }
    }
    char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign) __declspec(deprecated("This function or variable may be unsafe. Consider using _fcvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount);
    extern "C++" {
        template <size_t _Size> inline errno_t _gcvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount) throw()         {
            return _gcvt_s(_Buffer, _Size, _Value, _DigitCount);
        }
    }
    char *_gcvt(double _Value, int _DigitCount, char *_Buffer) __declspec(deprecated("This function or variable may be unsafe. Consider using _gcvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int ___mb_cur_max_func();
    int ___mb_cur_max_l_func(_locale_t _Locale);
    int mblen(const char *_Ch, size_t _MaxCount);
    int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale);
    size_t _mbstrlen(const char *_String);
    size_t _mbstrlen_l(const char *_String, _locale_t _Locale);
    size_t _mbstrnlen(const char *_String, size_t _MaxCount);
    size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale);
    int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes);
    int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale);
    errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount);
    extern "C++" {
        template <size_t _Size> inline errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t (&_Dest)[_Size], const char *_Source, size_t _MaxCount) throw()         {
            return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount);
        }
    }
    size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount) __declspec(deprecated("This function or variable may be unsafe. Consider using mbstowcs_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale);
    extern "C++" {
        template <size_t _Size> inline errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t (&_Dest)[_Size], const char *_Source, size_t _MaxCount, _locale_t _Locale) throw()         {
            return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale);
        }
    }
    size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale) __declspec(deprecated("This function or variable may be unsafe. Consider using _mbstowcs_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int wctomb(char *_MbCh, wchar_t _WCh) __declspec(deprecated("This function or variable may be unsafe. Consider using wctomb_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale) __declspec(deprecated("This function or variable may be unsafe. Consider using _wctomb_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh);
    errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale);
    errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes);
    extern "C++" {
        template <size_t _Size> inline errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char (&_Dest)[_Size], const wchar_t *_Source, size_t _MaxCount) throw()         {
            return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount);
        }
    }
    size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount) __declspec(deprecated("This function or variable may be unsafe. Consider using wcstombs_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale);
    extern "C++" {
        template <size_t _Size> inline errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char (&_Dest)[_Size], const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale) throw()         {
            return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale);
        }
    }
    size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcstombs_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount);
    errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext);
    extern "C++" {
        template <size_t _Size> inline errno_t _makepath_s(char (&_Buffer)[_Size], const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext) throw()         {
            return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext);
        }
    }
    void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext) __declspec(deprecated("This function or variable may be unsafe. Consider using _makepath_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext) __declspec(deprecated("This function or variable may be unsafe. Consider using _splitpath_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount);
    extern "C++" {
        template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t _splitpath_s(const char *_Dest, char (&_Drive)[_DriveSize], char (&_Dir)[_DirSize], char (&_Name)[_NameSize], char (&_Ext)[_ExtSize]) throw()         {
            return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize);
        }
    }
    errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName);
    int *__p___argc();
    char ***__p___argv();
    wchar_t ***__p___wargv();
    char ***__p__environ();
    wchar_t ***__p__wenviron();
    char *getenv(const char *_VarName) __declspec(deprecated("This function or variable may be unsafe. Consider using _dupenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    extern "C++" {
        template <size_t _Size> inline errno_t getenv_s(size_t *_RequiredCount, char (&_Buffer)[_Size], const char *_VarName) throw()         {
            return getenv_s(_RequiredCount, _Buffer, _Size, _VarName);
        }
    }
    errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName);
    int system(const char *_Command);
    int _putenv(const char *_EnvString);
    errno_t _putenv_s(const char *_Name, const char *_Value);
    errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount);
    extern "C++" {
        template <size_t _Size> inline errno_t _searchenv_s(const char *_Filename, const char *_VarName, char (&_Buffer)[_Size]) throw()         {
            return _searchenv_s(_Filename, _VarName, _Buffer, _Size);
        }
    }
    void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer) __declspec(deprecated("This function or variable may be unsafe. Consider using _searchenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    void _seterrormode(int _Mode) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetErrorMode instead. See online help for details."));
    void _beep(unsigned int _Frequency, unsigned int _Duration) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Beep instead. See online help for details."));
    void _sleep(unsigned long _Duration) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Sleep instead. See online help for details."));
    char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _ecvt. See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _ecvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _fcvt. See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _fcvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    char *gcvt(double _Value, int _DigitCount, char *_DstBuf) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _gcvt. See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _fcvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    char *itoa(int _Value, char *_Buffer, int _Radix) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _itoa. See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _itoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    char *ltoa(long _Value, char *_Buffer, int _Radix) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _ltoa. See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _ltoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    void swab(char *_Buf1, char *_Buf2, int _SizeInBytes) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _swab. See online help for details."));
    char *ultoa(unsigned long _Value, char *_Buffer, int _Radix) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _ultoa. See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _ultoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int putenv(const char *_EnvString) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _putenv. See online help for details."));
    _onexit_t onexit(_onexit_t _Func);
}
extern "C" {
    struct _exception {
        int type;
        char *name;
        double arg1;
        double arg2;
        double retval;
    };
    struct _complex {
        double x;
        double y;
    };
    typedef float float_t;
    typedef double double_t;
    extern const double _HUGE;
    void _fperrraise(int _Except);
    short _dclass(double _X);
    short _ldclass(long double _X);
    short _fdclass(float _X);
    int _dsign(double _X);
    int _ldsign(long double _X);
    int _fdsign(float _X);
    int _dpcomp(double _X, double _Y);
    int _ldpcomp(long double _X, long double _Y);
    int _fdpcomp(float _X, float _Y);
    short _dtest(double *_Px);
    short _ldtest(long double *_Px);
    short _fdtest(float *_Px);
    short _d_int(double *_Px, short _Xexp);
    short _ld_int(long double *_Px, short _Xexp);
    short _fd_int(float *_Px, short _Xexp);
    short _dscale(double *_Px, long _Lexp);
    short _ldscale(long double *_Px, long _Lexp);
    short _fdscale(float *_Px, long _Lexp);
    short _dunscale(short *_Pex, double *_Px);
    short _ldunscale(short *_Pex, long double *_Px);
    short _fdunscale(short *_Pex, float *_Px);
    short _dexp(double *_Px, double _Y, long _Eoff);
    short _ldexp(long double *_Px, long double _Y, long _Eoff);
    short _fdexp(float *_Px, float _Y, long _Eoff);
    short _dnorm(unsigned short *_Ps);
    short _fdnorm(unsigned short *_Ps);
    double _dpoly(double _X, const double *_Tab, int _N);
    long double _ldpoly(long double _X, const long double *_Tab, int _N);
    float _fdpoly(float _X, const float *_Tab, int _N);
    double _dlog(double _X, int _Baseflag);
    long double _ldlog(long double _X, int _Baseflag);
    float _fdlog(float _X, int _Baseflag);
    double _dsin(double _X, unsigned int _Qoff);
    long double _ldsin(long double _X, unsigned int _Qoff);
    float _fdsin(float _X, unsigned int _Qoff);
    typedef union {
        unsigned short _Sh[4];
        double _Val;
    } _double_val;
    typedef union {
        unsigned short _Sh[2];
        float _Val;
    } _float_val;
    typedef union {
        unsigned short _Sh[4];
        long double _Val;
    } _ldouble_val;
    typedef union {
        unsigned short _Word[4];
        float _Float;
        double _Double;
        long double _Long_double;
    } _float_const;
    extern const _float_const _Denorm_C;
    extern const _float_const _Inf_C;
    extern const _float_const _Nan_C;
    extern const _float_const _Snan_C;
    extern const _float_const _Hugeval_C;
    extern const _float_const _FDenorm_C;
    extern const _float_const _FInf_C;
    extern const _float_const _FNan_C;
    extern const _float_const _FSnan_C;
    extern const _float_const _LDenorm_C;
    extern const _float_const _LInf_C;
    extern const _float_const _LNan_C;
    extern const _float_const _LSnan_C;
    extern const _float_const _Eps_C;
    extern const _float_const _Rteps_C;
    extern const _float_const _FEps_C;
    extern const _float_const _FRteps_C;
    extern const _float_const _LEps_C;
    extern const _float_const _LRteps_C;
    extern const double _Zero_C;
    extern const double _Xbig_C;
    extern const float _FZero_C;
    extern const float _FXbig_C;
    extern const long double _LZero_C;
    extern const long double _LXbig_C;
    extern "C++" {
        inline int fpclassify(float _X) throw()         {
            return _fdtest(&_X);
        }
        inline int fpclassify(double _X) throw()         {
            return _dtest(&_X);
        }
        inline int fpclassify(long double _X) throw()         {
            return _ldtest(&_X);
        }
        inline bool signbit(float _X) throw()         {
            return _fdsign(_X) != 0;
        }
        inline bool signbit(double _X) throw()         {
            return _dsign(_X) != 0;
        }
        inline bool signbit(long double _X) throw()         {
            return _ldsign(_X) != 0;
        }
        inline int _fpcomp(float _X, float _Y) throw()         {
            return _fdpcomp(_X, _Y);
        }
        inline int _fpcomp(double _X, double _Y) throw()         {
            return _dpcomp(_X, _Y);
        }
        inline int _fpcomp(long double _X, long double _Y) throw()         {
            return _ldpcomp(_X, _Y);
        }
        template <class _Trc, class _Tre> struct _Combined_type {
            typedef float _Type;
        };
        template<> struct _Combined_type<float, double> {
            typedef double _Type;
        };
        template<> struct _Combined_type<float, long double> {
            typedef long double _Type;
        };
        template <class _Ty, class _T2> struct _Real_widened {
            typedef long double _Type;
        };
        template<> struct _Real_widened<float, float> {
            typedef float _Type;
        };
        template<> struct _Real_widened<float, double> {
            typedef double _Type;
        };
        template<> struct _Real_widened<double, float> {
            typedef double _Type;
        };
        template<> struct _Real_widened<double, double> {
            typedef double _Type;
        };
        template <class _Ty> struct _Real_type {
            typedef double _Type;
        };
        template<> struct _Real_type<float> {
            typedef float _Type;
        };
        template<> struct _Real_type<long double> {
            typedef long double _Type;
        };
        template <class _T1, class _T2> inline int _fpcomp(_T1 _X, _T2 _Y) throw()         {
            typedef typename _Combined_type<float, typename _Real_widened<typename _Real_type<_T1>::_Type, typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
            return _fpcomp((_Tw)_X, (_Tw)_Y);
        }
        template <class _Ty> inline bool isfinite(_Ty _X) throw()         {
            return fpclassify(_X) <= 0;
        }
        template <class _Ty> inline bool isinf(_Ty _X) throw()         {
            return fpclassify(_X) == 1;
        }
        template <class _Ty> inline bool isnan(_Ty _X) throw()         {
            return fpclassify(_X) == 2;
        }
        template <class _Ty> inline bool isnormal(_Ty _X) throw()         {
            return fpclassify(_X) == (-1);
        }
        template <class _Ty1, class _Ty2> inline bool isgreater(_Ty1 _X, _Ty2 _Y) throw()         {
            return (_fpcomp(_X, _Y) & 4) != 0;
        }
        template <class _Ty1, class _Ty2> inline bool isgreaterequal(_Ty1 _X, _Ty2 _Y) throw()         {
            return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
        }
        template <class _Ty1, class _Ty2> inline bool isless(_Ty1 _X, _Ty2 _Y) throw()         {
            return (_fpcomp(_X, _Y) & 1) != 0;
        }
        template <class _Ty1, class _Ty2> inline bool islessequal(_Ty1 _X, _Ty2 _Y) throw()         {
            return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
        }
        template <class _Ty1, class _Ty2> inline bool islessgreater(_Ty1 _X, _Ty2 _Y) throw()         {
            return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
        }
        template <class _Ty1, class _Ty2> inline bool isunordered(_Ty1 _X, _Ty2 _Y) throw()         {
            return _fpcomp(_X, _Y) == 0;
        }
    }
    int abs(int _X);
    long labs(long _X);
    long long llabs(long long _X);
    double acos(double _X);
    double asin(double _X);
    double atan(double _X);
    double atan2(double _Y, double _X);
    double cos(double _X);
    double cosh(double _X);
    double exp(double _X);
    double fabs(double _X);
    double fmod(double _X, double _Y);
    double log(double _X);
    double log10(double _X);
    double pow(double _X, double _Y);
    double sin(double _X);
    double sinh(double _X);
    double sqrt(double _X);
    double tan(double _X);
    double tanh(double _X);
    double acosh(double _X);
    double asinh(double _X);
    double atanh(double _X);
    double atof(const char *_String);
    double _atof_l(const char *_String, _locale_t _Locale);
    double _cabs(struct _complex _Complex_value);
    double cbrt(double _X);
    double ceil(double _X);
    double _chgsign(double _X);
    double copysign(double _Number, double _Sign);
    double _copysign(double _Number, double _Sign);
    double erf(double _X);
    double erfc(double _X);
    double exp2(double _X);
    double expm1(double _X);
    double fdim(double _X, double _Y);
    double floor(double _X);
    double fma(double _X, double _Y, double _Z);
    double fmax(double _X, double _Y);
    double fmin(double _X, double _Y);
    double frexp(double _X, int *_Y);
    double hypot(double _X, double _Y);
    double _hypot(double _X, double _Y);
    int ilogb(double _X);
    double ldexp(double _X, int _Y);
    double lgamma(double _X);
    long long llrint(double _X);
    long long llround(double _X);
    double log1p(double _X);
    double log2(double _X);
    double logb(double _X);
    long lrint(double _X);
    long lround(double _X);
    int _matherr(struct _exception *_Except);
    double modf(double _X, double *_Y);
    double nan(const char *_X);
    double nearbyint(double _X);
    double nextafter(double _X, double _Y);
    double nexttoward(double _X, long double _Y);
    double remainder(double _X, double _Y);
    double remquo(double _X, double _Y, int *_Z);
    double rint(double _X);
    double round(double _X);
    double scalbln(double _X, long _Y);
    double scalbn(double _X, int _Y);
    double tgamma(double _X);
    double trunc(double _X);
    double _j0(double _X);
    double _j1(double _X);
    double _jn(int _X, double _Y);
    double _y0(double _X);
    double _y1(double _X);
    double _yn(int _X, double _Y);
    float acoshf(float _X);
    float asinhf(float _X);
    float atanhf(float _X);
    float cbrtf(float _X);
    float _chgsignf(float _X);
    float copysignf(float _Number, float _Sign);
    float _copysignf(float _Number, float _Sign);
    float erff(float _X);
    float erfcf(float _X);
    float expm1f(float _X);
    float exp2f(float _X);
    float fdimf(float _X, float _Y);
    float fmaf(float _X, float _Y, float _Z);
    float fmaxf(float _X, float _Y);
    float fminf(float _X, float _Y);
    float _hypotf(float _X, float _Y);
    int ilogbf(float _X);
    float lgammaf(float _X);
    long long llrintf(float _X);
    long long llroundf(float _X);
    float log1pf(float _X);
    float log2f(float _X);
    float logbf(float _X);
    long lrintf(float _X);
    long lroundf(float _X);
    float nanf(const char *_X);
    float nearbyintf(float _X);
    float nextafterf(float _X, float _Y);
    float nexttowardf(float _X, long double _Y);
    float remainderf(float _X, float _Y);
    float remquof(float _X, float _Y, int *_Z);
    float rintf(float _X);
    float roundf(float _X);
    float scalblnf(float _X, long _Y);
    float scalbnf(float _X, int _Y);
    float tgammaf(float _X);
    float truncf(float _X);
    float _logbf(float _X);
    float _nextafterf(float _X, float _Y);
    int _finitef(float _X);
    int _isnanf(float _X);
    int _fpclassf(float _X);
    int _set_FMA3_enable(int _Flag);
    int _get_FMA3_enable();
    float acosf(float _X);
    float asinf(float _X);
    float atan2f(float _Y, float _X);
    float atanf(float _X);
    float ceilf(float _X);
    float cosf(float _X);
    float coshf(float _X);
    float expf(float _X);
    inline float fabsf(float _X)     {
        return (float)fabs(_X);
    }
    float floorf(float _X);
    float fmodf(float _X, float _Y);
    inline float frexpf(float _X, int *_Y)     {
        return (float)frexp(_X, _Y);
    }
    inline float hypotf(float _X, float _Y)     {
        return _hypotf(_X, _Y);
    }
    inline float ldexpf(float _X, int _Y)     {
        return (float)ldexp(_X, _Y);
    }
    float log10f(float _X);
    float logf(float _X);
    float modff(float _X, float *_Y);
    float powf(float _X, float _Y);
    float sinf(float _X);
    float sinhf(float _X);
    float sqrtf(float _X);
    float tanf(float _X);
    float tanhf(float _X);
    long double acoshl(long double _X);
    inline long double acosl(long double _X)     {
        return acos((double)_X);
    }
    long double asinhl(long double _X);
    inline long double asinl(long double _X)     {
        return asin((double)_X);
    }
    inline long double atan2l(long double _Y, long double _X)     {
        return atan2((double)_Y, (double)_X);
    }
    long double atanhl(long double _X);
    inline long double atanl(long double _X)     {
        return atan((double)_X);
    }
    long double cbrtl(long double _X);
    inline long double ceill(long double _X)     {
        return ceil((double)_X);
    }
    inline long double _chgsignl(long double _X)     {
        return _chgsign((double)_X);
    }
    long double copysignl(long double _Number, long double _Sign);
    inline long double _copysignl(long double _Number, long double _Sign)     {
        return _copysign((double)_Number, (double)_Sign);
    }
    inline long double coshl(long double _X)     {
        return cosh((double)_X);
    }
    inline long double cosl(long double _X)     {
        return cos((double)_X);
    }
    long double erfl(long double _X);
    long double erfcl(long double _X);
    inline long double expl(long double _X)     {
        return exp((double)_X);
    }
    long double exp2l(long double _X);
    long double expm1l(long double _X);
    inline long double fabsl(long double _X)     {
        return fabs((double)_X);
    }
    long double fdiml(long double _X, long double _Y);
    inline long double floorl(long double _X)     {
        return floor((double)_X);
    }
    long double fmal(long double _X, long double _Y, long double _Z);
    long double fmaxl(long double _X, long double _Y);
    long double fminl(long double _X, long double _Y);
    inline long double fmodl(long double _X, long double _Y)     {
        return fmod((double)_X, (double)_Y);
    }
    inline long double frexpl(long double _X, int *_Y)     {
        return frexp((double)_X, _Y);
    }
    int ilogbl(long double _X);
    inline long double _hypotl(long double _X, long double _Y)     {
        return _hypot((double)_X, (double)_Y);
    }
    inline long double hypotl(long double _X, long double _Y)     {
        return _hypot((double)_X, (double)_Y);
    }
    inline long double ldexpl(long double _X, int _Y)     {
        return ldexp((double)_X, _Y);
    }
    long double lgammal(long double _X);
    long long llrintl(long double _X);
    long long llroundl(long double _X);
    inline long double logl(long double _X)     {
        return log((double)_X);
    }
    inline long double log10l(long double _X)     {
        return log10((double)_X);
    }
    long double log1pl(long double _X);
    long double log2l(long double _X);
    long double logbl(long double _X);
    long lrintl(long double _X);
    long lroundl(long double _X);
    inline long double modfl(long double _X, long double *_Y)     {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }
    long double nanl(const char *_X);
    long double nearbyintl(long double _X);
    long double nextafterl(long double _X, long double _Y);
    long double nexttowardl(long double _X, long double _Y);
    inline long double powl(long double _X, long double _Y)     {
        return pow((double)_X, (double)_Y);
    }
    long double remainderl(long double _X, long double _Y);
    long double remquol(long double _X, long double _Y, int *_Z);
    long double rintl(long double _X);
    long double roundl(long double _X);
    long double scalblnl(long double _X, long _Y);
    long double scalbnl(long double _X, int _Y);
    inline long double sinhl(long double _X)     {
        return sinh((double)_X);
    }
    inline long double sinl(long double _X)     {
        return sin((double)_X);
    }
    inline long double sqrtl(long double _X)     {
        return sqrt((double)_X);
    }
    inline long double tanhl(long double _X)     {
        return tanh((double)_X);
    }
    inline long double tanl(long double _X)     {
        return tan((double)_X);
    }
    long double tgammal(long double _X);
    long double truncl(long double _X);
    extern double HUGE;
    double j0(double _X) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _j0. See online help for details."));
    double j1(double _X) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _j1. See online help for details."));
    double jn(int _X, double _Y) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _jn. See online help for details."));
    double y0(double _X) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _y0. See online help for details."));
    double y1(double _X) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _y1. See online help for details."));
    double yn(int _X, double _Y) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _yn. See online help for details."));
}
inline double abs(double _Xx) noexcept {
    return (::fabs(_Xx));
}
inline float abs(float _Xx) noexcept {
    return (::fabsf(_Xx));
}
inline long double abs(long double _Xx) noexcept {
    return (::fabsl(_Xx));
}
namespace std {
    using ::size_t;
    using ::div_t;
    using ::ldiv_t;
    using ::abort;
    using ::abs;
    using ::atexit;
    using ::atof;
    using ::atoi;
    using ::atol;
    using ::bsearch;
    using ::calloc;
    using ::div;
    using ::exit;
    using ::free;
    using ::labs;
    using ::ldiv;
    using ::malloc;
    using ::mblen;
    using ::mbstowcs;
    using ::mbtowc;
    using ::qsort;
    using ::rand;
    using ::realloc;
    using ::srand;
    using ::strtod;
    using ::strtol;
    using ::strtoul;
    using ::wcstombs;
    using ::wctomb;
    using ::lldiv_t;
    using ::getenv;
    using ::system;
    using ::atoll;
    using ::llabs;
    using ::lldiv;
    using ::strtof;
    using ::strtold;
    using ::strtoll;
    using ::strtoull;
    using ::_Exit;
    using ::at_quick_exit;
    using ::quick_exit;
}
extern "C" {
    void _Feraise(int);
    typedef union {
        unsigned short _Word[8];
        float _Float;
        double _Double;
        long double _Long_double;
    } _Dconst;
    double _Cosh(double, double);
    short _Dtest(double *);
    double _Sinh(double, double);
    short _Exp(double *, double, short);
    extern _Dconst _Denorm;
    extern _Dconst _Hugeval;
    extern _Dconst _Inf;
    extern _Dconst _Nan;
    extern _Dconst _Snan;
    float _FCosh(float, float);
    short _FDtest(float *);
    float _FSinh(float, float);
    short _FExp(float *, float, short);
    extern _Dconst _FDenorm;
    extern _Dconst _FInf;
    extern _Dconst _FNan;
    extern _Dconst _FSnan;
    long double _LCosh(long double, long double);
    short _LDtest(long double *);
    long double _LSinh(long double, long double);
    short _LExp(long double *, long double, short);
    extern _Dconst _LDenorm;
    extern _Dconst _LInf;
    extern _Dconst _LNan;
    extern _Dconst _LSnan;
}
extern "C" {
    unsigned int _clearfp();
    unsigned int _controlfp(unsigned int _NewValue, unsigned int _Mask) __declspec(deprecated("This function or variable may be unsafe. Consider using _controlfp_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    void _set_controlfp(unsigned int _NewValue, unsigned int _Mask);
    errno_t _controlfp_s(unsigned int *_CurrentState, unsigned int _NewValue, unsigned int _Mask);
    unsigned int _statusfp();
    void _fpreset();
    unsigned int _control87(unsigned int _NewValue, unsigned int _Mask);
    int *__fpecode();
    int __fpe_flt_rounds();
    double _copysign(double _Number, double _Sign);
    double _chgsign(double _X);
    double _scalb(double _X, long _Y);
    double _logb(double _X);
    double _nextafter(double _X, double _Y);
    int _finite(double _X);
    int _isnan(double _X);
    int _fpclass(double _X);
    float _scalbf(float _X, long _Y);
    void fpreset();
}
inline double pow(double _Xx, int _Yx) noexcept {
    if (_Yx == 2)
        return (_Xx * _Xx);
    return (::pow(_Xx, static_cast<double>(_Yx)));
}
inline float acos(float _Xx) noexcept {
    return (::acosf(_Xx));
}
inline float acosh(float _Xx) noexcept {
    return (::acoshf(_Xx));
}
inline float asin(float _Xx) noexcept {
    return (::asinf(_Xx));
}
inline float asinh(float _Xx) noexcept {
    return (::asinhf(_Xx));
}
inline float atan(float _Xx) noexcept {
    return (::atanf(_Xx));
}
inline float atanh(float _Xx) noexcept {
    return (::atanhf(_Xx));
}
inline float atan2(float _Yx, float _Xx) noexcept {
    return (::atan2f(_Yx, _Xx));
}
inline float cbrt(float _Xx) noexcept {
    return (::cbrtf(_Xx));
}
inline float ceil(float _Xx) noexcept {
    return (::ceilf(_Xx));
}
inline float copysign(float _Number, float _Sign) noexcept {
    return (::copysignf(_Number, _Sign));
}
inline float cos(float _Xx) noexcept {
    return (::cosf(_Xx));
}
inline float cosh(float _Xx) noexcept {
    return (::coshf(_Xx));
}
inline float erf(float _Xx) noexcept {
    return (::erff(_Xx));
}
inline float erfc(float _Xx) noexcept {
    return (::erfcf(_Xx));
}
inline float exp(float _Xx) noexcept {
    return (::expf(_Xx));
}
inline float exp2(float _Xx) noexcept {
    return (::exp2f(_Xx));
}
inline float expm1(float _Xx) noexcept {
    return (::expm1f(_Xx));
}
inline float fabs(float _Xx) noexcept {
    return (::fabsf(_Xx));
}
inline float fdim(float _Xx, float _Yx) noexcept {
    return (::fdimf(_Xx, _Yx));
}
inline float floor(float _Xx) noexcept {
    return (::floorf(_Xx));
}
inline float fma(float _Xx, float _Yx, float _Zx) noexcept {
    return (::fmaf(_Xx, _Yx, _Zx));
}
inline float fmax(float _Xx, float _Yx) noexcept {
    return (::fmaxf(_Xx, _Yx));
}
inline float fmin(float _Xx, float _Yx) noexcept {
    return (::fminf(_Xx, _Yx));
}
inline float fmod(float _Xx, float _Yx) noexcept {
    return (::fmodf(_Xx, _Yx));
}
inline float frexp(float _Xx, int *_Yx) noexcept {
    return (::frexpf(_Xx, _Yx));
}
inline float hypot(float _Xx, float _Yx) noexcept {
    return (::hypotf(_Xx, _Yx));
}
inline int ilogb(float _Xx) noexcept {
    return (::ilogbf(_Xx));
}
inline float ldexp(float _Xx, int _Yx) noexcept {
    return (::ldexpf(_Xx, _Yx));
}
inline float lgamma(float _Xx) noexcept {
    return (::lgammaf(_Xx));
}
inline long long llrint(float _Xx) noexcept {
    return (::llrintf(_Xx));
}
inline long long llround(float _Xx) noexcept {
    return (::llroundf(_Xx));
}
inline float log(float _Xx) noexcept {
    return (::logf(_Xx));
}
inline float log10(float _Xx) noexcept {
    return (::log10f(_Xx));
}
inline float log1p(float _Xx) noexcept {
    return (::log1pf(_Xx));
}
inline float log2(float _Xx) noexcept {
    return (::log2f(_Xx));
}
inline float logb(float _Xx) noexcept {
    return (::logbf(_Xx));
}
inline long lrint(float _Xx) noexcept {
    return (::lrintf(_Xx));
}
inline long lround(float _Xx) noexcept {
    return (::lroundf(_Xx));
}
inline float modf(float _Xx, float *_Yx) noexcept {
    return (::modff(_Xx, _Yx));
}
inline float nearbyint(float _Xx) noexcept {
    return (::nearbyintf(_Xx));
}
inline float nextafter(float _Xx, float _Yx) noexcept {
    return (::nextafterf(_Xx, _Yx));
}
inline float nexttoward(float _Xx, long double _Yx) noexcept {
    return (::nexttowardf(_Xx, _Yx));
}
inline float pow(float _Xx, float _Yx) noexcept {
    return (::powf(_Xx, _Yx));
}
inline float pow(float _Xx, int _Yx) noexcept {
    if (_Yx == 2)
        return (_Xx * _Xx);
    return (::powf(_Xx, static_cast<float>(_Yx)));
}
inline float remainder(float _Xx, float _Yx) noexcept {
    return (::remainderf(_Xx, _Yx));
}
inline float remquo(float _Xx, float _Yx, int *_Zx) noexcept {
    return (::remquof(_Xx, _Yx, _Zx));
}
inline float rint(float _Xx) noexcept {
    return (::rintf(_Xx));
}
inline float round(float _Xx) noexcept {
    return (::roundf(_Xx));
}
inline float scalbln(float _Xx, long _Yx) noexcept {
    return (::scalblnf(_Xx, _Yx));
}
inline float scalbn(float _Xx, int _Yx) noexcept {
    return (::scalbnf(_Xx, _Yx));
}
inline float sin(float _Xx) noexcept {
    return (::sinf(_Xx));
}
inline float sinh(float _Xx) noexcept {
    return (::sinhf(_Xx));
}
inline float sqrt(float _Xx) noexcept {
    return (::sqrtf(_Xx));
}
inline float tan(float _Xx) noexcept {
    return (::tanf(_Xx));
}
inline float tanh(float _Xx) noexcept {
    return (::tanhf(_Xx));
}
inline float tgamma(float _Xx) noexcept {
    return (::tgammaf(_Xx));
}
inline float trunc(float _Xx) noexcept {
    return (::truncf(_Xx));
}
inline long double acos(long double _Xx) noexcept {
    return (::acosl(_Xx));
}
inline long double acosh(long double _Xx) noexcept {
    return (::acoshl(_Xx));
}
inline long double asin(long double _Xx) noexcept {
    return (::asinl(_Xx));
}
inline long double asinh(long double _Xx) noexcept {
    return (::asinhl(_Xx));
}
inline long double atan(long double _Xx) noexcept {
    return (::atanl(_Xx));
}
inline long double atanh(long double _Xx) noexcept {
    return (::atanhl(_Xx));
}
inline long double atan2(long double _Yx, long double _Xx) noexcept {
    return (::atan2l(_Yx, _Xx));
}
inline long double cbrt(long double _Xx) noexcept {
    return (::cbrtl(_Xx));
}
inline long double ceil(long double _Xx) noexcept {
    return (::ceill(_Xx));
}
inline long double copysign(long double _Number, long double _Sign) noexcept {
    return (::copysignl(_Number, _Sign));
}
inline long double cos(long double _Xx) noexcept {
    return (::cosl(_Xx));
}
inline long double cosh(long double _Xx) noexcept {
    return (::coshl(_Xx));
}
inline long double erf(long double _Xx) noexcept {
    return (::erfl(_Xx));
}
inline long double erfc(long double _Xx) noexcept {
    return (::erfcl(_Xx));
}
inline long double exp(long double _Xx) noexcept {
    return (::expl(_Xx));
}
inline long double exp2(long double _Xx) noexcept {
    return (::exp2l(_Xx));
}
inline long double expm1(long double _Xx) noexcept {
    return (::expm1l(_Xx));
}
inline long double fabs(long double _Xx) noexcept {
    return (::fabsl(_Xx));
}
inline long double fdim(long double _Xx, long double _Yx) noexcept {
    return (::fdiml(_Xx, _Yx));
}
inline long double floor(long double _Xx) noexcept {
    return (::floorl(_Xx));
}
inline long double fma(long double _Xx, long double _Yx, long double _Zx) noexcept {
    return (::fmal(_Xx, _Yx, _Zx));
}
inline long double fmax(long double _Xx, long double _Yx) noexcept {
    return (::fmaxl(_Xx, _Yx));
}
inline long double fmin(long double _Xx, long double _Yx) noexcept {
    return (::fminl(_Xx, _Yx));
}
inline long double fmod(long double _Xx, long double _Yx) noexcept {
    return (::fmodl(_Xx, _Yx));
}
inline long double frexp(long double _Xx, int *_Yx) noexcept {
    return (::frexpl(_Xx, _Yx));
}
inline long double hypot(long double _Xx, long double _Yx) noexcept {
    return (::hypotl(_Xx, _Yx));
}
inline int ilogb(long double _Xx) noexcept {
    return (::ilogbl(_Xx));
}
inline long double ldexp(long double _Xx, int _Yx) noexcept {
    return (::ldexpl(_Xx, _Yx));
}
inline long double lgamma(long double _Xx) noexcept {
    return (::lgammal(_Xx));
}
inline long long llrint(long double _Xx) noexcept {
    return (::llrintl(_Xx));
}
inline long long llround(long double _Xx) noexcept {
    return (::llroundl(_Xx));
}
inline long double log(long double _Xx) noexcept {
    return (::logl(_Xx));
}
inline long double log10(long double _Xx) noexcept {
    return (::log10l(_Xx));
}
inline long double log1p(long double _Xx) noexcept {
    return (::log1pl(_Xx));
}
inline long double log2(long double _Xx) noexcept {
    return (::log2l(_Xx));
}
inline long double logb(long double _Xx) noexcept {
    return (::logbl(_Xx));
}
inline long lrint(long double _Xx) noexcept {
    return (::lrintl(_Xx));
}
inline long lround(long double _Xx) noexcept {
    return (::lroundl(_Xx));
}
inline long double modf(long double _Xx, long double *_Yx) noexcept {
    return (::modfl(_Xx, _Yx));
}
inline long double nearbyint(long double _Xx) noexcept {
    return (::nearbyintl(_Xx));
}
inline long double nextafter(long double _Xx, long double _Yx) noexcept {
    return (::nextafterl(_Xx, _Yx));
}
inline long double nexttoward(long double _Xx, long double _Yx) noexcept {
    return (::nexttowardl(_Xx, _Yx));
}
inline long double pow(long double _Xx, long double _Yx) noexcept {
    return (::powl(_Xx, _Yx));
}
inline long double pow(long double _Xx, int _Yx) noexcept {
    if (_Yx == 2)
        return (_Xx * _Xx);
    return (::powl(_Xx, static_cast<long double>(_Yx)));
}
inline long double remainder(long double _Xx, long double _Yx) noexcept {
    return (::remainderl(_Xx, _Yx));
}
inline long double remquo(long double _Xx, long double _Yx, int *_Zx) noexcept {
    return (::remquol(_Xx, _Yx, _Zx));
}
inline long double rint(long double _Xx) noexcept {
    return (::rintl(_Xx));
}
inline long double round(long double _Xx) noexcept {
    return (::roundl(_Xx));
}
inline long double scalbln(long double _Xx, long _Yx) noexcept {
    return (::scalblnl(_Xx, _Yx));
}
inline long double scalbn(long double _Xx, int _Yx) noexcept {
    return (::scalbnl(_Xx, _Yx));
}
inline long double sin(long double _Xx) noexcept {
    return (::sinl(_Xx));
}
inline long double sinh(long double _Xx) noexcept {
    return (::sinhl(_Xx));
}
inline long double sqrt(long double _Xx) noexcept {
    return (::sqrtl(_Xx));
}
inline long double tan(long double _Xx) noexcept {
    return (::tanl(_Xx));
}
inline long double tanh(long double _Xx) noexcept {
    return (::tanhl(_Xx));
}
inline long double tgamma(long double _Xx) noexcept {
    return (::tgammal(_Xx));
}
inline long double trunc(long double _Xx) noexcept {
    return (::truncl(_Xx));
}
namespace std {
    template <class _Ty, _Ty _Val> struct integral_constant {
        static constexpr _Ty value = _Val;
        using value_type = _Ty;
        using type = integral_constant<_Ty, _Val>;
        constexpr operator value_type() const noexcept         {
            return (value);
        }
        constexpr std::integral_constant::value_type operator()() const noexcept         {
            return (value);
        }
    };
template<> struct integral_constant<bool, true> {
        static constexpr bool value = true;
        using value_type = bool;
        using type = std::integral_constant<bool, true>;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<bool, true>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<bool, false> {
        static constexpr bool value = false;
        using value_type = bool;
        using type = std::integral_constant<bool, false>;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<bool, false>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<unsigned long long, 0> {
        static constexpr unsigned long long value = 0ULL;
        using value_type = unsigned long long;
        using type = std::integral_constant<unsigned long long, 0>;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<unsigned long long, 0>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<unsigned long long, 2> {
        static constexpr unsigned long long value = 2ULL;
        using value_type = unsigned long long;
        using type = std::integral_constant<unsigned long long, 2>;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<unsigned long long, 2>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<unsigned long long, 1> {
        static constexpr unsigned long long value = 1ULL;
        using value_type = unsigned long long;
        using type = std::integral_constant<unsigned long long, 1>;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<unsigned long long, 1>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<unsigned long long, 4> {
        static constexpr unsigned long long value = 4ULL;
        using value_type = unsigned long long;
        using type = std::integral_constant<unsigned long long, 4>;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<unsigned long long, 4>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<unsigned long long, 8> {
        static constexpr unsigned long long value = 8ULL;
        using value_type = unsigned long long;
        using type = std::integral_constant<unsigned long long, 8>;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<unsigned long long, 8>::value_type operator()() const noexcept;
    };
    template <bool _Val> using bool_constant = integral_constant<bool, _Val>;
    using true_type = bool_constant<true>;
    using false_type = bool_constant<false>;
    template <bool _Test, class _Ty = void> struct enable_if {
    };
template<> struct enable_if<false, void> {
    };
template<> struct enable_if<true, int> {
        using type = int;
    };
template<> struct enable_if<true, void> {
        using type = void;
    };
    template <class _Ty> struct enable_if<true, _Ty> {
        using type = _Ty;
    };
    template <bool _Test, class _Ty = void> using enable_if_t = typename enable_if<_Test, _Ty>::type;
    template <bool _Test, class _Ty1, class _Ty2> struct conditional {
        using type = _Ty2;
    };
template<> struct conditional<true, std::_Default_allocator_traits<std::allocator<char> >, std::_Normal_allocator_traits<std::allocator<char> >> {
        using type = std::_Default_allocator_traits<std::allocator<char> >;
    };
template<> struct conditional<true, std::_Simple_types<char>, std::_String_iter_types<char, unsigned long long, long long, char *, const char *, char &, const char &>> {
        using type = std::_Simple_types<char>;
    };
template<> struct conditional<false, std::is_same<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData> >, std::is_convertible<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData> >> {
        using type = std::is_convertible<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData> >;
    };
template<> struct conditional<false, std::is_same<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >, std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >> {
        using type = std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >;
    };
template<> struct conditional<false, std::is_same<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >, std::is_convertible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >> {
        using type = std::is_convertible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >;
    };
    template <class _Ty1, class _Ty2> struct conditional<true, _Ty1, _Ty2> {
        using type = _Ty1;
    };
    template <bool _Test, class _Ty1, class _Ty2> using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;
    template <class _Ty1, class _Ty2> struct is_same : std::false_type {
    };
template<> struct is_same<int, int &&> : std::false_type {
    };
template<> struct is_same<int &, int &&> : std::false_type {
    };
template<> struct is_same<int &&, int &&> : std::true_type {
    };
template<> struct is_same<unsigned long long, unsigned long long> : std::true_type {
    };
template<> struct is_same<long long, long long> : std::true_type {
    };
template<> struct is_same<char *, char *> : std::true_type {
    };
template<> struct is_same<const char *, const char *> : std::true_type {
    };
template<> struct is_same<char, char> : std::true_type {
    };
template<> struct is_same<const unsigned char *, const unsigned char *> : std::true_type {
    };
template<> struct is_same<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >, nullptr_t> : std::false_type {
    };
template<> struct is_same<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >, const unsigned char *> : std::false_type {
    };
    template <class _Ty1> struct is_same<_Ty1, _Ty1> : std::true_type {
    };
    template <class _Ty, class _Uty> constexpr bool is_same_v = is_same<_Ty, _Uty>::value;
    template <class _Ty> struct remove_const {
        using type = _Ty;
    };
    template <class _Ty> struct remove_const<_Ty> {
        using type = _Ty;
    };
    template <class _Ty> using remove_const_t = typename remove_const<_Ty>::type;
    template <class _Ty> struct remove_volatile {
        using type = _Ty;
    };
    template <class _Ty> struct remove_volatile<_Ty> {
        using type = _Ty;
    };
    template <class _Ty> using remove_volatile_t = typename remove_volatile<_Ty>::type;
    template <class _Ty> struct remove_cv {
        using type = _Ty;
    };
template<> struct remove_cv<double> {
        using type = double;
    };
    template <class _Ty> struct remove_cv<_Ty> {
        using type = _Ty;
    };
    template <class _Ty> struct remove_cv<_Ty> {
        using type = _Ty;
    };
    template <class _Ty> struct remove_cv<_Ty> {
        using type = _Ty;
    };
    template <class _Ty> using remove_cv_t = typename remove_cv<_Ty>::type;
    template <class _Ty> struct _Is_integral : std::false_type {
    };
template<> struct _Is_integral<double> : std::false_type {
    };
    template<> struct _Is_integral<bool> : std::true_type {
    };
    template<> struct _Is_integral<char> : std::true_type {
    };
    template<> struct _Is_integral<unsigned char> : std::true_type {
    };
    template<> struct _Is_integral<signed char> : std::true_type {
    };
    template<> struct _Is_integral<wchar_t> : std::true_type {
    };
    template<> struct _Is_integral<char16_t> : std::true_type {
    };
    template<> struct _Is_integral<char32_t> : std::true_type {
    };
    template<> struct _Is_integral<unsigned short> : std::true_type {
    };
    template<> struct _Is_integral<short> : std::true_type {
    };
    template<> struct _Is_integral<unsigned int> : std::true_type {
    };
    template<> struct _Is_integral<int> : std::true_type {
    };
    template<> struct _Is_integral<unsigned long> : std::true_type {
    };
    template<> struct _Is_integral<long> : std::true_type {
    };
    template<> struct _Is_integral<unsigned long long> : std::true_type {
    };
    template<> struct _Is_integral<long long> : std::true_type {
    };
    template <class _Ty> struct is_integral : _Is_integral<remove_cv_t<_Ty> >::type {
    };
template<> struct is_integral<double> : _Is_integral<remove_cv_t<double> >::type {
    };
    template <class _Ty> constexpr bool is_integral_v = is_integral<_Ty>::value;
    template <class _Ty> struct _Is_floating_point : std::false_type {
    };
    template<> struct _Is_floating_point<float> : std::true_type {
    };
    template<> struct _Is_floating_point<double> : std::true_type {
    };
    template<> struct _Is_floating_point<long double> : std::true_type {
    };
    template <class _Ty> struct is_floating_point : _Is_floating_point<remove_cv_t<_Ty> >::type {
    };
    template <class _Ty> constexpr bool is_floating_point_v = is_floating_point<_Ty>::value;
    template <class _Ty> struct is_arithmetic : bool_constant<is_integral_v<_Ty> || is_floating_point_v<_Ty> > {
    };
    template <class _Ty> constexpr bool is_arithmetic_v = is_arithmetic<_Ty>::value;
    template <class _Ty> struct remove_reference {
        using type = _Ty;
    };
template<> struct remove_reference<std::default_delete<v8::internal::ScriptStreamingData>> {
        using type = std::default_delete<v8::internal::ScriptStreamingData>;
    };
template<> struct remove_reference<std::default_delete<unsigned char const[]>> {
        using type = std::default_delete<unsigned char const[]>;
    };
template<> struct remove_reference<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &> {
        using type = std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >;
    };
template<> struct remove_reference<const unsigned char *&> {
        using type = const unsigned char *;
    };
template<> struct remove_reference<std::shared_ptr<v8::internal::wasm::NativeModule> &> {
        using type = std::shared_ptr<v8::internal::wasm::NativeModule>;
    };
template<> struct remove_reference<v8::OwnedBuffer &> {
        using type = v8::OwnedBuffer;
    };
template<> struct remove_reference<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> {
        using type = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>;
    };
    template <class _Ty> struct remove_reference<type-parameter-0-0 &> {
        using type = _Ty;
    };
    template <class _Ty> struct remove_reference<type-parameter-0-0 &&> {
        using type = _Ty;
    };
    template <class _Ty> using remove_reference_t = typename remove_reference<_Ty>::type;
    constexpr bool is_integral_v = is_integral<double>::value;
    constexpr bool is_same_v = is_same<int, int &&>::value;
    constexpr bool is_same_v = is_same<int &, int &&>::value;
    constexpr bool is_same_v = is_same<int &&, int &&>::value;
    constexpr bool is_same_v = is_same<unsigned long long, unsigned long long>::value;
    constexpr bool is_same_v = is_same<long long, long long>::value;
    constexpr bool is_same_v = is_same<char *, char *>::value;
    constexpr bool is_same_v = is_same<const char *, const char *>::value;
    constexpr bool is_same_v = is_same<char, char>::value;
    constexpr bool is_same_v = is_same<const unsigned char *, const unsigned char *>::value;
    constexpr bool is_same_v = is_same<unique_ptr<unsigned char const[], default_delete<unsigned char const[]> >, const unsigned char *>::value;
}
namespace std {
    template <class _Ty1, class _Ty2> using _Common_float_type_t = conditional_t<is_same_v<_Ty1, long double> || is_same_v<_Ty2, long double>, long double, conditional_t<is_same_v<_Ty1, float> && is_same_v<_Ty2, float>, float, double> >;
}
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> pow(const _Ty1 _Left, const _Ty2 _Right) {
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return (::pow(static_cast<_Common>(_Left), static_cast<_Common>(_Right)));
}
extern "C" double acos(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double acos(_Ty _Left) {
    return (::acos(static_cast<double>(_Left)));
}
extern "C" double asin(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double asin(_Ty _Left) {
    return (::asin(static_cast<double>(_Left)));
}
extern "C" double atan(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double atan(_Ty _Left) {
    return (::atan(static_cast<double>(_Left)));
}
extern "C" double atan2(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> atan2(_Ty1 _Left, _Ty2 _Right) {
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return (::atan2(static_cast<_Common>(_Left), static_cast<_Common>(_Right)));
}
extern "C" double ceil(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double ceil(_Ty _Left) {
    return (::ceil(static_cast<double>(_Left)));
}
extern "C" double cos(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double cos(_Ty _Left) {
    return (::cos(static_cast<double>(_Left)));
}
extern "C" double cosh(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double cosh(_Ty _Left) {
    return (::cosh(static_cast<double>(_Left)));
}
extern "C" double exp(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double exp(_Ty _Left) {
    return (::exp(static_cast<double>(_Left)));
}
extern "C" double fabs(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double fabs(_Ty _Left) {
    return (::fabs(static_cast<double>(_Left)));
}
extern "C" double floor(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double floor(_Ty _Left) {
    return (::floor(static_cast<double>(_Left)));
}
extern "C" double fmod(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> fmod(_Ty1 _Left, _Ty2 _Right) {
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return (::fmod(static_cast<_Common>(_Left), static_cast<_Common>(_Right)));
}
extern "C" double frexp(double, int *)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double frexp(_Ty _Left, int *_Arg2) {
    return (::frexp(static_cast<double>(_Left), _Arg2));
}
extern "C" double ldexp(double, int)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double ldexp(_Ty _Left, int _Arg2) {
    return (::ldexp(static_cast<double>(_Left), _Arg2));
}
extern "C" double log(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double log(_Ty _Left) {
    return (::log(static_cast<double>(_Left)));
}
extern "C" double log10(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double log10(_Ty _Left) {
    return (::log10(static_cast<double>(_Left)));
}
extern "C" double sin(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double sin(_Ty _Left) {
    return (::sin(static_cast<double>(_Left)));
}
extern "C" double sinh(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double sinh(_Ty _Left) {
    return (::sinh(static_cast<double>(_Left)));
}
extern "C" double sqrt(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double sqrt(_Ty _Left) {
    return (::sqrt(static_cast<double>(_Left)));
}
extern "C" double tan(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double tan(_Ty _Left) {
    return (::tan(static_cast<double>(_Left)));
}
extern "C" double tanh(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double tanh(_Ty _Left) {
    return (::tanh(static_cast<double>(_Left)));
}
inline float _Fma(float _Left, float _Middle, float _Right) {
    return (::fmaf(_Left, _Middle, _Right));
}
inline double _Fma(double _Left, double _Middle, double _Right) {
    return (::fma(_Left, _Middle, _Right));
}
inline long double _Fma(long double _Left, long double _Middle, long double _Right) {
    return (::fmal(_Left, _Middle, _Right));
}
template <class _Ty1, class _Ty2, class _Ty3, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> && ::std::is_arithmetic_v<_Ty3> >> inline ::std::_Common_float_type_t<_Ty1, ::std::_Common_float_type_t<_Ty2, _Ty3> > fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right) {
    using _Common = ::std::_Common_float_type_t<_Ty1, ::std::_Common_float_type_t<_Ty2, _Ty3> >;
    return (_Fma(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right)));
}
inline float _Remquo(float _Left, float _Right, int *_Pquo) {
    return (::remquof(_Left, _Right, _Pquo));
}
inline double _Remquo(double _Left, double _Right, int *_Pquo) {
    return (::remquo(_Left, _Right, _Pquo));
}
inline long double _Remquo(long double _Left, long double _Right, int *_Pquo) {
    return (::remquol(_Left, _Right, _Pquo));
}
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> remquo(_Ty1 _Left, _Ty2 _Right, int *_Pquo) {
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return (_Remquo(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo));
}
extern "C" double acosh(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double acosh(_Ty _Left) {
    return (::acosh(static_cast<double>(_Left)));
}
extern "C" double asinh(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double asinh(_Ty _Left) {
    return (::asinh(static_cast<double>(_Left)));
}
extern "C" double atanh(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double atanh(_Ty _Left) {
    return (::atanh(static_cast<double>(_Left)));
}
extern "C" double cbrt(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double cbrt(_Ty _Left) {
    return (::cbrt(static_cast<double>(_Left)));
}
extern "C" double copysign(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> copysign(_Ty1 _Left, _Ty2 _Right) {
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return (::copysign(static_cast<_Common>(_Left), static_cast<_Common>(_Right)));
}
extern "C" double erf(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double erf(_Ty _Left) {
    return (::erf(static_cast<double>(_Left)));
}
extern "C" double erfc(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double erfc(_Ty _Left) {
    return (::erfc(static_cast<double>(_Left)));
}
extern "C" double expm1(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double expm1(_Ty _Left) {
    return (::expm1(static_cast<double>(_Left)));
}
extern "C" double exp2(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double exp2(_Ty _Left) {
    return (::exp2(static_cast<double>(_Left)));
}
extern "C" double fdim(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> fdim(_Ty1 _Left, _Ty2 _Right) {
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return (::fdim(static_cast<_Common>(_Left), static_cast<_Common>(_Right)));
}
extern "C" double fmax(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> fmax(_Ty1 _Left, _Ty2 _Right) {
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return (::fmax(static_cast<_Common>(_Left), static_cast<_Common>(_Right)));
}
extern "C" double fmin(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> fmin(_Ty1 _Left, _Ty2 _Right) {
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return (::fmin(static_cast<_Common>(_Left), static_cast<_Common>(_Right)));
}
extern "C" double hypot(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> hypot(_Ty1 _Left, _Ty2 _Right) {
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return (::hypot(static_cast<_Common>(_Left), static_cast<_Common>(_Right)));
}
extern "C" int ilogb(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline int ilogb(_Ty _Left) {
    return (::ilogb(static_cast<double>(_Left)));
}
extern "C" double lgamma(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double lgamma(_Ty _Left) {
    return (::lgamma(static_cast<double>(_Left)));
}
extern "C" long long llrint(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline long long llrint(_Ty _Left) {
    return (::llrint(static_cast<double>(_Left)));
}
extern "C" long long llround(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline long long llround(_Ty _Left) {
    return (::llround(static_cast<double>(_Left)));
}
extern "C" double log1p(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double log1p(_Ty _Left) {
    return (::log1p(static_cast<double>(_Left)));
}
extern "C" double log2(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double log2(_Ty _Left) {
    return (::log2(static_cast<double>(_Left)));
}
extern "C" double logb(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double logb(_Ty _Left) {
    return (::logb(static_cast<double>(_Left)));
}
extern "C" long lrint(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline long lrint(_Ty _Left) {
    return (::lrint(static_cast<double>(_Left)));
}
extern "C" long lround(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline long lround(_Ty _Left) {
    return (::lround(static_cast<double>(_Left)));
}
extern "C" double nearbyint(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double nearbyint(_Ty _Left) {
    return (::nearbyint(static_cast<double>(_Left)));
}
extern "C" double nextafter(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> nextafter(_Ty1 _Left, _Ty2 _Right) {
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return (::nextafter(static_cast<_Common>(_Left), static_cast<_Common>(_Right)));
}
extern "C" double nexttoward(double, long double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double nexttoward(_Ty _Left, long double _Arg2) {
    return (::nexttoward(static_cast<double>(_Left), _Arg2));
}
extern "C" double remainder(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> remainder(_Ty1 _Left, _Ty2 _Right) {
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return (::remainder(static_cast<_Common>(_Left), static_cast<_Common>(_Right)));
}
extern "C" double rint(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double rint(_Ty _Left) {
    return (::rint(static_cast<double>(_Left)));
}
extern "C" double round(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double round(_Ty _Left) {
    return (::round(static_cast<double>(_Left)));
}
extern "C" double scalbln(double, long)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double scalbln(_Ty _Left, long _Arg2) {
    return (::scalbln(static_cast<double>(_Left), _Arg2));
}
extern "C" double scalbn(double, int)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double scalbn(_Ty _Left, int _Arg2) {
    return (::scalbn(static_cast<double>(_Left), _Arg2));
}
extern "C" double tgamma(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double tgamma(_Ty _Left) {
    return (::tgamma(static_cast<double>(_Left)));
}
extern "C" double trunc(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double trunc(_Ty _Left) {
    return (::trunc(static_cast<double>(_Left)));
}
namespace std {
    using ::abs;
    using ::acos;
    using ::asin;
    using ::atan;
    using ::atan2;
    using ::ceil;
    using ::cos;
    using ::cosh;
    using ::exp;
    using ::fabs;
    using ::floor;
    using ::fmod;
    using ::frexp;
    using ::ldexp;
    using ::log;
    using ::log10;
    using ::modf;
    using ::pow;
    using ::sin;
    using ::sinh;
    using ::sqrt;
    using ::tan;
    using ::tanh;
    using ::acosf;
    using ::asinf;
    using ::atanf;
    using ::atan2f;
    using ::ceilf;
    using ::cosf;
    using ::coshf;
    using ::expf;
    using ::fabsf;
    using ::floorf;
    using ::fmodf;
    using ::frexpf;
    using ::ldexpf;
    using ::logf;
    using ::log10f;
    using ::modff;
    using ::powf;
    using ::sinf;
    using ::sinhf;
    using ::sqrtf;
    using ::tanf;
    using ::tanhf;
    using ::acosl;
    using ::asinl;
    using ::atanl;
    using ::atan2l;
    using ::ceill;
    using ::cosl;
    using ::coshl;
    using ::expl;
    using ::fabsl;
    using ::floorl;
    using ::fmodl;
    using ::frexpl;
    using ::ldexpl;
    using ::logl;
    using ::log10l;
    using ::modfl;
    using ::powl;
    using ::sinl;
    using ::sinhl;
    using ::sqrtl;
    using ::tanl;
    using ::tanhl;
    using ::float_t;
    using ::double_t;
    using ::acosh;
    using ::asinh;
    using ::atanh;
    using ::cbrt;
    using ::erf;
    using ::erfc;
    using ::expm1;
    using ::exp2;
    using ::hypot;
    using ::ilogb;
    using ::lgamma;
    using ::log1p;
    using ::log2;
    using ::logb;
    using ::llrint;
    using ::lrint;
    using ::nearbyint;
    using ::rint;
    using ::llround;
    using ::lround;
    using ::fdim;
    using ::fma;
    using ::fmax;
    using ::fmin;
    using ::round;
    using ::trunc;
    using ::remainder;
    using ::remquo;
    using ::copysign;
    using ::nan;
    using ::nextafter;
    using ::scalbn;
    using ::scalbln;
    using ::nexttoward;
    using ::tgamma;
    using ::acoshf;
    using ::asinhf;
    using ::atanhf;
    using ::cbrtf;
    using ::erff;
    using ::erfcf;
    using ::expm1f;
    using ::exp2f;
    using ::hypotf;
    using ::ilogbf;
    using ::lgammaf;
    using ::log1pf;
    using ::log2f;
    using ::logbf;
    using ::llrintf;
    using ::lrintf;
    using ::nearbyintf;
    using ::rintf;
    using ::llroundf;
    using ::lroundf;
    using ::fdimf;
    using ::fmaf;
    using ::fmaxf;
    using ::fminf;
    using ::roundf;
    using ::truncf;
    using ::remainderf;
    using ::remquof;
    using ::copysignf;
    using ::nanf;
    using ::nextafterf;
    using ::scalbnf;
    using ::scalblnf;
    using ::nexttowardf;
    using ::tgammaf;
    using ::acoshl;
    using ::asinhl;
    using ::atanhl;
    using ::cbrtl;
    using ::erfl;
    using ::erfcl;
    using ::expm1l;
    using ::exp2l;
    using ::hypotl;
    using ::ilogbl;
    using ::lgammal;
    using ::log1pl;
    using ::log2l;
    using ::logbl;
    using ::llrintl;
    using ::lrintl;
    using ::nearbyintl;
    using ::rintl;
    using ::llroundl;
    using ::lroundl;
    using ::fdiml;
    using ::fmal;
    using ::fmaxl;
    using ::fminl;
    using ::roundl;
    using ::truncl;
    using ::remainderl;
    using ::remquol;
    using ::copysignl;
    using ::nanl;
    using ::nextafterl;
    using ::scalbnl;
    using ::scalblnl;
    using ::nexttowardl;
    using ::tgammal;
    using ::fpclassify;
    using ::signbit;
    using ::isfinite;
    using ::isinf;
    using ::isnan;
    using ::isnormal;
    using ::isgreater;
    using ::isgreaterequal;
    using ::isless;
    using ::islessequal;
    using ::islessgreater;
    using ::isunordered;
}
extern "C" {
    int *_errno();
    errno_t _set_errno(int _Value);
    errno_t _get_errno(int *_Value);
    unsigned long *__doserrno();
    errno_t _set_doserrno(unsigned long _Value);
    errno_t _get_doserrno(unsigned long *_Value);
}
extern "C" {
    const void *memchr(const void *_Buf, int _Val, size_t _MaxCount);
    int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size);
    void *memcpy(void *_Dst, const void *_Src, size_t _Size);
    void *memmove(void *_Dst, const void *_Src, size_t _Size);
    void *memset(void *_Dst, int _Val, size_t _Size);
    const char *strchr(const char *_Str, int _Val);
    const char *strrchr(const char *_Str, int _Ch);
    const char *strstr(const char *_Str, const char *_SubStr);
    const wchar_t *wcschr(const wchar_t *_Str, wchar_t _Ch);
    const wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch);
    const wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr);
}
extern "C" {
    static inline errno_t memcpy_s(void *const _Destination, const rsize_t _DestinationSize, const void *const _Source, const rsize_t _SourceSize)     {
        if (_SourceSize == 0) {
            return 0;
        }
        {
            int _Expr_val = !!(_Destination != 0);
            if (!(_Expr_val)) {
                (*_errno()) = 22;
                _invalid_parameter_noinfo();
                return 22;
            }
        }
        ;
        if (_Source == 0 || _DestinationSize < _SourceSize) {
            memset(_Destination, 0, _DestinationSize);
            {
                int _Expr_val = !!(_Source != 0);
                if (!(_Expr_val)) {
                    (*_errno()) = 22;
                    _invalid_parameter_noinfo();
                    return 22;
                }
            }
            ;
            {
                int _Expr_val = !!(_DestinationSize >= _SourceSize);
                if (!(_Expr_val)) {
                    (*_errno()) = 34;
                    _invalid_parameter_noinfo();
                    return 34;
                }
            }
            ;
            return 22;
        }
        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }
    static inline errno_t memmove_s(void *const _Destination, const rsize_t _DestinationSize, const void *const _Source, const rsize_t _SourceSize)     {
        if (_SourceSize == 0) {
            return 0;
        }
        {
            int _Expr_val = !!(_Destination != 0);
            if (!(_Expr_val)) {
                (*_errno()) = 22;
                _invalid_parameter_noinfo();
                return 22;
            }
        }
        ;
        {
            int _Expr_val = !!(_Source != 0);
            if (!(_Expr_val)) {
                (*_errno()) = 22;
                _invalid_parameter_noinfo();
                return 22;
            }
        }
        ;
        {
            int _Expr_val = !!(_DestinationSize >= _SourceSize);
            if (!(_Expr_val)) {
                (*_errno()) = 34;
                _invalid_parameter_noinfo();
                return 34;
            }
        }
        ;
        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }
}
extern "C" {
    errno_t _cgetws_s(wchar_t *_Buffer, size_t _BufferCount, size_t *_SizeRead);
    extern "C++" {
        template <size_t _Size> inline errno_t _cgetws_s(wchar_t (&_Buffer)[_Size], size_t *_SizeRead) throw()         {
            return _cgetws_s(_Buffer, _Size, _SizeRead);
        }
    }
    int _cputws(const wchar_t *_Buffer);
    wint_t _getwch();
    wint_t _getwche();
    wint_t _putwch(wchar_t _Character);
    wint_t _ungetwch(wint_t _Character);
    wint_t _getwch_nolock();
    wint_t _getwche_nolock();
    wint_t _putwch_nolock(wchar_t _Character);
    wint_t _ungetwch_nolock(wint_t _Character);
    int __conio_common_vcwprintf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    int __conio_common_vcwprintf_s(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    int __conio_common_vcwprintf_p(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vcwprintf_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
    inline int _vcwprintf(const wchar_t *const _Format, va_list _ArgList)     {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }
    inline int _vcwprintf_s_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
    inline int _vcwprintf_s(const wchar_t *const _Format, va_list _ArgList)     {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }
    inline int _vcwprintf_p_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
    inline int _vcwprintf_p(const wchar_t *const _Format, va_list _ArgList)     {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }
    inline int _cwprintf_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _cwprintf(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _cwprintf_s_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _cwprintf_s(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _cwprintf_p_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _cwprintf_p(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int __conio_common_vcwscanf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vcwscanf_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList) __declspec(deprecated("This function or variable may be unsafe. Consider using _vcwscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return __conio_common_vcwscanf((*__local_stdio_scanf_options()), _Format, _Locale, _ArgList);
    }
    inline int _vcwscanf(const wchar_t *const _Format, va_list _ArgList) __declspec(deprecated("This function or variable may be unsafe. Consider using _vcwscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return _vcwscanf_l(_Format, 0, _ArgList);
    }
    inline int _vcwscanf_s_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __conio_common_vcwscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Format, _Locale, _ArgList);
    }
    inline int _vcwscanf_s(const wchar_t *const _Format, va_list _ArgList)     {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }
    inline int _cwscanf_l(const wchar_t *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _cwscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _cwscanf(const wchar_t *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _cwscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vcwscanf_l(_Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _cwscanf_s_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _cwscanf_s(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
}
extern "C" {
    const unsigned short *__pctype_func();
    const wctype_t *__pwctype_func();
    int iswalnum(wint_t _C);
    int iswalpha(wint_t _C);
    int iswascii(wint_t _C);
    int iswblank(wint_t _C);
    int iswcntrl(wint_t _C);
    int iswdigit(wint_t _C);
    int iswgraph(wint_t _C);
    int iswlower(wint_t _C);
    int iswprint(wint_t _C);
    int iswpunct(wint_t _C);
    int iswspace(wint_t _C);
    int iswupper(wint_t _C);
    int iswxdigit(wint_t _C);
    int __iswcsymf(wint_t _C);
    int __iswcsym(wint_t _C);
    int _iswalnum_l(wint_t _C, _locale_t _Locale);
    int _iswalpha_l(wint_t _C, _locale_t _Locale);
    int _iswblank_l(wint_t _C, _locale_t _Locale);
    int _iswcntrl_l(wint_t _C, _locale_t _Locale);
    int _iswdigit_l(wint_t _C, _locale_t _Locale);
    int _iswgraph_l(wint_t _C, _locale_t _Locale);
    int _iswlower_l(wint_t _C, _locale_t _Locale);
    int _iswprint_l(wint_t _C, _locale_t _Locale);
    int _iswpunct_l(wint_t _C, _locale_t _Locale);
    int _iswspace_l(wint_t _C, _locale_t _Locale);
    int _iswupper_l(wint_t _C, _locale_t _Locale);
    int _iswxdigit_l(wint_t _C, _locale_t _Locale);
    int _iswcsymf_l(wint_t _C, _locale_t _Locale);
    int _iswcsym_l(wint_t _C, _locale_t _Locale);
    wint_t towupper(wint_t _C);
    wint_t towlower(wint_t _C);
    int iswctype(wint_t _C, wctype_t _Type);
    wint_t _towupper_l(wint_t _C, _locale_t _Locale);
    wint_t _towlower_l(wint_t _C, _locale_t _Locale);
    int _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale);
    int isleadbyte(int _C);
    int _isleadbyte_l(int _C, _locale_t _Locale);
    int is_wctype(wint_t _C, wctype_t _Type) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using iswctype instead. See online help for details."));
}
extern "C" {
    wchar_t *_wgetcwd(wchar_t *_DstBuf, int _SizeInWords);
    wchar_t *_wgetdcwd(int _Drive, wchar_t *_DstBuf, int _SizeInWords);
    int _wchdir(const wchar_t *_Path);
    int _wmkdir(const wchar_t *_Path);
    int _wrmdir(const wchar_t *_Path);
}
extern "C" {
    typedef unsigned long _fsize_t;
    struct _wfinddata32_t {
        unsigned int attrib;
        __time32_t time_create;
        __time32_t time_access;
        __time32_t time_write;
        _fsize_t size;
        wchar_t name[260];
    };
    struct _wfinddata32i64_t {
        unsigned int attrib;
        __time32_t time_create;
        __time32_t time_access;
        __time32_t time_write;
        long long size;
        wchar_t name[260];
    };
    struct _wfinddata64i32_t {
        unsigned int attrib;
        __time64_t time_create;
        __time64_t time_access;
        __time64_t time_write;
        _fsize_t size;
        wchar_t name[260];
    };
    struct _wfinddata64_t {
        unsigned int attrib;
        __time64_t time_create;
        __time64_t time_access;
        __time64_t time_write;
        long long size;
        wchar_t name[260];
    };
    int _waccess(const wchar_t *_FileName, int _AccessMode);
    errno_t _waccess_s(const wchar_t *_FileName, int _AccessMode);
    int _wchmod(const wchar_t *_FileName, int _Mode);
    int _wcreat(const wchar_t *_FileName, int _PermissionMode) __declspec(deprecated("This function or variable may be unsafe. Consider using _wsopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    intptr_t _wfindfirst32(const wchar_t *_FileName, struct _wfinddata32_t *_FindData);
    int _wfindnext32(intptr_t _FindHandle, struct _wfinddata32_t *_FindData);
    int _wunlink(const wchar_t *_FileName);
    int _wrename(const wchar_t *_OldFileName, const wchar_t *_NewFileName);
    errno_t _wmktemp_s(wchar_t *_TemplateName, size_t _SizeInWords);
    extern "C++" {
        template <size_t _Size> inline errno_t _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw()         {
            return _wmktemp_s(_TemplateName, _Size);
        }
    }
    wchar_t *_wmktemp(wchar_t *_TemplateName) __declspec(deprecated("This function or variable may be unsafe. Consider using _wmktemp_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    intptr_t _wfindfirst32i64(const wchar_t *_FileName, struct _wfinddata32i64_t *_FindData);
    intptr_t _wfindfirst64i32(const wchar_t *_FileName, struct _wfinddata64i32_t *_FindData);
    intptr_t _wfindfirst64(const wchar_t *_FileName, struct _wfinddata64_t *_FindData);
    int _wfindnext32i64(intptr_t _FindHandle, struct _wfinddata32i64_t *_FindData);
    int _wfindnext64i32(intptr_t _FindHandle, struct _wfinddata64i32_t *_FindData);
    int _wfindnext64(intptr_t _FindHandle, struct _wfinddata64_t *_FindData);
    errno_t _wsopen_s(int *_FileHandle, const wchar_t *_FileName, int _OpenFlag, int _ShareFlag, int _PermissionFlag);
    errno_t _wsopen_dispatch(const wchar_t *_FileName, int _OFlag, int _ShFlag, int _PMode, int *_PFileHandle, int _BSecure);
    extern "C++" inline int _wopen(const wchar_t *_FileName, int _OFlag, int _PMode = 0) __declspec(deprecated("This function or variable may be unsafe. Consider using _wsopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _FileHandle;
        const errno_t _Result = _wsopen_dispatch(_FileName, _OFlag, 64, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++" inline int _wsopen(const wchar_t *_FileName, int _OFlag, int _ShFlag, int _PMode = 0) __declspec(deprecated("This function or variable may be unsafe. Consider using _wsopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _FileHandle;
        const errno_t _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

}
extern "C" {
    intptr_t _wexecl(const wchar_t *_FileName, const wchar_t *_ArgList, ...);
    intptr_t _wexecle(const wchar_t *_FileName, const wchar_t *_ArgList, ...);
    intptr_t _wexeclp(const wchar_t *_FileName, const wchar_t *_ArgList, ...);
    intptr_t _wexeclpe(const wchar_t *_FileName, const wchar_t *_ArgList, ...);
    intptr_t _wexecv(const wchar_t *_FileName, const wchar_t *const *_ArgList);
    intptr_t _wexecve(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env);
    intptr_t _wexecvp(const wchar_t *_FileName, const wchar_t *const *_ArgList);
    intptr_t _wexecvpe(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env);
    intptr_t _wspawnl(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...);
    intptr_t _wspawnle(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...);
    intptr_t _wspawnlp(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...);
    intptr_t _wspawnlpe(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...);
    intptr_t _wspawnv(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList);
    intptr_t _wspawnve(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env);
    intptr_t _wspawnvp(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList);
    intptr_t _wspawnvpe(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env);
    int _wsystem(const wchar_t *_Command);
}
extern "C" {
    errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source);
    errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source);
    errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount);
    errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount);
    wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context);
    wchar_t *_wcsdup(const wchar_t *_String);
    extern "C++" {
        template <size_t _Size> inline errno_t wcscat_s(wchar_t (&_Destination)[_Size], const wchar_t *_Source) throw()         {
            return wcscat_s(_Destination, _Size, _Source);
        }
    }
    wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source) __declspec(deprecated("This function or variable may be unsafe. Consider using wcscat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int wcscmp(const wchar_t *_String1, const wchar_t *_String2);
    extern "C++" {
        template <size_t _Size> inline errno_t wcscpy_s(wchar_t (&_Destination)[_Size], const wchar_t *_Source) throw()         {
            return wcscpy_s(_Destination, _Size, _Source);
        }
    }
    wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source) __declspec(deprecated("This function or variable may be unsafe. Consider using wcscpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    size_t wcscspn(const wchar_t *_String, const wchar_t *_Control);
    size_t wcslen(const wchar_t *_String);
    size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount);
    static inline size_t wcsnlen_s(const wchar_t *_Source, size_t _MaxCount)     {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }
    extern "C++" {
        template <size_t _Size> inline errno_t wcsncat_s(wchar_t (&_Destination)[_Size], const wchar_t *_Source, size_t _Count) throw()         {
            return wcsncat_s(_Destination, _Size, _Source, _Count);
        }
    }
    wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count) __declspec(deprecated("This function or variable may be unsafe. Consider using wcsncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount);
    extern "C++" {
        template <size_t _Size> inline errno_t wcsncpy_s(wchar_t (&_Destination)[_Size], const wchar_t *_Source, size_t _Count) throw()         {
            return wcsncpy_s(_Destination, _Size, _Source, _Count);
        }
    }
    wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count) __declspec(deprecated("This function or variable may be unsafe. Consider using wcsncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    const wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control);
    size_t wcsspn(const wchar_t *_String, const wchar_t *_Control);
    wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context) __declspec(deprecated("This function or variable may be unsafe. Consider using wcstok_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    static inline wchar_t *_wcstok(wchar_t *const _String, const wchar_t *const _Delimiter) __declspec(deprecated("This function or variable may be unsafe. Consider using wcstok_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return wcstok(_String, _Delimiter, 0);
    }
    extern "C++" inline wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter) throw() __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, adding an extra context parameter. To use the legacy Microsoft wcstok, define _CRT_NON_CONFORMING_WCSTOK."))     {
        return wcstok(_String, _Delimiter, 0);
    }

    wchar_t *_wcserror(int _ErrorNumber) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcserror_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber);
    extern "C++" {
        template <size_t _Size> inline errno_t _wcserror_s(wchar_t (&_Buffer)[_Size], int _Error) throw()         {
            return _wcserror_s(_Buffer, _Size, _Error);
        }
    }
    wchar_t *__wcserror(const wchar_t *_String) __declspec(deprecated("This function or variable may be unsafe. Consider using __wcserror_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage);
    extern "C++" {
        template <size_t _Size> inline errno_t __wcserror_s(wchar_t (&_Buffer)[_Size], const wchar_t *_ErrorMessage) throw()         {
            return __wcserror_s(_Buffer, _Size, _ErrorMessage);
        }
    }
    int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2);
    int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale);
    int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount);
    int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale);
    errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount);
    extern "C++" {
        template <size_t _Size> inline errno_t _wcsnset_s(wchar_t (&_Destination)[_Size], wchar_t _Value, size_t _MaxCount) throw()         {
            return _wcsnset_s(_Destination, _Size, _Value, _MaxCount);
        }
    }
    wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcsnset_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    wchar_t *_wcsrev(wchar_t *_String);
    errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value);
    extern "C++" {
        template <size_t _Size> inline errno_t _wcsset_s(wchar_t (&_String)[_Size], wchar_t _Value) throw()         {
            return _wcsset_s(_String, _Size, _Value);
        }
    }
    wchar_t *_wcsset(wchar_t *_String, wchar_t _Value) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcsset_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords);
    extern "C++" {
        template <size_t _Size> inline errno_t _wcslwr_s(wchar_t (&_String)[_Size]) throw()         {
            return _wcslwr_s(_String, _Size);
        }
    }
    wchar_t *_wcslwr(wchar_t *_String) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcslwr_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale);
    extern "C++" {
        template <size_t _Size> inline errno_t _wcslwr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw()         {
            return _wcslwr_s_l(_String, _Size, _Locale);
        }
    }
    wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcslwr_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wcsupr_s(wchar_t *_String, size_t _Size);
    extern "C++" {
        template <size_t _Size> inline errno_t _wcsupr_s(wchar_t (&_String)[_Size]) throw()         {
            return _wcsupr_s(_String, _Size);
        }
    }
    wchar_t *_wcsupr(wchar_t *_String) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcsupr_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale);
    extern "C++" {
        template <size_t _Size> inline errno_t _wcsupr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw()         {
            return _wcsupr_s_l(_String, _Size, _Locale);
        }
    }
    wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcsupr_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount);
    size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale);
    int wcscoll(const wchar_t *_String1, const wchar_t *_String2);
    int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale);
    int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2);
    int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale);
    int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount);
    int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale);
    int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount);
    int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale);
    extern "C++" {
        inline wchar_t *wcschr(wchar_t *_String, wchar_t _C)         {
            return const_cast<wchar_t *>(wcschr(static_cast<const wchar_t *>(_String), _C));
        }
        inline wchar_t *wcspbrk(wchar_t *_String, const wchar_t *_Control)         {
            return const_cast<wchar_t *>(wcspbrk(static_cast<const wchar_t *>(_String), _Control));
        }
        inline wchar_t *wcsrchr(wchar_t *_String, wchar_t _C)         {
            return const_cast<wchar_t *>(wcsrchr(static_cast<const wchar_t *>(_String), _C));
        }
        inline wchar_t *wcsstr(wchar_t *_String, const wchar_t *_SubStr)         {
            return const_cast<wchar_t *>(wcsstr(static_cast<const wchar_t *>(_String), _SubStr));
        }
    }
    wchar_t *wcsdup(const wchar_t *_String) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcsdup. See online help for details."));
    int wcsicmp(const wchar_t *_String1, const wchar_t *_String2) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcsicmp. See online help for details."));
    int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcsnicmp. See online help for details."));
    wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcsnset. See online help for details."));
    wchar_t *wcsrev(wchar_t *_String) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcsrev. See online help for details."));
    wchar_t *wcsset(wchar_t *_String, wchar_t _Value) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcsset. See online help for details."));
    wchar_t *wcslwr(wchar_t *_String) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcslwr. See online help for details."));
    wchar_t *wcsupr(wchar_t *_String) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcsupr. See online help for details."));
    int wcsicoll(const wchar_t *_String1, const wchar_t *_String2) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcsicoll. See online help for details."));
}
extern "C" {
    struct tm {
        int tm_sec;
        int tm_min;
        int tm_hour;
        int tm_mday;
        int tm_mon;
        int tm_year;
        int tm_wday;
        int tm_yday;
        int tm_isdst;
    };
    wchar_t *_wasctime(const struct tm *_Tm) __declspec(deprecated("This function or variable may be unsafe. Consider using _wasctime_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wasctime_s(wchar_t *_Buffer, size_t _SizeInWords, const struct tm *_Tm);
    extern "C++" {
        template <size_t _Size> inline errno_t _wasctime_s(wchar_t (&_Buffer)[_Size], const struct tm *_Time) throw()         {
            return _wasctime_s(_Buffer, _Size, _Time);
        }
    }
    size_t wcsftime(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm);
    size_t _wcsftime_l(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm, _locale_t _Locale);
    wchar_t *_wctime32(const __time32_t *_Time) __declspec(deprecated("This function or variable may be unsafe. Consider using _wctime32_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wctime32_s(wchar_t *_Buffer, size_t _SizeInWords, const __time32_t *_Time);
    extern "C++" {
        template <size_t _Size> inline errno_t _wctime32_s(wchar_t (&_Buffer)[_Size], const __time32_t *_Time) throw()         {
            return _wctime32_s(_Buffer, _Size, _Time);
        }
    }
    wchar_t *_wctime64(const __time64_t *_Time) __declspec(deprecated("This function or variable may be unsafe. Consider using _wctime64_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wctime64_s(wchar_t *_Buffer, size_t _SizeInWords, const __time64_t *_Time);
    extern "C++" {
        template <size_t _Size> inline errno_t _wctime64_s(wchar_t (&_Buffer)[_Size], const __time64_t *_Time) throw()         {
            return _wctime64_s(_Buffer, _Size, _Time);
        }
    }
    errno_t _wstrdate_s(wchar_t *_Buffer, size_t _SizeInWords);
    extern "C++" {
        template <size_t _Size> inline errno_t _wstrdate_s(wchar_t (&_Buffer)[_Size]) throw()         {
            return _wstrdate_s(_Buffer, _Size);
        }
    }
    wchar_t *_wstrdate(wchar_t *_Buffer) __declspec(deprecated("This function or variable may be unsafe. Consider using _wstrdate_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wstrtime_s(wchar_t *_Buffer, size_t _SizeInWords);
    extern "C++" {
        template <size_t _Size> inline errno_t _wstrtime_s(wchar_t (&_Buffer)[_Size]) throw()         {
            return _wstrtime_s(_Buffer, _Size);
        }
    }
    wchar_t *_wstrtime(wchar_t *_Buffer) __declspec(deprecated("This function or variable may be unsafe. Consider using _wstrtime_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    static inline wchar_t *_wctime(const time_t *const _Time)     {
        return _wctime64(_Time);
    }
    static inline errno_t _wctime_s(wchar_t *const _Buffer, const size_t _SizeInWords, const time_t *const _Time)     {
        return _wctime64_s(_Buffer, _SizeInWords, _Time);
    }
}
typedef unsigned short _ino_t;
typedef _ino_t ino_t;
typedef unsigned int _dev_t;
typedef _dev_t dev_t;
typedef long _off_t;
typedef _off_t off_t;
extern "C" {
    struct _stat32 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
    };
    struct _stat32i64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        long long st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
    };
    struct _stat64i32 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
    };
    struct _stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        long long st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
    };
    struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
    };
    int _fstat32(int _FileHandle, struct _stat32 *_Stat);
    int _fstat32i64(int _FileHandle, struct _stat32i64 *_Stat);
    int _fstat64i32(int _FileHandle, struct _stat64i32 *_Stat);
    int _fstat64(int _FileHandle, struct _stat64 *_Stat);
    int _stat32(const char *_FileName, struct _stat32 *_Stat);
    int _stat32i64(const char *_FileName, struct _stat32i64 *_Stat);
    int _stat64i32(const char *_FileName, struct _stat64i32 *_Stat);
    int _stat64(const char *_FileName, struct _stat64 *_Stat);
    int _wstat32(const wchar_t *_FileName, struct _stat32 *_Stat);
    int _wstat32i64(const wchar_t *_FileName, struct _stat32i64 *_Stat);
    int _wstat64i32(const wchar_t *_FileName, struct _stat64i32 *_Stat);
    int _wstat64(const wchar_t *_FileName, struct _stat64 *_Stat);
    static inline int fstat(const int _FileHandle, struct stat *const _Stat)     {
        typedef char __static_assert_t[1];
        return _fstat64i32(_FileHandle, (struct _stat64i32 *)_Stat);
    }
    static inline int stat(const char *const _FileName, struct stat *const _Stat)     {
        typedef char __static_assert_t[1];
        return _stat64i32(_FileName, (struct _stat64i32 *)_Stat);
    }
}
extern "C" {
    typedef wchar_t _Wint_t;
    wchar_t *_wsetlocale(int _Category, const wchar_t *_Locale);
    _locale_t _wcreate_locale(int _Category, const wchar_t *_Locale);
    wint_t btowc(int _Ch);
    size_t mbrlen(const char *_Ch, size_t _SizeInBytes, mbstate_t *_State);
    size_t mbrtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SizeInBytes, mbstate_t *_State);
    errno_t mbsrtowcs_s(size_t *_Retval, wchar_t *_Dst, size_t _Size, const char **_PSrc, size_t _N, mbstate_t *_State);
    extern "C++" {
        template <size_t _Size> inline errno_t mbsrtowcs_s(size_t *_Retval, wchar_t (&_Dest)[_Size], const char **_PSource, size_t _Count, mbstate_t *_State) throw()         {
            return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State);
        }
    }
    size_t mbsrtowcs(wchar_t *_Dest, const char **_PSrc, size_t _Count, mbstate_t *_State) __declspec(deprecated("This function or variable may be unsafe. Consider using mbsrtowcs_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t wcrtomb_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, wchar_t _Ch, mbstate_t *_State);
    extern "C++" {
        template <size_t _Size> inline errno_t wcrtomb_s(size_t *_Retval, char (&_Dest)[_Size], wchar_t _Source, mbstate_t *_State) throw()         {
            return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State);
        }
    }
    size_t wcrtomb(char *_Dest, wchar_t _Source, mbstate_t *_State) __declspec(deprecated("This function or variable may be unsafe. Consider using wcrtomb_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t wcsrtombs_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, const wchar_t **_Src, size_t _Size, mbstate_t *_State);
    extern "C++" {
        template <size_t _Size> inline errno_t wcsrtombs_s(size_t *_Retval, char (&_Dest)[_Size], const wchar_t **_PSrc, size_t _Count, mbstate_t *_State) throw()         {
            return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State);
        }
    }
    size_t wcsrtombs(char *_Dest, const wchar_t **_PSource, size_t _Count, mbstate_t *_State) __declspec(deprecated("This function or variable may be unsafe. Consider using wcsrtombs_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int wctob(wint_t _WCh);
    errno_t wmemcpy_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N);
    errno_t wmemmove_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N);
    inline int fwide(FILE *_F, int _M)     {
        (void)_F;
        return (_M);
    }
    inline int mbsinit(const mbstate_t *_P)     {
        return _P == 0 || _P->_Wchar == 0;
    }
    inline const wchar_t *wmemchr(const wchar_t *_S, wchar_t _C, size_t _N)     {
        for (; 0 < _N; ++_S , --_N)
            if (*_S == _C)
                return (const wchar_t *)_S;
        return 0;
    }
    inline int wmemcmp(const wchar_t *_S1, const wchar_t *_S2, size_t _N)     {
        for (; 0 < _N; ++_S1 , ++_S2 , --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;
        return 0;
    }
    inline wchar_t *wmemcpy(wchar_t *_S1, const wchar_t *_S2, size_t _N)     {
        return (wchar_t *)memcpy(_S1, _S2, _N * sizeof(wchar_t));
    }
    inline wchar_t *wmemmove(wchar_t *_S1, const wchar_t *_S2, size_t _N)     {
        return (wchar_t *)memmove(_S1, _S2, _N * sizeof(wchar_t));
    }
    inline wchar_t *wmemset(wchar_t *_S, wchar_t _C, size_t _N)     {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su , --_N) {
            *_Su = _C;
        }
        return _S;
    }
    extern "C++" inline wchar_t *wmemchr(wchar_t *_S, wchar_t _C, size_t _N)     {
        const wchar_t *const _SC = _S;
        return const_cast<wchar_t *>(wmemchr(_SC, _C, _N));
    }

}
typedef mbstate_t _Mbstatet;
namespace std {
    using ::_Mbstatet;
    using ::mbstate_t;
    using ::size_t;
    using ::tm;
    using ::wint_t;
    using ::btowc;
    using ::fgetwc;
    using ::fgetws;
    using ::fputwc;
    using ::fputws;
    using ::fwide;
    using ::fwprintf;
    using ::fwscanf;
    using ::getwc;
    using ::getwchar;
    using ::mbrlen;
    using ::mbrtowc;
    using ::mbsrtowcs;
    using ::mbsinit;
    using ::putwc;
    using ::putwchar;
    using ::swprintf;
    using ::swscanf;
    using ::ungetwc;
    using ::vfwprintf;
    using ::vswprintf;
    using ::vwprintf;
    using ::wcrtomb;
    using ::wprintf;
    using ::wscanf;
    using ::wcsrtombs;
    using ::wcstol;
    using ::wcscat;
    using ::wcschr;
    using ::wcscmp;
    using ::wcscoll;
    using ::wcscpy;
    using ::wcscspn;
    using ::wcslen;
    using ::wcsncat;
    using ::wcsncmp;
    using ::wcsncpy;
    using ::wcspbrk;
    using ::wcsrchr;
    using ::wcsspn;
    using ::wcstod;
    using ::wcstoul;
    using ::wcsstr;
    using ::wcstok;
    using ::wcsxfrm;
    using ::wctob;
    using ::wmemchr;
    using ::wmemcmp;
    using ::wmemcpy;
    using ::wmemmove;
    using ::wmemset;
    using ::wcsftime;
    using ::vfwscanf;
    using ::vswscanf;
    using ::vwscanf;
    using ::wcstof;
    using ::wcstold;
    using ::wcstoll;
    using ::wcstoull;
}
namespace std {
    using ::ptrdiff_t;
    using ::size_t;
    typedef double max_align_t;
}
using ::std::max_align_t;
namespace std {
    template <class _Elem> class initializer_list {
    public:
        typedef _Elem value_type;
        typedef const _Elem &reference;
        typedef const _Elem &const_reference;
        typedef size_t size_type;
        typedef const _Elem *iterator;
        typedef const _Elem *const_iterator;
        constexpr initializer_list<_Elem>() noexcept : _First(nullptr), _Last(nullptr)         {
        }
        constexpr initializer_list<_Elem>(const _Elem *_First_arg, const _Elem *_Last_arg) noexcept : _First(_First_arg), _Last(_Last_arg)         {
        }
        constexpr const _Elem *begin() const noexcept         {
            return (this->_First);
        }
        constexpr const _Elem *end() const noexcept         {
            return (this->_Last);
        }
        constexpr size_t size() const noexcept         {
            return (static_cast<size_t>(this->_Last - this->_First));
        }
    private:
        const _Elem *_First;
        const _Elem *_Last;
    };
template<> class initializer_list<bool> {
    public:
        typedef bool value_type;
        typedef const bool &reference;
        typedef const bool &const_reference;
        typedef size_t size_type;
        typedef const bool *iterator;
        typedef const bool *const_iterator;
        constexpr initializer_list() noexcept;
        constexpr initializer_list(const bool *_First_arg, const bool *_Last_arg) noexcept;
        constexpr const bool *begin() const noexcept         {
            return (this->_First);
        }
        constexpr const bool *end() const noexcept         {
            return (this->_Last);
        }
        constexpr size_t size() const noexcept;
    private:
        const bool *_First;
        const bool *_Last;
    };
    template <class _Elem> constexpr const _Elem *begin(initializer_list<_Elem> _Ilist) noexcept     {
        return (_Ilist.begin());
    }
    template <class _Elem> constexpr const _Elem *end(initializer_list<_Elem> _Ilist) noexcept     {
        return (_Ilist.end());
    }
}
namespace std {
    template <class > constexpr bool _Always_false = false;
    template <class _Arg, class _Result> struct unary_function {
        typedef _Arg argument_type;
        typedef _Result result_type;
    };
    template <class _Arg1, class _Arg2, class _Result> struct binary_function {
        typedef _Arg1 first_argument_type;
        typedef _Arg2 second_argument_type;
        typedef _Result result_type;
    };
    template <class _Ty = void> struct plus {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef _Ty result_type;
        constexpr _Ty operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left + _Right);
        }
    };
    template <class _Ty = void> struct minus {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef _Ty result_type;
        constexpr _Ty operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left - _Right);
        }
    };
    template <class _Ty = void> struct multiplies {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef _Ty result_type;
        constexpr _Ty operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left * _Right);
        }
    };
    template <class _Ty = void> struct equal_to {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;
        constexpr bool operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left == _Right);
        }
    };
    template <class _Ty = void> struct not_equal_to {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;
        constexpr bool operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left != _Right);
        }
    };
    template <class _Ty = void> struct greater {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;
        constexpr bool operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left > _Right);
        }
    };
    template <class _Ty = void> struct less {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;
        constexpr bool operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left < _Right);
        }
    };
    template <class _Ty = void> struct greater_equal {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;
        constexpr bool operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left >= _Right);
        }
    };
    template <class _Ty = void> struct less_equal {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;
        constexpr bool operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left <= _Right);
        }
    };
    template<> struct plus<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) + static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) + static_cast<_Ty2 &&>(_Right));
        }
    };
    template<> struct minus<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) - static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) - static_cast<_Ty2 &&>(_Right));
        }
    };
    template<> struct multiplies<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) * static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) * static_cast<_Ty2 &&>(_Right));
        }
    };
    template<> struct equal_to<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) == static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) == static_cast<_Ty2 &&>(_Right));
        }
    };
    template<> struct not_equal_to<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) != static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) != static_cast<_Ty2 &&>(_Right));
        }
    };
    template<> struct greater<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) > static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) > static_cast<_Ty2 &&>(_Right));
        }
    };
    template<> struct less<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) < static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) < static_cast<_Ty2 &&>(_Right));
        }
    };
    template<> struct greater_equal<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) >= static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) >= static_cast<_Ty2 &&>(_Right));
        }
    };
    template<> struct less_equal<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) <= static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) <= static_cast<_Ty2 &&>(_Right));
        }
    };
    template <class _Ty> constexpr _Ty *addressof(_Ty &_Val) noexcept     {
        return (__builtin_addressof(_Val));
    }
    template <class _Ty> const _Ty *addressof(const _Ty &&) = delete
    template <class _Ptrty> inline auto _Unfancy(_Ptrty _Ptr)     {
        return (::std::addressof(*_Ptr));
    }
    template<> inline auto _Unfancy<char *>(char *_Ptr)    template <class _Ty> inline _Ty *_Unfancy(_Ty *_Ptr)     {
        return (_Ptr);
    }
    template<> inline char *_Unfancy<char>(char *_Ptr)     {
        return (_Ptr);
    }
}
namespace std {
    enum float_denorm_style {
        denorm_indeterminate = -1,
        denorm_absent = 0,
        denorm_present = 1
    };
    enum float_round_style {
        round_indeterminate = -1,
        round_toward_zero = 0,
        round_to_nearest = 1,
        round_toward_infinity = 2,
        round_toward_neg_infinity = 3
    };
    struct _Num_base {
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr bool is_bounded = false;
        static constexpr bool is_exact = false;
        static constexpr bool is_iec559 = false;
        static constexpr bool is_integer = false;
        static constexpr bool is_modulo = false;
        static constexpr bool is_signed = false;
        static constexpr bool is_specialized = false;
        static constexpr bool tinyness_before = false;
        static constexpr bool traps = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
        static constexpr int digits = 0;
        static constexpr int digits10 = 0;
        static constexpr int max_digits10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int radix = 0;
    };
    template <class _Ty> class numeric_limits : public std::_Num_base {
    public:
        static constexpr _Ty (min)() noexcept         {
            return (_Ty());
        }
        static constexpr _Ty (max)() noexcept         {
            return (_Ty());
        }
        static constexpr _Ty lowest() noexcept         {
            return (_Ty());
        }
        static constexpr _Ty epsilon() noexcept         {
            return (_Ty());
        }
        static constexpr _Ty round_error() noexcept         {
            return (_Ty());
        }
        static constexpr _Ty denorm_min() noexcept         {
            return (_Ty());
        }
        static constexpr _Ty infinity() noexcept         {
            return (_Ty());
        }
        static constexpr _Ty quiet_NaN() noexcept         {
            return (_Ty());
        }
        static constexpr _Ty signaling_NaN() noexcept         {
            return (_Ty());
        }
    };
    template <class _Ty> class numeric_limits<_Ty> : public numeric_limits<_Ty> {
    };
    template <class _Ty> class numeric_limits<_Ty> : public numeric_limits<_Ty> {
    };
    template <class _Ty> class numeric_limits<_Ty> : public numeric_limits<_Ty> {
    };
    struct _Num_int_base : std::_Num_base {
        static constexpr bool is_bounded = true;
        static constexpr bool is_exact = true;
        static constexpr bool is_integer = true;
        static constexpr bool is_specialized = true;
        static constexpr int radix = 2;
    };
    struct _Num_float_base : std::_Num_base {
        static constexpr std::float_denorm_style has_denorm = denorm_present;
        static constexpr bool has_infinity = true;
        static constexpr bool has_quiet_NaN = true;
        static constexpr bool has_signaling_NaN = true;
        static constexpr bool is_bounded = true;
        static constexpr bool is_iec559 = true;
        static constexpr bool is_signed = true;
        static constexpr bool is_specialized = true;
        static constexpr std::float_round_style round_style = round_to_nearest;
        static constexpr int radix = 2;
    };
    template<> class numeric_limits<char> : public std::_Num_int_base {
    public:
        static constexpr char (min)() noexcept         {
            return ((-127 - 1));
        }
        static constexpr char (max)() noexcept         {
            return (127);
        }
        static constexpr char lowest() noexcept         {
            return ((min)());
        }
        static constexpr char epsilon() noexcept         {
            return (0);
        }
        static constexpr char round_error() noexcept         {
            return (0);
        }
        static constexpr char denorm_min() noexcept         {
            return (0);
        }
        static constexpr char infinity() noexcept         {
            return (0);
        }
        static constexpr char quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr char signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = (-127 - 1) != 0;
        static constexpr bool is_modulo = (-127 - 1) == 0;
        static constexpr int digits = 8 - ((-127 - 1) != 0);
        static constexpr int digits10 = 2;
    };
    template<> class numeric_limits<wchar_t> : public std::_Num_int_base {
    public:
        static constexpr wchar_t (min)() noexcept         {
            return (0);
        }
        static constexpr wchar_t (max)() noexcept         {
            return (65535);
        }
        static constexpr wchar_t lowest() noexcept         {
            return ((min)());
        }
        static constexpr wchar_t epsilon() noexcept         {
            return (0);
        }
        static constexpr wchar_t round_error() noexcept         {
            return (0);
        }
        static constexpr wchar_t denorm_min() noexcept         {
            return (0);
        }
        static constexpr wchar_t infinity() noexcept         {
            return (0);
        }
        static constexpr wchar_t quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr wchar_t signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_modulo = true;
        static constexpr int digits = 16;
        static constexpr int digits10 = 4;
    };
    template<> class numeric_limits<bool> : public std::_Num_int_base {
    public:
        static constexpr bool (min)() noexcept         {
            return (false);
        }
        static constexpr bool (max)() noexcept         {
            return (true);
        }
        static constexpr bool lowest() noexcept         {
            return ((min)());
        }
        static constexpr bool epsilon() noexcept         {
            return (0);
        }
        static constexpr bool round_error() noexcept         {
            return (0);
        }
        static constexpr bool denorm_min() noexcept         {
            return (0);
        }
        static constexpr bool infinity() noexcept         {
            return (0);
        }
        static constexpr bool quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr bool signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr int digits = 1;
    };
    template<> class numeric_limits<signed char> : public std::_Num_int_base {
    public:
        static constexpr signed char (min)() noexcept         {
            return ((-127 - 1));
        }
        static constexpr signed char (max)() noexcept         {
            return (127);
        }
        static constexpr signed char lowest() noexcept         {
            return ((min)());
        }
        static constexpr signed char epsilon() noexcept         {
            return (0);
        }
        static constexpr signed char round_error() noexcept         {
            return (0);
        }
        static constexpr signed char denorm_min() noexcept         {
            return (0);
        }
        static constexpr signed char infinity() noexcept         {
            return (0);
        }
        static constexpr signed char quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr signed char signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = true;
        static constexpr int digits = 7;
        static constexpr int digits10 = 2;
    };
    template<> class numeric_limits<unsigned char> : public std::_Num_int_base {
    public:
        static constexpr unsigned char (min)() noexcept         {
            return (0);
        }
        static constexpr unsigned char (max)() noexcept         {
            return ((127 * 2 + 1));
        }
        static constexpr unsigned char lowest() noexcept         {
            return ((min)());
        }
        static constexpr unsigned char epsilon() noexcept         {
            return (0);
        }
        static constexpr unsigned char round_error() noexcept         {
            return (0);
        }
        static constexpr unsigned char denorm_min() noexcept         {
            return (0);
        }
        static constexpr unsigned char infinity() noexcept         {
            return (0);
        }
        static constexpr unsigned char quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr unsigned char signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_modulo = true;
        static constexpr int digits = 8;
        static constexpr int digits10 = 2;
    };
    template<> class numeric_limits<short> : public std::_Num_int_base {
    public:
        static constexpr short (min)() noexcept         {
            return ((-32767 - 1));
        }
        static constexpr short (max)() noexcept         {
            return (32767);
        }
        static constexpr short lowest() noexcept         {
            return ((min)());
        }
        static constexpr short epsilon() noexcept         {
            return (0);
        }
        static constexpr short round_error() noexcept         {
            return (0);
        }
        static constexpr short denorm_min() noexcept         {
            return (0);
        }
        static constexpr short infinity() noexcept         {
            return (0);
        }
        static constexpr short quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr short signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = true;
        static constexpr int digits = 15;
        static constexpr int digits10 = 4;
    };
    template<> class numeric_limits<unsigned short> : public std::_Num_int_base {
    public:
        static constexpr unsigned short (min)() noexcept         {
            return (0);
        }
        static constexpr unsigned short (max)() noexcept         {
            return ((32767 * 2 + 1));
        }
        static constexpr unsigned short lowest() noexcept         {
            return ((min)());
        }
        static constexpr unsigned short epsilon() noexcept         {
            return (0);
        }
        static constexpr unsigned short round_error() noexcept         {
            return (0);
        }
        static constexpr unsigned short denorm_min() noexcept         {
            return (0);
        }
        static constexpr unsigned short infinity() noexcept         {
            return (0);
        }
        static constexpr unsigned short quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr unsigned short signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_modulo = true;
        static constexpr int digits = 16;
        static constexpr int digits10 = 4;
    };
    template<> class numeric_limits<char16_t> : public std::_Num_int_base {
    public:
        static constexpr char16_t (min)() noexcept         {
            return (0);
        }
        static constexpr char16_t (max)() noexcept         {
            return ((32767 * 2 + 1));
        }
        static constexpr char16_t lowest() noexcept         {
            return ((min)());
        }
        static constexpr char16_t epsilon() noexcept         {
            return (0);
        }
        static constexpr char16_t round_error() noexcept         {
            return (0);
        }
        static constexpr char16_t denorm_min() noexcept         {
            return (0);
        }
        static constexpr char16_t infinity() noexcept         {
            return (0);
        }
        static constexpr char16_t quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr char16_t signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_modulo = true;
        static constexpr int digits = 16;
        static constexpr int digits10 = 4;
    };
    template<> class numeric_limits<int> : public std::_Num_int_base {
    public:
        static constexpr int (min)() noexcept         {
            return ((-2147483647 - 1));
        }
        static constexpr int (max)() noexcept         {
            return (2147483647);
        }
        static constexpr int lowest() noexcept         {
            return ((min)());
        }
        static constexpr int epsilon() noexcept         {
            return (0);
        }
        static constexpr int round_error() noexcept         {
            return (0);
        }
        static constexpr int denorm_min() noexcept         {
            return (0);
        }
        static constexpr int infinity() noexcept         {
            return (0);
        }
        static constexpr int quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr int signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = true;
        static constexpr int digits = 31;
        static constexpr int digits10 = 9;
    };
    template<> class numeric_limits<unsigned int> : public std::_Num_int_base {
    public:
        static constexpr unsigned int (min)() noexcept         {
            return (0);
        }
        static constexpr unsigned int (max)() noexcept         {
            return ((2147483647 * 2U + 1U));
        }
        static constexpr unsigned int lowest() noexcept         {
            return ((min)());
        }
        static constexpr unsigned int epsilon() noexcept         {
            return (0);
        }
        static constexpr unsigned int round_error() noexcept         {
            return (0);
        }
        static constexpr unsigned int denorm_min() noexcept         {
            return (0);
        }
        static constexpr unsigned int infinity() noexcept         {
            return (0);
        }
        static constexpr unsigned int quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr unsigned int signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_modulo = true;
        static constexpr int digits = 32;
        static constexpr int digits10 = 9;
    };
    template<> class numeric_limits<long> : public std::_Num_int_base {
    public:
        static constexpr long (min)() noexcept         {
            return ((-2147483647L - 1L));
        }
        static constexpr long (max)() noexcept         {
            return (2147483647L);
        }
        static constexpr long lowest() noexcept         {
            return ((min)());
        }
        static constexpr long epsilon() noexcept         {
            return (0);
        }
        static constexpr long round_error() noexcept         {
            return (0);
        }
        static constexpr long denorm_min() noexcept         {
            return (0);
        }
        static constexpr long infinity() noexcept         {
            return (0);
        }
        static constexpr long quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr long signaling_NaN() noexcept         {
            return (0);
        }
        static_assert(sizeof(int) == sizeof(long), "LLP64 assumption");
        static constexpr bool is_signed = true;
        static constexpr int digits = 31;
        static constexpr int digits10 = 9;
    };
    template<> class numeric_limits<unsigned long> : public std::_Num_int_base {
    public:
        static constexpr unsigned long (min)() noexcept         {
            return (0);
        }
        static constexpr unsigned long (max)() noexcept         {
            return ((2147483647L * 2UL + 1UL));
        }
        static constexpr unsigned long lowest() noexcept         {
            return ((min)());
        }
        static constexpr unsigned long epsilon() noexcept         {
            return (0);
        }
        static constexpr unsigned long round_error() noexcept         {
            return (0);
        }
        static constexpr unsigned long denorm_min() noexcept         {
            return (0);
        }
        static constexpr unsigned long infinity() noexcept         {
            return (0);
        }
        static constexpr unsigned long quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr unsigned long signaling_NaN() noexcept         {
            return (0);
        }
        static_assert(sizeof(unsigned int) == sizeof(unsigned long), "LLP64 assumption");
        static constexpr bool is_modulo = true;
        static constexpr int digits = 32;
        static constexpr int digits10 = 9;
    };
    template<> class numeric_limits<char32_t> : public std::_Num_int_base {
    public:
        static constexpr char32_t (min)() noexcept         {
            return (0);
        }
        static constexpr char32_t (max)() noexcept         {
            return ((2147483647 * 2U + 1U));
        }
        static constexpr char32_t lowest() noexcept         {
            return ((min)());
        }
        static constexpr char32_t epsilon() noexcept         {
            return (0);
        }
        static constexpr char32_t round_error() noexcept         {
            return (0);
        }
        static constexpr char32_t denorm_min() noexcept         {
            return (0);
        }
        static constexpr char32_t infinity() noexcept         {
            return (0);
        }
        static constexpr char32_t quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr char32_t signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_modulo = true;
        static constexpr int digits = 32;
        static constexpr int digits10 = 9;
    };
    template<> class numeric_limits<long long> : public std::_Num_int_base {
    public:
        static constexpr long long (min)() noexcept         {
            return ((-9223372036854775807LL - 1LL));
        }
        static constexpr long long (max)() noexcept         {
            return (9223372036854775807LL);
        }
        static constexpr long long lowest() noexcept         {
            return ((min)());
        }
        static constexpr long long epsilon() noexcept         {
            return (0);
        }
        static constexpr long long round_error() noexcept         {
            return (0);
        }
        static constexpr long long denorm_min() noexcept         {
            return (0);
        }
        static constexpr long long infinity() noexcept         {
            return (0);
        }
        static constexpr long long quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr long long signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = true;
        static constexpr int digits = 63;
        static constexpr int digits10 = 18;
    };
    template<> class numeric_limits<unsigned long long> : public std::_Num_int_base {
    public:
        static constexpr unsigned long long (min)() noexcept         {
            return (0);
        }
        static constexpr unsigned long long (max)() noexcept         {
            return ((9223372036854775807LL * 2ULL + 1ULL));
        }
        static constexpr unsigned long long lowest() noexcept         {
            return ((min)());
        }
        static constexpr unsigned long long epsilon() noexcept         {
            return (0);
        }
        static constexpr unsigned long long round_error() noexcept         {
            return (0);
        }
        static constexpr unsigned long long denorm_min() noexcept         {
            return (0);
        }
        static constexpr unsigned long long infinity() noexcept         {
            return (0);
        }
        static constexpr unsigned long long quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr unsigned long long signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_modulo = true;
        static constexpr int digits = 64;
        static constexpr int digits10 = 19;
    };
    template<> class numeric_limits<float> : public std::_Num_float_base {
    public:
        static constexpr float (min)() noexcept         {
            return (1.17549435E-38F);
        }
        static constexpr float (max)() noexcept         {
            return (3.40282347E+38F);
        }
        static constexpr float lowest() noexcept         {
            return (-(max)());
        }
        static constexpr float epsilon() noexcept         {
            return (1.1920929E-7F);
        }
        static constexpr float round_error() noexcept         {
            return (0.5F);
        }
        static constexpr float denorm_min() noexcept         {
            return (1.40129846E-45F);
        }
        static constexpr float infinity() noexcept         {
            return (__builtin_huge_valf());
        }
        static constexpr float quiet_NaN() noexcept         {
            return (__builtin_nanf("0"));
        }
        static constexpr float signaling_NaN() noexcept         {
            return (__builtin_nansf("1"));
        }
        static constexpr int digits = 24;
        static constexpr int digits10 = 6;
        static constexpr int max_digits10 = 9;
        static constexpr int max_exponent = 128;
        static constexpr int max_exponent10 = 38;
        static constexpr int min_exponent = (-125);
        static constexpr int min_exponent10 = (-37);
    };
    template<> class numeric_limits<double> : public std::_Num_float_base {
    public:
        static constexpr double (min)() noexcept         {
            return (2.2250738585072014E-308);
        }
        static constexpr double (max)() noexcept         {
            return (1.7976931348623157E+308);
        }
        static constexpr double lowest() noexcept         {
            return (-(max)());
        }
        static constexpr double epsilon() noexcept         {
            return (2.2204460492503131E-16);
        }
        static constexpr double round_error() noexcept         {
            return (0.5);
        }
        static constexpr double denorm_min() noexcept         {
            return (4.9406564584124654E-324);
        }
        static constexpr double infinity() noexcept         {
            return (__builtin_huge_val());
        }
        static constexpr double quiet_NaN() noexcept         {
            return (__builtin_nan("0"));
        }
        static constexpr double signaling_NaN() noexcept         {
            return (__builtin_nans("1"));
        }
        static constexpr int digits = 53;
        static constexpr int digits10 = 15;
        static constexpr int max_digits10 = 17;
        static constexpr int max_exponent = 1024;
        static constexpr int max_exponent10 = 308;
        static constexpr int min_exponent = (-1021);
        static constexpr int min_exponent10 = (-307);
    };
    template<> class numeric_limits<long double> : public std::_Num_float_base {
    public:
        static constexpr long double (min)() noexcept         {
            return (2.2250738585072014E-308L);
        }
        static constexpr long double (max)() noexcept         {
            return (1.7976931348623157E+308L);
        }
        static constexpr long double lowest() noexcept         {
            return (-(max)());
        }
        static constexpr long double epsilon() noexcept         {
            return (2.2204460492503131E-16L);
        }
        static constexpr long double round_error() noexcept         {
            return (0.5L);
        }
        static constexpr long double denorm_min() noexcept         {
            return (4.9406564584124654E-324L);
        }
        static constexpr long double infinity() noexcept         {
            return (__builtin_huge_val());
        }
        static constexpr long double quiet_NaN() noexcept         {
            return (__builtin_nan("0"));
        }
        static constexpr long double signaling_NaN() noexcept         {
            return (__builtin_nans("1"));
        }
        static constexpr int digits = 53;
        static constexpr int digits10 = 15;
        static constexpr int max_digits10 = 17;
        static constexpr int max_exponent = 1024;
        static constexpr int max_exponent10 = 308;
        static constexpr int min_exponent = (-1021);
        static constexpr int min_exponent10 = (-307);
    };
}
namespace std {
    template <class _Ty, _Ty ..._Vals> struct integer_sequence {
        static_assert(is_integral_v<_Ty>, "integer_sequence<T, I...> requires T to be an integral type.");
        using value_type = _Ty;
        static constexpr size_t size() noexcept         {
            return (sizeof...(_Vals));
        }
    };
    template <class _Ty, _Ty _Size> using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;
    template <size_t ..._Vals> using index_sequence = integer_sequence<size_t, _Vals...>;
    template <size_t _Size> using make_index_sequence = make_integer_sequence<size_t, _Size>;
    template <class ..._Types> using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
    template <bool _First_value, class _First, class ..._Rest> struct _Conjunction {
        using type = _First;
    };
template<> struct _Conjunction<true, std::negation<std::is_pointer<std::default_delete<v8::internal::ScriptStreamingData> > >, <std::is_default_constructible<std::default_delete<v8::internal::ScriptStreamingData> >>> {
        using type = typename _Conjunction<is_default_constructible<default_delete<ScriptStreamingData> >::value, is_default_constructible<default_delete<ScriptStreamingData> > >::type;
    };
template<> struct _Conjunction<true, std::is_default_constructible<std::default_delete<v8::internal::ScriptStreamingData> >, <>> {
        using type = std::is_default_constructible<std::default_delete<v8::internal::ScriptStreamingData> >;
    };
template<> struct _Conjunction<true, std::negation<std::is_array<v8::internal::ScriptStreamingData> >, <std::is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *>, std::is_convertible<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData> >>> {
        using type = typename _Conjunction<is_convertible<ScriptStreamingData *, ScriptStreamingData *>::value, is_convertible<ScriptStreamingData *, ScriptStreamingData *>, is_convertible<default_delete<ScriptStreamingData>, default_delete<ScriptStreamingData> > >::type;
    };
template<> struct _Conjunction<true, std::is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *>, <std::is_convertible<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData> >>> {
        using type = typename _Conjunction<is_convertible<default_delete<ScriptStreamingData>, default_delete<ScriptStreamingData> >::value, is_convertible<default_delete<ScriptStreamingData>, default_delete<ScriptStreamingData> > >::type;
    };
template<> struct _Conjunction<true, std::is_convertible<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData> >, <>> {
        using type = std::is_convertible<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData> >;
    };
template<> struct _Conjunction<true, std::negation<std::is_array<v8::internal::ScriptStreamingData> >, <std::is_assignable<std::default_delete<v8::internal::ScriptStreamingData> &, std::default_delete<v8::internal::ScriptStreamingData> >, std::is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *>>> {
        using type = typename _Conjunction<is_assignable<default_delete<ScriptStreamingData> &, default_delete<ScriptStreamingData> >::value, is_assignable<default_delete<ScriptStreamingData> &, default_delete<ScriptStreamingData> >, is_convertible<ScriptStreamingData *, ScriptStreamingData *> >::type;
    };
template<> struct _Conjunction<true, std::is_assignable<std::default_delete<v8::internal::ScriptStreamingData> &, std::default_delete<v8::internal::ScriptStreamingData> >, <std::is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *>>> {
        using type = typename _Conjunction<is_convertible<ScriptStreamingData *, ScriptStreamingData *>::value, is_convertible<ScriptStreamingData *, ScriptStreamingData *> >::type;
    };
template<> struct _Conjunction<true, std::is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *>, <>> {
        using type = std::is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *>;
    };
template<> struct _Conjunction<true, std::negation<std::is_pointer<std::default_delete<unsigned char const[]> > >, <std::is_default_constructible<std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_default_constructible<default_delete<unsigned char const[]> >::value, is_default_constructible<default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_default_constructible<std::default_delete<unsigned char const[]> >, <>> {
        using type = std::is_default_constructible<std::default_delete<unsigned char const[]> >;
    };
template<> struct _Conjunction<true, std::is_array<unsigned char const[]>, <std::is_same<const unsigned char *, const unsigned char *>, std::is_same<const unsigned char *, const unsigned char *>, std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_same<const unsigned char *, const unsigned char *>::value, is_same<const unsigned char *, const unsigned char *>, is_same<const unsigned char *, const unsigned char *>, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_convertible<default_delete<unsigned char const[]>, default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_same<const unsigned char *, const unsigned char *>, <std::is_same<const unsigned char *, const unsigned char *>, std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_same<const unsigned char *, const unsigned char *>::value, is_same<const unsigned char *, const unsigned char *>, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_convertible<default_delete<unsigned char const[]>, default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_same<const unsigned char *, const unsigned char *>, <std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_convertible<unsigned char const (*)[], unsigned char const (*)[]>::value, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_convertible<default_delete<unsigned char const[]>, default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, <std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_convertible<default_delete<unsigned char const[]>, default_delete<unsigned char const[]> >::value, is_convertible<default_delete<unsigned char const[]>, default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >, <>> {
        using type = std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >;
    };
template<> struct _Conjunction<true, std::is_array<unsigned char const[]>, <std::is_same<const unsigned char *, const unsigned char *>, std::is_same<const unsigned char *, const unsigned char *>, std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, std::is_assignable<std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_same<const unsigned char *, const unsigned char *>::value, is_same<const unsigned char *, const unsigned char *>, is_same<const unsigned char *, const unsigned char *>, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_assignable<default_delete<unsigned char const[]> &, default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_same<const unsigned char *, const unsigned char *>, <std::is_same<const unsigned char *, const unsigned char *>, std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, std::is_assignable<std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_same<const unsigned char *, const unsigned char *>::value, is_same<const unsigned char *, const unsigned char *>, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_assignable<default_delete<unsigned char const[]> &, default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_same<const unsigned char *, const unsigned char *>, <std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, std::is_assignable<std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_convertible<unsigned char const (*)[], unsigned char const (*)[]>::value, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_assignable<default_delete<unsigned char const[]> &, default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, <std::is_assignable<std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_assignable<default_delete<unsigned char const[]> &, default_delete<unsigned char const[]> >::value, is_assignable<default_delete<unsigned char const[]> &, default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_assignable<std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]> >, <>> {
        using type = std::is_assignable<std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]> >;
    };
template<> struct _Conjunction<true, std::negation<std::is_pointer<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > >, <std::is_default_constructible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >>> {
        using type = typename _Conjunction<is_default_constructible<default_delete<WasmStreamingImpl> >::value, is_default_constructible<default_delete<WasmStreamingImpl> > >::type;
    };
template<> struct _Conjunction<true, std::is_default_constructible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >, <>> {
        using type = std::is_default_constructible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >;
    };
template<> struct _Conjunction<true, std::negation<std::is_array<v8::WasmStreaming::WasmStreamingImpl> >, <std::is_convertible<v8::WasmStreaming::WasmStreamingImpl *, v8::WasmStreaming::WasmStreamingImpl *>, std::is_convertible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >>> {
        using type = typename _Conjunction<is_convertible<WasmStreamingImpl *, WasmStreamingImpl *>::value, is_convertible<WasmStreamingImpl *, WasmStreamingImpl *>, is_convertible<default_delete<WasmStreamingImpl>, default_delete<WasmStreamingImpl> > >::type;
    };
template<> struct _Conjunction<true, std::is_convertible<v8::WasmStreaming::WasmStreamingImpl *, v8::WasmStreaming::WasmStreamingImpl *>, <std::is_convertible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >>> {
        using type = typename _Conjunction<is_convertible<default_delete<WasmStreamingImpl>, default_delete<WasmStreamingImpl> >::value, is_convertible<default_delete<WasmStreamingImpl>, default_delete<WasmStreamingImpl> > >::type;
    };
template<> struct _Conjunction<true, std::is_convertible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >, <>> {
        using type = std::is_convertible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >;
    };
    template <class _True, class _Next, class ..._Rest> struct _Conjunction<true, _True, <type-parameter-0-1, type-parameter-0-2...>> {
        using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;
    };
    template <class ..._Traits> struct conjunction : std::true_type {
    };
template<> struct conjunction<<std::negation<std::is_pointer<std::default_delete<v8::internal::ScriptStreamingData> > >, std::is_default_constructible<std::default_delete<v8::internal::ScriptStreamingData> >>> : _Conjunction<negation<is_pointer<default_delete<ScriptStreamingData> > >::value, negation<is_pointer<default_delete<ScriptStreamingData> > >, is_default_constructible<default_delete<ScriptStreamingData> > >::type {
    };
template<> struct conjunction<<std::negation<std::is_array<v8::internal::ScriptStreamingData> >, std::is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *>, std::is_convertible<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData> >>> : _Conjunction<negation<is_array<ScriptStreamingData> >::value, negation<is_array<ScriptStreamingData> >, is_convertible<ScriptStreamingData *, ScriptStreamingData *>, is_convertible<default_delete<ScriptStreamingData>, default_delete<ScriptStreamingData> > >::type {
    };
template<> struct conjunction<<std::negation<std::is_array<v8::internal::ScriptStreamingData> >, std::is_assignable<std::default_delete<v8::internal::ScriptStreamingData> &, std::default_delete<v8::internal::ScriptStreamingData> >, std::is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *>>> : _Conjunction<negation<is_array<ScriptStreamingData> >::value, negation<is_array<ScriptStreamingData> >, is_assignable<default_delete<ScriptStreamingData> &, default_delete<ScriptStreamingData> >, is_convertible<ScriptStreamingData *, ScriptStreamingData *> >::type {
    };
template<> struct conjunction<<std::negation<std::is_pointer<std::default_delete<unsigned char const[]> > >, std::is_default_constructible<std::default_delete<unsigned char const[]> >>> : _Conjunction<negation<is_pointer<default_delete<unsigned char const[]> > >::value, negation<is_pointer<default_delete<unsigned char const[]> > >, is_default_constructible<default_delete<unsigned char const[]> > >::type {
    };
template<> struct conjunction<<std::is_array<unsigned char const[]>, std::is_same<const unsigned char *, const unsigned char *>, std::is_same<const unsigned char *, const unsigned char *>, std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >>> : _Conjunction<is_array<unsigned char const[]>::value, is_array<unsigned char const[]>, is_same<const unsigned char *, const unsigned char *>, is_same<const unsigned char *, const unsigned char *>, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_convertible<default_delete<unsigned char const[]>, default_delete<unsigned char const[]> > >::type {
    };
template<> struct conjunction<<std::is_array<unsigned char const[]>, std::is_same<const unsigned char *, const unsigned char *>, std::is_same<const unsigned char *, const unsigned char *>, std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, std::is_assignable<std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]> >>> : _Conjunction<is_array<unsigned char const[]>::value, is_array<unsigned char const[]>, is_same<const unsigned char *, const unsigned char *>, is_same<const unsigned char *, const unsigned char *>, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_assignable<default_delete<unsigned char const[]> &, default_delete<unsigned char const[]> > >::type {
    };
template<> struct conjunction<<std::negation<std::is_pointer<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > >, std::is_default_constructible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >>> : _Conjunction<negation<is_pointer<default_delete<WasmStreamingImpl> > >::value, negation<is_pointer<default_delete<WasmStreamingImpl> > >, is_default_constructible<default_delete<WasmStreamingImpl> > >::type {
    };
template<> struct conjunction<<std::negation<std::is_array<v8::WasmStreaming::WasmStreamingImpl> >, std::is_convertible<v8::WasmStreaming::WasmStreamingImpl *, v8::WasmStreaming::WasmStreamingImpl *>, std::is_convertible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >>> : _Conjunction<negation<is_array<WasmStreamingImpl> >::value, negation<is_array<WasmStreamingImpl> >, is_convertible<WasmStreamingImpl *, WasmStreamingImpl *>, is_convertible<default_delete<WasmStreamingImpl>, default_delete<WasmStreamingImpl> > >::type {
    };
    template <class _First, class ..._Rest> struct conjunction<<type-parameter-0-0, type-parameter-0-1...>> : _Conjunction<_First::value, _First, _Rest...>::type {
    };
    template <class ..._Traits> constexpr bool conjunction_v = conjunction<_Traits...>::value;
    template <bool _First_value, class _First, class ..._Rest> struct _Disjunction {
        using type = _First;
    };
    template <class _False, class _Next, class ..._Rest> struct _Disjunction<false, _False, <type-parameter-0-1, type-parameter-0-2...>> {
        using type = typename _Disjunction<_Next::value, _Next, _Rest...>::type;
    };
    template <class ..._Traits> struct disjunction : std::false_type {
    };
    template <class _First, class ..._Rest> struct disjunction<<type-parameter-0-0, type-parameter-0-1...>> : _Disjunction<_First::value, _First, _Rest...>::type {
    };
    template <class ..._Traits> constexpr bool disjunction_v = disjunction<_Traits...>::value;
    template <class _Trait> struct negation : bool_constant<!static_cast<bool>(_Trait::value)> {
    };
template<> struct negation<std::is_pointer<std::default_delete<v8::internal::ScriptStreamingData> >> : bool_constant<!static_cast<bool>(is_pointer<default_delete<ScriptStreamingData> >::value)> {
    };
template<> struct negation<std::is_array<v8::internal::ScriptStreamingData>> : bool_constant<!static_cast<bool>(is_array<ScriptStreamingData>::value)> {
    };
template<> struct negation<std::is_pointer<std::default_delete<unsigned char const[]> >> : bool_constant<!static_cast<bool>(is_pointer<default_delete<unsigned char const[]> >::value)> {
    };
template<> struct negation<std::is_pointer<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >> : bool_constant<!static_cast<bool>(is_pointer<default_delete<WasmStreamingImpl> >::value)> {
    };
template<> struct negation<std::is_array<v8::WasmStreaming::WasmStreamingImpl>> : bool_constant<!static_cast<bool>(is_array<WasmStreamingImpl>::value)> {
    };
    template <class _Trait> constexpr bool negation_v = negation<_Trait>::value;
    template <class _Ty, class ..._Types> constexpr bool _Is_any_of_v = disjunction_v<is_same<_Ty, _Types>...>;
    template <class ..._Types> struct _Arg_types {
    };
    template <class _Ty1> struct _Arg_types<<type-parameter-0-0>> {
        typedef _Ty1 argument_type;
    };
    template <class _Ty1, class _Ty2> struct _Arg_types<<type-parameter-0-0, type-parameter-0-1>> {
        typedef _Ty1 first_argument_type;
        typedef _Ty2 second_argument_type;
    };
    template <class _Ty> struct _Is_function {
        using _Bool_type = std::false_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...)> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall))> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) const> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) const> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) volatile> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) volatile> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) const volatile> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) const volatile> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) &> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) &> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) const &> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) const &> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) volatile &> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) volatile &> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) const volatile &> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) const volatile &> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) &&> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) &&> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) const &&> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) const &&> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) volatile &&> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) volatile &&> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) const volatile &&> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) const volatile &&> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...)> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) const> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) volatile> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) const volatile> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) &> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) const &> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) volatile &> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) const volatile &> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) &&> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) const &&> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) volatile &&> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) const volatile &&> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ty> struct is_function : _Is_function<_Ty>::_Bool_type {
    };
    template <class _Ty> constexpr bool is_function_v = is_function<_Ty>::value;
    template <class _Ty> struct _Is_memfunptr {
        using _Bool_type = std::false_type;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...)> : _Arg_types<_Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall))> : _Arg_types<_Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) const> : _Arg_types<const _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) const> : _Arg_types<const _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) volatile> : _Arg_types<volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) volatile> : _Arg_types<volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) const volatile> : _Arg_types<const volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) const volatile> : _Arg_types<const volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) &> : _Arg_types<_Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) &> : _Arg_types<_Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) const &> : _Arg_types<const _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) const &> : _Arg_types<const _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) &&> : _Arg_types<_Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &&, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) &&> : _Arg_types<_Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &&, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) const &&> : _Arg_types<const _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &&, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) const &&> : _Arg_types<const _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &&, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &&, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &&, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &&, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &&, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...)> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) const> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) volatile> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) const volatile> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) &> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) const &> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) volatile &> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) const volatile &> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) &&> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) const &&> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) volatile &&> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) const volatile &&> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ty> struct is_void : std::false_type {
    };
    template<> struct is_void<void> : std::true_type {
    };
    template<> struct is_void<const void> : std::true_type {
    };
    template<> struct is_void<volatile void> : std::true_type {
    };
    template<> struct is_void<const volatile void> : std::true_type {
    };
    template <class _Ty> constexpr bool is_void_v = is_void<_Ty>::value;
    template <class ..._Types> using void_t = void;
    template <class _Ty> struct add_const {
        using type = const _Ty;
    };
    template <class _Ty> using add_const_t = const _Ty;
    template <class _Ty> struct add_volatile {
        using type = volatile _Ty;
    };
    template <class _Ty> using add_volatile_t = volatile _Ty;
    template <class _Ty> struct add_cv {
        using type = const volatile _Ty;
    };
    template <class _Ty> using add_cv_t = const volatile _Ty;
    template <class _Ty, class  = void> struct _Add_reference {
        using _Lvalue = _Ty;
        using _Rvalue = _Ty;
    };
template<> struct _Add_reference<v8::internal::ScriptStreamingData, void> {
        using _Lvalue = v8::internal::ScriptStreamingData &;
        using _Rvalue = v8::internal::ScriptStreamingData &&;
    };
template<> struct _Add_reference<v8::WasmStreaming::WasmStreamingImpl, void> {
        using _Lvalue = v8::WasmStreaming::WasmStreamingImpl &;
        using _Rvalue = v8::WasmStreaming::WasmStreamingImpl &&;
    };
    template <class _Ty> struct _Add_reference<_Ty, void> {
        using _Lvalue = _Ty &;
        using _Rvalue = _Ty &&;
    };
    template <class _Ty> struct add_lvalue_reference {
        using type = typename _Add_reference<_Ty>::_Lvalue;
    };
    template <class _Ty> using add_lvalue_reference_t = typename _Add_reference<_Ty>::_Lvalue;
    template <class _Ty> struct add_rvalue_reference {
        using type = typename _Add_reference<_Ty>::_Rvalue;
    };
    template <class _Ty> using add_rvalue_reference_t = typename _Add_reference<_Ty>::_Rvalue;
    template <class _Ty> add_rvalue_reference_t<_Ty> declval() noexcept;
    template <class _Ty> struct remove_extent {
        using type = _Ty;
    };
template<> struct remove_extent<v8::internal::wasm::NativeModule> {
        using type = v8::internal::wasm::NativeModule;
    };
template<> struct remove_extent<v8::internal::wasm::StreamingDecoder> {
        using type = v8::internal::wasm::StreamingDecoder;
    };
    template <class _Ty, size_t _Ix> struct remove_extent<type-parameter-0-0 [_SizeOfArray]> {
        using type = _Ty;
    };
    template <class _Ty> struct remove_extent<type-parameter-0-0 []> {
        using type = _Ty;
    };
    template <class _Ty> using remove_extent_t = typename remove_extent<_Ty>::type;
    template <class _Ty> struct remove_all_extents {
        using type = _Ty;
    };
    template <class _Ty, size_t _Ix> struct remove_all_extents<type-parameter-0-0 [_SizeOfArray]> {
        using type = typename remove_all_extents<_Ty>::type;
    };
    template <class _Ty> struct remove_all_extents<type-parameter-0-0 []> {
        using type = typename remove_all_extents<_Ty>::type;
    };
    template <class _Ty> using remove_all_extents_t = typename remove_all_extents<_Ty>::type;
    template <class _Ty> struct remove_pointer {
        using type = _Ty;
    };
template<> struct remove_pointer<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >> {
        using type = std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >;
    };
    template <class _Ty> struct remove_pointer<type-parameter-0-0 *> {
        using type = _Ty;
    };
    template <class _Ty> struct remove_pointer<type-parameter-0-0 *const> {
        using type = _Ty;
    };
    template <class _Ty> struct remove_pointer<type-parameter-0-0 *volatile> {
        using type = _Ty;
    };
    template <class _Ty> struct remove_pointer<type-parameter-0-0 *const volatile> {
        using type = _Ty;
    };
    template <class _Ty> using remove_pointer_t = typename remove_pointer<_Ty>::type;
    template <class _Ty, class  = void> struct _Add_pointer {
        using type = _Ty;
    };
    template <class _Ty> struct _Add_pointer<_Ty, void> {
        using type = remove_reference_t<_Ty> *;
    };
    template <class _Ty> struct add_pointer {
        using type = typename _Add_pointer<_Ty>::type;
    };
    template <class _Ty> using add_pointer_t = typename _Add_pointer<_Ty>::type;
    template <class _Ty> struct is_array : std::false_type {
    };
template<> struct is_array<v8::internal::ScriptStreamingData> : std::false_type {
    };
template<> struct is_array<unsigned char const[]> : std::true_type {
    };
template<> struct is_array<v8::internal::wasm::NativeModule> : std::false_type {
    };
template<> struct is_array<v8::WasmStreaming::WasmStreamingImpl> : std::false_type {
    };
template<> struct is_array<v8::internal::wasm::StreamingDecoder> : std::false_type {
    };
    template <class _Ty, size_t _Nx> struct is_array<type-parameter-0-0 [_SizeOfArray]> : std::true_type {
    };
    template <class _Ty> struct is_array<type-parameter-0-0 []> : std::true_type {
    };
    template <class _Ty> constexpr bool is_array_v = is_array<_Ty>::value;
    template <class _Ty> struct is_lvalue_reference : std::false_type {
    };
    template <class _Ty> struct is_lvalue_reference<type-parameter-0-0 &> : std::true_type {
    };
    template <class _Ty> constexpr bool is_lvalue_reference_v = is_lvalue_reference<_Ty>::value;
    template <class _Ty> struct is_rvalue_reference : std::false_type {
    };
    template <class _Ty> struct is_rvalue_reference<type-parameter-0-0 &&> : std::true_type {
    };
    template <class _Ty> constexpr bool is_rvalue_reference_v = is_rvalue_reference<_Ty>::value;
    template <class _Ty> struct is_reference : std::false_type {
    };
template<> struct is_reference<std::default_delete<v8::internal::ScriptStreamingData>> : std::false_type {
    };
template<> struct is_reference<std::default_delete<unsigned char const[]>> : std::false_type {
    };
template<> struct is_reference<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> : std::false_type {
    };
    template <class _Ty> struct is_reference<type-parameter-0-0 &> : std::true_type {
    };
    template <class _Ty> struct is_reference<type-parameter-0-0 &&> : std::true_type {
    };
    template <class _Ty> constexpr bool is_reference_v = is_reference<_Ty>::value;
    template <class _Ty, bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value> struct _Is_member_object_pointer : std::false_type {
    };
    template <class _Ty1, class _Ty2> struct _Is_member_object_pointer<type-parameter-0-0 type-parameter-0-1::*, false> : std::true_type {
        using _Class_type = _Ty2;
    };
    template <class _Ty> struct is_member_object_pointer : _Is_member_object_pointer<remove_cv_t<_Ty> >::type {
    };
    template <class _Ty> constexpr bool is_member_object_pointer_v = is_member_object_pointer<_Ty>::value;
    template <class _Ty> struct is_member_function_pointer : _Is_memfunptr<remove_cv_t<_Ty> >::_Bool_type {
    };
    template <class _Ty> constexpr bool is_member_function_pointer_v = is_member_function_pointer<_Ty>::value;
    template <class _Ty> struct is_pointer : std::false_type {
    };
template<> struct is_pointer<std::default_delete<v8::internal::ScriptStreamingData>> : std::false_type {
    };
template<> struct is_pointer<std::default_delete<unsigned char const[]>> : std::false_type {
    };
template<> struct is_pointer<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >> : std::false_type {
    };
template<> struct is_pointer<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> : std::false_type {
    };
    template <class _Ty> struct is_pointer<type-parameter-0-0 *> : std::true_type {
    };
    template <class _Ty> struct is_pointer<type-parameter-0-0 *const> : std::true_type {
    };
    template <class _Ty> struct is_pointer<type-parameter-0-0 *volatile> : std::true_type {
    };
    template <class _Ty> struct is_pointer<type-parameter-0-0 *const volatile> : std::true_type {
    };
    template <class _Ty> constexpr bool is_pointer_v = is_pointer<_Ty>::value;
    template <class _Ty> struct is_null_pointer : bool_constant<is_same_v<remove_cv_t<_Ty>, std::nullptr_t> > {
    };
    template <class _Ty> constexpr bool is_null_pointer_v = is_same_v<remove_cv_t<_Ty>, std::nullptr_t>;
    template <class _Ty> struct is_union : bool_constant<__is_union(_Ty)> {
    };
    template <class _Ty> constexpr bool is_union_v = __is_union(_Ty);
    template <class _Ty> struct is_class : bool_constant<__is_class(_Ty)> {
    };
    template <class _Ty> constexpr bool is_class_v = __is_class(_Ty);
    template <class _Ty> struct is_fundamental : bool_constant<is_arithmetic_v<_Ty> || is_void_v<_Ty> || is_null_pointer_v<_Ty> > {
    };
    template <class _Ty> constexpr bool is_fundamental_v = is_fundamental<_Ty>::value;
    template <class _Ty> struct is_object : bool_constant<!is_function_v<_Ty> && !is_reference_v<_Ty> && !is_void_v<_Ty> > {
    };
    template <class _Ty> constexpr bool is_object_v = is_object<_Ty>::value;
    template <class _From, class _To> struct is_convertible : bool_constant<__is_convertible_to(_From, _To)> {
    };
template<> struct is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *> : bool_constant<__is_convertible_to(v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *)> {
    };
template<> struct is_convertible<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData>> : bool_constant<__is_convertible_to(std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData>)> {
    };
template<> struct is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]>> : bool_constant<__is_convertible_to(std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]>)> {
    };
template<> struct is_convertible<unsigned char const (*)[], unsigned char const (*)[]> : bool_constant<__is_convertible_to(unsigned char const (*)[], unsigned char const (*)[])> {
    };
template<> struct is_convertible<v8::internal::wasm::NativeModule *, v8::internal::wasm::NativeModule *> : bool_constant<__is_convertible_to(v8::internal::wasm::NativeModule *, v8::internal::wasm::NativeModule *)> {
    };
template<> struct is_convertible<v8::WasmStreaming::WasmStreamingImpl *, v8::WasmStreaming::WasmStreamingImpl *> : bool_constant<__is_convertible_to(v8::WasmStreaming::WasmStreamingImpl *, v8::WasmStreaming::WasmStreamingImpl *)> {
    };
template<> struct is_convertible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> : bool_constant<__is_convertible_to(std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl>)> {
    };
template<> struct is_convertible<v8::internal::wasm::StreamingDecoder *, v8::internal::wasm::StreamingDecoder *> : bool_constant<__is_convertible_to(v8::internal::wasm::StreamingDecoder *, v8::internal::wasm::StreamingDecoder *)> {
    };
    template <class _From, class _To> constexpr bool is_convertible_v = __is_convertible_to(_From, _To);
    template <class _Ty> struct is_enum : bool_constant<__is_enum(_Ty)> {
    };
    template <class _Ty> constexpr bool is_enum_v = __is_enum(_Ty);
    template <class _Ty> struct is_compound : bool_constant<!is_fundamental_v<_Ty> > {
    };
    template <class _Ty> constexpr bool is_compound_v = is_compound<_Ty>::value;
    template <class _Ty> struct is_member_pointer : bool_constant<is_member_object_pointer_v<_Ty> || is_member_function_pointer_v<_Ty> > {
    };
    template <class _Ty> constexpr bool is_member_pointer_v = is_member_pointer<_Ty>::value;
    template <class _Ty> struct is_scalar : bool_constant<is_arithmetic_v<_Ty> || is_enum_v<_Ty> || is_pointer_v<_Ty> || is_member_pointer_v<_Ty> || is_null_pointer_v<_Ty> > {
    };
    template <class _Ty> constexpr bool is_scalar_v = is_scalar<_Ty>::value;
    template <class _Ty> struct is_const : std::false_type {
    };
template<> struct is_const<char> : std::false_type {
    };
    template <class _Ty> struct is_const<_Ty> : std::true_type {
    };
    template <class _Ty> constexpr bool is_const_v = is_const<_Ty>::value;
    template <class _Ty> struct is_volatile : std::false_type {
    };
    template <class _Ty> struct is_volatile<_Ty> : std::true_type {
    };
    template <class _Ty> constexpr bool is_volatile_v = is_volatile<_Ty>::value;
    template <class _Ty> struct is_pod : bool_constant<__is_pod(_Ty)> {
    };
    template <class _Ty> constexpr bool is_pod_v = __is_pod(_Ty);
    template <class _Ty> struct is_empty : bool_constant<__is_empty(_Ty)> {
    };
    template <class _Ty> constexpr bool is_empty_v = __is_empty(_Ty);
    template <class _Ty> struct is_polymorphic : bool_constant<__is_polymorphic(_Ty)> {
    };
    template <class _Ty> constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);
    template <class _Ty> struct is_abstract : bool_constant<__is_abstract(_Ty)> {
    };
    template <class _Ty> constexpr bool is_abstract_v = __is_abstract(_Ty);
    template <class _Ty> struct is_final : bool_constant<__is_final(_Ty)> {
    };
    template <class _Ty> constexpr bool is_final_v = __is_final(_Ty);
    template <class _Ty> struct is_standard_layout : bool_constant<__is_standard_layout(_Ty)> {
    };
    template <class _Ty> constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);
    template <class _Ty> struct is_literal_type : bool_constant<__is_literal(_Ty)> {
    };
    template <class _Ty> constexpr bool is_literal_type_v = __is_literal(_Ty);
    template <class _Ty> struct is_trivial : bool_constant<__is_trivial(_Ty)> {
    };
    template <class _Ty> constexpr bool is_trivial_v = __is_trivial(_Ty);
    template <class _Ty> struct is_trivially_copyable : bool_constant<__is_trivially_copyable(_Ty)> {
    };
    template <class _Ty> constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);
    template <class _Ty> struct has_virtual_destructor : bool_constant<__has_virtual_destructor(_Ty)> {
    };
    template <class _Ty> constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);
    template <class _Ty, class ..._Args> struct is_constructible : bool_constant<__is_constructible(_Ty, _Args...)> {
    };
    template <class _Ty, class ..._Args> constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);
    template <class _Ty> struct is_copy_constructible : bool_constant<__is_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    };
    template <class _Ty> constexpr bool is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t<const _Ty>);
    template <class _Ty> struct is_default_constructible : bool_constant<__is_constructible(_Ty)> {
    };
template<> struct is_default_constructible<std::default_delete<v8::internal::ScriptStreamingData>> : bool_constant<__is_constructible(std::default_delete<v8::internal::ScriptStreamingData>)> {
    };
template<> struct is_default_constructible<std::default_delete<unsigned char const[]>> : bool_constant<__is_constructible(std::default_delete<unsigned char const[]>)> {
    };
template<> struct is_default_constructible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> : bool_constant<__is_constructible(std::default_delete<v8::WasmStreaming::WasmStreamingImpl>)> {
    };
    template <class _Ty> constexpr bool is_default_constructible_v = __is_constructible(_Ty);
    template <class _Ty, class  = void> struct _Is_implicitly_default_constructible : std::false_type {
    };
    template <class _Ty> void _Implicitly_default_construct(const _Ty &);
    template <class _Ty> struct _Is_implicitly_default_constructible<_Ty, void> : std::true_type {
    };
    template <class _Ty> struct is_move_constructible : bool_constant<__is_constructible(_Ty, _Ty)> {
    };
    template <class _Ty> constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);
    template <class _To, class _From> struct is_assignable : bool_constant<__is_assignable(_To, _From)> {
    };
template<> struct is_assignable<std::default_delete<v8::internal::ScriptStreamingData> &, std::default_delete<v8::internal::ScriptStreamingData>> : bool_constant<__is_assignable(std::default_delete<v8::internal::ScriptStreamingData> &, std::default_delete<v8::internal::ScriptStreamingData>)> {
    };
template<> struct is_assignable<std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]>> : bool_constant<__is_assignable(std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]>)> {
    };
    template <class _To, class _From> constexpr bool is_assignable_v = __is_assignable(_To, _From);
    template <class _Ty> struct is_copy_assignable : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    };
    template <class _Ty> constexpr bool is_copy_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);
    template <class _Ty> struct is_move_assignable : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    };
    template <class _Ty> constexpr bool is_move_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, _Ty);
    template <class _Ty> struct is_destructible : bool_constant<__is_destructible(_Ty)> {
    };
    template <class _Ty> constexpr bool is_destructible_v = __is_destructible(_Ty);
    template <class _Ty, class ..._Args> struct is_trivially_constructible : bool_constant<__is_trivially_constructible(_Ty, _Args...)> {
    };
    template <class _Ty, class ..._Args> constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);
    template <class _Ty> struct is_trivially_copy_constructible : bool_constant<__is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    };
    template <class _Ty> constexpr bool is_trivially_copy_constructible_v = __is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>);
    template <class _Ty> struct is_trivially_default_constructible : bool_constant<__is_trivially_constructible(_Ty)> {
    };
    template <class _Ty> constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);
    template <class _Ty> struct is_trivially_move_constructible : bool_constant<__is_trivially_constructible(_Ty, _Ty)> {
    };
    template <class _Ty> constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);
    template <class _To, class _From> struct is_trivially_assignable : bool_constant<__is_trivially_assignable(_To, _From)> {
    };
    template <class _To, class _From> constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);
    template <class _Ty> struct is_trivially_copy_assignable : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    };
    template <class _Ty> constexpr bool is_trivially_copy_assignable_v = __is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);
    template <class _Ty> struct is_trivially_move_assignable : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    };
    template <class _Ty> constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty);
    template <class _Ty> struct is_trivially_destructible : bool_constant<__is_trivially_destructible(_Ty)> {
    };
    template <class _Ty> constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);
    template <class _Ty, class ..._Args> struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Args...)> {
    };
    template <class _Ty, class ..._Args> constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);
    template <class _Ty> struct is_nothrow_copy_constructible : bool_constant<__is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    };
    template <class _Ty> constexpr bool is_nothrow_copy_constructible_v = __is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>);
    template <class _Ty> struct is_nothrow_default_constructible : bool_constant<__is_nothrow_constructible(_Ty)> {
    };
    template <class _Ty> constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);
    template <class _Ty> struct is_nothrow_move_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Ty)> {
    };
    template <class _Ty> constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);
    template <class _To, class _From> struct is_nothrow_assignable : bool_constant<__is_nothrow_assignable(_To, _From)> {
    };
    template <class _To, class _From> constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);
    template <class _Ty> struct is_nothrow_copy_assignable : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    };
    template <class _Ty> constexpr bool is_nothrow_copy_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);
    template <class _Ty> struct is_nothrow_move_assignable : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    };
    template <class _Ty> constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty);
    template <class _Ty> struct is_nothrow_destructible : bool_constant<__is_nothrow_destructible(_Ty)> {
    };
    template <class _Ty> constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);
    template <class _Ty, bool = is_integral_v<_Ty>> struct _Sign_base {
        using _Uty = remove_cv_t<_Ty>;
        using _Signed = bool_constant<std::_Sign_base::_Uty(-1) < std::_Sign_base::_Uty(0)>;
        using _Unsigned = bool_constant<std::_Sign_base::_Uty(0) < std::_Sign_base::_Uty(-1)>;
    };
    template <class _Ty> struct _Sign_base<_Ty, false> {
        using _Signed = typename is_floating_point<_Ty>::type;
        using _Unsigned = std::false_type;
    };
    template <class _Ty> struct is_signed : _Sign_base<_Ty>::_Signed {
    };
    template <class _Ty> constexpr bool is_signed_v = is_signed<_Ty>::value;
    template <class _Ty> struct is_unsigned : _Sign_base<_Ty>::_Unsigned {
    };
    template <class _Ty> constexpr bool is_unsigned_v = is_unsigned<_Ty>::value;
    template <class _Ty> using _Is_nonbool_integral = bool_constant<is_integral_v<_Ty> && !is_same_v<remove_cv_t<_Ty>, bool> >;
    template <class _Ty> struct _Change_sign {
        static_assert(_Is_nonbool_integral<_Ty>::value || is_enum_v<_Ty>, "make_signed<T>/make_unsigned<T> require that T shall be a (possibly cv-qualified) integral type or enumeration but not a bool type.");
        using _Signed = conditional_t<_Is_any_of_v<_Ty, long, unsigned long>, long, conditional_t<sizeof(_Ty) == 1, signed char, conditional_t<sizeof(_Ty) == 2, short, conditional_t<sizeof(_Ty) == 4, int, long long> > > >;
        using _Unsigned = conditional_t<_Is_any_of_v<_Ty, long, unsigned long>, unsigned long, conditional_t<sizeof(_Ty) == 1, unsigned char, conditional_t<sizeof(_Ty) == 2, unsigned short, conditional_t<sizeof(_Ty) == 4, unsigned int, unsigned long long> > > >;
    };
    template <class _Ty> struct _Change_sign<_Ty> {
        using _Signed = const typename _Change_sign<_Ty>::_Signed;
        using _Unsigned = const typename _Change_sign<_Ty>::_Unsigned;
    };
    template <class _Ty> struct _Change_sign<_Ty> {
        using _Signed = volatile typename _Change_sign<_Ty>::_Signed;
        using _Unsigned = volatile typename _Change_sign<_Ty>::_Unsigned;
    };
    template <class _Ty> struct _Change_sign<_Ty> {
        using _Signed = const volatile typename _Change_sign<_Ty>::_Signed;
        using _Unsigned = const volatile typename _Change_sign<_Ty>::_Unsigned;
    };
    template <class _Ty> struct make_signed {
        using type = typename _Change_sign<_Ty>::_Signed;
    };
    template <class _Ty> using make_signed_t = typename make_signed<_Ty>::type;
    template <class _Ty> struct make_unsigned {
        using type = typename _Change_sign<_Ty>::_Unsigned;
    };
    template <class _Ty> using make_unsigned_t = typename make_unsigned<_Ty>::type;
    template <class _Rep> constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val)     {
        return (static_cast<make_unsigned_t<_Rep>>(_Val));
    }
    template <class _Ty> struct alignment_of : integral_constant<size_t, alignof(_Ty)> {
    };
    template <class _Ty> constexpr size_t alignment_of_v = alignof(_Ty);
    template <class _Ty, size_t _Len> union _Align_type {
        _Ty _Val;
        char _Pad[_Len];
    };
    template <size_t _Len, size_t _Align, class _Ty, bool _Ok> struct _Aligned;
    template <size_t _Len, size_t _Align, class _Ty> struct _Aligned<_Len, _Align, _Ty, true> {
        using type = _Align_type<_Ty, _Len>;
    };
    template <size_t _Len, size_t _Align> struct _Aligned<_Len, _Align, double, false> {
        static_assert(_Always_false<_Aligned<_Len, _Align, double, false> >, "You've instantiated std::aligned_storage<Len, Align> with an extended alignment (in other words, Align > alignof(max_align_t)). Before VS 2017 15.8, the member type would non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to handle this correctly, but the fix inherently changes layout and breaks binary compatibility (*only* for uses of aligned_storage with extended alignments). Please define either (1) _ENABLE_EXTENDED_ALIGNED_STORAGE to acknowledge that you understand this message and that you actually want a type with an extended alignment, or (2) _DISABLE_EXTENDED_ALIGNED_STORAGE to silence this message and get the old non-conformant behavior.");
        using type = _Align_type<std::max_align_t, _Len>;
    };
    template <size_t _Len, size_t _Align> struct _Aligned<_Len, _Align, int, false> {
        using type = typename _Aligned<_Len, _Align, double, _Align <= alignof(double)>::type;
    };
    template <size_t _Len, size_t _Align> struct _Aligned<_Len, _Align, short, false> {
        using type = typename _Aligned<_Len, _Align, int, _Align <= alignof(int)>::type;
    };
    template <size_t _Len, size_t _Align> struct _Aligned<_Len, _Align, char, false> {
        using type = typename _Aligned<_Len, _Align, short, _Align <= alignof(short)>::type;
    };
    template <size_t _Len, size_t _Align = alignof(std::max_align_t)> struct aligned_storage {
        using type = typename _Aligned<_Len, _Align, char, _Align <= alignof(char)>::type;
    };
    template <size_t _Len, size_t _Align = alignof(std::max_align_t)> using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
    template <size_t ..._Vals> struct _Maximum;
    template<> struct _Maximum<<>> : integral_constant<size_t, 0> {
    };
    template <size_t _Val> struct _Maximum<<_Val>> : integral_constant<size_t, _Val> {
    };
    template <size_t _First, size_t _Second, size_t ..._Rest> struct _Maximum<<_First, _Second, _Rest...>> : _Maximum<(_First < _Second ? _Second : _First), _Rest...>::type {
    };
    template <size_t _Len, class ..._Types> struct aligned_union {
        static constexpr size_t _Max_len = _Maximum<_Len, sizeof(_Types)...>::value;
        static constexpr size_t alignment_value = _Maximum<alignof(_Types)...>::value;
        using type = aligned_storage_t<_Max_len, alignment_value>;
    };
    template <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
    template <class _Ty> struct underlying_type {
        using type = __underlying_type(_Ty);
    };
    template <class _Ty> using underlying_type_t = typename underlying_type<_Ty>::type;
    template <class _Ty> struct rank : integral_constant<size_t, 0> {
    };
    template <class _Ty, size_t _Ix> struct rank<type-parameter-0-0 [_SizeOfArray]> : integral_constant<size_t, rank<_Ty>::value + 1> {
    };
    template <class _Ty> struct rank<type-parameter-0-0 []> : integral_constant<size_t, rank<_Ty>::value + 1> {
    };
    template <class _Ty> constexpr size_t rank_v = rank<_Ty>::value;
    template <class _Ty, unsigned int _Nx> struct _Extent : integral_constant<size_t, 0> {
    };
    template <class _Ty, size_t _Ix> struct _Extent<type-parameter-0-0 [_SizeOfArray], 0> : integral_constant<size_t, _Ix> {
    };
    template <class _Ty, unsigned int _Nx, size_t _Ix> struct _Extent<type-parameter-0-0 [_Ix], _Nx> : _Extent<_Ty, _Nx - 1> {
    };
    template <class _Ty, unsigned int _Nx> struct _Extent<type-parameter-0-0 [], _Nx> : _Extent<_Ty, _Nx - 1> {
    };
    template <class _Ty, unsigned int _Nx = 0> struct extent : _Extent<_Ty, _Nx> {
    };
    template <class _Ty, unsigned int _Ix = 0> constexpr size_t extent_v = extent<_Ty, _Ix>::value;
    template <class _Base, class _Derived> struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)> {
    };
    template <class _Base, class _Derived> constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);
    template <class _Ty> struct decay {
        using _Ty1 = remove_reference_t<_Ty>;
        using type = conditional_t<is_array_v<std::decay::_Ty1>, add_pointer_t<remove_extent_t<std::decay::_Ty1> >, conditional_t<is_function_v<std::decay::_Ty1>, add_pointer_t<std::decay::_Ty1>, remove_cv_t<std::decay::_Ty1> > >;
    };
    template <class _Ty> using decay_t = typename decay<_Ty>::type;
    template <class _Ty1, class _Ty2, class  = void> struct _Decayed_cond_oper {
    };
    template <class _Ty1, class _Ty2> struct _Decayed_cond_oper<_Ty1, _Ty2, void> {
        using type = decay_t<decltype(false ? ::std::declval<_Ty1>() : ::std::declval<_Ty2>())>;
    };
    template <class ..._Ty> struct common_type;
    template <class ..._Ty> using common_type_t = typename common_type<_Ty...>::type;
    template<> struct common_type<<>> {
    };
    template <class _Ty1> struct common_type<<type-parameter-0-0>> : common_type<_Ty1, _Ty1> {
    };
    template <class _Ty1, class _Ty2, class _Decayed1 = decay_t<_Ty1>, class _Decayed2 = decay_t<_Ty2>> struct _Common_type2 : common_type<_Decayed1, _Decayed2> {
    };
    template <class _Ty1, class _Ty2> struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2> : _Decayed_cond_oper<_Ty1, _Ty2> {
    };
    template <class _Ty1, class _Ty2> struct common_type<<type-parameter-0-0, type-parameter-0-1>> : _Common_type2<_Ty1, _Ty2> {
    };
    template <class _Void, class _Ty1, class _Ty2, class ..._Rest> struct _Common_type3 {
    };
    template <class _Ty1, class _Ty2, class ..._Rest> struct _Common_type3<void, _Ty1, _Ty2, <type-parameter-0-2...>> : common_type<common_type_t<_Ty1, _Ty2>, _Rest...> {
    };
    template <class _Ty1, class _Ty2, class ..._Rest> struct common_type<<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2...>> : _Common_type3<void, _Ty1, _Ty2, _Rest...> {
    };
    template <class _Ty> struct [[deprecated("warning STL4003: The non-Standard std::identity struct is deprecated and will be REMOVED. You can define _SILENCE_IDENTITY_STRUCT_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] identity {
        using type = _Ty;
        const _Ty &operator()(const _Ty &_Left) const         {
            return (_Left);
        }
    };
    template <class _Ty> struct _Identity {
        using type = _Ty;
    };
    template <class _Ty> using _Identity_t = typename _Identity<_Ty>::type;
    template <class _Type, template <class ...> class _Template> constexpr bool _Is_specialization_v = false;
    constexpr bool _Is_specialization_v = true;
    template <class _Type, template <class ...> class _Template> struct _Is_specialization : bool_constant<_Is_specialization_v<_Type, _Template> > {
    };
    template <class _Ty> constexpr _Ty &&forward(remove_reference_t<_Ty> &_Arg) noexcept     {
        return (static_cast<_Ty &&>(_Arg));
    }
    template<> constexpr const unsigned char *&forward<const unsigned char *&>(remove_reference_t<const unsigned char *&> &_Arg) noexcept     {
        return (static_cast<const unsigned char *&>(_Arg));
    }
    template<> constexpr std::default_delete<unsigned char const[]> &&forward<std::default_delete<unsigned char const[]>>(remove_reference_t<std::default_delete<unsigned char const[]> > &_Arg) noexcept     {
        return (static_cast<std::default_delete<unsigned char const[]> &&>(_Arg));
    }
    template <class _Ty> constexpr _Ty &&forward(remove_reference_t<_Ty> &&_Arg) noexcept     {
        static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
        return (static_cast<_Ty &&>(_Arg));
    }
    template <class _Ty> constexpr remove_reference_t<_Ty> &&move(_Ty &&_Arg) noexcept     {
        return (static_cast<remove_reference_t<_Ty> &&>(_Arg));
    }
    template<> constexpr remove_reference_t<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &> &&move<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &>(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &_Arg) noexcept     {
        return (static_cast<remove_reference_t<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &> &&>(_Arg));
    }
    template<> constexpr remove_reference_t<std::shared_ptr<v8::internal::wasm::NativeModule> &> &&move<std::shared_ptr<v8::internal::wasm::NativeModule> &>(std::shared_ptr<v8::internal::wasm::NativeModule> &_Arg) noexcept     {
        return (static_cast<remove_reference_t<std::shared_ptr<v8::internal::wasm::NativeModule> &> &&>(_Arg));
    }
    template<> constexpr remove_reference_t<v8::OwnedBuffer &> &&move<v8::OwnedBuffer &>(v8::OwnedBuffer &_Arg) noexcept     {
        return (static_cast<remove_reference_t<v8::OwnedBuffer &> &&>(_Arg));
    }
    template <class _Ty> constexpr conditional_t<!is_nothrow_move_constructible_v<_Ty> && is_copy_constructible_v<_Ty>, const _Ty &, _Ty &&> move_if_noexcept(_Ty &_Arg) noexcept     {
        return (::std::move(_Arg));
    }
    template <class _Ty> class reference_wrapper;
    template <class _Callable, class ..._Types> struct _Invoker;
    template <class _Callable, class ..._Types> inline auto invoke(_Callable &&_Obj, _Types &&..._Args) noexcept(noexcept(_Invoker<_Callable, _Types...>::_Call(::std::forward<_Callable>(_Obj), ::std::forward<_Types>(_Args)...))invoke(_Callable &&_Obj, _Types &&..._Args) noexcept(noexcept(_Invoker<_Callable, _Types...>::_Call(::std::forward<_Callable>(_Obj), ::std::forward<_Types>(_Args)...))) -> decltype(_Invoker<_Callable, _Types...>::_Call(::std::forward<_Callable>(_Obj), ::std::forward<_Types>(_Args)...));
    struct _Unforced {
    };
    template <class _To> void _Implicitly_convert_to(_To) noexcept;
    template <class _From, class _To, bool = is_convertible_v<_From, _To>> struct _Is_nothrow_convertible : bool_constant<noexcept(_Implicitly_convert_to<_To>(::std::declval<_From>()))> {
    };
    template <class _From, class _To> struct _Is_nothrow_convertible<_From, _To, false> : std::false_type {
    };
    template <class _Void, class ..._Types> struct _Invoke_traits {
        using _Is_invocable = std::false_type;
        using _Is_nothrow_invocable = std::false_type;
        template <class _Rx> using _Is_invocable_r = std::false_type;
        template <class _Rx> using _Is_nothrow_invocable_r = std::false_type;
    };
    template <class ..._Types> struct _Invoke_traits<void, <type-parameter-0-0...>> {
        using type = decltype(::std::invoke(::std::declval<_Types>()...));
        using _Is_invocable = std::true_type;
        using _Is_nothrow_invocable = bool_constant<noexcept(::std::invoke(::std::declval<_Types>()...))>;
        template <class _Rx> using _Is_invocable_r = bool_constant<disjunction_v<is_void<_Rx>, is_convertible<std::_Invoke_traits<void, type-parameter-0-0...>::type, _Rx> > >;
        template <class _Rx> using _Is_nothrow_invocable_r = bool_constant<conjunction_v<std::_Invoke_traits<void, type-parameter-0-0...>::_Is_nothrow_invocable, disjunction<is_void<_Rx>, _Is_nothrow_convertible<std::_Invoke_traits<void, type-parameter-0-0...>::type, _Rx> > > >;
    };
    template <class _Fty> struct result_of {
        static_assert(_Always_false<_Fty>, "result_of<CallableType> is invalid; use result_of<CallableType(zero or more argument types)> instead.");
    };
    template <class _Callable, class ..._Args> struct result_of<type-parameter-0-0 (type-parameter-0-1...)> : _Invoke_traits<void, _Callable, _Args...> {
    };
    template <class _Callable, class ..._Args> struct result_of<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall))> : _Invoke_traits<void, _Callable, _Args...> {
    };
    template <class _Ty> using result_of_t = typename result_of<_Ty>::type;
    template <class _Callable, class ..._Args> using _Invoke_result_t = typename _Invoke_traits<void, _Callable, _Args...>::type;
    template <class _Rx, class _Callable, class ..._Args> using _Is_invocable_r_ = typename _Invoke_traits<void, _Callable, _Args...>::_Is_invocable_r<_Rx>;
    template <class _Rx, class _Callable, class ..._Args> struct _Is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...> {
    };
    template <class _Ty, class  = void> struct _Weak_result_type {
    };
    template <class _Ty> struct _Weak_result_type<_Ty, void> {
        typedef typename _Ty::result_type result_type;
    };
    template <class _Ty, class  = void> struct _Weak_argument_type : _Weak_result_type<_Ty> {
    };
    template <class _Ty> struct _Weak_argument_type<_Ty, void> : _Weak_result_type<_Ty> {
        typedef typename _Ty::argument_type argument_type;
    };
    template <class _Ty, class  = void> struct _Weak_binary_args : _Weak_argument_type<_Ty> {
    };
    template <class _Ty> struct _Weak_binary_args<_Ty, void> : _Weak_argument_type<_Ty> {
        typedef typename _Ty::first_argument_type first_argument_type;
        typedef typename _Ty::second_argument_type second_argument_type;
    };
    template <class _Ty> struct _Weak_types {
        using _Is_f_or_pf = _Is_function<remove_pointer_t<_Ty> >;
        using _Is_pmf = _Is_memfunptr<remove_cv_t<_Ty> >;
        using type = conditional_t<_Is_f_or_pf::_Bool_type::value, std::_Weak_types::_Is_f_or_pf, conditional_t<_Is_pmf::_Bool_type::value, std::_Weak_types::_Is_pmf, _Weak_binary_args<_Ty> > >;
    };
    template <class _Ty> void _Refwrap_ctor_fun(_Identity_t<_Ty &>) noexcept;
    template <class _Ty> void _Refwrap_ctor_fun(_Identity_t<_Ty &&>) = delete
    struct _Unique_tag_refwrap_has_ctor_from {
    };
    template <class _Ty, class _Uty, class  = void> struct _Refwrap_has_ctor_from : std::false_type {
    };
    template <class _Ty, class _Uty> struct _Refwrap_has_ctor_from<_Ty, _Uty, void> : std::true_type {
    };
    template <class _Ty> class reference_wrapper : public _Weak_types<_Ty>::type {
    public:
        static_assert(is_object_v<_Ty> || is_function_v<_Ty>, "reference_wrapper<T> requires T to be an object type or a function type.");
        using type = _Ty;
        template <class _Uty, enable_if_t<conjunction_v<negation<is_same<remove_cv_t<remove_reference_t<_Uty> >, reference_wrapper<_Ty> > >, _Refwrap_has_ctor_from<_Ty, _Uty> >, int> = 0> reference_wrapper<_Ty>(_Uty &&_Val) noexcept(noexcept(_Refwrap_ctor_fun<_Ty>(::std::declval<_Uty>()))reference_wrapper<_Ty>(_Uty &&_Val) noexcept(noexcept(_Refwrap_ctor_fun<_Ty>(::std::declval<_Uty>())))         {
            _Ty &_Ref = ::std::forward<_Uty>(_Val);
            this->_Ptr = ::std::addressof(_Ref);
        }
        operator _Ty &() const noexcept         {
            return (*this->_Ptr);
        }
        _Ty &get() const noexcept         {
            return (*this->_Ptr);
        }
        template <class ..._Types> auto operator()(_Types &&..._Args) const -> decltype(::std::invoke(this->get(), ::std::forward<_Types>(_Args)...))         {
            return (::std::invoke(this->get(), ::std::forward<_Types>(_Args)...));
        }
    private:
        _Ty *_Ptr;
    };
    template <class _Ty> inline reference_wrapper<_Ty> ref(_Ty &_Val) noexcept     {
        return (reference_wrapper<_Ty>(_Val));
    }
    template <class _Ty> void ref(const _Ty &&) = delete
    template <class _Ty> inline reference_wrapper<_Ty> ref(reference_wrapper<_Ty> _Val) noexcept     {
        return (::std::ref(_Val.get()));
    }
    template <class _Ty> inline reference_wrapper<const _Ty> cref(const _Ty &_Val) noexcept     {
        return (reference_wrapper<const _Ty>(_Val));
    }
    template <class _Ty> void cref(const _Ty &&) = delete
    template <class _Ty> inline reference_wrapper<const _Ty> cref(reference_wrapper<_Ty> _Val) noexcept     {
        return (::std::cref(_Val.get()));
    }
    template <class _Ty> struct _Is_swappable;
    template <class _Ty> struct _Is_nothrow_swappable;
    template <class _Ty, class  = void> inline void swap(_Ty &, _Ty &) noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>swap(_Ty &, _Ty &) noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>);
    template <class _Ty, size_t _Size, class  = enable_if_t<_Is_swappable<_Ty>::value>> inline void swap(_Ty (&)[_Size], _Ty (&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::valueswap(_Ty (&)[_Size], _Ty (&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value);
    template <class _Ty1, class _Ty2, class  = void> struct _Swappable_with_helper : std::false_type {
    };
    template <class _Ty1, class _Ty2> struct _Swappable_with_helper<_Ty1, _Ty2, void> : std::true_type {
    };
    template <class _Ty1, class _Ty2> struct _Is_swappable_with : bool_constant<conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1> > > {
    };
    template <class _Ty> struct _Is_swappable : _Is_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty> >::type {
    };
    template <class _Ty1, class _Ty2> struct _Swap_cannot_throw : bool_constant<noexcept(swap(::std::declval<_Ty1>(), ::std::declval<_Ty2>())) && noexcept(swap(::std::declval<_Ty2>(), ::std::declval<_Ty1>()))> {
    };
    template <class _Ty1, class _Ty2> struct _Is_nothrow_swappable_with : bool_constant<conjunction_v<_Is_swappable_with<_Ty1, _Ty2>, _Swap_cannot_throw<_Ty1, _Ty2> > > {
    };
    template <class _Ty> struct _Is_nothrow_swappable : _Is_nothrow_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty> >::type {
    };
    namespace _Has_ADL_swap_detail {
        void swap();
        template <class , class  = void> struct _Has_ADL_swap : std::false_type {
        };
        template <class _Ty> struct _Has_ADL_swap<_Ty, void> : std::true_type {
        };
    }
    using _Has_ADL_swap_detail::_Has_ADL_swap;
    template <class _Ty> struct _Is_trivially_swappable : bool_constant<conjunction_v<is_trivially_destructible<_Ty>, is_trivially_move_constructible<_Ty>, is_trivially_move_assignable<_Ty>, negation<_Has_ADL_swap<_Ty> > > > {
    };
    template <class _Ty> constexpr bool _Is_trivially_swappable_v = _Is_trivially_swappable<_Ty>::value;
    constexpr size_t _FNV_offset_basis = 14695981039346656037ULL;
    constexpr size_t _FNV_prime = 1099511628211ULL;
    inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char *const _First, const size_t _Count) noexcept     {
        for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
            _Val ^= static_cast<size_t>(_First[_Idx]);
            _Val *= _FNV_prime;
        }
        return (_Val);
    }
    template <class _Ty> inline size_t _Fnv1a_append_range(const size_t _Val, const _Ty *const _First, const _Ty *const _Last) noexcept     {
        static_assert(is_trivial_v<_Ty>, "Only trivial types can be directly hashed.");
        const auto _Firstb = reinterpret_cast<const unsigned char *>(_First);
        const auto _Lastb = reinterpret_cast<const unsigned char *>(_Last);
        return (_Fnv1a_append_bytes(_Val, _Firstb, static_cast<size_t>(_Lastb - _Firstb)));
    }
    template <class _Kty> inline size_t _Fnv1a_append_value(const size_t _Val, const _Kty &_Keyval) noexcept     {
        static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
        return (_Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char &>(_Keyval), sizeof(_Kty)));
    }
    template<> inline size_t _Fnv1a_append_value<float>(const size_t _Val, const float &_Keyval) noexcept     {
        static_assert(is_trivial_v<float>, "Only trivial types can be directly hashed.");
        return (_Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char &>(_Keyval), sizeof(float)));
    }
    template<> inline size_t _Fnv1a_append_value<double>(const size_t _Val, const double &_Keyval) noexcept     {
        static_assert(is_trivial_v<double>, "Only trivial types can be directly hashed.");
        return (_Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char &>(_Keyval), sizeof(double)));
    }
    template<> inline size_t _Fnv1a_append_value<long double>(const size_t _Val, const long double &_Keyval) noexcept     {
        static_assert(is_trivial_v<long double>, "Only trivial types can be directly hashed.");
        return (_Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char &>(_Keyval), sizeof(long double)));
    }
    template<> inline size_t _Fnv1a_append_value<void *>(const size_t _Val, void *const &_Keyval) noexcept     {
        static_assert(is_trivial_v<void *>, "Only trivial types can be directly hashed.");
        return (_Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char &>(_Keyval), sizeof(void *)));
    }
    template <class _Kty> inline size_t _Hash_representation(const _Kty &_Keyval) noexcept     {
        return (_Fnv1a_append_value(_FNV_offset_basis, _Keyval));
    }
    template<> inline size_t _Hash_representation<float>(const float &_Keyval) noexcept     {
        return (_Fnv1a_append_value(_FNV_offset_basis, _Keyval));
    }
    template<> inline size_t _Hash_representation<double>(const double &_Keyval) noexcept     {
        return (_Fnv1a_append_value(_FNV_offset_basis, _Keyval));
    }
    template<> inline size_t _Hash_representation<long double>(const long double &_Keyval) noexcept     {
        return (_Fnv1a_append_value(_FNV_offset_basis, _Keyval));
    }
    template<> inline size_t _Hash_representation<void *>(void *const &_Keyval) noexcept     {
        return (_Fnv1a_append_value(_FNV_offset_basis, _Keyval));
    }
    template <class _Kty> inline size_t _Hash_array_representation(const _Kty *const _First, const size_t _Count) noexcept     {
        static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
        return (_Fnv1a_append_bytes(_FNV_offset_basis, reinterpret_cast<const unsigned char *>(_First), _Count * sizeof(_Kty)));
    }
    template <class _Kty> struct hash;
    template <class _Kty, bool _Enabled> struct _Conditionally_enabled_hash {
        typedef _Kty argument_type;
        typedef size_t result_type;
        size_t operator()(const _Kty &_Keyval) const noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval))operator()(const _Kty &_Keyval) const noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval)))         {
            return (hash<_Kty>::_Do_hash(_Keyval));
        }
    };
    template <class _Kty> struct _Conditionally_enabled_hash<_Kty, false> {
        _Conditionally_enabled_hash<type-parameter-0-0, false>() = delete
        _Conditionally_enabled_hash<type-parameter-0-0, false>(const _Conditionally_enabled_hash<type-parameter-0-0, false> &) = delete
        _Conditionally_enabled_hash<type-parameter-0-0, false>(_Conditionally_enabled_hash<type-parameter-0-0, false> &&) = delete
        _Conditionally_enabled_hash<type-parameter-0-0, false> &operator=(const _Conditionally_enabled_hash<type-parameter-0-0, false> &) = delete
        _Conditionally_enabled_hash<type-parameter-0-0, false> &operator=(_Conditionally_enabled_hash<type-parameter-0-0, false> &&) = delete
    };
    template <class _Kty> struct hash : _Conditionally_enabled_hash<_Kty, !is_const_v<_Kty> && !is_volatile_v<_Kty> && (is_enum_v<_Kty> || is_integral_v<_Kty> || is_pointer_v<_Kty>)> {
        static size_t _Do_hash(const _Kty &_Keyval) noexcept         {
            return (_Hash_representation(_Keyval));
        }
    };
    template<> struct hash<float> {
        typedef float argument_type;
        typedef size_t result_type;
        size_t operator()(const float _Keyval) const noexcept         {
            return (_Hash_representation(_Keyval == 0.F ? 0.F : _Keyval));
        }
    };
    template<> struct hash<double> {
        typedef double argument_type;
        typedef size_t result_type;
        size_t operator()(const double _Keyval) const noexcept         {
            return (_Hash_representation(_Keyval == 0. ? 0. : _Keyval));
        }
    };
    template<> struct hash<long double> {
        typedef long double argument_type;
        typedef size_t result_type;
        size_t operator()(const long double _Keyval) const noexcept         {
            return (_Hash_representation(_Keyval == 0.L ? 0.L : _Keyval));
        }
    };
    template<> struct hash<nullptr_t> {
        typedef std::nullptr_t argument_type;
        typedef size_t result_type;
        size_t operator()(std::nullptr_t) const noexcept         {
            void *_Null{};
            return (_Hash_representation(_Null));
        }
    };
    template <class _Kty, class  = void> struct _Is_nothrow_hashable : std::false_type {
    };
    template <class _Kty> struct _Is_nothrow_hashable<_Kty, void> : bool_constant<noexcept(hash<_Kty>({})(::std::declval<const _Kty &>()))> {
    };
    namespace tr1 {
        using ::std::add_const;
        using ::std::add_cv;
        using ::std::add_pointer;
        using ::std::add_volatile;
        using ::std::aligned_storage;
        using ::std::alignment_of;
        using ::std::conditional;
        using ::std::decay;
        using ::std::enable_if;
        using ::std::extent;
        using ::std::false_type;
        using ::std::has_virtual_destructor;
        using ::std::integral_constant;
        using ::std::is_abstract;
        using ::std::is_arithmetic;
        using ::std::is_array;
        using ::std::is_base_of;
        using ::std::is_class;
        using ::std::is_compound;
        using ::std::is_const;
        using ::std::is_convertible;
        using ::std::is_empty;
        using ::std::is_enum;
        using ::std::is_floating_point;
        using ::std::is_function;
        using ::std::is_fundamental;
        using ::std::is_integral;
        using ::std::is_member_function_pointer;
        using ::std::is_member_object_pointer;
        using ::std::is_member_pointer;
        using ::std::is_object;
        using ::std::is_pod;
        using ::std::is_pointer;
        using ::std::is_polymorphic;
        using ::std::is_reference;
        using ::std::is_same;
        using ::std::is_scalar;
        using ::std::is_signed;
        using ::std::is_union;
        using ::std::is_unsigned;
        using ::std::is_void;
        using ::std::is_volatile;
        using ::std::make_signed;
        using ::std::make_unsigned;
        using ::std::rank;
        using ::std::remove_all_extents;
        using ::std::remove_const;
        using ::std::remove_cv;
        using ::std::remove_extent;
        using ::std::remove_pointer;
        using ::std::remove_reference;
        using ::std::remove_volatile;
        using ::std::true_type;
        using ::std::cref;
        using ::std::ref;
        using ::std::reference_wrapper;
        using ::std::result_of;
        using ::std::hash;
    }
    struct _Invoker_pmf_object {
        template <class _Decayed, class _Ty1, class ..._Types2> static inline auto _Call(_Decayed _Pmf, _Ty1 &&_Arg1, _Types2 &&..._Args2) noexcept(noexcept((::std::forward<_Ty1>(_Arg1) .* _Pmf)(::std::forward<_Types2>(_Args2)...))_Call(_Decayed _Pmf, _Ty1 &&_Arg1, _Types2 &&..._Args2) noexcept(noexcept((::std::forward<_Ty1>(_Arg1) .* _Pmf)(::std::forward<_Types2>(_Args2)...))) -> decltype((::std::forward<_Ty1>(_Arg1) .* _Pmf)(::std::forward<_Types2>(_Args2)...))         {
            return ((::std::forward<_Ty1>(_Arg1) .* _Pmf)(::std::forward<_Types2>(_Args2)...));
        }
    };
    struct _Invoker_pmf_refwrap {
        template <class _Decayed, class _Ty1, class ..._Types2> static inline auto _Call(_Decayed _Pmf, _Ty1 &&_Arg1, _Types2 &&..._Args2) noexcept(noexcept((::std::forward<_Ty1>(_Arg1).get() .* _Pmf)(::std::forward<_Types2>(_Args2)...))_Call(_Decayed _Pmf, _Ty1 &&_Arg1, _Types2 &&..._Args2) noexcept(noexcept((::std::forward<_Ty1>(_Arg1).get() .* _Pmf)(::std::forward<_Types2>(_Args2)...))) -> decltype((::std::forward<_Ty1>(_Arg1).get() .* _Pmf)(::std::forward<_Types2>(_Args2)...))         {
            return ((::std::forward<_Ty1>(_Arg1).get() .* _Pmf)(::std::forward<_Types2>(_Args2)...));
        }
    };
    struct _Invoker_pmf_pointer {
        template <class _Decayed, class _Ty1, class ..._Types2> static inline auto _Call(_Decayed _Pmf, _Ty1 &&_Arg1, _Types2 &&..._Args2) noexcept(noexcept(((*::std::forward<_Ty1>(_Arg1)) .* _Pmf)(::std::forward<_Types2>(_Args2)...))_Call(_Decayed _Pmf, _Ty1 &&_Arg1, _Types2 &&..._Args2) noexcept(noexcept(((*::std::forward<_Ty1>(_Arg1)) .* _Pmf)(::std::forward<_Types2>(_Args2)...))) -> decltype(((*::std::forward<_Ty1>(_Arg1)) .* _Pmf)(::std::forward<_Types2>(_Args2)...))         {
            return (((*::std::forward<_Ty1>(_Arg1)) .* _Pmf)(::std::forward<_Types2>(_Args2)...));
        }
    };
    struct _Invoker_pmd_object {
        template <class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1 &&_Arg1) noexcept(noexcept(::std::forward<_Ty1>(_Arg1) .* _Pmd)_Call(_Decayed _Pmd, _Ty1 &&_Arg1) noexcept(noexcept(::std::forward<_Ty1>(_Arg1) .* _Pmd)) -> decltype(::std::forward<_Ty1>(_Arg1) .* _Pmd)         {
            return (::std::forward<_Ty1>(_Arg1) .* _Pmd);
        }
    };
    struct _Invoker_pmd_refwrap {
        template <class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1 &&_Arg1) noexcept(noexcept(::std::forward<_Ty1>(_Arg1).get() .* _Pmd)_Call(_Decayed _Pmd, _Ty1 &&_Arg1) noexcept(noexcept(::std::forward<_Ty1>(_Arg1).get() .* _Pmd)) -> decltype(::std::forward<_Ty1>(_Arg1).get() .* _Pmd)         {
            return (::std::forward<_Ty1>(_Arg1).get() .* _Pmd);
        }
    };
    struct _Invoker_pmd_pointer {
        template <class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1 &&_Arg1) noexcept(noexcept((*::std::forward<_Ty1>(_Arg1)) .* _Pmd)_Call(_Decayed _Pmd, _Ty1 &&_Arg1) noexcept(noexcept((*::std::forward<_Ty1>(_Arg1)) .* _Pmd)) -> decltype((*::std::forward<_Ty1>(_Arg1)) .* _Pmd)         {
            return ((*::std::forward<_Ty1>(_Arg1)) .* _Pmd);
        }
    };
    struct _Invoker_functor {
        template <class _Callable, class ..._Types> static inline auto _Call(_Callable &&_Obj, _Types &&..._Args) noexcept(noexcept(::std::forward<_Callable>(_Obj)(::std::forward<_Types>(_Args)...))_Call(_Callable &&_Obj, _Types &&..._Args) noexcept(noexcept(::std::forward<_Callable>(_Obj)(::std::forward<_Types>(_Args)...))) -> decltype(::std::forward<_Callable>(_Obj)(::std::forward<_Types>(_Args)...))         {
            return (::std::forward<_Callable>(_Obj)(::std::forward<_Types>(_Args)...));
        }
    };
    template <class _Callable, class _Ty1, class _Removed_cvref = remove_cv_t<remove_reference_t<_Callable> >, bool _Is_pmf = is_member_function_pointer_v<_Removed_cvref>, bool _Is_pmd = is_member_object_pointer_v<_Removed_cvref>> struct _Invoker1;
    template <class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, true, false> : conditional_t<is_base_of_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1> >, std::_Invoker_pmf_object, conditional_t<_Is_specialization_v<remove_cv_t<remove_reference_t<_Ty1> >, reference_wrapper>, std::_Invoker_pmf_refwrap, std::_Invoker_pmf_pointer> > {
    };
    template <class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, true> : conditional_t<is_base_of_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1> >, std::_Invoker_pmd_object, conditional_t<_Is_specialization_v<remove_cv_t<remove_reference_t<_Ty1> >, reference_wrapper>, std::_Invoker_pmd_refwrap, std::_Invoker_pmd_pointer> > {
    };
    template <class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : std::_Invoker_functor {
    };
    template <class _Callable, class ..._Types> struct _Invoker;
    template <class _Callable> struct _Invoker<_Callable, <>> : std::_Invoker_functor {
    };
    template <class _Callable, class _Ty1, class ..._Types2> struct _Invoker<_Callable, <type-parameter-0-1, type-parameter-0-2...>> : _Invoker1<_Callable, _Ty1> {
    };
    template <class _Callable, class ..._Types> inline auto invoke(_Callable &&_Obj, _Types &&..._Args) noexcept(noexcept(_Invoker<_Callable, _Types...>::_Call(::std::forward<_Callable>(_Obj), ::std::forward<_Types>(_Args)...))invoke(_Callable &&_Obj, _Types &&..._Args) noexcept(noexcept(_Invoker<_Callable, _Types...>::_Call(::std::forward<_Callable>(_Obj), ::std::forward<_Types>(_Args)...))) -> decltype(_Invoker<_Callable, _Types...>::_Call(::std::forward<_Callable>(_Obj), ::std::forward<_Types>(_Args)...))     {
        return (_Invoker<_Callable, _Types...>::_Call(::std::forward<_Callable>(_Obj), ::std::forward<_Types>(_Args)...));
    }
    template <class _Rx, bool = is_void_v<_Rx>> struct _Invoker_ret {
    };
    template <class _Cv_void> struct _Invoker_ret<_Cv_void, true> {
        template <class ..._Valtys> static void _Call(_Valtys &&..._Vals)         {
            ::std::invoke(::std::forward<_Valtys>(_Vals)...);
        }
    };
    template <class _Rx> struct _Invoker_ret<_Rx, false> {
        template <class ..._Valtys> static _Rx _Call(_Valtys &&..._Vals)         {
            return (::std::invoke(::std::forward<_Valtys>(_Vals)...));
        }
    };
    template<> struct _Invoker_ret<std::_Unforced, false> {
        template <class ..._Valtys> static auto _Call(_Valtys &&..._Vals) -> decltype(::std::invoke(::std::forward<_Valtys>(_Vals)...))         {
            return (::std::invoke(::std::forward<_Valtys>(_Vals)...));
        }
    };
    constexpr bool is_empty_v = __is_empty(std::_Container_base0);
    constexpr bool is_const_v = is_const<char>::value;
    constexpr bool is_empty_v = __is_empty(std::allocator<char>);
    constexpr bool is_final_v = __is_final(std::allocator<char>);
    constexpr bool _Is_specialization_v = true;
    constexpr bool is_trivial_v = __is_trivial(char *);
    constexpr bool is_empty_v = __is_empty(std::default_delete<v8::internal::ScriptStreamingData>);
    constexpr bool is_final_v = __is_final(std::default_delete<v8::internal::ScriptStreamingData>);
    constexpr bool is_reference_v = is_reference<default_delete<ScriptStreamingData> >::value;
    constexpr bool is_convertible_v = __is_convertible_to(v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *);
    constexpr bool conjunction_v = conjunction<negation<is_pointer<default_delete<ScriptStreamingData> > >, is_default_constructible<default_delete<ScriptStreamingData> > >::value;
    constexpr bool conjunction_v = conjunction<negation<is_array<ScriptStreamingData> >, is_convertible<ScriptStreamingData *, ScriptStreamingData *>, is_convertible<default_delete<ScriptStreamingData>, default_delete<ScriptStreamingData> > >::value;
    constexpr bool conjunction_v = conjunction<negation<is_array<ScriptStreamingData> >, is_assignable<default_delete<ScriptStreamingData> &, default_delete<ScriptStreamingData> >, is_convertible<ScriptStreamingData *, ScriptStreamingData *> >::value;
    constexpr bool is_empty_v = __is_empty(std::default_delete<unsigned char const[]>);
    constexpr bool is_final_v = __is_final(std::default_delete<unsigned char const[]>);
    constexpr bool is_reference_v = is_reference<default_delete<unsigned char const[]> >::value;
    constexpr bool is_convertible_v = __is_convertible_to(unsigned char const (*)[], unsigned char const (*)[]);
    constexpr bool conjunction_v = conjunction<negation<is_pointer<default_delete<unsigned char const[]> > >, is_default_constructible<default_delete<unsigned char const[]> > >::value;
    constexpr bool is_pointer_v = is_pointer<unique_ptr<unsigned char const[], default_delete<unsigned char const[]> > >::value;
    constexpr bool is_convertible_v = __is_convertible_to(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > (*)[], unsigned char const (*)[]);
    constexpr bool conjunction_v = conjunction<is_array<unsigned char const[]>, is_same<const unsigned char *, const unsigned char *>, is_same<const unsigned char *, const unsigned char *>, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_convertible<default_delete<unsigned char const[]>, default_delete<unsigned char const[]> > >::value;
    constexpr bool conjunction_v = conjunction<is_array<unsigned char const[]>, is_same<const unsigned char *, const unsigned char *>, is_same<const unsigned char *, const unsigned char *>, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_assignable<default_delete<unsigned char const[]> &, default_delete<unsigned char const[]> > >::value;
    constexpr bool is_array_v = is_array<NativeModule>::value;
    constexpr bool is_empty_v = __is_empty(std::default_delete<v8::WasmStreaming::WasmStreamingImpl>);
    constexpr bool is_final_v = __is_final(std::default_delete<v8::WasmStreaming::WasmStreamingImpl>);
    constexpr bool is_reference_v = is_reference<default_delete<WasmStreamingImpl> >::value;
    constexpr bool is_convertible_v = __is_convertible_to(v8::WasmStreaming::WasmStreamingImpl *, v8::WasmStreaming::WasmStreamingImpl *);
    constexpr bool conjunction_v = conjunction<negation<is_pointer<default_delete<WasmStreamingImpl> > >, is_default_constructible<default_delete<WasmStreamingImpl> > >::value;
    constexpr bool conjunction_v = conjunction<negation<is_array<WasmStreamingImpl> >, is_convertible<WasmStreamingImpl *, WasmStreamingImpl *>, is_convertible<default_delete<WasmStreamingImpl>, default_delete<WasmStreamingImpl> > >::value;
    constexpr bool is_array_v = is_array<StreamingDecoder>::value;
    constexpr bool is_trivial_v = __is_trivial(float);
    constexpr bool is_trivial_v = __is_trivial(double);
    constexpr bool is_trivial_v = __is_trivial(long double);
    constexpr bool is_trivial_v = __is_trivial(void *);
}
namespace std {
    bool uncaught_exception() noexcept;
    int uncaught_exceptions() noexcept;
}
extern "C" {
    typedef struct _heapinfo {
        int *_pentry;
        size_t _size;
        int _useflag;
    } _HEAPINFO;
    void *_alloca(size_t _Size) throw();
    intptr_t _get_heap_handle();
    int _heapmin();
    int _heapwalk(_HEAPINFO *_EntryInfo);
    int _heapchk();
    int _resetstkoflw();
    typedef char __static_assert_t[1];
    inline void *_MarkAllocaS(void *_Ptr, unsigned int _Marker)     {
        if (_Ptr) {
            *((unsigned int *)_Ptr) = _Marker;
            _Ptr = (char *)_Ptr + 16;
        }
        return _Ptr;
    }
    inline size_t _MallocaComputeSize(size_t _Size)     {
        size_t _MarkedSize = _Size + 16;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }
    inline void _freea(void *_Memory)     {
        unsigned int _Marker;
        if (_Memory) {
            _Memory = (char *)_Memory - 16;
            _Marker = *(unsigned int *)_Memory;
            if (_Marker == 56797) {
                free(_Memory);
            } else if (_Marker != 52428) {
                ((void)0);
            }
        }
    }
}
extern "C" {
    typedef void (*terminate_handler)() __attribute__((cdecl));
    typedef void (*terminate_function)() __attribute__((cdecl));
    void abort();
    void terminate() throw();
    terminate_handler set_terminate(terminate_handler _NewTerminateHandler) throw();
    terminate_handler _get_terminate();
}
extern "C" {
    typedef void (*unexpected_handler)() __attribute__((cdecl));
    typedef void (*unexpected_function)() __attribute__((cdecl));
    struct _EXCEPTION_POINTERS;
    void unexpected() noexcept(falseunexpected() noexcept(false);
    unexpected_handler set_unexpected(unexpected_handler _NewUnexpectedHandler) noexcept;
    unexpected_handler _get_unexpected() noexcept;
    typedef void (*_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS *) __attribute__((cdecl));
    _se_translator_function _set_se_translator(_se_translator_function _NewSETranslator);
    class type_info;
    int _is_exception_typeof(const type_info &_Type, _EXCEPTION_POINTERS *_ExceptionPtr);
    bool __uncaught_exception();
    int __uncaught_exceptions();
}
extern "C" {
    struct __std_exception_data {
        const char *_What;
        bool _DoFree;
    };
    void __std_exception_copy(const __std_exception_data *_From, __std_exception_data *_To);
    void __std_exception_destroy(__std_exception_data *_Data);
}
namespace std {
    class exception {
    public:
        exception() noexcept : _Data()         {
        }
        explicit exception(const char *const _Message) noexcept : _Data()         {
            __std_exception_data _InitData = {_Message, true};
            __std_exception_copy(&_InitData, &this->_Data);
        }
        exception(const char *const _Message, int) noexcept : _Data()         {
            this->_Data._What = _Message;
        }
        exception(const std::exception &_Other) noexcept : _Data()         {
            __std_exception_copy(&_Other._Data, &this->_Data);
        }
        std::exception &operator=(const std::exception &_Other) noexcept         {
            if (this == &_Other) {
                return *this;
            }
            __std_exception_destroy(&this->_Data);
            __std_exception_copy(&_Other._Data, &this->_Data);
            return *this;
        }
        virtual ~exception() noexcept         {
            __std_exception_destroy(&this->_Data);
        }
        virtual const char *what() const         {
            return this->_Data._What ? this->_Data._What : "Unknown exception";
        }
    private:
        __std_exception_data _Data;
    };
    class bad_exception : public std::exception {
    public:
        bad_exception() noexcept : std::exception("bad exception", 1)         {
        }
    };
    class bad_alloc : public std::exception {
    public:
        bad_alloc() noexcept : std::exception("bad allocation", 1)         {
        }
    private:
        friend  class bad_array_new_length;
        bad_alloc(const char *const _Message) noexcept : std::exception(_Message, 1)         {
        }
    };
    class bad_array_new_length : public std::bad_alloc {
    public:
        bad_array_new_length() noexcept : std::bad_alloc("bad array new length")         {
        }
    };
}
namespace std {
    using ::terminate;
    using ::set_terminate;
    using ::terminate_handler;
    inline terminate_handler get_terminate() noexcept     {
        return (_get_terminate());
    }
    using ::unexpected;
    using ::set_unexpected;
    using ::unexpected_handler;
    inline unexpected_handler get_unexpected() noexcept     {
        return (_get_unexpected());
    }
}
void __ExceptionPtrCreate(void *);
void __ExceptionPtrDestroy(void *);
void __ExceptionPtrCopy(void *, const void *);
void __ExceptionPtrAssign(void *, const void *);
bool __ExceptionPtrCompare(const void *, const void *);
bool __ExceptionPtrToBool(const void *);
void __ExceptionPtrSwap(void *, void *);
void __ExceptionPtrCurrentException(void *);
void __ExceptionPtrRethrow(const void *) [[noreturn]];
void __ExceptionPtrCopyException(void *, const void *, const void *);
namespace std {
    class exception_ptr {
    public:
        exception_ptr() noexcept         {
            __ExceptionPtrCreate(this);
        }
        exception_ptr(std::nullptr_t) noexcept         {
            __ExceptionPtrCreate(this);
        }
        ~exception_ptr() noexcept         {
            __ExceptionPtrDestroy(this);
        }
        exception_ptr(const std::exception_ptr &_Rhs) noexcept         {
            __ExceptionPtrCopy(this, &_Rhs);
        }
        std::exception_ptr &operator=(const std::exception_ptr &_Rhs) noexcept         {
            __ExceptionPtrAssign(this, &_Rhs);
            return *this;
        }
        std::exception_ptr &operator=(std::nullptr_t) noexcept         {
            std::exception_ptr _Ptr;
            __ExceptionPtrAssign(this, &_Ptr);
            return *this;
        }
        explicit operator bool() const noexcept         {
            return __ExceptionPtrToBool(this);
        }
        void _RethrowException() const [[noreturn]]         {
            __ExceptionPtrRethrow(this);
        }
        static std::exception_ptr _Current_exception() noexcept         {
            std::exception_ptr _Retval;
            __ExceptionPtrCurrentException(&_Retval);
            return _Retval;
        }
        static std::exception_ptr _Copy_exception(void *_Except, const void *_Ptr)         {
            std::exception_ptr _Retval;
            if (!_Ptr) {
                return _Retval;
            }
            __ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
            return _Retval;
        }
    private:
        void *_Data1;
        void *_Data2;
    };
    inline void swap(std::exception_ptr &_Lhs, std::exception_ptr &_Rhs) noexcept     {
        __ExceptionPtrSwap(&_Lhs, &_Rhs);
    }
    inline bool operator==(const std::exception_ptr &_Lhs, const std::exception_ptr &_Rhs) noexcept     {
        return __ExceptionPtrCompare(&_Lhs, &_Rhs);
    }
    inline bool operator==(std::nullptr_t, const std::exception_ptr &_Rhs) noexcept     {
        return !_Rhs;
    }
    inline bool operator==(const std::exception_ptr &_Lhs, std::nullptr_t) noexcept     {
        return !_Lhs;
    }
    inline bool operator!=(const std::exception_ptr &_Lhs, const std::exception_ptr &_Rhs) noexcept     {
        return !(_Lhs == _Rhs);
    }
    inline bool operator!=(std::nullptr_t _Lhs, const std::exception_ptr &_Rhs) noexcept     {
        return !(_Lhs == _Rhs);
    }
    inline bool operator!=(const std::exception_ptr &_Lhs, std::nullptr_t _Rhs) noexcept     {
        return !(_Lhs == _Rhs);
    }
    inline std::exception_ptr current_exception() noexcept     {
        return exception_ptr::_Current_exception();
    }
    inline void rethrow_exception(std::exception_ptr _Ptr) [[noreturn]]     {
        _Ptr._RethrowException();
    }
    template <class _Ex> void *__GetExceptionInfo(_Ex);
    template <class _Ex> std::exception_ptr make_exception_ptr(_Ex _Except) noexcept     {
        return exception_ptr::_Copy_exception(::std::addressof(_Except), __GetExceptionInfo(_Except));
    }
    class nested_exception {
    public:
        nested_exception() noexcept : _Exc(::std::current_exception())         {
        }
        nested_exception(const std::nested_exception &) = default
        std::nested_exception &operator=(const std::nested_exception &) = default
        virtual ~nested_exception() noexcept         {
        }
        void rethrow_nested() const [[noreturn]]         {
            if (this->_Exc)
                ::std::rethrow_exception(this->_Exc);
            else
                ::std::terminate();
        }
        std::exception_ptr nested_ptr() const noexcept         {
            return (this->_Exc);
        }
    private:
        std::exception_ptr _Exc;
    };
    template <class _Ty, class _Uty> struct _With_nested : _Uty, std::nested_exception {
        explicit _With_nested<_Ty, _Uty>(_Ty &&_Arg) : _Uty(::std::forward<_Ty>(_Arg)), std::nested_exception()         {
        }
    };
    template <class _Ty> inline void _Throw_with_nested(_Ty &&_Arg, std::true_type) [[noreturn]]     {
        using _Uty = decay_t<_Ty>;
        using _Glued = _With_nested<_Ty, _Uty>;
        throw _Glued(::std::forward<_Ty>(_Arg));
    }
    template <class _Ty> inline void _Throw_with_nested(_Ty &&_Arg, std::false_type) [[noreturn]]     {
        throw ::std::forward<_Ty>(_Arg);
    }
    template <class _Ty> inline void throw_with_nested(_Ty &&_Arg) [[noreturn]]     {
        typedef decay_t<_Ty> _Uty;
        bool_constant<is_class_v<_Uty> && !is_base_of_v<std::nested_exception, _Uty> && !is_final_v<_Uty> > _Tag;
        _Throw_with_nested(::std::forward<_Ty>(_Arg), _Tag);
    }
    template <class _Ty> inline void _Rethrow_if_nested(const _Ty *_Ptr, std::true_type)     {
        const auto _Nested = dynamic_cast<const std::nested_exception *>(_Ptr);
        if (_Nested)
            _Nested->rethrow_nested();
    }
    template <class _Ty> inline void _Rethrow_if_nested(const _Ty *, std::false_type)     {
    }
    template <class _Ty> inline void rethrow_if_nested(const _Ty &_Arg)     {
        bool_constant<is_polymorphic_v<_Ty> && (!is_base_of_v<std::nested_exception, _Ty> || is_convertible_v<_Ty *, std::nested_exception *>)> _Tag;
        _Rethrow_if_nested(::std::addressof(_Arg), _Tag);
    }
}
namespace std {
    typedef void (*new_handler)() __attribute__((cdecl));
    std::new_handler set_new_handler(std::new_handler) noexcept;
    std::new_handler get_new_handler() noexcept;
}
namespace std {
    using ::FILE;
    using ::_Mbstatet;
    using ::size_t;
    using ::fpos_t;
    using ::FILE;
    using ::clearerr;
    using ::fclose;
    using ::feof;
    using ::ferror;
    using ::fflush;
    using ::fgetc;
    using ::fgetpos;
    using ::fgets;
    using ::fopen;
    using ::fprintf;
    using ::fputc;
    using ::fputs;
    using ::fread;
    using ::freopen;
    using ::fscanf;
    using ::fseek;
    using ::fsetpos;
    using ::ftell;
    using ::fwrite;
    using ::getc;
    using ::getchar;
    using ::perror;
    using ::putc;
    using ::putchar;
    using ::printf;
    using ::puts;
    using ::remove;
    using ::rename;
    using ::rewind;
    using ::scanf;
    using ::setbuf;
    using ::setvbuf;
    using ::sprintf;
    using ::sscanf;
    using ::tmpfile;
    using ::tmpnam;
    using ::ungetc;
    using ::vfprintf;
    using ::vprintf;
    using ::vsprintf;
    using ::snprintf;
    using ::vsnprintf;
    using ::vfscanf;
    using ::vscanf;
    using ::vsscanf;
}
extern "C" {
    int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size);
    int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale);
    void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _memccpy. See online help for details."));
    int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _memicmp. See online help for details."));
    extern "C++" inline void *memchr(void *_Pv, int _C, size_t _N)     {
        const void *const _Pvc = _Pv;
        return const_cast<void *>(memchr(_Pvc, _C, _N));
    }

}
extern "C" {
    errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source);
    errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source);
    errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber);
    errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount);
    errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount);
    char *strtok_s(char *_String, const char *_Delimiter, char **_Context);
    void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount);
    extern "C++" {
        template <size_t _Size> inline errno_t strcat_s(char (&_Destination)[_Size], const char *_Source) throw()         {
            return strcat_s(_Destination, _Size, _Source);
        }
    }
    char *strcat(char *_Destination, const char *_Source) __declspec(deprecated("This function or variable may be unsafe. Consider using strcat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int strcmp(const char *_Str1, const char *_Str2);
    int _strcmpi(const char *_String1, const char *_String2);
    int strcoll(const char *_String1, const char *_String2);
    int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale);
    extern "C++" {
        template <size_t _Size> inline errno_t strcpy_s(char (&_Destination)[_Size], const char *_Source) throw()         {
            return strcpy_s(_Destination, _Size, _Source);
        }
    }
    char *strcpy(char *_Destination, const char *_Source) __declspec(deprecated("This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    size_t strcspn(const char *_Str, const char *_Control);
    char *_strdup(const char *_Source);
    char *_strerror(const char *_ErrorMessage) __declspec(deprecated("This function or variable may be unsafe. Consider using _strerror_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage);
    extern "C++" {
        template <size_t _Size> inline errno_t _strerror_s(char (&_Buffer)[_Size], const char *_ErrorMessage) throw()         {
            return _strerror_s(_Buffer, _Size, _ErrorMessage);
        }
    }
    char *strerror(int _ErrorMessage) __declspec(deprecated("This function or variable may be unsafe. Consider using strerror_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    extern "C++" {
        template <size_t _Size> inline errno_t strerror_s(char (&_Buffer)[_Size], int _ErrorMessage) throw()         {
            return strerror_s(_Buffer, _Size, _ErrorMessage);
        }
    }
    int _stricmp(const char *_String1, const char *_String2);
    int _stricoll(const char *_String1, const char *_String2);
    int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale);
    int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale);
    size_t strlen(const char *_Str);
    errno_t _strlwr_s(char *_String, size_t _Size);
    extern "C++" {
        template <size_t _Size> inline errno_t _strlwr_s(char (&_String)[_Size]) throw()         {
            return _strlwr_s(_String, _Size);
        }
    }
    char *_strlwr(char *_String) __declspec(deprecated("This function or variable may be unsafe. Consider using _strlwr_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale);
    extern "C++" {
        template <size_t _Size> inline errno_t _strlwr_s_l(char (&_String)[_Size], _locale_t _Locale) throw()         {
            return _strlwr_s_l(_String, _Size, _Locale);
        }
    }
    char *_strlwr_l(char *_String, _locale_t _Locale) __declspec(deprecated("This function or variable may be unsafe. Consider using _strlwr_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    extern "C++" {
        template <size_t _Size> inline errno_t strncat_s(char (&_Destination)[_Size], const char *_Source, size_t _Count) throw()         {
            return strncat_s(_Destination, _Size, _Source, _Count);
        }
    }
    char *strncat(char *_Destination, const char *_Source, size_t _Count) __declspec(deprecated("This function or variable may be unsafe. Consider using strncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount);
    int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount);
    int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale);
    int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount);
    int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale);
    int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount);
    int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale);
    size_t __strncnt(const char *_String, size_t _Count);
    extern "C++" {
        template <size_t _Size> inline errno_t strncpy_s(char (&_Destination)[_Size], const char *_Source, size_t _Count) throw()         {
            return strncpy_s(_Destination, _Size, _Source, _Count);
        }
    }
    char *strncpy(char *_Destination, const char *_Source, size_t _Count) __declspec(deprecated("This function or variable may be unsafe. Consider using strncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    size_t strnlen(const char *_String, size_t _MaxCount);
    static inline size_t strnlen_s(const char *_String, size_t _MaxCount)     {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }
    errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount);
    extern "C++" {
        template <size_t _Size> inline errno_t _strnset_s(char (&_Destination)[_Size], int _Value, size_t _Count) throw()         {
            return _strnset_s(_Destination, _Size, _Value, _Count);
        }
    }
    char *_strnset(char *_Destination, int _Value, size_t _Count) __declspec(deprecated("This function or variable may be unsafe. Consider using _strnset_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    const char *strpbrk(const char *_Str, const char *_Control);
    char *_strrev(char *_Str);
    errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value);
    extern "C++" {
        template <size_t _Size> inline errno_t _strset_s(char (&_Destination)[_Size], int _Value) throw()         {
            return _strset_s(_Destination, _Size, _Value);
        }
    }
    char *_strset(char *_Destination, int _Value) __declspec(deprecated("This function or variable may be unsafe. Consider using _strset_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    size_t strspn(const char *_Str, const char *_Control);
    char *strtok(char *_String, const char *_Delimiter) __declspec(deprecated("This function or variable may be unsafe. Consider using strtok_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _strupr_s(char *_String, size_t _Size);
    extern "C++" {
        template <size_t _Size> inline errno_t _strupr_s(char (&_String)[_Size]) throw()         {
            return _strupr_s(_String, _Size);
        }
    }
    char *_strupr(char *_String) __declspec(deprecated("This function or variable may be unsafe. Consider using _strupr_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale);
    extern "C++" {
        template <size_t _Size> inline errno_t _strupr_s_l(char (&_String)[_Size], _locale_t _Locale) throw()         {
            return _strupr_s_l(_String, _Size, _Locale);
        }
    }
    char *_strupr_l(char *_String, _locale_t _Locale) __declspec(deprecated("This function or variable may be unsafe. Consider using _strupr_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    size_t strxfrm(char *_Destination, const char *_Source, size_t _MaxCount);
    size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale);
    extern "C++" {
        inline char *strchr(char *const _String, const int _Ch)         {
            return const_cast<char *>(strchr(static_cast<const char *>(_String), _Ch));
        }
        inline char *strpbrk(char *const _String, const char *const _Control)         {
            return const_cast<char *>(strpbrk(static_cast<const char *>(_String), _Control));
        }
        inline char *strrchr(char *const _String, const int _Ch)         {
            return const_cast<char *>(strrchr(static_cast<const char *>(_String), _Ch));
        }
        inline char *strstr(char *const _String, const char *const _SubString)         {
            return const_cast<char *>(strstr(static_cast<const char *>(_String), _SubString));
        }
    }
    char *strdup(const char *_String) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _strdup. See online help for details."));
    int strcmpi(const char *_String1, const char *_String2) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _strcmpi. See online help for details."));
    int stricmp(const char *_String1, const char *_String2) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _stricmp. See online help for details."));
    char *strlwr(char *_String) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _strlwr. See online help for details."));
    int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _strnicmp. See online help for details."));
    char *strnset(char *_String, int _Value, size_t _MaxCount) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _strnset. See online help for details."));
    char *strrev(char *_String) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _strrev. See online help for details."));
    char *strset(char *_String, int _Value) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _strset. See online help for details."));
    char *strupr(char *_String) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _strupr. See online help for details."));
}
namespace std {
    using ::size_t;
    using ::memchr;
    using ::memcmp;
    using ::memcpy;
    using ::memmove;
    using ::memset;
    using ::strcat;
    using ::strchr;
    using ::strcmp;
    using ::strcoll;
    using ::strcpy;
    using ::strcspn;
    using ::strerror;
    using ::strlen;
    using ::strncat;
    using ::strncmp;
    using ::strncpy;
    using ::strpbrk;
    using ::strrchr;
    using ::strspn;
    using ::strstr;
    using ::strtok;
    using ::strxfrm;
}
namespace std {
    using streamoff = long long;
    using streamsize = long long;
    template <class _Statetype> class fpos {
    public:
        fpos<_Statetype>(std::streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate()         {
        }
        fpos<_Statetype>(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State)         {
        }
        _Statetype state() const         {
            return (this->_Mystate);
        }
        void state(_Statetype _State)         {
            this->_Mystate = _State;
        }
        operator streamoff() const         {
            return (this->_Myoff + this->_Fpos);
        }
        fpos_t seekpos() const noexcept [[deprecated("warning STL4019: The member std::fpos::seekpos() is non-Standard, and is preserved only for compatibility with workarounds for old versions of Visual C++. It will be removed in a future release, and in this release always returns 0. Please use standards-conforming mechanisms to manipulate fpos, such as conversions to and from streamoff, or an integral type, instead. If you are receiving this message while compiling Boost.IOStreams, a fix has been submitted upstream to make Boost use standards-conforming mechanisms, as it does for other compilers. You can define _SILENCE_FPOS_SEEKPOS_DEPRECATION_WARNING to acknowledge that you have received this warning, or define _REMOVE_FPOS_SEEKPOS to remove std::fpos::seekpos entirely.")]]         {
            return {};
        }
        std::streamoff operator-(const fpos<_Statetype> &_Right) const         {
            return (static_cast<std::streamoff>(*this) - static_cast<std::streamoff>(_Right));
        }
        fpos<_Statetype> &operator+=(std::streamoff _Off)         {
            this->_Myoff += _Off;
            return (*this);
        }
        fpos<_Statetype> &operator-=(std::streamoff _Off)         {
            this->_Myoff -= _Off;
            return (*this);
        }
        fpos<_Statetype> operator+(std::streamoff _Off) const         {
            fpos<_Statetype> _Tmp = *this;
            _Tmp += _Off;
            return (_Tmp);
        }
        fpos<_Statetype> operator-(std::streamoff _Off) const         {
            fpos<_Statetype> _Tmp = *this;
            _Tmp -= _Off;
            return (_Tmp);
        }
        bool operator==(const fpos<_Statetype> &_Right) const         {
            return (static_cast<std::streamoff>(*this) == static_cast<std::streamoff>(_Right));
        }
        friend template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0> bool operator==(const fpos<_Statetype> &_Left, const _Int _Right)         {
            return (static_cast<std::streamoff>(_Left) == _Right);
        }
;
        friend template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0> bool operator==(const _Int _Left, const fpos<_Statetype> &_Right)         {
            return (_Left == static_cast<std::streamoff>(_Right));
        }
;
        bool operator!=(const fpos<_Statetype> &_Right) const         {
            return (static_cast<std::streamoff>(*this) != static_cast<std::streamoff>(_Right));
        }
        friend template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0> bool operator!=(const fpos<_Statetype> &_Left, const _Int _Right)         {
            return (static_cast<std::streamoff>(_Left) != _Right);
        }
;
        friend template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0> bool operator!=(const _Int _Left, const fpos<_Statetype> &_Right)         {
            return (_Left != static_cast<std::streamoff>(_Right));
        }
;
    private:
        std::streamoff _Myoff;
        fpos_t _Fpos;
        _Statetype _Mystate;
    };
    using streampos = fpos<_Mbstatet>;
    using wstreampos = std::streampos;
    template <class _Elem, class _Int_type> struct _Char_traits {
        using char_type = _Elem;
        using int_type = _Int_type;
        using pos_type = std::streampos;
        using off_type = std::streamoff;
        using state_type = _Mbstatet;
        static inline int compare(const _Elem *_First1, const _Elem *_First2, size_t _Count) noexcept         {
            for (; 0 < _Count; --_Count , ++_First1 , ++_First2) {
                if (*_First1 != *_First2) {
                    return (*_First1 < *_First2 ? -1 : +1);
                }
            }
            return (0);
        }
        static inline size_t length(const _Elem *_First) noexcept         {
            size_t _Count = 0;
            while (*_First != _Elem())
                {
                    ++_Count;
                    ++_First;
                }
            return (_Count);
        }
        static _Elem *copy(_Elem *const _First1, const _Elem *_First2, size_t _Count) noexcept         {
            return (static_cast<_Elem *>(::memcpy(_First1, _First2, _Count * sizeof(_Elem))));
        }
        static _Elem *_Copy_s(_Elem *const _First1, const size_t _Dest_size, const _Elem *const _First2, const size_t _Count) noexcept         {
            do {
                if (_Count <= _Dest_size) {
                } else {
                    do {
                        ;
                        ::_invalid_parameter_noinfo_noreturn();
                    } while (false);
                }
                ;
            } while (false);
            return (copy(_First1, _First2, _Count));
        }
        static inline const _Elem *find(const _Elem *_First, size_t _Count, const _Elem &_Ch) noexcept         {
            for (; 0 < _Count; --_Count , ++_First) {
                if (*_First == _Ch) {
                    return (_First);
                }
            }
            return (nullptr);
        }
        static _Elem *move(_Elem *const _First1, const _Elem *_First2, size_t _Count) noexcept         {
            return (static_cast<_Elem *>(::memmove(_First1, _First2, _Count * sizeof(_Elem))));
        }
        static _Elem *assign(_Elem *const _First, size_t _Count, const _Elem _Ch) noexcept         {
            _Elem *_Next = _First;
            for (; 0 < _Count; --_Count , ++_Next) {
                *_Next = _Ch;
            }
            return (_First);
        }
        static inline void assign(_Elem &_Left, const _Elem &_Right) noexcept         {
            _Left = _Right;
        }
        static constexpr bool eq(const _Elem &_Left, const _Elem &_Right) noexcept         {
            return (_Left == _Right);
        }
        static constexpr bool lt(const _Elem &_Left, const _Elem &_Right) noexcept         {
            return (_Left < _Right);
        }
        static constexpr _Elem to_char_type(const std::_Char_traits::int_type &_Meta) noexcept         {
            return (static_cast<_Elem>(_Meta));
        }
        static constexpr std::_Char_traits::int_type to_int_type(const _Elem &_Ch) noexcept         {
            return (static_cast<std::_Char_traits::int_type>(_Ch));
        }
        static constexpr bool eq_int_type(const std::_Char_traits::int_type &_Left, const std::_Char_traits::int_type &_Right) noexcept         {
            return (_Left == _Right);
        }
        static constexpr std::_Char_traits::int_type not_eof(const std::_Char_traits::int_type &_Meta) noexcept         {
            return (_Meta != eof() ? _Meta : !eof());
        }
        static constexpr std::_Char_traits::int_type eof() noexcept         {
            return (static_cast<std::_Char_traits::int_type>((-1)));
        }
    };
template<> struct _Char_traits<char32_t, unsigned int> {
        using char_type = char32_t;
        using int_type = unsigned int;
        using pos_type = std::streampos;
        using off_type = std::streamoff;
        using state_type = _Mbstatet;
        static inline int compare(const char32_t *_First1, const char32_t *_First2, size_t _Count) noexcept;
        static inline size_t length(const char32_t *_First) noexcept;
        static char32_t *copy(char32_t *const _First1, const char32_t *_First2, size_t _Count) noexcept;
        static char32_t *_Copy_s(char32_t *const _First1, const size_t _Dest_size, const char32_t *const _First2, const size_t _Count) noexcept;
        static inline const char32_t *find(const char32_t *_First, size_t _Count, const char32_t &_Ch) noexcept;
        static char32_t *move(char32_t *const _First1, const char32_t *_First2, size_t _Count) noexcept;
        static char32_t *assign(char32_t *const _First, size_t _Count, const char32_t _Ch) noexcept;
        static inline void assign(char32_t &_Left, const char32_t &_Right) noexcept;
        static constexpr bool eq(const char32_t &_Left, const char32_t &_Right) noexcept;
        static constexpr bool lt(const char32_t &_Left, const char32_t &_Right) noexcept;
        static constexpr char32_t to_char_type(const std::_Char_traits<char32_t, unsigned int>::int_type &_Meta) noexcept;
        static constexpr std::_Char_traits<char32_t, unsigned int>::int_type to_int_type(const char32_t &_Ch) noexcept;
        static constexpr bool eq_int_type(const std::_Char_traits<char32_t, unsigned int>::int_type &_Left, const std::_Char_traits<char32_t, unsigned int>::int_type &_Right) noexcept;
        static constexpr std::_Char_traits<char32_t, unsigned int>::int_type not_eof(const std::_Char_traits<char32_t, unsigned int>::int_type &_Meta) noexcept;
        static constexpr std::_Char_traits<char32_t, unsigned int>::int_type eof() noexcept;
    };
    template <class _Elem> struct _WChar_traits {
        using char_type = _Elem;
        using int_type = unsigned short;
        using pos_type = std::streampos;
        using off_type = std::streamoff;
        using state_type = _Mbstatet;
        static inline int compare(const _Elem *const _First1, const _Elem *const _First2, const size_t _Count) noexcept         {
            return (::wmemcmp(reinterpret_cast<const wchar_t *>(_First1), reinterpret_cast<const wchar_t *>(_First2), _Count));
        }
        static inline size_t length(const _Elem *_First) noexcept         {
            return (::wcslen(reinterpret_cast<const wchar_t *>(_First)));
        }
        static _Elem *copy(_Elem *const _First1, const _Elem *const _First2, const size_t _Count) noexcept         {
            return (reinterpret_cast<_Elem *>(::wmemcpy(reinterpret_cast<wchar_t *>(_First1), reinterpret_cast<const wchar_t *>(_First2), _Count)));
        }
        static _Elem *_Copy_s(_Elem *const _First1, const size_t _Size_in_words, const _Elem *const _First2, const size_t _Count) noexcept         {
            do {
                if (_Count <= _Size_in_words) {
                } else {
                    do {
                        ;
                        ::_invalid_parameter_noinfo_noreturn();
                    } while (false);
                }
                ;
            } while (false);
            return (copy(_First1, _First2, _Count));
        }
        static inline const _Elem *find(const _Elem *_First, const size_t _Count, const _Elem &_Ch) noexcept         {
            return (reinterpret_cast<const _Elem *>(::wmemchr(reinterpret_cast<const wchar_t *>(_First), _Ch, _Count)));
        }
        static _Elem *move(_Elem *const _First1, const _Elem *const _First2, const size_t _Count) noexcept         {
            return (reinterpret_cast<_Elem *>(::wmemmove(reinterpret_cast<wchar_t *>(_First1), reinterpret_cast<const wchar_t *>(_First2), _Count)));
        }
        static _Elem *assign(_Elem *const _First, size_t _Count, _Elem _Ch) noexcept         {
            return (reinterpret_cast<_Elem *>(::wmemset(reinterpret_cast<wchar_t *>(_First), _Ch, _Count)));
        }
        static inline void assign(_Elem &_Left, const _Elem &_Right) noexcept         {
            _Left = _Right;
        }
        static constexpr bool eq(const _Elem &_Left, const _Elem &_Right) noexcept         {
            return (_Left == _Right);
        }
        static constexpr bool lt(const _Elem &_Left, const _Elem &_Right) noexcept         {
            return (_Left < _Right);
        }
        static constexpr _Elem to_char_type(const std::_WChar_traits::int_type &_Meta) noexcept         {
            return (_Meta);
        }
        static constexpr std::_WChar_traits::int_type to_int_type(const _Elem &_Ch) noexcept         {
            return (_Ch);
        }
        static constexpr bool eq_int_type(const std::_WChar_traits::int_type &_Left, const std::_WChar_traits::int_type &_Right) noexcept         {
            return (_Left == _Right);
        }
        static constexpr std::_WChar_traits::int_type not_eof(const std::_WChar_traits::int_type &_Meta) noexcept         {
            return (_Meta != eof() ? _Meta : static_cast<std::_WChar_traits::int_type>(!eof()));
        }
        static constexpr std::_WChar_traits::int_type eof() noexcept         {
            return (((wint_t)(65535)));
        }
    };
template<> struct _WChar_traits<char16_t> {
        using char_type = char16_t;
        using int_type = unsigned short;
        using pos_type = std::streampos;
        using off_type = std::streamoff;
        using state_type = _Mbstatet;
        static inline int compare(const char16_t *const _First1, const char16_t *const _First2, const size_t _Count) noexcept;
        static inline size_t length(const char16_t *_First) noexcept;
        static char16_t *copy(char16_t *const _First1, const char16_t *const _First2, const size_t _Count) noexcept;
        static char16_t *_Copy_s(char16_t *const _First1, const size_t _Size_in_words, const char16_t *const _First2, const size_t _Count) noexcept;
        static inline const char16_t *find(const char16_t *_First, const size_t _Count, const char16_t &_Ch) noexcept;
        static char16_t *move(char16_t *const _First1, const char16_t *const _First2, const size_t _Count) noexcept;
        static char16_t *assign(char16_t *const _First, size_t _Count, char16_t _Ch) noexcept;
        static inline void assign(char16_t &_Left, const char16_t &_Right) noexcept;
        static constexpr bool eq(const char16_t &_Left, const char16_t &_Right) noexcept;
        static constexpr bool lt(const char16_t &_Left, const char16_t &_Right) noexcept;
        static constexpr char16_t to_char_type(const std::_WChar_traits::int_type &_Meta) noexcept;
        static constexpr std::_WChar_traits<char16_t>::int_type to_int_type(const char16_t &_Ch) noexcept;
        static constexpr bool eq_int_type(const std::_WChar_traits::int_type &_Left, const std::_WChar_traits::int_type &_Right) noexcept;
        static constexpr std::_WChar_traits<char16_t>::int_type not_eof(const std::_WChar_traits::int_type &_Meta) noexcept;
        static constexpr std::_WChar_traits::int_type eof() noexcept;
    };
template<> struct _WChar_traits<wchar_t> {
        using char_type = wchar_t;
        using int_type = unsigned short;
        using pos_type = std::streampos;
        using off_type = std::streamoff;
        using state_type = _Mbstatet;
        static inline int compare(const wchar_t *const _First1, const wchar_t *const _First2, const size_t _Count) noexcept;
        static inline size_t length(const wchar_t *_First) noexcept;
        static wchar_t *copy(wchar_t *const _First1, const wchar_t *const _First2, const size_t _Count) noexcept;
        static wchar_t *_Copy_s(wchar_t *const _First1, const size_t _Size_in_words, const wchar_t *const _First2, const size_t _Count) noexcept;
        static inline const wchar_t *find(const wchar_t *_First, const size_t _Count, const wchar_t &_Ch) noexcept;
        static wchar_t *move(wchar_t *const _First1, const wchar_t *const _First2, const size_t _Count) noexcept;
        static wchar_t *assign(wchar_t *const _First, size_t _Count, wchar_t _Ch) noexcept;
        static inline void assign(wchar_t &_Left, const wchar_t &_Right) noexcept;
        static constexpr bool eq(const wchar_t &_Left, const wchar_t &_Right) noexcept;
        static constexpr bool lt(const wchar_t &_Left, const wchar_t &_Right) noexcept;
        static constexpr wchar_t to_char_type(const std::_WChar_traits::int_type &_Meta) noexcept;
        static constexpr std::_WChar_traits<wchar_t>::int_type to_int_type(const wchar_t &_Ch) noexcept;
        static constexpr bool eq_int_type(const std::_WChar_traits::int_type &_Left, const std::_WChar_traits::int_type &_Right) noexcept;
        static constexpr std::_WChar_traits<wchar_t>::int_type not_eof(const std::_WChar_traits::int_type &_Meta) noexcept;
        static constexpr std::_WChar_traits::int_type eof() noexcept;
    };
template<> struct _WChar_traits<unsigned short> {
        using char_type = unsigned short;
        using int_type = unsigned short;
        using pos_type = std::streampos;
        using off_type = std::streamoff;
        using state_type = _Mbstatet;
        static inline int compare(const unsigned short *const _First1, const unsigned short *const _First2, const size_t _Count) noexcept;
        static inline size_t length(const unsigned short *_First) noexcept;
        static unsigned short *copy(unsigned short *const _First1, const unsigned short *const _First2, const size_t _Count) noexcept;
        static unsigned short *_Copy_s(unsigned short *const _First1, const size_t _Size_in_words, const unsigned short *const _First2, const size_t _Count) noexcept;
        static inline const unsigned short *find(const unsigned short *_First, const size_t _Count, const unsigned short &_Ch) noexcept;
        static unsigned short *move(unsigned short *const _First1, const unsigned short *const _First2, const size_t _Count) noexcept;
        static unsigned short *assign(unsigned short *const _First, size_t _Count, unsigned short _Ch) noexcept;
        static inline void assign(unsigned short &_Left, const unsigned short &_Right) noexcept;
        static constexpr bool eq(const unsigned short &_Left, const unsigned short &_Right) noexcept;
        static constexpr bool lt(const unsigned short &_Left, const unsigned short &_Right) noexcept;
        static constexpr unsigned short to_char_type(const std::_WChar_traits::int_type &_Meta) noexcept;
        static constexpr std::_WChar_traits<unsigned short>::int_type to_int_type(const unsigned short &_Ch) noexcept;
        static constexpr bool eq_int_type(const std::_WChar_traits::int_type &_Left, const std::_WChar_traits::int_type &_Right) noexcept;
        static constexpr std::_WChar_traits<unsigned short>::int_type not_eof(const std::_WChar_traits::int_type &_Meta) noexcept;
        static constexpr std::_WChar_traits::int_type eof() noexcept;
    };
    template <class _Elem> struct char_traits : _Char_traits<_Elem, long> {
    };
    template<> struct char_traits<char16_t> : _WChar_traits<char16_t> {
    };
    using u16streampos = std::streampos;
    template<> struct char_traits<char32_t> : _Char_traits<char32_t, unsigned int> {
    };
    using u32streampos = std::streampos;
    template<> struct char_traits<wchar_t> : _WChar_traits<wchar_t> {
    };
    template<> struct char_traits<unsigned short> : _WChar_traits<unsigned short> {
    };
    template<> struct char_traits<char> {
        using char_type = char;
        using int_type = int;
        using pos_type = std::streampos;
        using off_type = std::streamoff;
        using state_type = _Mbstatet;
        static inline int compare(const char *const _First1, const char *const _First2, const size_t _Count) noexcept         {
            return (::memcmp(_First1, _First2, _Count));
        }
        static inline size_t length(const char *const _First) noexcept         {
            return (::strlen(_First));
        }
        static char *copy(char *const _First1, const char *const _First2, const size_t _Count) noexcept         {
            return (static_cast<char *>(::memcpy(_First1, _First2, _Count)));
        }
        static char *_Copy_s(char *const _First1, const size_t _Size_in_bytes, const char *const _First2, const size_t _Count) noexcept         {
            do {
                if (_Count <= _Size_in_bytes) {
                } else {
                    do {
                        ;
                        ::_invalid_parameter_noinfo_noreturn();
                    } while (false);
                }
                ;
            } while (false);
            return (copy(_First1, _First2, _Count));
        }
        static inline const char *find(const char *const _First, const size_t _Count, const char &_Ch) noexcept         {
            return (static_cast<const char *>(::memchr(_First, _Ch, _Count)));
        }
        static char *move(char *const _First1, const char *const _First2, const size_t _Count) noexcept         {
            return (static_cast<char *>(::memmove(_First1, _First2, _Count)));
        }
        static char *assign(char *const _First, const size_t _Count, const char _Ch) noexcept         {
            return (static_cast<char *>(::memset(_First, _Ch, _Count)));
        }
        static inline void assign(char &_Left, const char &_Right) noexcept         {
            _Left = _Right;
        }
        static constexpr bool eq(const char &_Left, const char &_Right) noexcept         {
            return (_Left == _Right);
        }
        static constexpr bool lt(const char &_Left, const char &_Right) noexcept         {
            return (static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right));
        }
        static constexpr char to_char_type(const std::char_traits<char>::int_type &_Meta) noexcept         {
            return (static_cast<char>(_Meta));
        }
        static constexpr std::char_traits<char>::int_type to_int_type(const char &_Ch) noexcept         {
            return (static_cast<unsigned char>(_Ch));
        }
        static constexpr bool eq_int_type(const std::char_traits<char>::int_type &_Left, const std::char_traits<char>::int_type &_Right) noexcept         {
            return (_Left == _Right);
        }
        static constexpr std::char_traits<char>::int_type not_eof(const std::char_traits<char>::int_type &_Meta) noexcept         {
            return (_Meta != eof() ? _Meta : !eof());
        }
        static constexpr std::char_traits<char>::int_type eof() noexcept         {
            return ((-1));
        }
    };
    template <class _Ty> class allocator
template<> class allocator<char> {
    public:
        static_assert(!is_const_v<char>, "The C++ Standard forbids containers of const elements because allocator<const T> is ill-formed.");
        using _Not_user_specialized = void;
        using value_type = char;
        typedef char *pointer;
        typedef const char *const_pointer;
        typedef char &reference;
        typedef const char &const_reference;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal = std::true_type;
        template <class _Other> struct rebind;
        char *address(char &_Val) const noexcept;
        const char *address(const char &_Val) const noexcept;
        constexpr allocator() noexcept;
        allocator(const std::allocator<char> &) = default
        template <class _Other> constexpr allocator(const allocator<_Other> &) noexcept;
        template<> constexpr allocator<char>(const allocator<char> &) noexcept;
        void deallocate(char *const _Ptr, const size_t _Count);
        char *allocate(const size_t _Count);
        char *allocate(const size_t _Count, const void *);
        template <class _Objty, class ..._Types> void construct(_Objty *const _Ptr, _Types &&..._Args);
        template <class _Uty> void destroy(_Uty *const _Ptr);
        size_t max_size() const noexcept;
    };
    class ios_base;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_ios;
    template <class _Elem, class _Traits = char_traits<_Elem>> class istreambuf_iterator;
    template <class _Elem, class _Traits = char_traits<_Elem>> class ostreambuf_iterator;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_streambuf;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_istream;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_ostream;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_iostream;
    template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>> class basic_stringbuf;
    template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>> class basic_istringstream;
    template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>> class basic_ostringstream;
    template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>> class basic_stringstream;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_filebuf;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_ifstream;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_ofstream;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_fstream;
    using ios = basic_ios<char, char_traits<char> >;
    using streambuf = basic_streambuf<char, char_traits<char> >;
    using istream = basic_istream<char, char_traits<char> >;
    using ostream = basic_ostream<char, char_traits<char> >;
    using iostream = basic_iostream<char, char_traits<char> >;
    using stringbuf = basic_stringbuf<char, char_traits<char>, allocator<char> >;
    using istringstream = basic_istringstream<char, char_traits<char>, allocator<char> >;
    using ostringstream = basic_ostringstream<char, char_traits<char>, allocator<char> >;
    using stringstream = basic_stringstream<char, char_traits<char>, allocator<char> >;
    using filebuf = basic_filebuf<char, char_traits<char> >;
    using ifstream = basic_ifstream<char, char_traits<char> >;
    using ofstream = basic_ofstream<char, char_traits<char> >;
    using fstream = basic_fstream<char, char_traits<char> >;
    using wios = basic_ios<wchar_t, char_traits<wchar_t> >;
    using wstreambuf = basic_streambuf<wchar_t, char_traits<wchar_t> >;
    using wistream = basic_istream<wchar_t, char_traits<wchar_t> >;
    using wostream = basic_ostream<wchar_t, char_traits<wchar_t> >;
    using wiostream = basic_iostream<wchar_t, char_traits<wchar_t> >;
    using wstringbuf = basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >;
    using wistringstream = basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >;
    using wostringstream = basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >;
    using wstringstream = basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >;
    using wfilebuf = basic_filebuf<wchar_t, char_traits<wchar_t> >;
    using wifstream = basic_ifstream<wchar_t, char_traits<wchar_t> >;
    using wofstream = basic_ofstream<wchar_t, char_traits<wchar_t> >;
    using wfstream = basic_fstream<wchar_t, char_traits<wchar_t> >;
}
namespace std {
    template <class _Ty> constexpr const _Ty &_Min_value(const _Ty &_Left, const _Ty &_Right) noexcept(noexcept(_Right < _Left)_Min_value(const _Ty &_Left, const _Ty &_Right) noexcept(noexcept(_Right < _Left))     {
        return (_Right < _Left ? _Right : _Left);
    }
    template<> constexpr const unsigned long long &_Min_value<unsigned long long>(const unsigned long long &_Left, const unsigned long long &_Right) noexcept(noexcept(_Right < _Left)_Min_value<unsigned long long>(const unsigned long long &_Left, const unsigned long long &_Right) noexcept(noexcept(_Right < _Left))     {
        return (_Right < _Left ? _Right : _Left);
    }
    template <class _Ty> constexpr const _Ty &_Max_value(const _Ty &_Left, const _Ty &_Right) noexcept(noexcept(_Left < _Right)_Max_value(const _Ty &_Left, const _Ty &_Right) noexcept(noexcept(_Left < _Right))     {
        return (_Left < _Right ? _Right : _Left);
    }
    template<> constexpr const unsigned long long &_Max_value<unsigned long long>(const unsigned long long &_Left, const unsigned long long &_Right) noexcept(noexcept(_Left < _Right)_Max_value<unsigned long long>(const unsigned long long &_Left, const unsigned long long &_Right) noexcept(noexcept(_Left < _Right))     {
        return (_Left < _Right ? _Right : _Left);
    }
    template <class _FwdIt1, class _FwdIt2> inline void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)     {
        swap(*_Left, *_Right);
    }
    template <class _Ty, size_t _Size, class  = enable_if_t<_Is_swappable<_Ty>::value>> inline void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::valueswap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value)     {
        if (&_Left != &_Right) {
            _Ty *_First1 = _Left;
            _Ty *_Last1 = _First1 + _Size;
            _Ty *_First2 = _Right;
            for (; _First1 != _Last1; ++_First1 , ++_First2)
                ::std::iter_swap(_First1, _First2);
        }
    }
    template <class _Ty, class  = void> inline void swap(_Ty &_Left, _Ty &_Right) noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>swap(_Ty &_Left, _Ty &_Right) noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>)     {
        _Ty _Tmp = ::std::move(_Left);
        _Left = ::std::move(_Right);
        _Right = ::std::move(_Tmp);
    }
    template <class _Ty> inline void _Swap_adl(_Ty &_Left, _Ty &_Right) noexcept(_Is_nothrow_swappable<_Ty>::value_Swap_adl(_Ty &_Left, _Ty &_Right) noexcept(_Is_nothrow_swappable<_Ty>::value)     {
        swap(_Left, _Right);
    }
    struct piecewise_construct_t {
        explicit piecewise_construct_t() noexcept = default
    };
    constexpr std::piecewise_construct_t piecewise_construct{};
    template <class ...> class tuple;
    template <class _Ty1, class _Ty2> struct pair {
        using first_type = _Ty1;
        using second_type = _Ty2;
        template <class _Uty1 = _Ty1, class _Uty2 = _Ty2, enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2>, _Is_implicitly_default_constructible<_Uty1>, _Is_implicitly_default_constructible<_Uty2> >, int> = 0> constexpr pair<_Ty1, _Ty2>() noexcept(is_nothrow_default_constructible_v<_Uty1> && is_nothrow_default_constructible_v<_Uty2>pair<_Ty1, _Ty2>() noexcept(is_nothrow_default_constructible_v<_Uty1> && is_nothrow_default_constructible_v<_Uty2>) : first(), second()         {
        }
        template <class _Uty1 = _Ty1, class _Uty2 = _Ty2, enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2>, negation<conjunction<_Is_implicitly_default_constructible<_Uty1>, _Is_implicitly_default_constructible<_Uty2> > > >, int> = 0> constexpr explicit pair<_Ty1, _Ty2>() noexcept(is_nothrow_default_constructible_v<_Uty1> && is_nothrow_default_constructible_v<_Uty2>pair<_Ty1, _Ty2>() noexcept(is_nothrow_default_constructible_v<_Uty1> && is_nothrow_default_constructible_v<_Uty2>) : first(), second()         {
        }
        template <class _Uty1 = _Ty1, class _Uty2 = _Ty2, enable_if_t<conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>, is_convertible<const _Uty1 &, _Uty1>, is_convertible<const _Uty2 &, _Uty2> >, int> = 0> constexpr pair<_Ty1, _Ty2>(const _Ty1 &_Val1, const _Ty2 &_Val2) noexcept(is_nothrow_copy_constructible_v<_Uty1> && is_nothrow_copy_constructible_v<_Uty2>pair<_Ty1, _Ty2>(const _Ty1 &_Val1, const _Ty2 &_Val2) noexcept(is_nothrow_copy_constructible_v<_Uty1> && is_nothrow_copy_constructible_v<_Uty2>) : first(_Val1), second(_Val2)         {
        }
        template <class _Uty1 = _Ty1, class _Uty2 = _Ty2, enable_if_t<conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>, negation<conjunction<is_convertible<const _Uty1 &, _Uty1>, is_convertible<const _Uty2 &, _Uty2> > > >, int> = 0> constexpr explicit pair<_Ty1, _Ty2>(const _Ty1 &_Val1, const _Ty2 &_Val2) noexcept(is_nothrow_copy_constructible_v<_Uty1> && is_nothrow_copy_constructible_v<_Uty2>pair<_Ty1, _Ty2>(const _Ty1 &_Val1, const _Ty2 &_Val2) noexcept(is_nothrow_copy_constructible_v<_Uty1> && is_nothrow_copy_constructible_v<_Uty2>) : first(_Val1), second(_Val2)         {
        }
        template <class _Other1, class _Other2, enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>, is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2> >, int> = 0> constexpr pair<_Ty1, _Ty2>(_Other1 &&_Val1, _Other2 &&_Val2) noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>pair<_Ty1, _Ty2>(_Other1 &&_Val1, _Other2 &&_Val2) noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>) : first(::std::forward<_Other1>(_Val1)), second(::std::forward<_Other2>(_Val2))         {
        }
        template <class _Other1, class _Other2, enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>, negation<conjunction<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2> > > >, int> = 0> constexpr explicit pair<_Ty1, _Ty2>(_Other1 &&_Val1, _Other2 &&_Val2) noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>pair<_Ty1, _Ty2>(_Other1 &&_Val1, _Other2 &&_Val2) noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>) : first(::std::forward<_Other1>(_Val1)), second(::std::forward<_Other2>(_Val2))         {
        }
        pair<_Ty1, _Ty2>(const pair<_Ty1, _Ty2> &) = default
        pair<_Ty1, _Ty2>(pair<_Ty1, _Ty2> &&) = default
        template <class _Other1, class _Other2, enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1 &>, is_constructible<_Ty2, const _Other2 &>, is_convertible<const _Other1 &, _Ty1>, is_convertible<const _Other2 &, _Ty2> >, int> = 0> constexpr pair<_Ty1, _Ty2>(const pair<_Other1, _Other2> &_Right) noexcept(is_nothrow_constructible_v<_Ty1, const _Other1 &> && is_nothrow_constructible_v<_Ty2, const _Other2 &>pair<_Ty1, _Ty2>(const pair<_Other1, _Other2> &_Right) noexcept(is_nothrow_constructible_v<_Ty1, const _Other1 &> && is_nothrow_constructible_v<_Ty2, const _Other2 &>) : first(_Right.first), second(_Right.second)         {
        }
        template <class _Other1, class _Other2, enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1 &>, is_constructible<_Ty2, const _Other2 &>, negation<conjunction<is_convertible<const _Other1 &, _Ty1>, is_convertible<const _Other2 &, _Ty2> > > >, int> = 0> constexpr explicit pair<_Ty1, _Ty2>(const pair<_Other1, _Other2> &_Right) noexcept(is_nothrow_constructible_v<_Ty1, const _Other1 &> && is_nothrow_constructible_v<_Ty2, const _Other2 &>pair<_Ty1, _Ty2>(const pair<_Other1, _Other2> &_Right) noexcept(is_nothrow_constructible_v<_Ty1, const _Other1 &> && is_nothrow_constructible_v<_Ty2, const _Other2 &>) : first(_Right.first), second(_Right.second)         {
        }
        template <class _Other1, class _Other2, enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>, is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2> >, int> = 0> constexpr pair<_Ty1, _Ty2>(pair<_Other1, _Other2> &&_Right) noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>pair<_Ty1, _Ty2>(pair<_Other1, _Other2> &&_Right) noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>) : first(::std::forward<_Other1>(_Right.first)), second(::std::forward<_Other2>(_Right.second))         {
        }
        template <class _Other1, class _Other2, enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>, negation<conjunction<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2> > > >, int> = 0> constexpr explicit pair<_Ty1, _Ty2>(pair<_Other1, _Other2> &&_Right) noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>pair<_Ty1, _Ty2>(pair<_Other1, _Other2> &&_Right) noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>) : first(::std::forward<_Other1>(_Right.first)), second(::std::forward<_Other2>(_Right.second))         {
        }
        template <class _Tuple1, class _Tuple2, size_t ..._Indexes1, size_t ..._Indexes2> inline pair<_Ty1, _Ty2>(_Tuple1 &_Val1, _Tuple2 &_Val2, index_sequence<_Indexes1...>, index_sequence<_Indexes2...>);
        template <class ..._Types1, class ..._Types2> inline pair<_Ty1, _Ty2>(std::piecewise_construct_t, tuple<_Types1...> _Val1, tuple<_Types2...> _Val2);
        pair<_Ty1, _Ty2> &operator=(const volatile pair<_Ty1, _Ty2> &) = delete
        template <class _Other1 = _Ty1, class _Other2 = _Ty2, enable_if_t<conjunction_v<is_assignable<_Ty1 &, const _Other1 &>, is_assignable<_Ty2 &, const _Other2 &> >, int> = 0> pair<_Ty1, _Ty2> &operator=(const pair<_Other1, _Other2> &_Right) noexcept(is_nothrow_assignable_v<_Ty1 &, const _Other1 &> && is_nothrow_assignable_v<_Ty2 &, const _Other2 &>operator=(const pair<_Other1, _Other2> &_Right) noexcept(is_nothrow_assignable_v<_Ty1 &, const _Other1 &> && is_nothrow_assignable_v<_Ty2 &, const _Other2 &>)         {
            this->first = _Right.first;
            this->second = _Right.second;
            return (*this);
        }
        template <class _Other1 = _Ty1, class _Other2 = _Ty2, enable_if_t<conjunction_v<is_assignable<_Ty1 &, _Other1>, is_assignable<_Ty2 &, _Other2> >, int> = 0> pair<_Ty1, _Ty2> &operator=(pair<_Other1, _Other2> &&_Right) noexcept(is_nothrow_assignable_v<_Ty1 &, _Other1> && is_nothrow_assignable_v<_Ty2 &, _Other2>operator=(pair<_Other1, _Other2> &&_Right) noexcept(is_nothrow_assignable_v<_Ty1 &, _Other1> && is_nothrow_assignable_v<_Ty2 &, _Other2>)         {
            this->first = ::std::forward<_Other1>(_Right.first);
            this->second = ::std::forward<_Other2>(_Right.second);
            return (*this);
        }
        void swap(pair<_Ty1, _Ty2> &_Right) noexcept(_Is_nothrow_swappable<_Ty1>::value && _Is_nothrow_swappable<_Ty2>::valueswap(pair<_Ty1, _Ty2> &_Right) noexcept(_Is_nothrow_swappable<_Ty1>::value && _Is_nothrow_swappable<_Ty2>::value)         {
            if (this != ::std::addressof(_Right)) {
                _Swap_adl(this->first, _Right.first);
                _Swap_adl(this->second, _Right.second);
            }
        }
        _Ty1 first;
        _Ty2 second;
    };
    template <class _Ty1, class _Ty2, class  = enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value>> inline void swap(pair<_Ty1, _Ty2> &_Left, pair<_Ty1, _Ty2> &_Right) noexcept(noexcept(_Left.swap(_Right))swap(pair<_Ty1, _Ty2> &_Left, pair<_Ty1, _Ty2> &_Right) noexcept(noexcept(_Left.swap(_Right)))     {
        _Left.swap(_Right);
    }
    template <class _Ty1, class _Ty2> constexpr bool operator==(const pair<_Ty1, _Ty2> &_Left, const pair<_Ty1, _Ty2> &_Right)     {
        return (_Left.first == _Right.first && _Left.second == _Right.second);
    }
    template <class _Ty1, class _Ty2> constexpr bool operator!=(const pair<_Ty1, _Ty2> &_Left, const pair<_Ty1, _Ty2> &_Right)     {
        return (!(_Left == _Right));
    }
    template <class _Ty1, class _Ty2> constexpr bool operator<(const pair<_Ty1, _Ty2> &_Left, const pair<_Ty1, _Ty2> &_Right)     {
        return (_Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second));
    }
    template <class _Ty1, class _Ty2> constexpr bool operator>(const pair<_Ty1, _Ty2> &_Left, const pair<_Ty1, _Ty2> &_Right)     {
        return (_Right < _Left);
    }
    template <class _Ty1, class _Ty2> constexpr bool operator<=(const pair<_Ty1, _Ty2> &_Left, const pair<_Ty1, _Ty2> &_Right)     {
        return (!(_Right < _Left));
    }
    template <class _Ty1, class _Ty2> constexpr bool operator>=(const pair<_Ty1, _Ty2> &_Left, const pair<_Ty1, _Ty2> &_Right)     {
        return (!(_Left < _Right));
    }
    template <class _Ty> struct _Unrefwrap_helper {
        using type = _Ty;
    };
    template <class _Ty> struct _Unrefwrap_helper<reference_wrapper<type-parameter-0-0>> {
        using type = _Ty &;
    };
    template <class _Ty> using _Unrefwrap_t = typename _Unrefwrap_helper<decay_t<_Ty> >::type;
    template <class _Ty1, class _Ty2> constexpr pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2> > make_pair(_Ty1 &&_Val1, _Ty2 &&_Val2)     {
        using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2> >;
        return (_Mypair(::std::forward<_Ty1>(_Val1), ::std::forward<_Ty2>(_Val2)));
    }
    namespace rel_ops {
        template <class _Ty> inline bool operator!=(const _Ty &_Left, const _Ty &_Right)         {
            return (!(_Left == _Right));
        }
        template <class _Ty> inline bool operator>(const _Ty &_Left, const _Ty &_Right)         {
            return (_Right < _Left);
        }
        template <class _Ty> inline bool operator<=(const _Ty &_Left, const _Ty &_Right)         {
            return (!(_Right < _Left));
        }
        template <class _Ty> inline bool operator>=(const _Ty &_Left, const _Ty &_Right)         {
            return (!(_Left < _Right));
        }
    }
}
namespace std {
    template <class _Tuple> struct tuple_size;
    template <class _Tuple, class  = void> struct _Tuple_size_sfinae {
    };
    template <class _Tuple> struct _Tuple_size_sfinae<_Tuple, void> : integral_constant<size_t, tuple_size<_Tuple>::value> {
    };
    template <class _Tuple> struct tuple_size<_Tuple> : _Tuple_size_sfinae<_Tuple> {
    };
    template <class _Tuple> struct tuple_size<_Tuple> : _Tuple_size_sfinae<_Tuple> {
    };
    template <class _Tuple> struct tuple_size<_Tuple> : _Tuple_size_sfinae<_Tuple> {
    };
    template <class _Ty> constexpr size_t tuple_size_v = tuple_size<_Ty>::value;
    template <size_t _Index, class _Tuple> struct tuple_element;
    template <size_t _Index, class _Tuple> struct tuple_element<_Index, _Tuple> : public tuple_element<_Index, _Tuple> {
        using _Mybase = tuple_element<_Index, _Tuple>;
        using type = add_const_t<typename _Mybase::type>;
    };
    template <size_t _Index, class _Tuple> struct tuple_element<_Index, _Tuple> : public tuple_element<_Index, _Tuple> {
        using _Mybase = tuple_element<_Index, _Tuple>;
        using type = add_volatile_t<typename _Mybase::type>;
    };
    template <size_t _Index, class _Tuple> struct tuple_element<_Index, _Tuple> : public tuple_element<_Index, _Tuple> {
        using _Mybase = tuple_element<_Index, _Tuple>;
        using type = add_cv_t<typename _Mybase::type>;
    };
    template <size_t _Index, class _Tuple> using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;
    template <class _Ty, size_t _Size> class array;
    template <class _Ty, size_t _Size> struct tuple_size<array<type-parameter-0-0, _Size>> : integral_constant<size_t, _Size> {
    };
    template <size_t _Idx, class _Ty, size_t _Size> struct tuple_element<_Idx, array<type-parameter-0-1, _Size>> {
        static_assert(_Idx < _Size, "array index out of bounds");
        using type = _Ty;
    };
    template <class ..._Types> struct tuple_size<tuple<type-parameter-0-0...>> : integral_constant<size_t, sizeof...(_Types)> {
    };
    template <size_t _Index> struct tuple_element<_Index, std::tuple<>> {
        static_assert(_Always_false<integral_constant<size_t, _Index> >, "tuple index out of bounds");
    };
    template <class _This, class ..._Rest> struct tuple_element<0, tuple<type-parameter-0-0, type-parameter-0-1...>> {
        using type = _This;
        using _Ttype = tuple<_This, _Rest...>;
    };
    template <size_t _Index, class _This, class ..._Rest> struct tuple_element<_Index, tuple<type-parameter-0-1, type-parameter-0-2...>> : public tuple_element<_Index - 1, tuple<_Rest...> > {
    };
    template <class _Ty1, class _Ty2> struct tuple_size<pair<type-parameter-0-0, type-parameter-0-1>> : integral_constant<size_t, 2> {
    };
    template <size_t _Idx, class _Ty1, class _Ty2> struct tuple_element<_Idx, pair<type-parameter-0-1, type-parameter-0-2>> {
        static_assert(_Idx < 2, "pair index out of bounds");
        using type = conditional_t<_Idx == 0, _Ty1, _Ty2>;
    };
    template <class _Ret, class _Pair> constexpr _Ret _Pair_get(_Pair &_Pr, integral_constant<size_t, 0>) noexcept     {
        return (_Pr.first);
    }
    template <class _Ret, class _Pair> constexpr _Ret _Pair_get(_Pair &_Pr, integral_constant<size_t, 1>) noexcept     {
        return (_Pr.second);
    }
    template <size_t _Idx, class _Ty1, class _Ty2> constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2> > &get(pair<_Ty1, _Ty2> &_Pr) noexcept     {
        using _Rtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2> > &;
        return (_Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>()));
    }
    template <class _Ty1, class _Ty2> constexpr _Ty1 &get(pair<_Ty1, _Ty2> &_Pr) noexcept     {
        return (::std::get<0>(_Pr));
    }
    template <class _Ty2, class _Ty1> constexpr _Ty2 &get(pair<_Ty1, _Ty2> &_Pr) noexcept     {
        return (::std::get<1>(_Pr));
    }
    template <size_t _Idx, class _Ty1, class _Ty2> constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2> > &get(const pair<_Ty1, _Ty2> &_Pr) noexcept     {
        using _Ctype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2> > &;
        return (_Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>()));
    }
    template <class _Ty1, class _Ty2> constexpr const _Ty1 &get(const pair<_Ty1, _Ty2> &_Pr) noexcept     {
        return (::std::get<0>(_Pr));
    }
    template <class _Ty2, class _Ty1> constexpr const _Ty2 &get(const pair<_Ty1, _Ty2> &_Pr) noexcept     {
        return (::std::get<1>(_Pr));
    }
    template <size_t _Idx, class _Ty1, class _Ty2> constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2> > &&get(pair<_Ty1, _Ty2> &&_Pr) noexcept     {
        using _RRtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2> > &&;
        return (::std::forward<_RRtype>(::std::get<_Idx>(_Pr)));
    }
    template <class _Ty1, class _Ty2> constexpr _Ty1 &&get(pair<_Ty1, _Ty2> &&_Pr) noexcept     {
        return (::std::get<0>(::std::move(_Pr)));
    }
    template <class _Ty2, class _Ty1> constexpr _Ty2 &&get(pair<_Ty1, _Ty2> &&_Pr) noexcept     {
        return (::std::get<1>(::std::move(_Pr)));
    }
    template <size_t _Idx, class _Ty1, class _Ty2> constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2> > &&get(const pair<_Ty1, _Ty2> &&_Pr) noexcept     {
        using _RRtype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2> > &&;
        return (::std::forward<_RRtype>(::std::get<_Idx>(_Pr)));
    }
    template <class _Ty1, class _Ty2> constexpr const _Ty1 &&get(const pair<_Ty1, _Ty2> &&_Pr) noexcept     {
        return (::std::get<0>(::std::move(_Pr)));
    }
    template <class _Ty2, class _Ty1> constexpr const _Ty2 &&get(const pair<_Ty1, _Ty2> &&_Pr) noexcept     {
        return (::std::get<1>(::std::move(_Pr)));
    }
    template <class _Ty, class _Other = _Ty> inline _Ty exchange(_Ty &_Val, _Other &&_New_val)     {
        _Ty _Old_val = ::std::move(_Val);
        _Val = ::std::forward<_Other>(_New_val);
        return (_Old_val);
    }
    template <class _Ty> constexpr add_const_t<_Ty> &as_const(_Ty &_Val) noexcept     {
        return (_Val);
    }
    template <class _Ty> void as_const(const _Ty &&) = delete
    namespace tr1 {
        using ::std::get;
        using ::std::tuple_element;
        using ::std::tuple_size;
    }
}
extern "C" {
    void __std_reverse_trivially_swappable_1(void *_First, void *_Last) noexcept __declspec(noalias);
    void __std_reverse_trivially_swappable_2(void *_First, void *_Last) noexcept __declspec(noalias);
    void __std_reverse_trivially_swappable_4(void *_First, void *_Last) noexcept __declspec(noalias);
    void __std_reverse_trivially_swappable_8(void *_First, void *_Last) noexcept __declspec(noalias);
}
namespace std {
    struct _Container_proxy;
    struct _Container_base12;
    struct _Iterator_base12;
    struct _Container_base0 {
        void _Orphan_all() noexcept         {
        }
        void _Swap_all(std::_Container_base0 &) noexcept         {
        }
    };
    struct _Iterator_base0 {
        void _Adopt(const void *) noexcept         {
        }
        const std::_Container_base0 *_Getcont() const noexcept         {
            return (nullptr);
        }
        static constexpr bool _Unwrap_when_unverified = true;
    };
    struct _Container_proxy {
        _Container_proxy() noexcept : _Mycont(nullptr), _Myfirstiter(nullptr)         {
        }
        const std::_Container_base12 *_Mycont;
        std::_Iterator_base12 *_Myfirstiter;
    };
    struct _Container_base12 {
    public:
        _Container_base12() : _Myproxy(nullptr)         {
        }
        _Container_base12(const std::_Container_base12 &) noexcept : _Myproxy(nullptr)         {
        }
        std::_Container_base12 &operator=(const std::_Container_base12 &) noexcept         {
            return (*this);
        }
        std::_Iterator_base12 **_Getpfirst() const noexcept         {
            return (this->_Myproxy == nullptr ? nullptr : &this->_Myproxy->_Myfirstiter);
        }
        void _Orphan_all() noexcept;
        void _Swap_all(std::_Container_base12 &) noexcept;
        std::_Container_proxy *_Myproxy;
    };
    struct _Iterator_base12 {
        _Iterator_base12() noexcept : _Myproxy(nullptr), _Mynextiter(nullptr)         {
        }
        _Iterator_base12(const std::_Iterator_base12 &_Right) noexcept : _Myproxy(nullptr), _Mynextiter(nullptr)         {
            *this = _Right;
        }
        std::_Iterator_base12 &operator=(const std::_Iterator_base12 &_Right) noexcept         {
            if (this->_Myproxy != _Right._Myproxy) {
                if (_Right._Myproxy == nullptr) {
                } else {
                    this->_Adopt(_Right._Myproxy->_Mycont);
                }
            }
            return (*this);
        }
        ~_Iterator_base12() noexcept         {
        }
        void _Adopt(const std::_Container_base12 *_Parent) noexcept         {
            if (_Parent == nullptr) {
            } else {
                std::_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
                this->_Myproxy = _Parent_proxy;
            }
        }
        void _Clrcont() noexcept         {
            this->_Myproxy = nullptr;
        }
        const std::_Container_base12 *_Getcont() const noexcept         {
            return (this->_Myproxy == nullptr ? nullptr : this->_Myproxy->_Mycont);
        }
        std::_Iterator_base12 **_Getpnext() noexcept         {
            return (&this->_Mynextiter);
        }
        void _Orphan_me() noexcept         {
        }
        static constexpr bool _Unwrap_when_unverified = 0 == 0;
        std::_Container_proxy *_Myproxy;
        std::_Iterator_base12 *_Mynextiter;
    };
    inline void _Container_base12::_Orphan_all() noexcept     {
    }
    inline void _Container_base12::_Swap_all(std::_Container_base12 &_Right) noexcept     {
        std::_Container_proxy *_Temp = this->_Myproxy;
        this->_Myproxy = _Right._Myproxy;
        _Right._Myproxy = _Temp;
        if (this->_Myproxy != nullptr)
            this->_Myproxy->_Mycont = (std::_Container_base12 *)this;
        if (_Right._Myproxy != nullptr)
            _Right._Myproxy->_Mycont = (std::_Container_base12 *)&_Right;
    }
    using _Container_base = std::_Container_base0;
    using _Iterator_base = std::_Iterator_base0;
    struct _Zero_then_variadic_args_t {
    };
    struct _One_then_variadic_args_t {
    };
    template <class _Ty1, class _Ty2, bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>> class final _Compressed_pair : private _Ty1 {
    private:
        _Ty2 _Myval2;
        using _Mybase = _Ty1;
    public:
        template <class ..._Other2> constexpr explicit _Compressed_pair<_Ty1, _Ty2, >(std::_Zero_then_variadic_args_t, _Other2 &&..._Val2) : _Ty1(), _Myval2(::std::forward<_Other2>(_Val2)...)         {
        }
        template <class _Other1, class ..._Other2> _Compressed_pair<_Ty1, _Ty2, >(std::_One_then_variadic_args_t, _Other1 &&_Val1, _Other2 &&..._Val2) : _Ty1(::std::forward<_Other1>(_Val1)), _Myval2(::std::forward<_Other2>(_Val2)...)         {
        }
        _Ty1 &_Get_first() noexcept         {
            return (*this);
        }
        const _Ty1 &_Get_first() const noexcept         {
            return (*this);
        }
        _Ty2 &_Get_second() noexcept         {
            return (this->_Myval2);
        }
        const _Ty2 &_Get_second() const noexcept         {
            return (this->_Myval2);
        }
    };
template<> class final _Compressed_pair<std::allocator<char>, std::_String_val<std::_Simple_types<char> >, true> : private std::allocator<char> {
    private:
        std::_String_val<std::_Simple_types<char> > _Myval2;
        using _Mybase = std::allocator<char>;
    public:
        template <class ..._Other2> constexpr explicit _Compressed_pair(std::_Zero_then_variadic_args_t, _Other2 &&..._Val2);
        template <class _Other1, class ..._Other2> _Compressed_pair(std::_One_then_variadic_args_t, _Other1 &&_Val1, _Other2 &&..._Val2);
        std::allocator<char> &_Get_first() noexcept;
        const std::allocator<char> &_Get_first() const noexcept;
        std::_String_val<std::_Simple_types<char> > &_Get_second() noexcept;
        const std::_String_val<std::_Simple_types<char> > &_Get_second() const noexcept         {
            return (this->_Myval2);
        }
    };
template<> class final _Compressed_pair<std::default_delete<v8::internal::ScriptStreamingData>, v8::internal::ScriptStreamingData *, true> : private std::default_delete<v8::internal::ScriptStreamingData> {
    private:
        v8::internal::ScriptStreamingData *_Myval2;
        using _Mybase = std::default_delete<v8::internal::ScriptStreamingData>;
    public:
        template <class ..._Other2> constexpr explicit _Compressed_pair(std::_Zero_then_variadic_args_t, _Other2 &&..._Val2);
        template <class _Other1, class ..._Other2> _Compressed_pair(std::_One_then_variadic_args_t, _Other1 &&_Val1, _Other2 &&..._Val2);
        std::default_delete<v8::internal::ScriptStreamingData> &_Get_first() noexcept;
        const std::default_delete<v8::internal::ScriptStreamingData> &_Get_first() const noexcept;
        v8::internal::ScriptStreamingData *&_Get_second() noexcept;
        v8::internal::ScriptStreamingData *const &_Get_second() const noexcept         {
            return (this->_Myval2);
        }
    };
template<> class final _Compressed_pair<std::default_delete<unsigned char const[]>, const unsigned char *, true> : private std::default_delete<unsigned char const[]> {
    private:
        const unsigned char *_Myval2;
        using _Mybase = std::default_delete<unsigned char const[]>;
    public:
        template <class ..._Other2> constexpr explicit _Compressed_pair(std::_Zero_then_variadic_args_t, _Other2 &&..._Val2);
        template<> constexpr explicit _Compressed_pair<<const unsigned char *&>>(std::_Zero_then_variadic_args_t, const unsigned char *&_Val2) : std::default_delete<unsigned char const[]>(), _Myval2(::std::forward<const unsigned char *&>(_Val2))         {
        }
;
        template <class _Other1, class ..._Other2> _Compressed_pair(std::_One_then_variadic_args_t, _Other1 &&_Val1, _Other2 &&..._Val2);
        template<> _Compressed_pair<std::default_delete<unsigned char const[]>, <const unsigned char *&>>(std::_One_then_variadic_args_t, std::default_delete<unsigned char const[]> &&_Val1, const unsigned char *&_Val2) : std::default_delete<unsigned char const[]>(::std::forward<std::default_delete<unsigned char const[]> >(_Val1)), _Myval2(::std::forward<const unsigned char *&>(_Val2))         {
        }
;
        std::default_delete<unsigned char const[]> &_Get_first() noexcept         {
            return (*this);
        }
        const std::default_delete<unsigned char const[]> &_Get_first() const noexcept;
        const unsigned char *&_Get_second() noexcept         {
            return (this->_Myval2);
        }
        const unsigned char *const &_Get_second() const noexcept         {
            return (this->_Myval2);
        }
    };
template<> class final _Compressed_pair<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, v8::WasmStreaming::WasmStreamingImpl *, true> : private std::default_delete<v8::WasmStreaming::WasmStreamingImpl> {
    private:
        v8::WasmStreaming::WasmStreamingImpl *_Myval2;
        using _Mybase = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>;
    public:
        template <class ..._Other2> constexpr explicit _Compressed_pair(std::_Zero_then_variadic_args_t, _Other2 &&..._Val2);
        template <class _Other1, class ..._Other2> _Compressed_pair(std::_One_then_variadic_args_t, _Other1 &&_Val1, _Other2 &&..._Val2);
        std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &_Get_first() noexcept;
        const std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &_Get_first() const noexcept;
        v8::WasmStreaming::WasmStreamingImpl *&_Get_second() noexcept;
        v8::WasmStreaming::WasmStreamingImpl *const &_Get_second() const noexcept;
    };
    template <class _Ty1, class _Ty2> class final _Compressed_pair<_Ty1, _Ty2, false> {
    private:
        _Ty1 _Myval1;
        _Ty2 _Myval2;
    public:
        template <class ..._Other2> constexpr explicit _Compressed_pair<type-parameter-0-0, type-parameter-0-1, false>(std::_Zero_then_variadic_args_t, _Other2 &&..._Val2) : _Myval1(), _Myval2(::std::forward<_Other2>(_Val2)...)         {
        }
        template <class _Other1, class ..._Other2> _Compressed_pair<type-parameter-0-0, type-parameter-0-1, false>(std::_One_then_variadic_args_t, _Other1 &&_Val1, _Other2 &&..._Val2) : _Myval1(::std::forward<_Other1>(_Val1)), _Myval2(::std::forward<_Other2>(_Val2)...)         {
        }
        _Ty1 &_Get_first() noexcept         {
            return (this->_Myval1);
        }
        const _Ty1 &_Get_first() const noexcept         {
            return (this->_Myval1);
        }
        _Ty2 &_Get_second() noexcept         {
            return (this->_Myval2);
        }
        const _Ty2 &_Get_second() const noexcept         {
            return (this->_Myval2);
        }
    };
    template <class _Fx> struct _Ref_fn {
        template <class ..._Args> constexpr decltype(auto) operator()(_Args &&..._Vals)         {
            return (this->_Fn(::std::forward<_Args>(_Vals)...));
        }
        _Fx &_Fn;
    };
    template <class _Fn> constexpr bool _Pass_functor_by_value_v = sizeof(_Fn) <= sizeof(void *) && conjunction_v<is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn> >;
    template <class _Fn, enable_if_t<_Pass_functor_by_value_v<_Fn>, int> = 0> constexpr _Fn _Pass_fn(_Fn _Val)     {
        return (_Val);
    }
    template <class _Fn, enable_if_t<!_Pass_functor_by_value_v<_Fn>, int> = 0> constexpr _Ref_fn<_Fn> _Pass_fn(_Fn &_Val)     {
        return {_Val};
    }
    struct input_iterator_tag {
    };
    struct output_iterator_tag {
    };
    struct forward_iterator_tag : std::input_iterator_tag {
    };
    struct bidirectional_iterator_tag : std::forward_iterator_tag {
    };
    struct random_access_iterator_tag : std::bidirectional_iterator_tag {
    };
    struct _General_ptr_iterator_tag {
    };
    struct _Trivially_copyable_ptr_iterator_tag : std::_General_ptr_iterator_tag {
    };
    struct _Really_trivial_ptr_iterator_tag : std::_Trivially_copyable_ptr_iterator_tag {
    };
    struct _Unused_parameter {
        _Unused_parameter() = default
        template <class _Ty> constexpr _Unused_parameter(_Ty &&) noexcept         {
        }
    };
    using _Any_tag = std::_Unused_parameter;
    template <class _Ty> using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;
    template <class , class  = void> struct _Iterator_traits_base {
    };
    template <class _Iter> struct _Iterator_traits_base<_Iter, void> {
        using iterator_category = typename _Iter::iterator_category;
        using value_type = typename _Iter::value_type;
        using difference_type = typename _Iter::difference_type;
        using pointer = typename _Iter::pointer;
        using reference = typename _Iter::reference;
    };
    template <class _Ty, bool = is_object_v<_Ty>> struct _Iterator_traits_pointer_base {
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<_Ty>;
        using difference_type = ptrdiff_t;
        using pointer = _Ty *;
        using reference = _Ty &;
    };
    template <class _Ty> struct _Iterator_traits_pointer_base<_Ty, false> {
    };
    template <class _Iter> struct iterator_traits : _Iterator_traits_base<_Iter> {
    };
    template <class _Ty> struct iterator_traits<type-parameter-0-0 *> : _Iterator_traits_pointer_base<_Ty> {
    };
    template <class _Iter> using _Iter_value_t = typename iterator_traits<_Iter>::value_type;
    template <class _Iter> using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;
    template <class ..._Iters> using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;
    template <class _Iter> using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;
    template <class _Ty, class  = void> constexpr bool _Is_iterator_v = false;
    constexpr bool _Is_iterator_v = true;
    template <class _Ty> struct _Is_iterator : bool_constant<_Is_iterator_v<_Ty> > {
    };
    template <class _Iter> constexpr bool _Is_input_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, std::input_iterator_tag>;
    template <class _Iter> constexpr bool _Is_fwd_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, std::forward_iterator_tag>;
    template <class _Iter> constexpr bool _Is_bidi_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, std::bidirectional_iterator_tag>;
    template <class _Iter> constexpr bool _Is_random_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, std::random_access_iterator_tag>;
    template <class , class  = void> struct _Is_checked_helper {
    };
    template <class _Iter, class _Sentinel = _Iter, class  = void> struct _Range_verifiable : std::false_type {
    };
    template <class _Iter, class _Sentinel> struct _Range_verifiable<_Iter, _Sentinel, void> : std::true_type {
    };
    template <class _Iter, class _Sentinel = _Iter> constexpr bool _Range_verifiable_v = _Range_verifiable<_Iter, _Sentinel>::value;
    template <class _Iter, class _Sentinel> constexpr void _Adl_verify_range1(const _Iter &_First, const _Sentinel &_Last, std::true_type)     {
        _Verify_range(_First, _Last);
    }
    template <class _Iter, class _Sentinel> constexpr void _Adl_verify_range1(const _Iter &, const _Sentinel &, std::false_type)     {
    }
    template <class _Iter, class _Sentinel> constexpr void _Adl_verify_range(const _Iter &_First, const _Sentinel &_Last)     {
        _Adl_verify_range1(_First, _Last, bool_constant<_Range_verifiable_v<_Iter, _Sentinel> >({}));
    }
    template <class _Iter, class  = void> struct _Unwrappable : std::false_type {
    };
    template <class _Iter> struct _Unwrappable<_Iter, void> : std::true_type {
    };
    template <class _Iter> constexpr bool _Unwrappable_v = _Unwrappable<_Iter>::value;
    template <class _Iter, enable_if_t<_Unwrappable_v<_Iter>, int> = 0> constexpr auto _Get_unwrapped(const _Iter &_It)     {
        return (_It._Unwrapped());
    }
    template <class _Iter, enable_if_t<!_Unwrappable_v<_Iter>, int> = 0> constexpr const _Iter &_Get_unwrapped(const _Iter &_It)     {
        return (_It);
    }
    template <class _Iter, enable_if_t<!_Unwrappable_v<_Iter>, int> = 0> constexpr const _Iter &&_Get_unwrapped(const _Iter &&_It)     {
        return (static_cast<const _Iter &&>(_It));
    }
    template <class _Ty> constexpr _Ty *_Get_unwrapped(_Ty *const _Ptr)     {
        return (_Ptr);
    }
    template <class _Iter> using _Unwrapped_t = remove_cv_t<remove_reference_t<decltype(_Get_unwrapped(::std::declval<const _Iter &>()))> >;
    template <class _Iter, class  = bool> struct _Do_unwrap_when_unverified : std::false_type {
    };
    template <class _Iter> struct _Do_unwrap_when_unverified<_Iter, decltype(static_cast<bool>(_Iter::_Unwrap_when_unverified))> : bool_constant<static_cast<bool>(_Iter::_Unwrap_when_unverified)> {
    };
    template <class _Iter> constexpr bool _Do_unwrap_when_unverified_v = _Do_unwrap_when_unverified<_Iter>::value;
    template <class _Iter> constexpr bool _Unwrappable_for_unverified_v = _Unwrappable_v<_Iter> && _Do_unwrap_when_unverified_v<_Iter>;
    template <class _Iter, enable_if_t<_Unwrappable_for_unverified_v<_Iter>, int> = 0> constexpr auto _Get_unwrapped_unverified(const _Iter &_It)     {
        return (_It._Unwrapped());
    }
    template <class _Iter, enable_if_t<!_Unwrappable_for_unverified_v<_Iter>, int> = 0> constexpr const _Iter &_Get_unwrapped_unverified(const _Iter &_It)     {
        return (_It);
    }
    template <class _Iter, enable_if_t<!_Unwrappable_for_unverified_v<_Iter>, int> = 0> constexpr const _Iter &&_Get_unwrapped_unverified(const _Iter &&_It)     {
        return (static_cast<const _Iter &&>(_It));
    }
    template <class _Ty> constexpr _Ty *_Get_unwrapped_unverified(_Ty *const _Ptr)     {
        return (_Ptr);
    }
    template <class _Iter> using _Unwrapped_unverified_t = remove_cv_t<remove_reference_t<decltype(_Get_unwrapped_unverified(::std::declval<const _Iter &>()))> >;
    struct _Distance_unknown {
        constexpr std::_Distance_unknown operator-() const noexcept         {
            return {};
        }
    };
    template <class _Diff> constexpr _Diff _Max_possible_v = static_cast<_Diff>(static_cast<make_unsigned_t<_Diff>>(-1) >> 1);
    template <class _Diff> constexpr _Diff _Min_possible_v = -_Max_possible_v<_Diff> - 1;
    template <class _Iter, class  = void> struct _Offset_verifiable : std::false_type {
    };
    template <class _Iter> struct _Offset_verifiable<_Iter, void> : std::true_type {
    };
    template <class _Iter> constexpr bool _Offset_verifiable_v = _Offset_verifiable<_Iter>::value;
    template <class _Iter> constexpr bool _Unwrappable_for_offset_v = _Unwrappable_v<_Iter> && _Offset_verifiable_v<_Iter>;
    template <class _Iter, class _Diff, enable_if_t<_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>, int> = 0> constexpr auto _Get_unwrapped_n(const _Iter &_It, const _Diff _Off)     {
        using _IDiff = _Iter_diff_t<_Iter>;
        using _CDiff = common_type_t<_Diff, _IDiff>;
        const auto _COff = static_cast<_CDiff>(_Off);
        ;
        (void)_COff;
        _It._Verify_offset(static_cast<_IDiff>(_Off));
        return (_It._Unwrapped());
    }
    template <class _Iter, class _Diff, enable_if_t<_Unwrappable_for_unverified_v<_Iter> && ((!_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) || is_same_v<_Diff, std::_Distance_unknown>), int> = 0> constexpr auto _Get_unwrapped_n(const _Iter &_It, _Diff)     {
        return (_It._Unwrapped());
    }
    template <class _Iter, class _Diff, enable_if_t<!_Unwrappable_for_unverified_v<_Iter> && ((!_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) || is_same_v<_Diff, std::_Distance_unknown>), int> = 0> constexpr const _Iter &_Get_unwrapped_n(const _Iter &_It, _Diff)     {
        return (_It);
    }
    template <class _Iter, class _Diff, enable_if_t<!_Unwrappable_for_unverified_v<_Iter> && ((!_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) || is_same_v<_Diff, std::_Distance_unknown>), int> = 0> constexpr const _Iter &&_Get_unwrapped_n(const _Iter &&_It, _Diff)     {
        return (static_cast<const _Iter &&>(_It));
    }
    template <class _Ty, class _Diff, enable_if_t<is_same_v<_Diff, std::_Distance_unknown> || is_integral_v<_Diff>, int> = 0> constexpr _Ty *_Get_unwrapped_n(_Ty *const _Src, _Diff)     {
        return (_Src);
    }
    template <class _Iter> using _Unwrapped_n_t = remove_cv_t<remove_reference_t<decltype(_Get_unwrapped_n(::std::declval<const _Iter &>(), _Iter_diff_t<_Iter>({})))> >;
    template <class _Iter, class _UIter, class  = void> struct _Wrapped_seekable : std::false_type {
    };
    template <class _Iter, class _UIter> struct _Wrapped_seekable<_Iter, _UIter, void> : std::true_type {
    };
    template <class _Iter, class _UIter> constexpr bool _Wrapped_seekable_v = _Wrapped_seekable<_Iter, _UIter>::value;
    template <class _Iter, class _UIter, enable_if_t<_Wrapped_seekable_v<_Iter, _UIter>, int> = 0> constexpr void _Seek_wrapped(_Iter &_It, const _UIter &_UIt)     {
        _It._Seek_to(_UIt);
    }
    template <class _Iter, class _UIter, enable_if_t<!_Wrapped_seekable_v<_Iter, _UIter>, int> = 0> constexpr void _Seek_wrapped(_Iter &_It, const _UIter &_UIt)     {
        _It = _UIt;
    }
    template <class _Ty> constexpr void _Seek_wrapped(_Ty *&_It, _Ty *const _UIt)     {
        _It = _UIt;
    }
    template <size_t _Value> struct _Priority_tag : _Priority_tag<_Value - 1> {
    };
    template<> struct _Priority_tag<0> {
    };
    template <class _Checked, class _Iter> inline std::_Distance_unknown _Idl_distance1(const _Iter &, const _Iter &, std::input_iterator_tag)     {
        return {};
    }
    template <class _Checked, class _Iter> inline _Iter_diff_t<_Checked> _Idl_distance1(const _Iter &_First, const _Iter &_Last, std::random_access_iterator_tag)     {
        return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));
    }
    template <class _Checked, class _Iter> inline auto _Idl_distance(const _Iter &_First, const _Iter &_Last)     {
        return (_Idl_distance1<_Checked>(_First, _Last, _Iter_cat_t<_Iter>()));
    }
    template <class _Ty1, class _Ty2> struct _Is_same_size : bool_constant<sizeof(_Ty1) == sizeof(_Ty2)> {
    };
    template <class _Elem, bool _Is_enum = is_enum_v<_Elem>> struct _Unwrap_enum {
        using type = underlying_type_t<_Elem>;
    };
    template <class _Elem> struct _Unwrap_enum<_Elem, false> {
        using type = _Elem;
    };
    template <class _Elem> using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;
    template <class _Ty1, class _Ty2> struct _Both_or_neither_bool : bool_constant<is_same_v<bool, _Ty1> == is_same_v<bool, _Ty2> > {
    };
    template <class _Source, class _Dest> struct _Ptr_cat_helper {
        using _USource = _Unwrap_enum_t<_Source>;
        using _UDest = _Unwrap_enum_t<_Dest>;
        using type = conditional_t<conjunction_v<_Is_same_size<std::_Ptr_cat_helper::_USource, std::_Ptr_cat_helper::_UDest>, is_integral<std::_Ptr_cat_helper::_USource>, is_integral<std::_Ptr_cat_helper::_UDest>, _Both_or_neither_bool<std::_Ptr_cat_helper::_USource, std::_Ptr_cat_helper::_UDest> >, std::_Really_trivial_ptr_iterator_tag, std::_General_ptr_iterator_tag>;
    };
    template <class _Elem> struct _Ptr_cat_helper<_Elem, _Elem> {
        using type = conditional_t<is_trivially_copyable_v<_Elem>, conditional_t<is_trivial_v<_Elem>, std::_Really_trivial_ptr_iterator_tag, std::_Trivially_copyable_ptr_iterator_tag>, std::_General_ptr_iterator_tag>;
    };
    template <class _Anything> struct _Ptr_cat_helper<type-parameter-0-0 *, const type-parameter-0-0 *> {
        using type = std::_Really_trivial_ptr_iterator_tag;
    };
    template <class _Anything> struct _Ptr_cat_helper<type-parameter-0-0 *, volatile type-parameter-0-0 *> {
        using type = std::_Really_trivial_ptr_iterator_tag;
    };
    template <class _Anything> struct _Ptr_cat_helper<type-parameter-0-0 *, const volatile type-parameter-0-0 *> {
        using type = std::_Really_trivial_ptr_iterator_tag;
    };
    template <class _Source, class _Dest> inline std::_General_ptr_iterator_tag _Ptr_copy_cat(const _Source &, const _Dest &)     {
        return {};
    }
    template <class _Source, class _Dest> inline conditional_t<is_trivially_assignable_v<_Dest &, _Source &>, typename _Ptr_cat_helper<remove_cv_t<_Source>, remove_cv_t<_Dest> >::type, std::_General_ptr_iterator_tag> _Ptr_copy_cat(_Source *const &, _Dest *const &)     {
        return {};
    }
    template <class _Source, class _Dest> inline std::_General_ptr_iterator_tag _Ptr_move_cat(const _Source &, const _Dest &)     {
        return {};
    }
    template <class _Source, class _Dest> inline conditional_t<is_trivially_assignable_v<_Dest &, _Source>, typename _Ptr_cat_helper<remove_cv_t<_Source>, remove_cv_t<_Dest> >::type, std::_General_ptr_iterator_tag> _Ptr_move_cat(_Source *const &, _Dest *const &)     {
        return {};
    }
    template <class _InIt, class _Diff> inline void _Advance1(_InIt &_Where, _Diff _Off, std::input_iterator_tag)     {
        ;
        for (; 0 < _Off; --_Off) {
            ++_Where;
        }
    }
    template <class _BidIt, class _Diff> inline void _Advance1(_BidIt &_Where, _Diff _Off, std::bidirectional_iterator_tag)     {
        for (; 0 < _Off; --_Off) {
            ++_Where;
        }
        for (; _Off < 0; ++_Off) {
            --_Where;
        }
    }
    template <class _RanIt, class _Diff> inline void _Advance1(_RanIt &_Where, _Diff _Off, std::random_access_iterator_tag)     {
        _Where += _Off;
    }
    template <class _InIt, class _Diff> inline void advance(_InIt &_Where, _Diff _Off)     {
        _Advance1(_Where, _Off, _Iter_cat_t<remove_const_t<_InIt> >());
    }
    template <class _InIt> inline _Iter_diff_t<_InIt> _Distance1(_InIt _First, _InIt _Last, std::input_iterator_tag)     {
        _Iter_diff_t<_InIt> _Off = 0;
        for (; _First != _Last; ++_First) {
            ++_Off;
        }
        return (_Off);
    }
    template <class _RanIt> inline _Iter_diff_t<_RanIt> _Distance1(_RanIt _First, _RanIt _Last, std::random_access_iterator_tag)     {
        return (_Last - _First);
    }
    template <class _InIt> inline _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last)     {
        return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));
    }
    template <class _InIt> constexpr _InIt _Next_iter(_InIt _First)     {
        return (++_First);
    }
    template <class _InIt> inline _InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1)     {
        static_assert(_Is_input_iter_v<_InIt>, "next requires input iterator");
        ::std::advance(_First, _Off);
        return (_First);
    }
    template <class _BidIt> constexpr _BidIt _Prev_iter(_BidIt _First)     {
        return (--_First);
    }
    template <class _BidIt> inline _BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1)     {
        static_assert(_Is_bidi_iter_v<_BidIt>, "prev requires bidirectional iterator");
        ::std::advance(_First, -_Off);
        return (_First);
    }
    template <class _Ty> struct pointer_traits;
    template <class _Iterator> constexpr _Iterator _Operator_arrow(_Iterator _Target, std::true_type)     {
        return (_Target);
    }
    template <class _Iterator> constexpr decltype(auto) _Operator_arrow(_Iterator &&_Target, std::false_type)     {
        return (::std::forward<_Iterator>(_Target).operator->());
    }
    template <class _BidIt> class reverse_iterator {
    public:
        using iterator_category = typename iterator_traits<_BidIt>::iterator_category;
        using value_type = typename iterator_traits<_BidIt>::value_type;
        using difference_type = typename iterator_traits<_BidIt>::difference_type;
        using pointer = typename iterator_traits<_BidIt>::pointer;
        using reference = typename iterator_traits<_BidIt>::reference;
        using iterator_type = _BidIt;
        inline reverse_iterator<_BidIt>() : current()         {
        }
        inline explicit reverse_iterator<_BidIt>(_BidIt _Right) : current(_Right)         {
        }
        template <class _Other> inline reverse_iterator<_BidIt>(const reverse_iterator<_Other> &_Right) : current(_Right.base())         {
        }
        template <class _Other> inline reverse_iterator<_BidIt> &operator=(const reverse_iterator<_Other> &_Right)         {
            this->current = _Right.base();
            return (*this);
        }
        inline _BidIt base() const         {
            return (this->current);
        }
        inline std::reverse_iterator::reference operator*() const         {
            _BidIt _Tmp = this->current;
            return (*--_Tmp);
        }
        inline std::reverse_iterator::pointer operator->() const         {
            _BidIt _Tmp = this->current;
            --_Tmp;
            return (_Operator_arrow(_Tmp, is_pointer<_BidIt>()));
        }
        inline reverse_iterator<_BidIt> &operator++()         {
            --this->current;
            return (*this);
        }
        inline reverse_iterator<_BidIt> operator++(int)         {
            reverse_iterator<_BidIt> _Tmp = *this;
            --this->current;
            return (_Tmp);
        }
        inline reverse_iterator<_BidIt> &operator--()         {
            ++this->current;
            return (*this);
        }
        inline reverse_iterator<_BidIt> operator--(int)         {
            reverse_iterator<_BidIt> _Tmp = *this;
            ++this->current;
            return (_Tmp);
        }
        inline reverse_iterator<_BidIt> &operator+=(const std::reverse_iterator::difference_type _Off)         {
            this->current -= _Off;
            return (*this);
        }
        inline reverse_iterator<_BidIt> operator+(const std::reverse_iterator::difference_type _Off) const         {
            return (reverse_iterator<_BidIt>(this->current - _Off));
        }
        inline reverse_iterator<_BidIt> &operator-=(const std::reverse_iterator::difference_type _Off)         {
            this->current += _Off;
            return (*this);
        }
        inline reverse_iterator<_BidIt> operator-(const std::reverse_iterator::difference_type _Off) const         {
            return (reverse_iterator<_BidIt>(this->current + _Off));
        }
        inline std::reverse_iterator::reference operator[](const std::reverse_iterator::difference_type _Off) const         {
            return (*(*this + _Off));
        }
        template <class _BidIt2 = _BidIt, enable_if_t<_Offset_verifiable_v<_BidIt2>, int> = 0> constexpr void _Verify_offset(const std::reverse_iterator::difference_type _Off) const         {
            do {
                if (_Off != _Min_possible_v<std::reverse_iterator::difference_type>) {
                } else {
                    do {
                        ;
                        ::_invalid_parameter_noinfo_noreturn();
                    } while (false);
                }
                ;
            } while (false);
            this->current._Verify_offset(-_Off);
        }
        template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<_BidIt2>, int> = 0> constexpr reverse_iterator<_Unwrapped_t<_BidIt2> > _Unwrapped() const         {
            return (static_cast<reverse_iterator<_Unwrapped_t<_BidIt2> >>(this->current._Unwrapped()));
        }
        static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_BidIt>;
        template <class _Src, enable_if_t<_Wrapped_seekable_v<_BidIt, _Src>, int> = 0> constexpr void _Seek_to(const reverse_iterator<_Src> &_It)         {
            this->current._Seek_to(_It.base());
        }
    protected:
        _BidIt current;
    };
    template <class _BidIt, class _BidIt2, enable_if_t<_Range_verifiable_v<_BidIt, _BidIt2>, int> = 0> constexpr void _Verify_range(const reverse_iterator<_BidIt> &_First, const reverse_iterator<_BidIt2> &_Last)     {
        _Verify_range(_Last.base(), _First.base());
    }
    template <class _BidIt> inline reverse_iterator<_BidIt> operator+(typename reverse_iterator<_BidIt>::difference_type _Off, const reverse_iterator<_BidIt> &_Right)     {
        return (_Right + _Off);
    }
    template <class _BidIt1, class _BidIt2> inline auto operator-(const reverse_iterator<_BidIt1> &_Left, const reverse_iterator<_BidIt2> &_Right) -> decltype(_Right.base() - _Left.base())     {
        return (_Right.base() - _Left.base());
    }
    template <class _BidIt1, class _BidIt2> inline bool operator==(const reverse_iterator<_BidIt1> &_Left, const reverse_iterator<_BidIt2> &_Right)     {
        return (_Left.base() == _Right.base());
    }
    template <class _BidIt1, class _BidIt2> inline bool operator!=(const reverse_iterator<_BidIt1> &_Left, const reverse_iterator<_BidIt2> &_Right)     {
        return (!(_Left == _Right));
    }
    template <class _BidIt1, class _BidIt2> inline bool operator<(const reverse_iterator<_BidIt1> &_Left, const reverse_iterator<_BidIt2> &_Right)     {
        return (_Right.base() < _Left.base());
    }
    template <class _BidIt1, class _BidIt2> inline bool operator>(const reverse_iterator<_BidIt1> &_Left, const reverse_iterator<_BidIt2> &_Right)     {
        return (_Right < _Left);
    }
    template <class _BidIt1, class _BidIt2> inline bool operator<=(const reverse_iterator<_BidIt1> &_Left, const reverse_iterator<_BidIt2> &_Right)     {
        return (!(_Right < _Left));
    }
    template <class _BidIt1, class _BidIt2> inline bool operator>=(const reverse_iterator<_BidIt1> &_Left, const reverse_iterator<_BidIt2> &_Right)     {
        return (!(_Left < _Right));
    }
    template <class _BidIt> inline reverse_iterator<_BidIt> make_reverse_iterator(_BidIt _Iter)     {
        return (reverse_iterator<_BidIt>(_Iter));
    }
    template <class _Container> inline auto begin(_Container &_Cont) -> decltype(_Cont.begin())     {
        return (_Cont.begin());
    }
    template <class _Container> inline auto begin(const _Container &_Cont) -> decltype(_Cont.begin())     {
        return (_Cont.begin());
    }
    template <class _Container> inline auto end(_Container &_Cont) -> decltype(_Cont.end())     {
        return (_Cont.end());
    }
    template <class _Container> inline auto end(const _Container &_Cont) -> decltype(_Cont.end())     {
        return (_Cont.end());
    }
    template <class _Ty, size_t _Size> constexpr _Ty *begin(_Ty (&_Array)[_Size]) noexcept     {
        return (_Array);
    }
    template <class _Ty, size_t _Size> constexpr _Ty *end(_Ty (&_Array)[_Size]) noexcept     {
        return (_Array + _Size);
    }
    template <class _Container> constexpr auto cbegin(const _Container &_Cont) noexcept(noexcept(::std::begin(_Cont))cbegin(const _Container &_Cont) noexcept(noexcept(::std::begin(_Cont))) -> decltype(::std::begin(_Cont))     {
        return (::std::begin(_Cont));
    }
    template <class _Container> constexpr auto cend(const _Container &_Cont) noexcept(noexcept(::std::end(_Cont))cend(const _Container &_Cont) noexcept(noexcept(::std::end(_Cont))) -> decltype(::std::end(_Cont))     {
        return (::std::end(_Cont));
    }
    template <class _Container> inline auto rbegin(_Container &_Cont) -> decltype(_Cont.rbegin())     {
        return (_Cont.rbegin());
    }
    template <class _Container> inline auto rbegin(const _Container &_Cont) -> decltype(_Cont.rbegin())     {
        return (_Cont.rbegin());
    }
    template <class _Container> inline auto rend(_Container &_Cont) -> decltype(_Cont.rend())     {
        return (_Cont.rend());
    }
    template <class _Container> inline auto rend(const _Container &_Cont) -> decltype(_Cont.rend())     {
        return (_Cont.rend());
    }
    template <class _Ty, size_t _Size> inline reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])     {
        return (reverse_iterator<_Ty *>(_Array + _Size));
    }
    template <class _Ty, size_t _Size> inline reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])     {
        return (reverse_iterator<_Ty *>(_Array));
    }
    template <class _Elem> inline reverse_iterator<const _Elem *> rbegin(initializer_list<_Elem> _Ilist)     {
        return (reverse_iterator<const _Elem *>(_Ilist.end()));
    }
    template <class _Elem> inline reverse_iterator<const _Elem *> rend(initializer_list<_Elem> _Ilist)     {
        return (reverse_iterator<const _Elem *>(_Ilist.begin()));
    }
    template <class _Container> inline auto crbegin(const _Container &_Cont) -> decltype(::std::rbegin(_Cont))     {
        return (::std::rbegin(_Cont));
    }
    template <class _Container> inline auto crend(const _Container &_Cont) -> decltype(::std::rend(_Cont))     {
        return (::std::rend(_Cont));
    }
    template <class _Container> constexpr auto size(const _Container &_Cont) -> decltype(_Cont.size())     {
        return (_Cont.size());
    }
    template <class _Ty, size_t _Size> constexpr size_t size(const _Ty (&)[_Size]) noexcept     {
        return (_Size);
    }
    template <class _Container> constexpr auto empty(const _Container &_Cont) -> decltype(_Cont.empty())     {
        return (_Cont.empty());
    }
    template <class _Ty, size_t _Size> constexpr bool empty(const _Ty (&)[_Size]) noexcept     {
        return (false);
    }
    template <class _Elem> constexpr bool empty(initializer_list<_Elem> _Ilist) noexcept     {
        return (_Ilist.size() == 0);
    }
    template <class _Container> constexpr auto data(_Container &_Cont) -> decltype(_Cont.data())     {
        return (_Cont.data());
    }
    template <class _Container> constexpr auto data(const _Container &_Cont) -> decltype(_Cont.data())     {
        return (_Cont.data());
    }
    template <class _Ty, size_t _Size> constexpr _Ty *data(_Ty (&_Array)[_Size]) noexcept     {
        return (_Array);
    }
    template <class _Elem> constexpr const _Elem *data(initializer_list<_Elem> _Ilist) noexcept     {
        return (_Ilist.begin());
    }
    template <class _Ty, size_t _Size> class _Array_const_iterator {
    public:
        using iterator_category = std::random_access_iterator_tag;
        using value_type = _Ty;
        using difference_type = ptrdiff_t;
        using pointer = const _Ty *;
        using reference = const _Ty &;
        enum  {
            _EEN_SIZE = _Size
        };
        inline _Array_const_iterator<_Ty, _Size>() : _Ptr()         {
        }
        inline explicit _Array_const_iterator<_Ty, _Size>(std::_Array_const_iterator::pointer _Parg, size_t _Off = 0) : _Ptr(_Parg + _Off)         {
        }
        inline std::_Array_const_iterator::reference operator*() const         {
            return (*this->_Ptr);
        }
        inline std::_Array_const_iterator::pointer operator->() const         {
            return (this->_Ptr);
        }
        inline _Array_const_iterator<_Ty, _Size> &operator++()         {
            ++this->_Ptr;
            return (*this);
        }
        inline _Array_const_iterator<_Ty, _Size> operator++(int)         {
            _Array_const_iterator<_Ty, _Size> _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        inline _Array_const_iterator<_Ty, _Size> &operator--()         {
            --this->_Ptr;
            return (*this);
        }
        inline _Array_const_iterator<_Ty, _Size> operator--(int)         {
            _Array_const_iterator<_Ty, _Size> _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        inline _Array_const_iterator<_Ty, _Size> &operator+=(const ptrdiff_t _Off)         {
            this->_Ptr += _Off;
            return (*this);
        }
        inline _Array_const_iterator<_Ty, _Size> operator+(const ptrdiff_t _Off) const         {
            _Array_const_iterator<_Ty, _Size> _Tmp = *this;
            return (_Tmp += _Off);
        }
        inline _Array_const_iterator<_Ty, _Size> &operator-=(const ptrdiff_t _Off)         {
            return (*this += -_Off);
        }
        inline _Array_const_iterator<_Ty, _Size> operator-(const ptrdiff_t _Off) const         {
            _Array_const_iterator<_Ty, _Size> _Tmp = *this;
            return (_Tmp -= _Off);
        }
        inline ptrdiff_t operator-(const _Array_const_iterator<_Ty, _Size> &_Right) const         {
            return (this->_Ptr - _Right._Ptr);
        }
        inline std::_Array_const_iterator::reference operator[](const ptrdiff_t _Off) const         {
            return (*(*this + _Off));
        }
        inline bool operator==(const _Array_const_iterator<_Ty, _Size> &_Right) const         {
            return (this->_Ptr == _Right._Ptr);
        }
        inline bool operator!=(const _Array_const_iterator<_Ty, _Size> &_Right) const         {
            return (!(*this == _Right));
        }
        inline bool operator<(const _Array_const_iterator<_Ty, _Size> &_Right) const         {
            return (this->_Ptr < _Right._Ptr);
        }
        inline bool operator>(const _Array_const_iterator<_Ty, _Size> &_Right) const         {
            return (_Right < *this);
        }
        inline bool operator<=(const _Array_const_iterator<_Ty, _Size> &_Right) const         {
            return (!(_Right < *this));
        }
        inline bool operator>=(const _Array_const_iterator<_Ty, _Size> &_Right) const         {
            return (!(*this < _Right));
        }
        constexpr std::_Array_const_iterator::pointer _Unwrapped() const         {
            return (this->_Ptr);
        }
        static constexpr bool _Unwrap_when_unverified = true;
        constexpr void _Seek_to(std::_Array_const_iterator::pointer _It)         {
            this->_Ptr = _It;
        }
    private:
        std::_Array_const_iterator::pointer _Ptr;
    };
    template <class _Ty, size_t _Size> inline _Array_const_iterator<_Ty, _Size> operator+(ptrdiff_t _Off, _Array_const_iterator<_Ty, _Size> _Next)     {
        return (_Next += _Off);
    }
    template <class _Ty, size_t _Size> class _Array_iterator : public _Array_const_iterator<_Ty, _Size> {
    public:
        using _Mybase = _Array_const_iterator<_Ty, _Size>;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = _Ty;
        using difference_type = ptrdiff_t;
        using pointer = _Ty *;
        using reference = _Ty &;
        inline _Array_iterator<_Ty, _Size>()         {
        }
        inline explicit _Array_iterator<_Ty, _Size>(std::_Array_iterator::pointer _Parg, size_t _Off = 0) : std::_Array_iterator::_Mybase(_Parg, _Off)         {
        }
        enum  {
            _EEN_SIZE = _Size
        };
        inline std::_Array_iterator::reference operator*() const         {
            return (const_cast<std::_Array_iterator::reference>(_Mybase::operator*()));
        }
        inline std::_Array_iterator::pointer operator->() const         {
            return (const_cast<std::_Array_iterator::pointer>(_Mybase::operator->()));
        }
        inline _Array_iterator<_Ty, _Size> &operator++()         {
            ++*static_cast<std::_Array_iterator::_Mybase *>(this);
            return (*this);
        }
        inline _Array_iterator<_Ty, _Size> operator++(int)         {
            _Array_iterator<_Ty, _Size> _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        inline _Array_iterator<_Ty, _Size> &operator--()         {
            --*static_cast<std::_Array_iterator::_Mybase *>(this);
            return (*this);
        }
        inline _Array_iterator<_Ty, _Size> operator--(int)         {
            _Array_iterator<_Ty, _Size> _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        inline _Array_iterator<_Ty, _Size> &operator+=(const ptrdiff_t _Off)         {
            *static_cast<std::_Array_iterator::_Mybase *>(this) += _Off;
            return (*this);
        }
        inline _Array_iterator<_Ty, _Size> operator+(const ptrdiff_t _Off) const         {
            _Array_iterator<_Ty, _Size> _Tmp = *this;
            return (_Tmp += _Off);
        }
        inline _Array_iterator<_Ty, _Size> &operator-=(const ptrdiff_t _Off)         {
            return (*this += -_Off);
        }
        inline _Array_iterator<_Ty, _Size> operator-(const ptrdiff_t _Off) const         {
            _Array_iterator<_Ty, _Size> _Tmp = *this;
            return (_Tmp -= _Off);
        }
        inline ptrdiff_t operator-(const std::_Array_iterator::_Mybase &_Right) const         {
            return (*static_cast<const std::_Array_iterator::_Mybase *>(this) - _Right);
        }
        inline std::_Array_iterator::reference operator[](const ptrdiff_t _Off) const         {
            return (*(*this + _Off));
        }
        constexpr std::_Array_iterator::pointer _Unwrapped() const         {
            return (const_cast<std::_Array_iterator::pointer>(_Mybase::_Unwrapped()));
        }
    };
    template <class _Ty, size_t _Size> inline _Array_iterator<_Ty, _Size> operator+(ptrdiff_t _Off, _Array_iterator<_Ty, _Size> _Next)     {
        return (_Next += _Off);
    }
    template <class _Iter> class move_iterator {
    public:
        using iterator_category = typename iterator_traits<_Iter>::iterator_category;
        using value_type = typename iterator_traits<_Iter>::value_type;
        using difference_type = typename iterator_traits<_Iter>::difference_type;
        using pointer = _Iter;
        using _Ref0 = typename iterator_traits<_Iter>::reference;
        using reference = conditional_t<is_reference_v<std::move_iterator::_Ref0>, remove_reference_t<std::move_iterator::_Ref0> &&, std::move_iterator::_Ref0>;
        using iterator_type = _Iter;
        inline move_iterator<_Iter>() : current()         {
        }
        inline explicit move_iterator<_Iter>(std::move_iterator::iterator_type _Right) : current(_Right)         {
        }
        template <class _Iter2> inline move_iterator<_Iter>(const move_iterator<_Iter2> &_Right) : current(_Right.base())         {
        }
        template <class _Iter2> inline move_iterator<_Iter> &operator=(const move_iterator<_Iter2> &_Right)         {
            this->current = _Right.base();
            return (*this);
        }
        inline _Iter base() const         {
            return (this->current);
        }
        inline std::move_iterator::reference operator*() const         {
            return (static_cast<std::move_iterator::reference>(*this->current));
        }
        inline std::move_iterator::pointer operator->() const         {
            return (this->current);
        }
        inline move_iterator<_Iter> &operator++()         {
            ++this->current;
            return (*this);
        }
        inline move_iterator<_Iter> operator++(int)         {
            move_iterator<_Iter> _Tmp = *this;
            ++this->current;
            return (_Tmp);
        }
        inline move_iterator<_Iter> &operator--()         {
            --this->current;
            return (*this);
        }
        inline move_iterator<_Iter> operator--(int)         {
            move_iterator<_Iter> _Tmp = *this;
            --this->current;
            return (_Tmp);
        }
        inline move_iterator<_Iter> &operator+=(const std::move_iterator::difference_type _Off)         {
            this->current += _Off;
            return (*this);
        }
        inline move_iterator<_Iter> operator+(const std::move_iterator::difference_type _Off) const         {
            return (move_iterator<_Iter>(this->current + _Off));
        }
        inline move_iterator<_Iter> &operator-=(const std::move_iterator::difference_type _Off)         {
            this->current -= _Off;
            return (*this);
        }
        inline move_iterator<_Iter> operator-(const std::move_iterator::difference_type _Off) const         {
            return (move_iterator<_Iter>(this->current - _Off));
        }
        inline std::move_iterator::reference operator[](const std::move_iterator::difference_type _Off) const         {
            return (::std::move(this->current[_Off]));
        }
        friend template <class _Iter2, enable_if_t<_Range_verifiable_v<_Iter, _Iter2>, int> = 0> constexpr void _Verify_range(const move_iterator<_Iter> &_First, const move_iterator<_Iter2> &_Last)         {
            _Verify_range(_First.base(), _Last.base());
        }
;
        template <class _Iter2 = std::move_iterator::iterator_type, enable_if_t<_Offset_verifiable_v<_Iter2>, int> = 0> constexpr void _Verify_offset(const std::move_iterator::difference_type _Off) const         {
            this->current._Verify_offset(_Off);
        }
        template <class _Iter2 = std::move_iterator::iterator_type, enable_if_t<_Unwrappable_v<_Iter2>, int> = 0> constexpr move_iterator<_Unwrapped_t<_Iter2> > _Unwrapped() const         {
            return (static_cast<move_iterator<_Unwrapped_t<_Iter2> >>(this->current._Unwrapped()));
        }
        static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<std::move_iterator::iterator_type>;
        template <class _Src, enable_if_t<_Wrapped_seekable_v<std::move_iterator::iterator_type, _Src>, int> = 0> constexpr void _Seek_to(const move_iterator<_Src> &_It)         {
            this->current._Seek_to(_It.base());
        }
    protected:
        std::move_iterator::iterator_type current;
    };
    template <class _Iter> inline move_iterator<_Iter> operator+(typename move_iterator<_Iter>::difference_type _Off, const move_iterator<_Iter> &_Right)     {
        return (_Right + _Off);
    }
    template <class _Iter1, class _Iter2> inline auto operator-(const move_iterator<_Iter1> &_Left, const move_iterator<_Iter2> &_Right) -> decltype(_Left.base() - _Right.base())     {
        return (_Left.base() - _Right.base());
    }
    template <class _Iter1, class _Iter2> inline bool operator==(const move_iterator<_Iter1> &_Left, const move_iterator<_Iter2> &_Right)     {
        return (_Left.base() == _Right.base());
    }
    template <class _Iter1, class _Iter2> inline bool operator!=(const move_iterator<_Iter1> &_Left, const move_iterator<_Iter2> &_Right)     {
        return (!(_Left == _Right));
    }
    template <class _Iter1, class _Iter2> inline bool operator<(const move_iterator<_Iter1> &_Left, const move_iterator<_Iter2> &_Right)     {
        return (_Left.base() < _Right.base());
    }
    template <class _Iter1, class _Iter2> inline bool operator>(const move_iterator<_Iter1> &_Left, const move_iterator<_Iter2> &_Right)     {
        return (_Right < _Left);
    }
    template <class _Iter1, class _Iter2> inline bool operator<=(const move_iterator<_Iter1> &_Left, const move_iterator<_Iter2> &_Right)     {
        return (!(_Right < _Left));
    }
    template <class _Iter1, class _Iter2> inline bool operator>=(const move_iterator<_Iter1> &_Left, const move_iterator<_Iter2> &_Right)     {
        return (!(_Left < _Right));
    }
    template <class _Iter> inline move_iterator<_Iter> make_move_iterator(_Iter _It)     {
        return (move_iterator<_Iter>(_It));
    }
    template <class _Traits> struct _Char_traits_eq {
        using _Elem = typename _Traits::char_type;
        bool operator()(std::_Char_traits_eq::_Elem _Left, std::_Char_traits_eq::_Elem _Right) const         {
            return (_Traits::eq(_Left, _Right));
        }
    };
    template <class _Traits> struct _Char_traits_lt {
        using _Elem = typename _Traits::char_type;
        bool operator()(std::_Char_traits_lt::_Elem _Left, std::_Char_traits_lt::_Elem _Right) const         {
            return (_Traits::lt(_Left, _Right));
        }
    };
    template <class _InIt, class _OutIt> inline _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest)     {
        const char *const _First_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_First));
        const char *const _Last_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_Last));
        char *const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
        const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
        ::memmove(_Dest_ch, _First_ch, _Count);
        return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));
    }
    template <class _InIt, class _OutIt> inline _OutIt _Copy_unchecked1(_InIt _First, _InIt _Last, _OutIt _Dest, std::_General_ptr_iterator_tag)     {
        for (; _First != _Last; ++_Dest , (void)++_First) {
            *_Dest = *_First;
        }
        return (_Dest);
    }
    template <class _InIt, class _OutIt> inline _OutIt _Copy_unchecked1(_InIt _First, _InIt _Last, _OutIt _Dest, std::_Trivially_copyable_ptr_iterator_tag)     {
        return (_Copy_memmove(_First, _Last, _Dest));
    }
    template <class _InIt, class _OutIt> inline _OutIt _Copy_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest)     {
        return (_Copy_unchecked1(_First, _Last, _Dest, _Ptr_copy_cat(_First, _Dest)));
    }
    template <class _InIt, class _OutIt> inline _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest)     {
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
        _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst, _ULast, _UDest));
        return (_Dest);
    }
    template <class _InIt, class _Diff, class _OutIt> inline _OutIt _Copy_n_unchecked4(_InIt _First, _Diff _Count, _OutIt _Dest, std::_General_ptr_iterator_tag)     {
        for (;;) {
            *_Dest = *_First;
            ++_Dest;
            --_Count;
            if (_Count == 0) {
                return (_Dest);
            }
            ++_First;
        }
    }
    template <class _InIt, class _Diff, class _OutIt> inline _OutIt _Copy_n_unchecked4(_InIt _First, _Diff _Count, _OutIt _Dest, std::_Trivially_copyable_ptr_iterator_tag)     {
        return (_Copy_memmove(_First, _First + _Count, _Dest));
    }
    template <class _InIt, class _Diff, class _OutIt> inline _OutIt _Copy_n_unchecked3(_InIt _First, _Diff _Count, _OutIt _Dest)     {
        return (_Copy_n_unchecked4(_First, _Count, _Dest, _Ptr_copy_cat(_First, _Dest)));
    }
    template <class _InIt, class _Diff, class _OutIt> inline _OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest)     {
        const _Algorithm_int_t<_Diff> _Count = _Count_raw;
        if (0 < _Count) {
            _Seek_wrapped(_Dest, _Copy_n_unchecked3(_Get_unwrapped_n(_First, _Count), _Count, _Get_unwrapped_n(_Dest, _Count)));
        }
        return (_Dest);
    }
    template <class _BidIt1, class _BidIt2> inline _BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)     {
        const char *const _First_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_First));
        const char *const _Last_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_Last));
        char *const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
        const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
        return (static_cast<_BidIt2>(::memmove(_Dest_ch - _Count, _First_ch, _Count)));
    }
    template <class _BidIt1, class _BidIt2> inline _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, std::_General_ptr_iterator_tag)     {
        while (_First != _Last)
            *--_Dest = *--_Last;
        return (_Dest);
    }
    template <class _BidIt1, class _BidIt2> inline _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, std::_Trivially_copyable_ptr_iterator_tag)     {
        return (_Copy_backward_memmove(_First, _Last, _Dest));
    }
    template <class _BidIt1, class _BidIt2> inline _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)     {
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        const auto _UDest = _Get_unwrapped_n(_Dest, - _Idl_distance<_BidIt1>(_UFirst, _ULast));
        _Seek_wrapped(_Dest, _Copy_backward_unchecked(_UFirst, _ULast, _UDest, _Ptr_copy_cat(_UFirst, _UDest)));
        return (_Dest);
    }
    template <class _InIt, class _OutIt> inline _OutIt _Move_unchecked1(_InIt _First, _InIt _Last, _OutIt _Dest, std::_General_ptr_iterator_tag)     {
        for (; _First != _Last; ++_Dest , (void)++_First)
            *_Dest = ::std::move(*_First);
        return (_Dest);
    }
    template <class _InIt, class _OutIt> inline _OutIt _Move_unchecked1(_InIt _First, _InIt _Last, _OutIt _Dest, std::_Trivially_copyable_ptr_iterator_tag)     {
        return (_Copy_memmove(_First, _Last, _Dest));
    }
    template <class _InIt, class _OutIt> inline _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest)     {
        return (_Move_unchecked1(_First, _Last, _Dest, _Ptr_move_cat(_First, _Dest)));
    }
    template <class _InIt, class _OutIt> inline _OutIt move(_InIt _First, _InIt _Last, _OutIt _Dest)     {
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
        _Seek_wrapped(_Dest, _Move_unchecked(_UFirst, _ULast, _UDest));
        return (_Dest);
    }
    template <class _BidIt1, class _BidIt2> inline _BidIt2 _Move_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, std::_General_ptr_iterator_tag)     {
        while (_First != _Last)
            *--_Dest = ::std::move(*--_Last);
        return (_Dest);
    }
    template <class _BidIt1, class _BidIt2> inline _BidIt2 _Move_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, std::_Trivially_copyable_ptr_iterator_tag)     {
        return (_Copy_backward_memmove(_First, _Last, _Dest));
    }
    template <class _BidIt1, class _BidIt2> inline _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)     {
        return (_Move_backward_unchecked1(_First, _Last, _Dest, _Ptr_move_cat(_First, _Dest)));
    }
    template <class _BidIt1, class _BidIt2> inline _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)     {
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        const auto _UDest = _Get_unwrapped_n(_Dest, - _Idl_distance<_BidIt1>(_UFirst, _ULast));
        _Seek_wrapped(_Dest, _Move_backward_unchecked(_UFirst, _ULast, _UDest));
        return (_Dest);
    }
    template <class _Ty> struct _Is_character : std::false_type {
    };
    template<> struct _Is_character<char> : std::true_type {
    };
    template<> struct _Is_character<signed char> : std::true_type {
    };
    template<> struct _Is_character<unsigned char> : std::true_type {
    };
    template <class _FwdIt, class _Ty> struct _Fill_memset_is_safe_helper {
        using _Value_type = _Iter_value_t<_FwdIt>;
        using _Raw_ty = _Unwrap_enum_t<_Ty>;
        using _Raw_value_type = _Unwrap_enum_t<std::_Fill_memset_is_safe_helper::_Value_type>;
        using type = bool_constant<conjunction_v<is_pointer<_FwdIt>, disjunction<conjunction<_Is_character<std::_Fill_memset_is_safe_helper::_Raw_ty>, _Is_character<std::_Fill_memset_is_safe_helper::_Raw_value_type> >, conjunction<is_same<bool, std::_Fill_memset_is_safe_helper::_Raw_ty>, is_same<bool, std::_Fill_memset_is_safe_helper::_Raw_value_type> > >, is_convertible<_Ty, std::_Fill_memset_is_safe_helper::_Value_type> > >;
    };
    template <class _FwdIt, class _Ty> inline typename _Fill_memset_is_safe_helper<_FwdIt, _Ty>::type _Fill_memset_is_safe(const _FwdIt &, const _Ty &)     {
        return {};
    }
    template <class _FwdIt, class _Ty> inline void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty &_Val, std::false_type)     {
        for (; _First != _Last; ++_First)
            *_First = _Val;
    }
    template <class _FwdIt, class _Ty> inline void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty &_Val, std::true_type)     {
        ::memset(_First, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First));
    }
    template <class _FwdIt, class _Ty> inline void _Fill_unchecked(_FwdIt _First, _FwdIt _Last, const _Ty &_Val)     {
        _Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));
    }
    template <class _FwdIt, class _Ty> inline void fill(_FwdIt _First, _FwdIt _Last, const _Ty &_Val)     {
        _Adl_verify_range(_First, _Last);
        _Fill_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val);
    }
    template <class _OutIt, class _Diff, class _Ty> inline _OutIt _Fill_n_unchecked2(_OutIt _Dest, _Diff _Count, const _Ty &_Val, std::false_type)     {
        for (; 0 < _Count; --_Count , (void)++_Dest)
            *_Dest = _Val;
        return (_Dest);
    }
    template <class _OutIt, class _Diff, class _Ty> inline _OutIt _Fill_n_unchecked2(_OutIt _Dest, _Diff _Count, const _Ty &_Val, std::true_type)     {
        ::memset(_Dest, static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));
        return (_Dest + _Count);
    }
    template <class _OutIt, class _Diff, class _Ty> inline _OutIt fill_n(_OutIt _Dest, _Diff _Count_raw, const _Ty &_Val)     {
        const _Algorithm_int_t<_Diff> _Count = _Count_raw;
        if (0 < _Count) {
            const auto _UDest = _Get_unwrapped_n(_Dest, _Count);
            _Seek_wrapped(_Dest, _Fill_n_unchecked2(_UDest, _Count, _Val, _Fill_memset_is_safe(_UDest, _Val)));
        }
        return (_Dest);
    }
    template <class _Elem1, class _Elem2> struct _Value_equality_is_bitwise_equality : bool_constant<static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1)> {
    };
    template <class _Elem1, class _Elem2, class _Pr> struct _Equal_memcmp_is_safe_helper : std::false_type {
    };
    template <class _Elem1, class _Elem2> struct _Equal_memcmp_is_safe_helper<_Elem1, _Elem2, std::equal_to<void>> : bool_constant<conjunction_v<_Is_same_size<_Elem1, _Elem2>, _Is_nonbool_integral<_Elem1>, _Is_nonbool_integral<_Elem2>, negation<is_volatile<_Elem1> >, negation<is_volatile<_Elem2> >, _Value_equality_is_bitwise_equality<_Elem1, _Elem2> > > {
    };
    template <class _Elem1, class _Elem2> struct _Equal_memcmp_is_safe_helper<type-parameter-0-0 *, type-parameter-0-1 *, std::equal_to<void>> : is_same<remove_cv_t<_Elem1>, remove_cv_t<_Elem2> >::type {
    };
    template <class _Elem> struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<type-parameter-0-0> >> : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<> >::type {
    };
    template <class _Elem> struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<type-parameter-0-0>> : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<> >::type {
    };
    template <class _Iter1, class _Iter2, class _Pr> inline std::false_type _Equal_memcmp_is_safe(const _Iter1 &, const _Iter2 &, const _Pr &)     {
        return {};
    }
    template <class _Obj1, class _Obj2, class _Pr> inline typename _Equal_memcmp_is_safe_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _Pr>::type _Equal_memcmp_is_safe(_Obj1 *const &, _Obj2 *const &, const _Pr &)     {
        return {};
    }
    template <class _InIt1, class _InIt2, class _Pr> inline bool _Equal_unchecked1(_InIt1 _First1, const _InIt1 _Last1, _InIt2 _First2, _Pr _Pred, std::false_type)     {
        for (; _First1 != _Last1; ++_First1 , (void)++_First2) {
            if (!_Pred(*_First1, *_First2)) {
                return (false);
            }
        }
        return (true);
    }
    template <class _InIt1, class _InIt2, class _Pr> inline bool _Equal_unchecked1(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr, std::true_type)     {
        const auto _First1_ch = reinterpret_cast<const char *>(_First1);
        const auto _First2_ch = reinterpret_cast<const char *>(_First2);
        const auto _Count = static_cast<size_t>(reinterpret_cast<const char *>(_Last1) - _First1_ch);
        return (::memcmp(_First1_ch, _First2_ch, _Count) == 0);
    }
    template <class _InIt1, class _InIt2, class _Pr> inline bool _Equal_unchecked(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred)     {
        return (_Equal_unchecked1(_First1, _Last1, _First2, _Pred, _Equal_memcmp_is_safe(_First1, _First2, _Pred)));
    }
    template <class _InIt1, class _InIt2, class _Pr> inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred)     {
        _Adl_verify_range(_First1, _Last1);
        const auto _UFirst1 = _Get_unwrapped(_First1);
        const auto _ULast1 = _Get_unwrapped(_Last1);
        const auto _UFirst2 = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
        return (_Equal_unchecked(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred)));
    }
    template <class _InIt1, class _InIt2> inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2)     {
        return (::std::equal(_First1, _Last1, _First2, equal_to<>()));
    }
    template <class _InIt1, class _InIt2, class _Pr> inline bool _Equal_unchecked(_InIt1 _First1, const _InIt1 _Last1, _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred, std::input_iterator_tag, std::input_iterator_tag)     {
        for (;;) {
            if (_First1 == _Last1) {
                return (_First2 == _Last2);
            }
            if (_First2 == _Last2) {
                return (false);
            }
            if (!_Pred(*_First1, *_First2)) {
                return (false);
            }
            ++_First1;
            ++_First2;
        }
    }
    template <class _InIt1, class _InIt2, class _Pr> inline bool _Equal_unchecked(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred, std::random_access_iterator_tag, std::random_access_iterator_tag)     {
        if (_Last1 - _First1 != _Last2 - _First2) {
            return (false);
        }
        return (_Equal_unchecked(_First1, _Last1, _First2, _Pred));
    }
    template <class _InIt1, class _InIt2, class _Pr> inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred)     {
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        return (_Equal_unchecked(_Get_unwrapped(_First1), _Get_unwrapped(_Last1), _Get_unwrapped(_First2), _Get_unwrapped(_Last2), _Pass_fn(_Pred), _Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>()));
    }
    template <class _InIt1, class _InIt2> inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2)     {
        return (::std::equal(_First1, _Last1, _First2, _Last2, equal_to<>()));
    }
    template <class _Elem1, class _Elem2, class _FTy> struct _Lex_compare_check_element_types_helper : bool_constant<conjunction_v<_Is_character<_Elem1>, _Is_character<_Elem2>, _Is_character<_FTy>, is_unsigned<_FTy> > > {
    };
    template <class _Elem1, class _Elem2> struct _Lex_compare_check_element_types_helper<_Elem1, _Elem2, void> : bool_constant<conjunction_v<_Is_character<_Elem1>, _Is_character<_Elem2>, is_unsigned<_Elem1>, is_unsigned<_Elem2> > > {
    };
    template <class _Memcmp_pr> struct _Lex_compare_optimize {
    };
template<> struct _Lex_compare_optimize<void> {
    };
    template <class _Memcmp_pr, class _Obj1, class _Obj2, class _FTy> using _Lex_compare_check_element_types = _Lex_compare_optimize<conditional_t<_Lex_compare_check_element_types_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _FTy>::value, _Memcmp_pr, void> >;
    template <class _InIt1, class _InIt2, class _Pr> inline _Lex_compare_optimize<void> _Lex_compare_memcmp_classify(const _InIt1 &, const _InIt2 &, const _Pr &)     {
        return {};
    }
    template <class _Obj1, class _Obj2, class _FTy> inline _Lex_compare_check_element_types<less<int>, _Obj1, _Obj2, _FTy> _Lex_compare_memcmp_classify(_Obj1 *const &, _Obj2 *const &, const less<_FTy> &)     {
        return {};
    }
    template <class _Obj1, class _Obj2, class _FTy> inline _Lex_compare_check_element_types<greater<int>, _Obj1, _Obj2, _FTy> _Lex_compare_memcmp_classify(_Obj1 *const &, _Obj2 *const &, const greater<_FTy> &)     {
        return {};
    }
    template <class _InIt1, class _InIt2, class _Pr> inline bool _Lex_compare_unchecked(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred, _Lex_compare_optimize<void>)     {
        for (; _First1 != _Last1 && _First2 != _Last2; ++_First1 , (void)++_First2) {
            if (_Pred(*_First1, *_First2))
                return (true);
            else if (_Pred(*_First2, *_First1))
                return (false);
        }
        return (_First1 == _Last1 && _First2 != _Last2);
    }
    template <class _InIt1, class _InIt2, class _Pr, class _Memcmp_pr> inline bool _Lex_compare_unchecked(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr, _Lex_compare_optimize<_Memcmp_pr>)     {
        const auto _Num1 = static_cast<size_t>(_Last1 - _First1);
        const auto _Num2 = static_cast<size_t>(_Last2 - _First2);
        const int _Ans = ::memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
        return (_Memcmp_pr({})(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2));
    }
    template <class _InIt1, class _InIt2, class _Pr> inline bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)     {
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        const auto _UFirst1 = _Get_unwrapped(_First1);
        const auto _ULast1 = _Get_unwrapped(_Last1);
        const auto _UFirst2 = _Get_unwrapped(_First2);
        const auto _ULast2 = _Get_unwrapped(_Last2);
        return (_Lex_compare_unchecked(_UFirst1, _ULast1, _UFirst2, _ULast2, _Pass_fn(_Pred), _Lex_compare_memcmp_classify(_UFirst1, _UFirst2, _Pred)));
    }
    template <class _InIt1, class _InIt2> inline bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2)     {
        return (::std::lexicographical_compare(_First1, _Last1, _First2, _Last2, less<>()));
    }
    template <class _Ty> inline bool _Within_limits(const _Ty &_Val, std::true_type, std::true_type, std::_Any_tag)     {
        return ((-127 - 1) <= _Val && _Val <= 127);
    }
    template <class _Ty> inline bool _Within_limits(const _Ty &_Val, std::true_type, std::false_type, std::true_type)     {
        return (_Val <= 127 || static_cast<_Ty>((-127 - 1)) <= _Val);
    }
    template <class _Ty> inline bool _Within_limits(const _Ty &_Val, std::true_type, std::false_type, std::false_type)     {
        return (_Val <= 127);
    }
    template <class _Ty> inline bool _Within_limits(const _Ty &_Val, std::false_type, std::true_type, std::_Any_tag)     {
        return (0 <= _Val && _Val <= (127 * 2 + 1));
    }
    template <class _Ty> inline bool _Within_limits(const _Ty &_Val, std::false_type, std::false_type, std::_Any_tag)     {
        return (_Val <= (127 * 2 + 1));
    }
    template <class _InIt, class _Ty> inline bool _Within_limits(_InIt, const _Ty &_Val)     {
        using _Elem = remove_pointer_t<_InIt>;
        return (_Within_limits(_Val, is_signed<_Elem>({}), is_signed<_Ty>({}), bool_constant<-1 == static_cast<_Ty>(-1)>({})));
    }
    template <class _InIt> inline bool _Within_limits(_InIt, const bool &)     {
        return (true);
    }
    template <class _InIt, class _Ty> inline _InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty &_Val, std::true_type)     {
        if (!_Within_limits(_First, _Val)) {
            return (_Last);
        }
        _First = static_cast<_InIt>(::memchr(_First, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
        return (_First ? _First : _Last);
    }
    template <class _InIt, class _Ty> inline _InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty &_Val, std::false_type)     {
        for (; _First != _Last; ++_First)
            if (*_First == _Val)
                break;
        return (_First);
    }
    template <class _InIt, class _Ty> inline _InIt _Find_unchecked(const _InIt _First, const _InIt _Last, const _Ty &_Val)     {
        using _Memchr_opt = bool_constant<is_integral_v<_Ty> && _Is_any_of_v<_InIt, char *, signed char *, unsigned char *, const char *, const signed char *, const unsigned char *> >;
        return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt({})));
    }
    template <class _InIt, class _Ty> inline _InIt find(_InIt _First, const _InIt _Last, const _Ty &_Val)     {
        _Adl_verify_range(_First, _Last);
        _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
        return (_First);
    }
    template <class _InIt, class _Ty, class _Pr> inline _InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty &_Val, _Pr _Pred)     {
        for (; _First != _Last; ++_First) {
            if (_Pred(*_First, _Val)) {
                break;
            }
        }
        return (_First);
    }
    template <class _InIt, class _Ty> inline _Iter_diff_t<_InIt> count(const _InIt _First, const _InIt _Last, const _Ty &_Val)     {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        _Iter_diff_t<_InIt> _Count = 0;
        for (; _UFirst != _ULast; ++_UFirst) {
            if (*_UFirst == _Val) {
                ++_Count;
            }
        }
        return (_Count);
    }
    template <class _InIt, class _Ty, class _Pr> inline _Iter_diff_t<_InIt> _Count_pr(_InIt _First, _InIt _Last, const _Ty &_Val, _Pr _Pred)     {
        _Iter_diff_t<_InIt> _Count = 0;
        for (; _First != _Last; ++_First) {
            if (_Pred(*_First, _Val)) {
                ++_Count;
            }
        }
        return (_Count);
    }
    template <class _FwdIt1, class _FwdIt2, class _Pr> inline void _Trim_matching_suffixes(_FwdIt1 &, _FwdIt2 &, _Pr, std::forward_iterator_tag, std::forward_iterator_tag)     {
    }
    template <class _FwdIt1, class _FwdIt2, class _Pr> inline void _Trim_matching_suffixes(_FwdIt1 &_Last1, _FwdIt2 &_Last2, _Pr _Pred, std::bidirectional_iterator_tag, std::bidirectional_iterator_tag)     {
        do {
            --_Last1;
            --_Last2;
        } while (_Pred(*_Last1, *_Last2));
        ++_Last1;
        ++_Last2;
    }
    template <class _FwdIt1, class _FwdIt2, class _Pr> inline bool _Check_match_counts(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)     {
        _Trim_matching_suffixes(_Last1, _Last2, _Pred, _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>());
        for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1) {
            if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred)) {
                _Iter_diff_t<_FwdIt2> _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
                if (_Count2 == 0) {
                    return (false);
                }
                _FwdIt1 _Skip1 = _Next_iter(_Next1);
                _Iter_diff_t<_FwdIt1> _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
                if (_Count2 != _Count1) {
                    return (false);
                }
            }
        }
        return (true);
    }
    template <class _FwdIt1, class _FwdIt2, class _Pr> inline bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred)     {
        for (; _First1 != _Last1; ++_First1 , (void)++_First2) {
            if (!_Pred(*_First1, *_First2)) {
                auto _Last2 = ::std::next(_First2, static_cast<_Iter_diff_t<_FwdIt2>>(::std::distance(_First1, _Last1)));
                return (_Check_match_counts(_First1, _Last1, _First2, _Last2, _Pred));
            }
        }
        return (true);
    }
    template <class _FwdIt1, class _FwdIt2, class _Pr> inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred)     {
        _Adl_verify_range(_First1, _Last1);
        const auto _UFirst1 = _Get_unwrapped(_First1);
        const auto _ULast1 = _Get_unwrapped(_Last1);
        const auto _UFirst2 = _Get_unwrapped_n(_First2, _Idl_distance<_FwdIt1>(_UFirst1, _ULast1));
        return (_Is_permutation_unchecked(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred)));
    }
    template <class _FwdIt1, class _FwdIt2> inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)     {
        return (::std::is_permutation(_First1, _Last1, _First2, equal_to<>()));
    }
    template <class _FwdIt1, class _FwdIt2, class _Pr> inline bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, std::forward_iterator_tag, std::forward_iterator_tag)     {
        for (; _First1 != _Last1 && _First2 != _Last2; ++_First1 , (void)++_First2) {
            if (!_Pred(*_First1, *_First2)) {
                if (::std::distance(_First1, _Last1) == ::std::distance(_First2, _Last2)) {
                    return (_Check_match_counts(_First1, _Last1, _First2, _Last2, _Pred));
                } else {
                    return (false);
                }
            }
        }
        return (_First1 == _Last1 && _First2 == _Last2);
    }
    template <class _FwdIt1, class _FwdIt2, class _Pr> inline bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, std::random_access_iterator_tag, std::random_access_iterator_tag)     {
        if (_Last1 - _First1 != _Last2 - _First2) {
            return (false);
        }
        return (_Is_permutation_unchecked(_First1, _Last1, _First2, _Pred));
    }
    template <class _FwdIt1, class _FwdIt2, class _Pr> inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)     {
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        return (_Is_permutation_unchecked(_Get_unwrapped(_First1), _Get_unwrapped(_Last1), _Get_unwrapped(_First2), _Get_unwrapped(_Last2), _Pass_fn(_Pred), _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>()));
    }
    template <class _FwdIt1, class _FwdIt2> inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2)     {
        return (::std::is_permutation(_First1, _Last1, _First2, _Last2, equal_to<>()));
    }
    template <class _BidIt> inline void _Reverse_unchecked1(_BidIt _First, _BidIt _Last, integral_constant<size_t, 0>)     {
        for (; _First != _Last && _First != --_Last; ++_First) {
            ::std::iter_swap(_First, _Last);
        }
    }
    template <class _BidIt> inline void _Reverse_unchecked1(const _BidIt _First, const _BidIt _Last, integral_constant<size_t, 1>)     {
        __std_reverse_trivially_swappable_1(_First, _Last);
    }
    template <class _BidIt> inline void _Reverse_unchecked1(const _BidIt _First, const _BidIt _Last, integral_constant<size_t, 2>)     {
        __std_reverse_trivially_swappable_2(_First, _Last);
    }
    template <class _BidIt> inline void _Reverse_unchecked1(const _BidIt _First, const _BidIt _Last, integral_constant<size_t, 4>)     {
        __std_reverse_trivially_swappable_4(_First, _Last);
    }
    template <class _BidIt> inline void _Reverse_unchecked1(const _BidIt _First, const _BidIt _Last, integral_constant<size_t, 8>)     {
        __std_reverse_trivially_swappable_8(_First, _Last);
    }
    template <class _BidIt> inline void _Reverse_unchecked(const _BidIt _First, const _BidIt _Last)     {
        using _Elem = remove_pointer_t<_BidIt>;
        constexpr size_t _Opt = is_pointer_v<_BidIt> && _Is_trivially_swappable_v<_Elem> && !is_volatile_v<_Elem> && (sizeof(_Elem) == 1 || sizeof(_Elem) == 2 || sizeof(_Elem) == 4 || sizeof(_Elem) == 8) ? sizeof(_Elem) : 0;
        _Reverse_unchecked1(_First, _Last, integral_constant<size_t, _Opt>({}));
    }
    template <class _BidIt> inline void reverse(const _BidIt _First, const _BidIt _Last)     {
        _Adl_verify_range(_First, _Last);
        _Reverse_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last));
    }
    template <class _FwdIt> inline _FwdIt _Rotate_unchecked1(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, std::forward_iterator_tag)     {
        for (_FwdIt _Next = _Mid, _Res = _Last; ;) {
            ::std::iter_swap(_First, _Next);
            if (++_First == _Mid) {
                if (++_Next == _Last)
                    return (_Res == _Last ? _Mid : _Res);
                else
                    _Mid = _Next;
            } else if (++_Next == _Last) {
                if (_Res == _Last)
                    _Res = _First;
                _Next = _Mid;
            }
        }
    }
    template <class _BidIt> inline pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(_BidIt _First, _BidIt _Sentinel, _BidIt _Last)     {
        while (_First != _Sentinel && _Last != _Sentinel)
            {
                ::std::iter_swap(_First, --_Last);
                ++_First;
            }
        return (::std::make_pair(_First, _Last));
    }
    template <class _BidIt> inline _BidIt _Rotate_unchecked1(_BidIt _First, _BidIt _Mid, _BidIt _Last, std::bidirectional_iterator_tag)     {
        _Reverse_unchecked(_First, _Mid);
        _Reverse_unchecked(_Mid, _Last);
        pair<_BidIt, _BidIt> _Tmp = _Reverse_until_sentinel_unchecked(_First, _Mid, _Last);
        _Reverse_unchecked(_Tmp.first, _Tmp.second);
        return (_Mid != _Tmp.first ? _Tmp.first : _Tmp.second);
    }
    template <class _RanIt> inline _RanIt _Rotate_unchecked1(_RanIt _First, _RanIt _Mid, _RanIt _Last, std::random_access_iterator_tag)     {
        _Reverse_unchecked(_First, _Mid);
        _Reverse_unchecked(_Mid, _Last);
        _Reverse_unchecked(_First, _Last);
        return (_First + (_Last - _Mid));
    }
    template <class _FwdIt> inline _FwdIt _Rotate_unchecked(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)     {
        if (_First == _Mid)
            return (_Last);
        if (_Mid == _Last)
            return (_First);
        return (_Rotate_unchecked1(_First, _Mid, _Last, _Iter_cat_t<_FwdIt>()));
    }
    template <class _FwdIt> inline _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)     {
        _Adl_verify_range(_First, _Mid);
        _Adl_verify_range(_Mid, _Last);
        _Seek_wrapped(_First, _Rotate_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Mid), _Get_unwrapped(_Last)));
        return (_First);
    }
    template <class _FwdIt, class _Ty, class _Pr> inline _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty &_Val, _Pr _Pred)     {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        _Iter_diff_t<_FwdIt> _Count = ::std::distance(_UFirst, _Get_unwrapped(_Last));
        while (0 < _Count)
            {
                const _Iter_diff_t<_FwdIt> _Count2 = _Count >> 1;
                const auto _UMid = ::std::next(_UFirst, _Count2);
                if (_Pred(*_UMid, _Val)) {
                    _UFirst = _Next_iter(_UMid);
                    _Count -= _Count2 + 1;
                } else {
                    _Count = _Count2;
                }
            }
        _Seek_wrapped(_First, _UFirst);
        return (_First);
    }
    template <class _Diff, class _Urng> class _Rng_from_urng {
    public:
        using _Ty0 = make_unsigned_t<_Diff>;
        using _Ty1 = typename _Urng::result_type;
        using _Udiff = conditional_t<sizeof(std::_Rng_from_urng::_Ty1) < sizeof(std::_Rng_from_urng::_Ty0), std::_Rng_from_urng::_Ty0, std::_Rng_from_urng::_Ty1>;
        explicit _Rng_from_urng<_Diff, _Urng>(_Urng &_Func) : _Ref(_Func), _Bits(8 * sizeof(std::_Rng_from_urng::_Udiff)), _Bmask(std::_Rng_from_urng::_Udiff(-1))         {
            for (; (_Urng::max)() - (_Urng::min)() < this->_Bmask; this->_Bmask >>= 1)
                --this->_Bits;
        }
        _Diff operator()(_Diff _Index)         {
            for (;;) {
                std::_Rng_from_urng::_Udiff _Ret = 0;
                std::_Rng_from_urng::_Udiff _Mask = 0;
                while (_Mask < std::_Rng_from_urng::_Udiff(_Index - 1))
                    {
                        _Ret <<= this->_Bits - 1;
                        _Ret <<= 1;
                        _Ret |= this->_Get_bits();
                        _Mask <<= this->_Bits - 1;
                        _Mask <<= 1;
                        _Mask |= this->_Bmask;
                    }
                if (_Ret / _Index < _Mask / _Index || _Mask % _Index == std::_Rng_from_urng::_Udiff(_Index - 1))
                    return (static_cast<_Diff>(_Ret % _Index));
            }
        }
        std::_Rng_from_urng::_Udiff _Get_all_bits()         {
            std::_Rng_from_urng::_Udiff _Ret = 0;
            for (size_t _Num = 0; _Num < 8 * sizeof(std::_Rng_from_urng::_Udiff); _Num += this->_Bits) {
                _Ret <<= this->_Bits - 1;
                _Ret <<= 1;
                _Ret |= this->_Get_bits();
            }
            return (_Ret);
        }
        _Rng_from_urng<_Diff, _Urng>(const _Rng_from_urng<_Diff, _Urng> &) = delete
        _Rng_from_urng<_Diff, _Urng> &operator=(const _Rng_from_urng<_Diff, _Urng> &) = delete
    private:
        std::_Rng_from_urng::_Udiff _Get_bits()         {
            for (;;) {
                std::_Rng_from_urng::_Udiff _Val = this->_Ref() - (_Urng::min)();
                if (_Val <= this->_Bmask)
                    return (_Val);
            }
        }
        _Urng &_Ref;
        size_t _Bits;
        std::_Rng_from_urng::_Udiff _Bmask;
    };
    template <class _Elem> class _Yarn {
    public:
        _Yarn<_Elem>() : _Myptr(nullptr), _Nul(0)         {
        }
        _Yarn<_Elem>(const _Yarn<_Elem> &_Right) : _Myptr(nullptr), _Nul(0)         {
            *this = _Right;
        }
        _Yarn<_Elem>(const _Elem *_Right) : _Myptr(nullptr), _Nul(0)         {
            *this = _Right;
        }
        _Yarn<_Elem> &operator=(const _Yarn<_Elem> &_Right)         {
            return (*this = _Right._Myptr);
        }
        _Yarn<_Elem> &operator=(const _Elem *_Right)         {
            if (this->_Myptr != _Right) {
                this->_Tidy();
                if (_Right != nullptr) {
                    const _Elem *_Ptr = _Right;
                    while (*_Ptr != (_Elem)0)
                        {
                            ++_Ptr;
                        }
                    const auto _Count = (++_Ptr - _Right) * sizeof(_Elem);
                    this->_Myptr = (_Elem *)::malloc(_Count);
                    if (this->_Myptr != nullptr) {
                        ::memcpy(this->_Myptr, _Right, _Count);
                    }
                }
            }
            return (*this);
        }
        ~_Yarn<_Elem>() noexcept         {
            this->_Tidy();
        }
        bool empty() const         {
            return (this->_Myptr == nullptr);
        }
        const _Elem *c_str() const         {
            return (this->_Myptr != nullptr ? this->_Myptr : &this->_Nul);
        }
        bool _Empty() const         {
            return (this->_Myptr == nullptr);
        }
        const _Elem *_C_str() const         {
            return (this->_Myptr != nullptr ? this->_Myptr : &this->_Nul);
        }
    private:
        void _Tidy()         {
            if (this->_Myptr != nullptr)
                ::free(this->_Myptr);
            this->_Myptr = nullptr;
        }
        _Elem *_Myptr;
        _Elem _Nul;
    };
    template <class _Container> class back_insert_iterator {
    public:
        using iterator_category = std::output_iterator_tag;
        using value_type = void;
        using difference_type = void;
        using pointer = void;
        using reference = void;
        using container_type = _Container;
        explicit back_insert_iterator<_Container>(_Container &_Cont) : container(::std::addressof(_Cont))         {
        }
        back_insert_iterator<_Container> &operator=(const typename _Container::value_type &_Val)         {
            this->container->push_back(_Val);
            return (*this);
        }
        back_insert_iterator<_Container> &operator=(typename _Container::value_type &&_Val)         {
            this->container->push_back(::std::move(_Val));
            return (*this);
        }
        back_insert_iterator<_Container> &operator*()         {
            return (*this);
        }
        back_insert_iterator<_Container> &operator++()         {
            return (*this);
        }
        back_insert_iterator<_Container> operator++(int)         {
            return (*this);
        }
    protected:
        _Container *container;
    };
    template <class _Container> inline back_insert_iterator<_Container> back_inserter(_Container &_Cont)     {
        return (back_insert_iterator<_Container>(_Cont));
    }
    template <class _Ty, class _Alloc, class  = void> struct _Has_allocator_type : std::false_type {
    };
    template <class _Ty, class _Alloc> struct _Has_allocator_type<_Ty, _Alloc, void> : is_convertible<_Alloc, typename _Ty::allocator_type>::type {
    };
    struct allocator_arg_t {
        explicit allocator_arg_t() noexcept = default
    };
    constexpr std::allocator_arg_t allocator_arg{};
    void _Xbad_alloc() [[noreturn]];
    void _Xinvalid_argument(const char *) [[noreturn]];
    void _Xlength_error(const char *) [[noreturn]];
    void _Xout_of_range(const char *) [[noreturn]];
    void _Xoverflow_error(const char *) [[noreturn]];
    void _Xruntime_error(const char *) [[noreturn]];
    template <class _Ty, class _Alloc> struct uses_allocator : _Has_allocator_type<_Ty, _Alloc>::type {
    };
    template <class _Ty, class _Alloc> constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;
    template <class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty *, class _Reference = _Ty &> struct iterator {
        using iterator_category = _Category;
        using value_type = _Ty;
        using difference_type = _Diff;
        using pointer = _Pointer;
        using reference = _Reference;
    };
}
namespace std {
    template <size_t _Ty_size> inline size_t _Get_size_of_n(const size_t _Count)     {
        constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
        size_t _Result = _Count * _Ty_size;
        if (_Max_possible < _Count) {
            _Result = static_cast<size_t>(-1);
        }
        return (_Result);
    }
    template<> inline size_t _Get_size_of_n<1>(const size_t _Count)     {
        return (_Count);
    }
    template <class _Ty> constexpr size_t _New_alignof = _Max_value(alignof(_Ty), static_cast<size_t>(16ULL));
    struct _Default_allocate_traits {
        static void *_Allocate(const size_t _Bytes)         {
            return (::operator new(_Bytes));
        }
    };
    constexpr bool _Is_pow_2(const size_t _Value) noexcept     {
        return (_Value != 0 && (_Value & (_Value - 1)) == 0);
    }
    constexpr size_t _Big_allocation_threshold = 4096;
    constexpr size_t _Big_allocation_alignment = 32;
    static_assert(2 * sizeof(void *) <= _Big_allocation_alignment, "Big allocation alignment should at least match vector register alignment");
    static_assert(_Is_pow_2(_Big_allocation_alignment), "Big allocation alignment must be a power of two");
    constexpr size_t _Non_user_size = sizeof(void *) + _Big_allocation_alignment - 1;
    constexpr size_t _Big_allocation_sentinel = 18085043209519168250ULL;
    template <class _Traits> inline void *_Allocate_manually_vector_aligned(const size_t _Bytes)     {
        size_t _Block_size = _Non_user_size + _Bytes;
        if (_Block_size <= _Bytes) {
            _Block_size = static_cast<size_t>(-1);
        }
        const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
        do {
            if (_Ptr_container != 0) {
            } else {
                do {
                    ;
                    ::_invalid_parameter_noinfo_noreturn();
                } while (false);
            }
            ;
        } while (false);
        void *const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));
        static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;
        return (_Ptr);
    }
    inline void _Adjust_manually_vector_aligned(void *&_Ptr, size_t &_Bytes)     {
        _Bytes += _Non_user_size;
        const uintptr_t *const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
        const uintptr_t _Ptr_container = _Ptr_user[-1];
        ;
        constexpr uintptr_t _Min_back_shift = sizeof(void *);
        const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
        do {
            if (_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size) {
            } else {
                do {
                    ;
                    ::_invalid_parameter_noinfo_noreturn();
                } while (false);
            }
            ;
        } while (false);
        _Ptr = reinterpret_cast<void *>(_Ptr_container);
    }
    template <size_t _Align, class _Traits = std::_Default_allocate_traits, enable_if_t<(!0 || _Align <= 16ULL), int> = 0> inline void *_Allocate(const size_t _Bytes)     {
        if (_Bytes >= _Big_allocation_threshold) {
            return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));
        }
        if (_Bytes != 0) {
            return (_Traits::_Allocate(_Bytes));
        }
        return (nullptr);
    }
    template <size_t _Align, enable_if_t<(!0 || _Align <= 16ULL), int> = 0> inline void _Deallocate(void *_Ptr, size_t _Bytes)     {
        if (_Bytes >= _Big_allocation_threshold) {
            _Adjust_manually_vector_aligned(_Ptr, _Bytes);
        }
        ::operator delete(_Ptr, _Bytes);
    }
    template <class _Ty, class ..._Types> inline void _Construct_in_place(_Ty &_Obj, _Types &&..._Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>_Construct_in_place(_Ty &_Obj, _Types &&..._Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>)     {
        ::new (const_cast<void *>(static_cast<const volatile void *>(::std::addressof(_Obj)))) _Ty((::std::forward<_Types>(_Args)...));
    }
    template <class _Ty, class ..._Types> inline _Ty *_Global_new(_Types &&..._Args)     {
        void *const _Result = _Allocate<_New_alignof<_Ty> >(sizeof(_Ty));
        try {
            ::new (_Result) _Ty((::std::forward<_Types>(_Args)...));
        } catch (...) {
            _Deallocate<_New_alignof<_Ty> >(_Result, sizeof(_Ty));
            throw;
        }
        return (static_cast<_Ty *>(_Result));
    }
    template <class _Ty> struct _Get_first_parameter;
    template <template <class , class ...> class _Ty, class _First, class ..._Rest> struct _Get_first_parameter<<type-parameter-0-1, type-parameter-0-2...>> {
        using type = _First;
    };
    template <class _Newfirst, class _Ty> struct _Replace_first_parameter;
    template <class _Newfirst, template <class , class ...> class _Ty, class _First, class ..._Rest> struct _Replace_first_parameter<_Newfirst, <type-parameter-0-2, type-parameter-0-3...>> {
        using type = _Ty<_Newfirst, _Rest...>;
    };
    template <class _Ty, class  = void> struct _Get_element_type {
        using type = typename _Get_first_parameter<_Ty>::type;
    };
    template <class _Ty> struct _Get_element_type<_Ty, void> {
        using type = typename _Ty::element_type;
    };
    template <class _Ty, class  = void> struct _Get_ptr_difference_type {
        using type = ptrdiff_t;
    };
    template <class _Ty> struct _Get_ptr_difference_type<_Ty, void> {
        using type = typename _Ty::difference_type;
    };
    template <class _Ty, class _Other, class  = void> struct _Get_rebind_alias {
        using type = typename _Replace_first_parameter<_Other, _Ty>::type;
    };
    template <class _Ty, class _Other> struct _Get_rebind_alias<_Ty, _Other, void> {
        using type = typename _Ty::rebind<_Other>;
    };
    template <class _Ty> struct pointer_traits {
        using element_type = typename _Get_element_type<_Ty>::type;
        using pointer = _Ty;
        using difference_type = typename _Get_ptr_difference_type<_Ty>::type;
        template <class _Other> using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;
        using _Reftype = conditional_t<is_void_v<std::pointer_traits::element_type>, char &, add_lvalue_reference_t<std::pointer_traits::element_type> >;
        static std::pointer_traits::pointer pointer_to(std::pointer_traits::_Reftype _Val)         {
            return (_Ty::pointer_to(_Val));
        }
    };
    template <class _Ty> struct pointer_traits<type-parameter-0-0 *> {
        using element_type = _Ty;
        using pointer = _Ty *;
        using difference_type = ptrdiff_t;
        template <class _Other> using rebind = _Other *;
        using _Reftype = conditional_t<is_void_v<_Ty>, char &, add_lvalue_reference_t<_Ty> >;
        static std::pointer_traits<type-parameter-0-0 *>::pointer pointer_to(std::pointer_traits<type-parameter-0-0 *>::_Reftype _Val)         {
            return (::std::addressof(_Val));
        }
    };
    template <class _Ptr, class _Ty> using _Rebind_pointer_t = typename pointer_traits<_Ptr>::rebind<_Ty>;
    template <class _Pointer, enable_if_t<!is_pointer_v<_Pointer>, int> = 0> inline _Pointer _Refancy(typename pointer_traits<_Pointer>::element_type *_Ptr)     {
        return (pointer_traits<_Pointer>::pointer_to(*_Ptr));
    }
    template <class _Pointer, enable_if_t<is_pointer_v<_Pointer>, int> = 0> inline _Pointer _Refancy(_Pointer _Ptr)     {
        return (_Ptr);
    }
    template <class _Ty> inline void _Destroy_in_place(_Ty &_Obj) noexcept     {
        _Obj.~_Ty();
    }
    template <class _Ptrty> inline auto _Const_cast(_Ptrty _Ptr)     {
        using _Elem = typename pointer_traits<_Ptrty>::element_type;
        using _Modifiable = remove_const_t<_Elem>;
        using _Dest = typename pointer_traits<_Ptrty>::rebind<_Modifiable>;
        return (pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable &>(*_Ptr)));
    }
    template <class _Ty> inline auto _Const_cast(_Ty *_Ptr)     {
        return (const_cast<remove_const_t<_Ty> *>(_Ptr));
    }
    template <class _Ty, class  = void> struct _Get_pointer_type {
        using type = typename _Ty::value_type *;
    };
    template <class _Ty> struct _Get_pointer_type<_Ty, void> {
        using type = typename _Ty::pointer;
    };
    template <class _Ty, class  = void> struct _Get_const_pointer_type {
        using _Ptrty = typename _Get_pointer_type<_Ty>::type;
        using _Valty = typename _Ty::value_type;
        using type = typename pointer_traits<_Ptrty>::rebind<const std::_Get_const_pointer_type::_Valty>;
    };
    template <class _Ty> struct _Get_const_pointer_type<_Ty, void> {
        using type = typename _Ty::const_pointer;
    };
    template <class _Ty, class  = void> struct _Get_void_pointer_type {
        using _Ptrty = typename _Get_pointer_type<_Ty>::type;
        using type = typename pointer_traits<_Ptrty>::rebind<void>;
    };
    template <class _Ty> struct _Get_void_pointer_type<_Ty, void> {
        using type = typename _Ty::void_pointer;
    };
    template <class _Ty, class  = void> struct _Get_const_void_pointer_type {
        using _Ptrty = typename _Get_pointer_type<_Ty>::type;
        using type = typename pointer_traits<_Ptrty>::rebind<const void>;
    };
    template <class _Ty> struct _Get_const_void_pointer_type<_Ty, void> {
        using type = typename _Ty::const_void_pointer;
    };
    template <class _Ty, class  = void> struct _Get_difference_type {
        using _Ptrty = typename _Get_pointer_type<_Ty>::type;
        using type = typename pointer_traits<_Ptrty>::difference_type;
    };
    template <class _Ty> struct _Get_difference_type<_Ty, void> {
        using type = typename _Ty::difference_type;
    };
    template <class _Ty, class  = void> struct _Get_size_type {
        using type = make_unsigned_t<typename _Get_difference_type<_Ty>::type>;
    };
    template <class _Ty> struct _Get_size_type<_Ty, void> {
        using type = typename _Ty::size_type;
    };
    template <class _Ty, class  = void> struct _Get_propagate_on_container_copy {
        using type = std::false_type;
    };
    template <class _Ty> struct _Get_propagate_on_container_copy<_Ty, void> {
        using type = typename _Ty::propagate_on_container_copy_assignment;
    };
    template <class _Ty, class  = void> struct _Get_propagate_on_container_move {
        using type = std::false_type;
    };
    template <class _Ty> struct _Get_propagate_on_container_move<_Ty, void> {
        using type = typename _Ty::propagate_on_container_move_assignment;
    };
    template <class _Ty, class  = void> struct _Get_propagate_on_container_swap {
        using type = std::false_type;
    };
    template <class _Ty> struct _Get_propagate_on_container_swap<_Ty, void> {
        using type = typename _Ty::propagate_on_container_swap;
    };
    template <class _Ty, class  = void> struct _Get_is_always_equal {
        using type = typename is_empty<_Ty>::type;
    };
    template <class _Ty> struct _Get_is_always_equal<_Ty, void> {
        using type = typename _Ty::is_always_equal;
    };
    template <class _Ty, class _Other, class  = void> struct _Get_rebind_type {
        using type = typename _Replace_first_parameter<_Other, _Ty>::type;
    };
    template <class _Ty, class _Other> struct _Get_rebind_type<_Ty, _Other, void> {
        using type = typename _Ty::template _Ty::rebind<_Other>::other;
    };
    template <class _Ty> class allocator
template<> class allocator<char> {
    public:
        static_assert(!is_const_v<char>, "The C++ Standard forbids containers of const elements because allocator<const T> is ill-formed.");
        using _Not_user_specialized = void;
        using value_type = char;
        typedef char *pointer;
        typedef const char *const_pointer;
        typedef char &reference;
        typedef const char &const_reference;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal = std::true_type;
        template <class _Other> struct rebind;
        char *address(char &_Val) const noexcept;
        const char *address(const char &_Val) const noexcept;
        constexpr allocator() noexcept;
        allocator(const std::allocator<char> &) = default
        template <class _Other> constexpr allocator(const allocator<_Other> &) noexcept;
        template<> constexpr allocator<char>(const allocator<char> &) noexcept;
        void deallocate(char *const _Ptr, const size_t _Count);
        char *allocate(const size_t _Count);
        char *allocate(const size_t _Count, const void *);
        template <class _Objty, class ..._Types> void construct(_Objty *const _Ptr, _Types &&..._Args);
        template <class _Uty> void destroy(_Uty *const _Ptr);
        size_t max_size() const noexcept;
    };
    template <class _Alloc, class  = void> struct _Is_default_allocator : std::false_type {
    };
template<> struct _Is_default_allocator<std::allocator<char>, void> : std::true_type {
    };
    template <class _Ty> struct _Is_default_allocator<allocator<type-parameter-0-0>, typename allocator<type-parameter-0-0>::_Not_user_specialized> : std::true_type {
    };
    template <class _Void, class ..._Types> struct _Has_no_alloc_construct : std::true_type {
    };
    template <class _Alloc, class _Ptr, class ..._Args> struct _Has_no_alloc_construct<void, <type-parameter-0-0, type-parameter-0-1, type-parameter-0-2...>> : std::false_type {
    };
    template <class _Alloc, class _Ptr, class ..._Args> using _Uses_default_construct = disjunction<_Is_default_allocator<_Alloc>, _Has_no_alloc_construct<void, _Alloc, _Ptr, _Args...> >;
    template <class _Alloc, class _Ptr, class ..._Args> using _Uses_default_construct_t = typename _Uses_default_construct<_Alloc, _Ptr, _Args...>::type;
    template <class _Alloc, class _Ptr, class  = void> struct _Has_no_alloc_destroy : std::true_type {
    };
    template <class _Alloc, class _Ptr> struct _Has_no_alloc_destroy<_Alloc, _Ptr, void> : std::false_type {
    };
    template <class _Alloc, class _Ptr> using _Uses_default_destroy = disjunction<_Is_default_allocator<_Alloc>, _Has_no_alloc_destroy<_Alloc, _Ptr> >;
    template <class _Alloc, class _Ptr> using _Uses_default_destroy_t = typename _Uses_default_destroy<_Alloc, _Ptr>::type;
    template <class _Alloc, class _Size_type, class _Const_void_pointer, class  = void> struct _Has_allocate_hint : std::false_type {
    };
    template <class _Alloc, class _Size_type, class _Const_void_pointer> struct _Has_allocate_hint<_Alloc, _Size_type, _Const_void_pointer, void> : std::true_type {
    };
    template <class _Alloc, class  = void> struct _Has_max_size : std::false_type {
    };
    template <class _Alloc> struct _Has_max_size<_Alloc, void> : std::true_type {
    };
    template <class _Alloc, class  = void> struct _Has_select_on_container_copy_construction : std::false_type {
    };
    template <class _Alloc> struct _Has_select_on_container_copy_construction<_Alloc, void> : std::true_type {
    };
    template <class _Alloc> struct allocator_traits
template<> struct allocator_traits<std::allocator<char>> : conditional_t<_Is_default_allocator<allocator<char> >::value, _Default_allocator_traits<std::allocator<char> >, _Normal_allocator_traits<std::allocator<char> > > {
    };
    template <class _Alloc> struct _Normal_allocator_traits {
        using allocator_type = _Alloc;
        using value_type = typename _Alloc::value_type;
        using pointer = typename _Get_pointer_type<_Alloc>::type;
        using const_pointer = typename _Get_const_pointer_type<_Alloc>::type;
        using void_pointer = typename _Get_void_pointer_type<_Alloc>::type;
        using const_void_pointer = typename _Get_const_void_pointer_type<_Alloc>::type;
        using size_type = typename _Get_size_type<_Alloc>::type;
        using difference_type = typename _Get_difference_type<_Alloc>::type;
        using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy<_Alloc>::type;
        using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move<_Alloc>::type;
        using propagate_on_container_swap = typename _Get_propagate_on_container_swap<_Alloc>::type;
        using is_always_equal = typename _Get_is_always_equal<_Alloc>::type;
        template <class _Other> using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
        template <class _Other> using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
        static std::_Normal_allocator_traits::pointer allocate(_Alloc &_Al, const std::_Normal_allocator_traits::size_type _Count)         {
            return (_Al.allocate(_Count));
        }
        static std::_Normal_allocator_traits::pointer _Allocate1(_Alloc &_Al, const std::_Normal_allocator_traits::size_type _Count, const std::_Normal_allocator_traits::const_void_pointer _Hint, std::true_type)         {
            return (_Al.allocate(_Count, _Hint));
        }
        static std::_Normal_allocator_traits::pointer _Allocate1(_Alloc &_Al, const std::_Normal_allocator_traits::size_type _Count, std::_Normal_allocator_traits::const_void_pointer, std::false_type)         {
            return (_Al.allocate(_Count));
        }
        static std::_Normal_allocator_traits::pointer allocate(_Alloc &_Al, const std::_Normal_allocator_traits::size_type _Count, const std::_Normal_allocator_traits::const_void_pointer _Hint)         {
            return (_Allocate1(_Al, _Count, _Hint, _Has_allocate_hint<_Alloc, std::_Normal_allocator_traits::size_type, std::_Normal_allocator_traits::const_void_pointer>({})));
        }
        static void deallocate(_Alloc &_Al, std::_Normal_allocator_traits::pointer _Ptr, std::_Normal_allocator_traits::size_type _Count)         {
            _Al.deallocate(_Ptr, _Count);
        }
        template <class _Ty, class ..._Types> static void _Construct1(std::true_type, _Alloc &, _Ty *_Ptr, _Types &&..._Args)         {
            ::new (static_cast<void *>(_Ptr)) _Ty((::std::forward<_Types>(_Args)...));
        }
        template <class _Ty, class ..._Types> static void _Construct1(std::false_type, _Alloc &_Al, _Ty *_Ptr, _Types &&..._Args)         {
            _Al.construct(_Ptr, ::std::forward<_Types>(_Args)...);
        }
        template <class _Ty, class ..._Types> static void construct(_Alloc &_Al, _Ty *_Ptr, _Types &&..._Args)         {
            _Construct1(_Uses_default_construct_t<_Alloc, _Ty *, _Types...>(), _Al, _Ptr, ::std::forward<_Types>(_Args)...);
        }
        template <class _Ty> static void _Destroy1(_Alloc &, _Ty *_Ptr, std::true_type)         {
            _Ptr->~_Ty();
        }
        template <class _Ty> static void _Destroy1(_Alloc &_Al, _Ty *_Ptr, std::false_type)         {
            _Al.destroy(_Ptr);
        }
        template <class _Ty> static void destroy(_Alloc &_Al, _Ty *_Ptr)         {
            _Destroy1(_Al, _Ptr, _Uses_default_destroy_t<_Alloc, _Ty *>());
        }
        static std::_Normal_allocator_traits::size_type _Max_size1(const _Alloc &_Al, std::true_type) noexcept         {
            return (_Al.max_size());
        }
        static std::_Normal_allocator_traits::size_type _Max_size1(const _Alloc &, std::false_type) noexcept         {
            return ((numeric_limits<size_type>::max)() / sizeof(std::_Normal_allocator_traits::value_type));
        }
        static std::_Normal_allocator_traits::size_type max_size(const _Alloc &_Al) noexcept         {
            return (_Max_size1(_Al, _Has_max_size<_Alloc>({})));
        }
        static _Alloc _Select_on_container_copy_construction1(const _Alloc &_Al, std::true_type)         {
            return (_Al.select_on_container_copy_construction());
        }
        static _Alloc _Select_on_container_copy_construction1(const _Alloc &_Al, std::false_type)         {
            return (_Al);
        }
        static _Alloc select_on_container_copy_construction(const _Alloc &_Al)         {
            return (_Select_on_container_copy_construction1(_Al, _Has_select_on_container_copy_construction<_Alloc>({})));
        }
    };
    template <class _Alloc> struct _Default_allocator_traits {
        using allocator_type = _Alloc;
        using value_type = typename _Alloc::value_type;
        using pointer = std::_Default_allocator_traits::value_type *;
        using const_pointer = const std::_Default_allocator_traits::value_type *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <class _Other> using rebind_alloc = allocator<_Other>;
        template <class _Other> using rebind_traits = allocator_traits<allocator<_Other> >;
        static std::_Default_allocator_traits::pointer allocate(_Alloc &, const std::_Default_allocator_traits::size_type _Count)         {
            return (static_cast<std::_Default_allocator_traits::pointer>(_Allocate<_New_alignof<std::_Default_allocator_traits::value_type> >(_Get_size_of_n<sizeof(std::_Default_allocator_traits::value_type)>(_Count))));
        }
        static std::_Default_allocator_traits::pointer allocate(_Alloc &, const std::_Default_allocator_traits::size_type _Count, std::_Default_allocator_traits::const_void_pointer)         {
            return (static_cast<std::_Default_allocator_traits::pointer>(_Allocate<_New_alignof<std::_Default_allocator_traits::value_type> >(_Get_size_of_n<sizeof(std::_Default_allocator_traits::value_type)>(_Count))));
        }
        static void deallocate(_Alloc &, const std::_Default_allocator_traits::pointer _Ptr, const std::_Default_allocator_traits::size_type _Count)         {
            _Deallocate<_New_alignof<std::_Default_allocator_traits::value_type> >(_Ptr, sizeof(std::_Default_allocator_traits::value_type) * _Count);
        }
        template <class _Objty, class ..._Types> static void construct(_Alloc &, _Objty *const _Ptr, _Types &&..._Args)         {
            ::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr))) _Objty((::std::forward<_Types>(_Args)...));
        }
        template <class _Uty> static void destroy(_Alloc &, _Uty *const _Ptr)         {
            _Ptr->~_Uty();
        }
        static std::_Default_allocator_traits::size_type max_size(const _Alloc &) noexcept         {
            return (static_cast<size_t>(-1) / sizeof(std::_Default_allocator_traits::value_type));
        }
        static _Alloc select_on_container_copy_construction(const _Alloc &_Al)         {
            return (_Al);
        }
    };
template<> struct _Default_allocator_traits<std::allocator<char>> {
        using allocator_type = std::allocator<char>;
        using value_type = typename allocator<char>::value_type;
        using pointer = std::_Default_allocator_traits<std::allocator<char> >::value_type *;
        using const_pointer = const std::_Default_allocator_traits<std::allocator<char> >::value_type *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <class _Other> using rebind_alloc = allocator<_Other>;
        template <class _Other> using rebind_traits = allocator_traits<allocator<_Other> >;
        static std::_Default_allocator_traits<std::allocator<char> >::pointer allocate(std::allocator<char> &, const std::_Default_allocator_traits::size_type _Count);
        static std::_Default_allocator_traits<std::allocator<char> >::pointer allocate(std::allocator<char> &, const std::_Default_allocator_traits::size_type _Count, std::_Default_allocator_traits::const_void_pointer);
        static void deallocate(std::allocator<char> &, const std::_Default_allocator_traits<std::allocator<char> >::pointer _Ptr, const std::_Default_allocator_traits::size_type _Count);
        template <class _Objty, class ..._Types> static void construct(std::allocator<char> &, _Objty *const _Ptr, _Types &&..._Args);
        template <class _Uty> static void destroy(std::allocator<char> &, _Uty *const _Ptr);
        static std::_Default_allocator_traits<std::allocator<char> >::size_type max_size(const std::allocator<char> &) noexcept;
        static std::allocator<char> select_on_container_copy_construction(const std::allocator<char> &_Al);
    };
    template <class _Alloc> struct allocator_traits : conditional_t<_Is_default_allocator<_Alloc>::value, _Default_allocator_traits<_Alloc>, _Normal_allocator_traits<_Alloc> > {
    };
template<> struct allocator_traits<std::allocator<char>> : conditional_t<_Is_default_allocator<allocator<char> >::value, _Default_allocator_traits<std::allocator<char> >, _Normal_allocator_traits<std::allocator<char> > > {
    };
    template <class _Alloc> constexpr bool _Always_equal_after_move = allocator_traits<_Alloc>::is_always_equal::value || allocator_traits<_Alloc>::propagate_on_container_move_assignment::value;
    template <class _Alloc, class _Value_type> using _Rebind_alloc_t = typename allocator_traits<_Alloc>::rebind_alloc<_Value_type>;
    template <class _Alloc> constexpr bool _Is_simple_alloc_v = is_same_v<typename allocator_traits<_Alloc>::size_type, size_t> && is_same_v<typename allocator_traits<_Alloc>::difference_type, ptrdiff_t> && is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type *> && is_same_v<typename allocator_traits<_Alloc>::const_pointer, const typename _Alloc::value_type *>;
    template <class _Value_type> struct _Simple_types {
        using value_type = _Value_type;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        using pointer = std::_Simple_types::value_type *;
        using const_pointer = const std::_Simple_types::value_type *;
    };
template<> struct _Simple_types<char> {
        using value_type = char;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        using pointer = std::_Simple_types<char>::value_type *;
        using const_pointer = const std::_Simple_types<char>::value_type *;
    };
    template <class _Ty> class allocator {
    public:
        static_assert(!is_const_v<_Ty>, "The C++ Standard forbids containers of const elements because allocator<const T> is ill-formed.");
        using _Not_user_specialized = void;
        using value_type = _Ty;
        typedef _Ty *pointer;
        typedef const _Ty *const_pointer;
        typedef _Ty &reference;
        typedef const _Ty &const_reference;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal = std::true_type;
        template <class _Other> struct rebind {
            using other = allocator<_Other>;
        };
        _Ty *address(_Ty &_Val) const noexcept         {
            return (::std::addressof(_Val));
        }
        const _Ty *address(const _Ty &_Val) const noexcept         {
            return (::std::addressof(_Val));
        }
        constexpr allocator<_Ty>() noexcept         {
        }
        allocator<_Ty>(const allocator<_Ty> &) noexcept = default
        template <class _Other> constexpr allocator<_Ty>(const allocator<_Other> &) noexcept         {
        }
        void deallocate(_Ty *const _Ptr, const size_t _Count)         {
            _Deallocate<_New_alignof<_Ty> >(_Ptr, sizeof(_Ty) * _Count);
        }
        _Ty *allocate(const size_t _Count)         {
            return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty> >(_Get_size_of_n<sizeof(_Ty)>(_Count))));
        }
        _Ty *allocate(const size_t _Count, const void *)         {
            return (allocate(_Count));
        }
        template <class _Objty, class ..._Types> void construct(_Objty *const _Ptr, _Types &&..._Args)         {
            ::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr))) _Objty((::std::forward<_Types>(_Args)...));
        }
        template <class _Uty> void destroy(_Uty *const _Ptr)         {
            _Ptr->~_Uty();
        }
        size_t max_size() const noexcept         {
            return (static_cast<size_t>(-1) / sizeof(_Ty));
        }
    };
template<> class allocator<char> {
    public:
        static_assert(!is_const_v<char>, "The C++ Standard forbids containers of const elements because allocator<const T> is ill-formed.");
        using _Not_user_specialized = void;
        using value_type = char;
        typedef char *pointer;
        typedef const char *const_pointer;
        typedef char &reference;
        typedef const char &const_reference;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal = std::true_type;
        template <class _Other> struct rebind;
        char *address(char &_Val) const noexcept;
        const char *address(const char &_Val) const noexcept;
        constexpr allocator() noexcept;
        allocator(const std::allocator<char> &) = default
        template <class _Other> constexpr allocator(const allocator<_Other> &) noexcept;
        template<> constexpr allocator<char>(const allocator<char> &) noexcept;
        void deallocate(char *const _Ptr, const size_t _Count);
        char *allocate(const size_t _Count);
        char *allocate(const size_t _Count, const void *);
        template <class _Objty, class ..._Types> void construct(_Objty *const _Ptr, _Types &&..._Args);
        template <class _Uty> void destroy(_Uty *const _Ptr);
        size_t max_size() const noexcept;
    };
    template<> class allocator<void> {
    public:
        using value_type = void;
        using pointer = void *;
        using const_pointer = const void *;
        template <class _Other> struct rebind {
            using other = allocator<_Other>;
        };
    };
    template <class _Ty, class _Other> inline bool operator==(const allocator<_Ty> &, const allocator<_Other> &) noexcept     {
        return (true);
    }
    template <class _Ty, class _Other> inline bool operator!=(const allocator<_Ty> &, const allocator<_Other> &) noexcept     {
        return (false);
    }
    template <class _Alloc> inline void _Pocca(_Alloc &_Left, const _Alloc &_Right, std::true_type) noexcept     {
        _Left = _Right;
    }
    template <class _Alloc> inline void _Pocca(_Alloc &, const _Alloc &, std::false_type) noexcept     {
    }
    template <class _Alloc> inline void _Pocca(_Alloc &_Left, const _Alloc &_Right) noexcept     {
        typename allocator_traits<_Alloc>::propagate_on_container_copy_assignment _Tag;
        _Pocca(_Left, _Right, _Tag);
    }
    template <class _Alloc> inline void _Pocma(_Alloc &_Left, _Alloc &_Right, std::true_type) noexcept     {
        _Left = ::std::move(_Right);
    }
    template <class _Alloc> inline void _Pocma(_Alloc &, _Alloc &, std::false_type) noexcept     {
    }
    template <class _Alloc> inline void _Pocma(_Alloc &_Left, _Alloc &_Right) noexcept     {
        typename allocator_traits<_Alloc>::propagate_on_container_move_assignment _Tag;
        _Pocma(_Left, _Right, _Tag);
    }
    template <class _Alloc> inline void _Pocs(_Alloc &_Left, _Alloc &_Right, std::true_type) noexcept     {
        _Swap_adl(_Left, _Right);
    }
    template <class _Alloc> inline void _Pocs(_Alloc &_Left, _Alloc &_Right, std::false_type) noexcept     {
        ;
        (void)_Left;
        (void)_Right;
    }
    template <class _Alloc> inline void _Pocs(_Alloc &_Left, _Alloc &_Right) noexcept     {
        typename allocator_traits<_Alloc>::propagate_on_container_swap _Tag;
        _Pocs(_Left, _Right, _Tag);
    }
    template <class _Alloc> inline void _Destroy_range1(typename allocator_traits<_Alloc>::pointer _First, typename allocator_traits<_Alloc>::pointer _Last, _Alloc &_Al, std::false_type)     {
        for (; _First != _Last; ++_First) {
            allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
        }
    }
    template <class _Alloc> inline void _Destroy_range1(typename allocator_traits<_Alloc>::pointer, typename allocator_traits<_Alloc>::pointer, _Alloc &, std::true_type)     {
    }
    template <class _Alloc> inline void _Destroy_range(typename allocator_traits<_Alloc>::pointer _First, typename allocator_traits<_Alloc>::pointer _Last, _Alloc &_Al)     {
        using _Val = typename _Alloc::value_type;
        _Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<is_trivially_destructible<_Val>, _Uses_default_destroy<_Alloc, _Val *> > >({}));
    }
    template <class _FwdIt> inline void _Destroy_range1(_FwdIt _First, _FwdIt _Last, std::false_type)     {
        for (; _First != _Last; ++_First) {
            _Destroy_in_place(*_First);
        }
    }
    template <class _FwdIt> inline void _Destroy_range1(_FwdIt, _FwdIt, std::true_type)     {
    }
    template <class _FwdIt> inline void _Destroy_range(_FwdIt _First, _FwdIt _Last)     {
        _Destroy_range1(_First, _Last, is_trivially_destructible<_Iter_value_t<_FwdIt> >());
    }
    template <class _Size_type> inline _Size_type _Convert_size(const size_t _Len)     {
        if (_Len > (numeric_limits<_Size_type>::max)()) {
            _Xlength_error("size_t too long for _Size_type");
        }
        return (static_cast<_Size_type>(_Len));
    }
    template<> inline size_t _Convert_size<unsigned long long>(const size_t _Len)     {
        return (_Len);
    }
    template <class _Alloc, enable_if_t<is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type *>, int> = 0> inline void _Deallocate_plain(_Alloc &_Al, typename _Alloc::value_type *const _Ptr)     {
        allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);
    }
    template <class _Alloc, enable_if_t<!is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type *>, int> = 0> inline void _Deallocate_plain(_Alloc &_Al, typename _Alloc::value_type *const _Ptr)     {
        using _Alloc_traits = allocator_traits<_Alloc>;
        using _Ptr_traits = pointer_traits<typename _Alloc_traits::pointer>;
        _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
    }
    constexpr bool _Is_simple_alloc_v = is_same_v<typename allocator_traits<allocator<char> >::size_type, size_t> && is_same_v<typename allocator_traits<allocator<char> >::difference_type, ptrdiff_t> && is_same_v<typename allocator_traits<allocator<char> >::pointer, typename allocator<char>::value_type *> && is_same_v<typename allocator_traits<allocator<char> >::const_pointer, const typename allocator<char>::value_type *>;
}
namespace std {
    typedef enum memory_order {
        memory_order_relaxed,
        memory_order_consume,
        memory_order_acquire,
        memory_order_release,
        memory_order_acq_rel,
        memory_order_seq_cst
    } memory_order;
    typedef unsigned long _Uint4_t;
    typedef std::_Uint4_t _Atomic_integral_t;
    typedef std::_Atomic_integral_t _Atomic_counter_t;
    inline std::_Atomic_integral_t _Get_atomic_count(const std::_Atomic_counter_t &_Counter)     {
        return (_Counter);
    }
}
extern "C" {
    unsigned char _BitScanForward(unsigned long *_Index, unsigned long _Mask) throw();
    unsigned char _BitScanForward64(unsigned long *_Index, unsigned long long _Mask) throw();
    unsigned char _BitScanReverse(unsigned long *_Index, unsigned long _Mask) throw();
    unsigned char _BitScanReverse64(unsigned long *_Index, unsigned long long _Mask) throw();
    unsigned char _bittest(const long *, long) throw();
    long _InterlockedAnd(volatile long *_Value, long _Mask) throw();
    short _InterlockedAnd16(volatile short *_Value, short _Mask) throw();
    long long _InterlockedAnd64(volatile long long *_Value, long long _Mask) throw();
    char _InterlockedAnd8(volatile char *_Value, char _Mask) throw();
    long _InterlockedCompareExchange(volatile long *_Destination, long _Exchange, long _Comparand) throw();
    short _InterlockedCompareExchange16(volatile short *_Destination, short _Exchange, short _Comparand) throw();
    long long _InterlockedCompareExchange64(volatile long long *_Destination, long long _Exchange, long long _Comparand) throw();
    char _InterlockedCompareExchange8(volatile char *_Destination, char _Exchange, char _Comparand) throw();
    long _InterlockedDecrement(volatile long *_Addend) throw();
    long _InterlockedExchange(volatile long *_Target, long _Value) throw();
    short _InterlockedExchange16(volatile short *_Target, short _Value) throw();
    long long _InterlockedExchange64(volatile long long *_Target, long long _Value) throw();
    char _InterlockedExchange8(volatile char *_Target, char _Value) throw();
    long _InterlockedExchangeAdd(volatile long *_Addend, long _Value) throw();
    short _InterlockedExchangeAdd16(volatile short *_Addend, short _Value) throw();
    long long _InterlockedExchangeAdd64(volatile long long *_Addend, long long _Value) throw();
    char _InterlockedExchangeAdd8(volatile char *_Addend, char _Value) throw();
    long _InterlockedIncrement(volatile long *_Addend) throw();
    long _InterlockedOr(volatile long *_Value, long _Mask) throw();
    short _InterlockedOr16(volatile short *_Value, short _Mask) throw();
    long long _InterlockedOr64(volatile long long *_Value, long long _Mask) throw();
    char _InterlockedOr8(volatile char *_Value, char _Mask) throw();
    long _InterlockedXor(volatile long *_Value, long _Mask) throw();
    short _InterlockedXor16(volatile short *_Value, short _Mask) throw();
    long long _InterlockedXor64(volatile long long *_Value, long long _Mask) throw();
    char _InterlockedXor8(volatile char *_Value, char _Mask) throw();
    void _ReadWriteBarrier() throw();
    unsigned char _interlockedbittestandset(volatile long *, long) throw();
    unsigned long long __shiftright128(unsigned long long _LowPart, unsigned long long _HighPart, unsigned char _Shift) throw();
    unsigned long long _umul128(unsigned long long _Multiplier, unsigned long long _Multiplicand, unsigned long long *_HighProduct) throw();
}
namespace std {
    template <class _Ty> inline pair<_Ty *, ptrdiff_t> _Get_temporary_buffer(ptrdiff_t _Count) noexcept     {
        if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty)) {
            for (; 0 < _Count; _Count /= 2) {
                const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);
                void *_Pbuf;
                {
                    _Pbuf = ::operator new(_Size, nothrow);
                }
                if (_Pbuf) {
                    return {static_cast<_Ty *>(_Pbuf), _Count};
                }
            }
        }
        return {nullptr, 0};
    }
    template <class _Ty> inline void _Return_temporary_buffer(_Ty *const _Pbuf) noexcept     {
        {
            ::operator delete(_Pbuf);
        }
    }
    template <class _FwdIt> struct _Uninitialized_backout {
        _FwdIt _First;
        _FwdIt _Last;
        explicit _Uninitialized_backout<_FwdIt>(_FwdIt _Dest) : _First(_Dest), _Last(_Dest)         {
        }
        _Uninitialized_backout<_FwdIt>(_FwdIt _First_, _FwdIt _Last_) : _First(_First_), _Last(_Last_)         {
        }
        _Uninitialized_backout<_FwdIt>(const _Uninitialized_backout<_FwdIt> &) = delete
        _Uninitialized_backout<_FwdIt> &operator=(const _Uninitialized_backout<_FwdIt> &) = delete
        ~_Uninitialized_backout<_FwdIt>()         {
            _Destroy_range(this->_First, this->_Last);
        }
        template <class ..._Types> void _Emplace_back(_Types &&..._Vals)         {
            _Construct_in_place(*this->_Last, ::std::forward<_Types>(_Vals)...);
            ++this->_Last;
        }
        _FwdIt _Release()         {
            this->_First = this->_Last;
            return (this->_Last);
        }
    };
    template <class _InIt, class _FwdIt> inline _FwdIt _Uninitialized_move_unchecked1(_InIt _First, const _InIt _Last, const _FwdIt _Dest, std::_General_ptr_iterator_tag)     {
        _Uninitialized_backout<_FwdIt> _Backout{_Dest};
        for (; _First != _Last; ++_First) {
            _Backout._Emplace_back(::std::move(*_First));
        }
        return (_Backout._Release());
    }
    template <class _InIt, class _FwdIt> inline _FwdIt _Uninitialized_move_unchecked1(const _InIt _First, const _InIt _Last, const _FwdIt _Dest, std::_Really_trivial_ptr_iterator_tag)     {
        return (_Copy_memmove(_First, _Last, _Dest));
    }
    template <class _InIt, class _FwdIt> inline _FwdIt _Uninitialized_move_unchecked(const _InIt _First, const _InIt _Last, const _FwdIt _Dest)     {
        return (_Uninitialized_move_unchecked1(_First, _Last, _Dest, _Ptr_move_cat(_First, _Dest)));
    }
    template <class _FwdIt, class _Alloc> class _Uninitialized_backout_al {
    public:
        _Uninitialized_backout_al<_FwdIt, _Alloc>(_FwdIt _Dest, _Alloc &_Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_)         {
        }
        _Uninitialized_backout_al<_FwdIt, _Alloc>(const _Uninitialized_backout_al<_FwdIt, _Alloc> &) = delete
        _Uninitialized_backout_al<_FwdIt, _Alloc> &operator=(const _Uninitialized_backout_al<_FwdIt, _Alloc> &) = delete
        ~_Uninitialized_backout_al<_FwdIt, _Alloc>()         {
            _Destroy_range(this->_First, this->_Last, this->_Al);
        }
        template <class ..._Types> void _Emplace_back(_Types &&..._Vals)         {
            allocator_traits<_Alloc>::construct(this->_Al, _Unfancy(this->_Last), ::std::forward<_Types>(_Vals)...);
            ++this->_Last;
        }
        _FwdIt _Release()         {
            this->_First = this->_Last;
            return (this->_Last);
        }
    private:
        _FwdIt _First;
        _FwdIt _Last;
        _Alloc &_Al;
    };
    template <class _InIt, class _FwdIt, class _Alloc> inline _FwdIt _Uninitialized_copy_al_unchecked(_InIt _First, const _InIt _Last, const _FwdIt _Dest, _Alloc &_Al, std::_General_ptr_iterator_tag, std::_Any_tag)     {
        _Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_Dest, _Al};
        for (; _First != _Last; ++_First) {
            _Backout._Emplace_back(*_First);
        }
        return (_Backout._Release());
    }
    template <class _Ty1, class _Ty2, class _Alloc> inline _Ty2 *_Uninitialized_copy_al_unchecked(_Ty1 *const _First, _Ty1 *const _Last, _Ty2 *const _Dest, _Alloc &, std::_Really_trivial_ptr_iterator_tag, std::true_type)     {
        return (_Copy_memmove(_First, _Last, _Dest));
    }
    template <class _InIt, class _FwdIt, class _Alloc> inline _FwdIt _Uninitialized_copy(const _InIt _First, const _InIt _Last, _FwdIt _Dest, _Alloc &_Al)     {
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
        _Seek_wrapped(_Dest, _Uninitialized_copy_al_unchecked(_UFirst, _ULast, _UDest, _Al, _Ptr_copy_cat(_UFirst, _UDest), _Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(*_UFirst)>()));
        return (_Dest);
    }
    template <class _InIt, class _FwdIt, class _Alloc> inline _FwdIt _Uninitialized_move_al_unchecked(_InIt _First, const _InIt _Last, const _FwdIt _Dest, _Alloc &_Al, std::_General_ptr_iterator_tag, std::_Any_tag)     {
        _Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_Dest, _Al};
        for (; _First != _Last; ++_First) {
            _Backout._Emplace_back(::std::move(*_First));
        }
        return (_Backout._Release());
    }
    template <class _Ty1, class _Ty2, class _Alloc> inline _Ty2 *_Uninitialized_move_al_unchecked(_Ty1 *const _First, _Ty1 *const _Last, _Ty2 *const _Dest, _Alloc &, std::_Really_trivial_ptr_iterator_tag, std::true_type)     {
        return (_Copy_memmove(_First, _Last, _Dest));
    }
    template <class _InIt, class _FwdIt, class _Alloc> inline _FwdIt _Uninitialized_move(const _InIt _First, const _InIt _Last, _FwdIt _Dest, _Alloc &_Al)     {
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
        _Seek_wrapped(_Dest, _Uninitialized_move_al_unchecked(_UFirst, _ULast, _UDest, _Al, _Ptr_move_cat(_UFirst, _UDest), _Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(::std::move(*_UFirst))>()));
        return (_Dest);
    }
    template <class _FwdIt, class _Diff, class _Alloc> inline _FwdIt _Uninit_alloc_fill_n1(const _FwdIt _First, _Diff _Count, const _Iter_value_t<_FwdIt> &_Val, _Alloc &_Al, std::false_type)     {
        _Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_First, _Al};
        for (; 0 < _Count; --_Count) {
            _Backout._Emplace_back(_Val);
        }
        return (_Backout._Release());
    }
    template <class _FwdIt, class _Diff, class _Alloc> inline _FwdIt _Uninit_alloc_fill_n1(const _FwdIt _First, const _Diff _Count, const _Iter_value_t<_FwdIt> &_Val, _Alloc &, std::true_type)     {
        ::memset(_First, static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));
        return (_First + _Count);
    }
    template <class _FwdIt, class _Diff, class _Alloc> inline _FwdIt _Uninitialized_fill_n(const _FwdIt _First, const _Diff _Count, const _Iter_value_t<_FwdIt> &_Val, _Alloc &_Al)     {
        return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al, bool_constant<conjunction_v<decltype(_Fill_memset_is_safe(_First, _Val)), _Uses_default_construct<_Alloc, decltype(_Unfancy(_First)), decltype(_Val)> > >({})));
    }
    template <class _FwdIt> using _Use_memset_value_construct_t = bool_constant<conjunction_v<is_pointer<_FwdIt>, is_scalar<_Iter_value_t<_FwdIt> >, negation<is_volatile<_Iter_value_t<_FwdIt> > >, negation<is_member_pointer<_Iter_value_t<_FwdIt> > > > >;
    template <class _FwdIt> inline _FwdIt _Zero_range(const _FwdIt _First, const _FwdIt _Last)     {
        char *const _First_ch = reinterpret_cast<char *>(_First);
        char *const _Last_ch = reinterpret_cast<char *>(_Last);
        ::memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));
        return (_Last);
    }
    template <class _FwdIt, class _Diff, class _Alloc> inline _FwdIt _Uninitialized_value_construct_n1(const _FwdIt _First, _Diff _Count, _Alloc &_Al, std::false_type)     {
        _Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_First, _Al};
        for (; 0 < _Count; --_Count) {
            _Backout._Emplace_back();
        }
        return (_Backout._Release());
    }
    template <class _FwdIt, class _Diff, class _Alloc> inline _FwdIt _Uninitialized_value_construct_n1(_FwdIt _First, _Diff _Count, _Alloc &, std::true_type)     {
        return (_Zero_range(_First, _First + _Count));
    }
    template <class _FwdIt, class _Diff, class _Alloc> inline _FwdIt _Uninitialized_value_construct_n(_FwdIt _First, _Diff _Count, _Alloc &_Al)     {
        return (_Uninitialized_value_construct_n1(_First, _Count, _Al, bool_constant<conjunction_v<_Use_memset_value_construct_t<_FwdIt>, _Uses_default_construct<_Alloc, decltype(_Unfancy(_First))> > >({})));
    }
    struct _Not_a_node_tag {
    };
    template <class _Ty> pair<_Ty *, ptrdiff_t> get_temporary_buffer(ptrdiff_t _Count) noexcept     {
        return (_Get_temporary_buffer<_Ty>(_Count));
    }
    template <class _Ty> void return_temporary_buffer(_Ty *_Pbuf)     {
        _Return_temporary_buffer(_Pbuf);
    }
}
struct __type_info_node;
extern __type_info_node __type_info_root_node;
extern "C" {
    struct __std_type_info_data {
        const char *_UndecoratedName;
        const char _DecoratedName[1];
        __std_type_info_data() = delete
        __std_type_info_data(const __std_type_info_data &) = delete
        __std_type_info_data(__std_type_info_data &&) = delete
        __std_type_info_data &operator=(const __std_type_info_data &) = delete
        __std_type_info_data &operator=(__std_type_info_data &&) = delete
    };
    int __std_type_info_compare(const __std_type_info_data *_Lhs, const __std_type_info_data *_Rhs);
    size_t __std_type_info_hash(const __std_type_info_data *_Data);
    const char *__std_type_info_name(__std_type_info_data *_Data, __type_info_node *_RootNode);
}
class type_info {
public:
    type_info(const type_info &) = delete
    type_info &operator=(const type_info &) = delete
    size_t hash_code() const noexcept     {
        return __std_type_info_hash(&this->_Data);
    }
    bool operator==(const type_info &_Other) const noexcept     {
        return __std_type_info_compare(&this->_Data, &_Other._Data) == 0;
    }
    bool operator!=(const type_info &_Other) const noexcept     {
        return __std_type_info_compare(&this->_Data, &_Other._Data) != 0;
    }
    bool before(const type_info &_Other) const noexcept     {
        return __std_type_info_compare(&this->_Data, &_Other._Data) < 0;
    }
    const char *name() const noexcept     {
        return __std_type_info_name(&this->_Data, &__type_info_root_node);
    }
    const char *raw_name() const noexcept     {
        return this->_Data._DecoratedName;
    }
    virtual ~type_info() noexcept;
private:
    mutable __std_type_info_data _Data;
};
namespace std {
    using ::type_info;
}
namespace std {
    class bad_cast : public std::exception {
    public:
        bad_cast() noexcept : std::exception("bad cast", 1)         {
        }
        static std::bad_cast __construct_from_string_literal(const char *const _Message) noexcept         {
            return std::bad_cast(_Message, 1);
        }
    private:
        bad_cast(const char *const _Message, int) noexcept : std::exception(_Message, 1)         {
        }
    };
    class bad_typeid : public std::exception {
    public:
        bad_typeid() noexcept : std::exception("bad typeid", 1)         {
        }
        static std::bad_typeid __construct_from_string_literal(const char *const _Message) noexcept         {
            return std::bad_typeid(_Message, 1);
        }
    private:
        friend  class __non_rtti_object;
        bad_typeid(const char *const _Message, int) noexcept : std::exception(_Message, 1)         {
        }
    };
    class __non_rtti_object : public std::bad_typeid {
    public:
        static std::__non_rtti_object __construct_from_string_literal(const char *const _Message) noexcept         {
            return std::__non_rtti_object(_Message, 1);
        }
    private:
        __non_rtti_object(const char *const _Message, int) noexcept : std::bad_typeid(_Message, 1)         {
        }
    };
}
namespace std {
    constexpr int _Small_object_num_ptrs = 6 + 16 / sizeof(void *);
}
namespace std {
    template <class _InIt, class _FwdIt> inline _FwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last, const _FwdIt _Dest, std::_General_ptr_iterator_tag)     {
        _Uninitialized_backout<_FwdIt> _Backout{_Dest};
        for (; _First != _Last; ++_First) {
            _Backout._Emplace_back(*_First);
        }
        return (_Backout._Release());
    }
    template <class _InIt, class _FwdIt> inline _FwdIt _Uninitialized_copy_unchecked(const _InIt _First, const _InIt _Last, const _FwdIt _Dest, std::_Really_trivial_ptr_iterator_tag)     {
        return (_Copy_memmove(_First, _Last, _Dest));
    }
    template <class _InIt, class _FwdIt> inline _FwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _FwdIt _Dest)     {
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
        _Seek_wrapped(_Dest, _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest, _Ptr_copy_cat(_UFirst, _UDest)));
        return (_Dest);
    }
    template <class _InIt, class _Diff, class _FwdIt> inline _FwdIt _Uninitialized_copy_n_unchecked2(_InIt _First, _Diff _Count, const _FwdIt _Dest, std::_General_ptr_iterator_tag)     {
        _Uninitialized_backout<_FwdIt> _Backout{_Dest};
        for (; 0 < _Count; --_Count , (void)++_First) {
            _Backout._Emplace_back(*_First);
        }
        return (_Backout._Release());
    }
    template <class _InIt, class _Diff, class _FwdIt> inline _FwdIt _Uninitialized_copy_n_unchecked2(const _InIt _First, const _Diff _Count, const _FwdIt _Dest, std::_Really_trivial_ptr_iterator_tag)     {
        return (_Copy_memmove(_First, _First + _Count, _Dest));
    }
    template <class _InIt, class _Diff, class _FwdIt> inline _FwdIt uninitialized_copy_n(const _InIt _First, const _Diff _Count_raw, _FwdIt _Dest)     {
        _Algorithm_int_t<_Diff> _Count = _Count_raw;
        if (0 < _Count) {
            const auto _UFirst = _Get_unwrapped_n(_First, _Count);
            const auto _UDest = _Get_unwrapped_n(_Dest, _Count);
            _Seek_wrapped(_Dest, _Uninitialized_copy_n_unchecked2(_UFirst, _Count, _UDest, _Ptr_copy_cat(_UFirst, _UDest)));
        }
        return (_Dest);
    }
    template <class _FwdIt, class _Tval> inline void _Uninitialized_fill_unchecked(const _FwdIt _First, const _FwdIt _Last, const _Tval &_Val, std::false_type)     {
        _Uninitialized_backout<_FwdIt> _Backout{_First};
        while (_Backout._Last != _Last)
            {
                _Backout._Emplace_back(_Val);
            }
        _Backout._Release();
    }
    template <class _FwdIt, class _Tval> inline void _Uninitialized_fill_unchecked(const _FwdIt _First, const _FwdIt _Last, const _Tval &_Val, std::true_type)     {
        ::memset(_First, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First));
    }
    template <class _FwdIt, class _Tval> inline void uninitialized_fill(const _FwdIt _First, const _FwdIt _Last, const _Tval &_Val)     {
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        _Uninitialized_fill_unchecked(_UFirst, _Get_unwrapped(_Last), _Val, _Fill_memset_is_safe(_UFirst, _Val));
    }
    template <class _FwdIt, class _Diff, class _Tval> inline _FwdIt _Uninitialized_fill_n_unchecked1(const _FwdIt _First, _Diff _Count, const _Tval &_Val, std::false_type)     {
        _Uninitialized_backout<_FwdIt> _Backout{_First};
        for (; 0 < _Count; --_Count) {
            _Backout._Emplace_back(_Val);
        }
        return (_Backout._Release());
    }
    template <class _FwdIt, class _Diff, class _Tval> inline _FwdIt _Uninitialized_fill_n_unchecked1(const _FwdIt _First, const _Diff _Count, const _Tval &_Val, std::true_type)     {
        ::memset(_First, static_cast<unsigned char>(_Val), _Count);
        return (_First + _Count);
    }
    template <class _FwdIt, class _Diff, class _Tval> inline _FwdIt uninitialized_fill_n(_FwdIt _First, const _Diff _Count_raw, const _Tval &_Val)     {
        _Algorithm_int_t<_Diff> _Count = _Count_raw;
        if (0 < _Count) {
            const auto _UFirst = _Get_unwrapped_n(_First, _Count);
            _Seek_wrapped(_First, _Uninitialized_fill_n_unchecked1(_UFirst, _Count, _Val, _Fill_memset_is_safe(_UFirst, _Val)));
        }
        return (_First);
    }
    template <class _OutIt, class _Ty> class raw_storage_iterator {
    public:
        using iterator_category = std::output_iterator_tag;
        using value_type = void;
        using difference_type = void;
        using pointer = void;
        using reference = void;
        explicit raw_storage_iterator<_OutIt, _Ty>(_OutIt _First) : _Next(_First)         {
        }
        raw_storage_iterator<_OutIt, _Ty> &operator*()         {
            return (*this);
        }
        raw_storage_iterator<_OutIt, _Ty> &operator=(const _Ty &_Val)         {
            _Construct_in_place(*this->_Next, _Val);
            return (*this);
        }
        raw_storage_iterator<_OutIt, _Ty> &operator=(_Ty &&_Val)         {
            _Construct_in_place(*this->_Next, ::std::move(_Val));
            return (*this);
        }
        raw_storage_iterator<_OutIt, _Ty> &operator++()         {
            ++this->_Next;
            return (*this);
        }
        raw_storage_iterator<_OutIt, _Ty> operator++(int)         {
            raw_storage_iterator<_OutIt, _Ty> _Ans = *this;
            ++this->_Next;
            return (_Ans);
        }
        _OutIt base() const         {
            return (this->_Next);
        }
    private:
        _OutIt _Next;
    };
    template <class _Ty> class auto_ptr;
    template <class _Ty> struct auto_ptr_ref {
        explicit auto_ptr_ref<_Ty>(_Ty *_Right) : _Ref(_Right)         {
        }
        _Ty *_Ref;
    };
    template <class _Ty> class auto_ptr {
    public:
        typedef _Ty element_type;
        explicit auto_ptr<_Ty>(_Ty *_Ptr = nullptr) noexcept : _Myptr(_Ptr)         {
        }
        auto_ptr<_Ty>(auto_ptr<_Ty> &_Right) noexcept : _Myptr(_Right.release())         {
        }
        auto_ptr<_Ty>(auto_ptr_ref<_Ty> _Right) noexcept         {
            _Ty *_Ptr = _Right._Ref;
            _Right._Ref = nullptr;
            this->_Myptr = _Ptr;
        }
        template <class _Other> operator auto_ptr<_Other>() noexcept         {
            return (auto_ptr<_Other>(*this));
        }
        template <class _Other> operator auto_ptr_ref<_Other>() noexcept         {
            _Other *_Cvtptr = this->_Myptr;
            auto_ptr_ref<_Other> _Ans(_Cvtptr);
            this->_Myptr = nullptr;
            return (_Ans);
        }
        template <class _Other> auto_ptr<_Ty> &operator=(auto_ptr<_Other> &_Right) noexcept         {
            this->reset(_Right.release());
            return (*this);
        }
        template <class _Other> auto_ptr<_Ty>(auto_ptr<_Other> &_Right) noexcept : _Myptr(_Right.release())         {
        }
        auto_ptr<_Ty> &operator=(auto_ptr<_Ty> &_Right) noexcept         {
            this->reset(_Right.release());
            return (*this);
        }
        auto_ptr<_Ty> &operator=(auto_ptr_ref<_Ty> _Right) noexcept         {
            _Ty *_Ptr = _Right._Ref;
            _Right._Ref = 0;
            this->reset(_Ptr);
            return (*this);
        }
        ~auto_ptr<_Ty>() noexcept         {
            delete this->_Myptr;
        }
        _Ty &operator*() const noexcept         {
            return (*this->get());
        }
        _Ty *operator->() const noexcept         {
            return (this->get());
        }
        _Ty *get() const noexcept         {
            return (this->_Myptr);
        }
        _Ty *release() noexcept         {
            _Ty *_Tmp = this->_Myptr;
            this->_Myptr = nullptr;
            return (_Tmp);
        }
        void reset(_Ty *_Ptr = nullptr)         {
            if (_Ptr != this->_Myptr)
                delete this->_Myptr;
            this->_Myptr = _Ptr;
        }
    private:
        _Ty *_Myptr;
    };
    template<> class auto_ptr<void> {
    public:
        typedef void element_type;
    };
    class bad_weak_ptr : public std::exception {
    public:
        bad_weak_ptr() noexcept : std::exception()         {
        }
        virtual const char *what() const noexcept override         {
            return ("bad_weak_ptr");
        }
    };
    class __declspec(novtable) _Ref_count_base {
    private:
        virtual void _Destroy() noexcept = 0;
        virtual void _Delete_this() noexcept = 0;
        std::_Atomic_counter_t _Uses;
        std::_Atomic_counter_t _Weaks;
    protected:
        _Ref_count_base() : _Uses(1), _Weaks(1)         {
        }
    public:
        virtual ~_Ref_count_base() noexcept         {
        }
        bool _Incref_nz()         {
            for (;;) {
                const std::_Atomic_integral_t _Count = static_cast<volatile std::_Atomic_counter_t &>(this->_Uses);
                if (_Count == 0)
                    return (false);
                if (static_cast<std::_Atomic_integral_t>(_InterlockedCompareExchange(reinterpret_cast<volatile long *>(&this->_Uses), static_cast<long>(_Count + 1), static_cast<long>(_Count))) == _Count)
                    return (true);
            }
        }
        void _Incref()         {
            _InterlockedIncrement(reinterpret_cast<volatile long *>(&this->_Uses));
        }
        void _Incwref()         {
            _InterlockedIncrement(reinterpret_cast<volatile long *>(&this->_Weaks));
        }
        void _Decref()         {
            if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&this->_Uses)) == 0) {
                this->_Destroy();
                this->_Decwref();
            }
        }
        void _Decwref()         {
            if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&this->_Weaks)) == 0) {
                this->_Delete_this();
            }
        }
        long _Use_count() const noexcept         {
            return (static_cast<long>(_Get_atomic_count(this->_Uses)));
        }
        virtual void *_Get_deleter(const type_info &) const noexcept         {
            return (nullptr);
        }
    };
    template <class _Ty> class _Ref_count : public std::_Ref_count_base {
    public:
        explicit _Ref_count<_Ty>(_Ty *_Px) : std::_Ref_count_base(), _Ptr(_Px)         {
        }
    private:
        virtual void _Destroy() noexcept override         {
            delete this->_Ptr;
        }
        virtual void _Delete_this() noexcept override         {
            delete this;
        }
        _Ty *_Ptr;
    };
    template <class _Resource, class _Dx> class _Ref_count_resource : public std::_Ref_count_base {
    public:
        _Ref_count_resource<_Resource, _Dx>(_Resource _Px, _Dx _Dt) : std::_Ref_count_base(), _Mypair(std::_One_then_variadic_args_t(), ::std::move(_Dt), _Px)         {
        }
        virtual void *_Get_deleter(const type_info &_Typeid) const noexcept override         {
            if (_Typeid == typeid(_Dx)) {
                return (const_cast<_Dx *>(::std::addressof(this->_Mypair._Get_first())));
            }
            return (nullptr);
        }
    private:
        virtual void _Destroy() noexcept override         {
            this->_Mypair._Get_first()(this->_Mypair._Get_second());
        }
        virtual void _Delete_this() noexcept override         {
            delete this;
        }
        _Compressed_pair<_Dx, _Resource> _Mypair;
    };
    template <class _Resource, class _Dx, class _Alloc> class _Ref_count_resource_alloc : public std::_Ref_count_base {
    public:
        _Ref_count_resource_alloc<_Resource, _Dx, _Alloc>(_Resource _Px, _Dx _Dt, const _Alloc &_Ax) : std::_Ref_count_base(), _Mypair(std::_One_then_variadic_args_t(), ::std::move(_Dt), std::_One_then_variadic_args_t(), _Ax, _Px)         {
        }
        virtual void *_Get_deleter(const type_info &_Typeid) const noexcept override         {
            if (_Typeid == typeid(_Dx)) {
                return (const_cast<_Dx *>(::std::addressof(this->_Mypair._Get_first())));
            }
            return (nullptr);
        }
    private:
        using _Myalty = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc<_Resource, _Dx, _Alloc> >;
        virtual void _Destroy() noexcept override         {
            this->_Mypair._Get_first()(this->_Mypair._Get_second()._Get_second());
        }
        virtual void _Delete_this() noexcept override         {
            std::_Ref_count_resource_alloc::_Myalty _Al = this->_Mypair._Get_second()._Get_first();
            allocator_traits<_Myalty>::destroy(_Al, this);
            _Deallocate_plain(_Al, this);
        }
        _Compressed_pair<_Dx, _Compressed_pair<std::_Ref_count_resource_alloc::_Myalty, _Resource> > _Mypair;
    };
    template <class _Ty> struct default_delete
template<> struct default_delete<v8::internal::ScriptStreamingData> {
        default_delete() noexcept = default
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, v8::internal::ScriptStreamingData *>, int> = 0> default_delete(const default_delete<_Ty2> &) noexcept;
        template<> default_delete<v8::internal::ScriptStreamingData, 0>(const default_delete<v8::internal::ScriptStreamingData> &) noexcept;
        void operator()(v8::internal::ScriptStreamingData *_Ptr) const noexcept;
    }
template<> struct default_delete<unsigned char const[]> {
        default_delete() noexcept = default
        template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], const unsigned char (*)[]>, int> = 0> default_delete(const default_delete<_Uty []> &) noexcept;
        template<> default_delete<const unsigned char, 0>(const default_delete<const unsigned char []> &) noexcept;
        template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], const unsigned char (*)[]>, int> = 0> void operator()(_Uty *_Ptr) const noexcept;
        template<> void operator()<const unsigned char, 0>(const unsigned char *_Ptr) const noexcept         {
            static_assert(0 < sizeof(const unsigned char), "can't delete an incomplete type");
            delete [] _Ptr;
        }
;
    }
template<> struct default_delete<v8::WasmStreaming::WasmStreamingImpl> {
        default_delete() noexcept = default
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, v8::WasmStreaming::WasmStreamingImpl *>, int> = 0> default_delete(const default_delete<_Ty2> &) noexcept;
        template<> default_delete<v8::WasmStreaming::WasmStreamingImpl, 0>(const default_delete<v8::WasmStreaming::WasmStreamingImpl> &) noexcept;
        void operator()(v8::WasmStreaming::WasmStreamingImpl *_Ptr) const noexcept;
    };
    template <class _Ty, class _Dx = default_delete<_Ty>> class unique_ptr
template<> class unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData>> : public _Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > {
    public:
        typedef _Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > _Mybase;
        typedef typename _Mybase::pointer pointer;
        typedef v8::internal::ScriptStreamingData element_type;
        typedef std::default_delete<v8::internal::ScriptStreamingData> deleter_type;
        using _Mybase::get_deleter;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr() noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr(std::nullptr_t) noexcept;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=(std::nullptr_t) noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, _Unique_ptr_enable_default_t<_Dx2> = 0> explicit unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer _Ptr) noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, enable_if_t<is_constructible_v<_Dx2, const _Dx2 &>, int> = 0> unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer _Ptr, const std::default_delete<v8::internal::ScriptStreamingData> &_Dt) noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, enable_if_t<conjunction_v<negation<is_reference<_Dx2> >, is_constructible<_Dx2, _Dx2> >, int> = 0> unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer _Ptr, std::default_delete<v8::internal::ScriptStreamingData> &&_Dt) noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2> > >, int> = 0> unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer, remove_reference_t<std::default_delete<v8::internal::ScriptStreamingData> > &&) = delete
        unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &&_Right) noexcept;
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer>, conditional_t<is_reference_v<std::default_delete<v8::internal::ScriptStreamingData> >, is_same<_Dx2, std::default_delete<v8::internal::ScriptStreamingData> >, is_convertible<_Dx2, std::default_delete<v8::internal::ScriptStreamingData> > > >, int> = 0> unique_ptr(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept;
        template<> unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData>, 0>(unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &&_Right) noexcept;
        template <class _Ty2, enable_if_t<conjunction_v<is_convertible<_Ty2 *, v8::internal::ScriptStreamingData *>, is_same<std::default_delete<v8::internal::ScriptStreamingData>, default_delete<v8::internal::ScriptStreamingData> > >, int> = 0> unique_ptr(auto_ptr<_Ty2> &&_Right) noexcept;
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_assignable<std::default_delete<v8::internal::ScriptStreamingData> &, _Dx2>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer> >, int> = 0> std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept;
        template<> std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData>, 0>(unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &&_Right) noexcept;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &&_Right) noexcept;
        void swap(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &_Right) noexcept;
        ~unique_ptr<ScriptStreamingData, default_delete<ScriptStreamingData> >() noexcept;
        add_lvalue_reference_t<v8::internal::ScriptStreamingData> operator*() const;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer operator->() const noexcept;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer get() const noexcept         {
            return (this->_Myptr());
        }
        explicit operator bool() const noexcept;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer release() noexcept;
        void reset(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer _Ptr) noexcept;
        unique_ptr(const std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &) = delete
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=(const std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &) = delete
    }
template<> class unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]>> : public _Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> > {
    public:
        typedef _Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> > _Mybase;
        typedef typename _Mybase::pointer pointer;
        typedef const unsigned char element_type;
        typedef std::default_delete<unsigned char const[]> deleter_type;
        using _Mybase::get_deleter;
        template <class _Dx2 = std::default_delete<unsigned char const[]>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr() noexcept;
        template<> constexpr unique_ptr<std::default_delete<unsigned char const[]>, 0>() noexcept;
        template <class _Uty, class _Is_nullptr = is_same<_Uty, std::nullptr_t>> using _Enable_ctor_reset = enable_if_t<is_same_v<_Uty, std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer> || _Is_nullptr::value || (is_same_v<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer, std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::element_type *> && is_pointer_v<_Uty> && is_convertible_v<remove_pointer_t<_Uty> (*)[], std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::element_type (*)[]>)>;
        template <class _Uty, class _Dx2 = std::default_delete<unsigned char const[]>, _Unique_ptr_enable_default_t<_Dx2> = 0, class  = _Enable_ctor_reset<_Uty>> explicit unique_ptr(_Uty _Ptr) noexcept;
        template <class _Uty, class _Dx2 = std::default_delete<unsigned char const[]>, enable_if_t<is_constructible_v<_Dx2, const _Dx2 &>, int> = 0, class  = _Enable_ctor_reset<_Uty>> unique_ptr(_Uty _Ptr, const std::default_delete<unsigned char const[]> &_Dt) noexcept;
        template <class _Uty, class _Dx2 = std::default_delete<unsigned char const[]>, enable_if_t<conjunction_v<negation<is_reference<_Dx2> >, is_constructible<_Dx2, _Dx2> >, int> = 0, class  = _Enable_ctor_reset<_Uty>> unique_ptr(_Uty _Ptr, std::default_delete<unsigned char const[]> &&_Dt) noexcept;
        template <class _Uty, class _Dx2 = std::default_delete<unsigned char const[]>, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2> > >, int> = 0> unique_ptr(_Uty, remove_reference_t<std::default_delete<unsigned char const[]> > &&) = delete
        unique_ptr(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &&_Right) noexcept : std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::_Mybase(_Right.release(), ::std::forward<std::default_delete<unsigned char const[]> >(_Right.get_deleter()))         {
        }
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &&_Right) noexcept;
        template <class _Uty, class _Ex, class _More, class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer, class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type> using _Enable_conversion = enable_if_t<conjunction_v<is_array<_Uty>, is_same<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer, std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::element_type *>, is_same<_UP_pointer, _UP_element_type *>, is_convertible<_UP_element_type (*)[], std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::element_type (*)[]>, _More> >;
        template <class _Uty, class _Ex, class  = _Enable_conversion<_Uty, _Ex, conditional_t<is_reference_v<std::default_delete<unsigned char const[]> >, is_same<_Ex, std::default_delete<unsigned char const[]> >, is_convertible<_Ex, std::default_delete<unsigned char const[]> > > >> unique_ptr(unique_ptr<_Uty, _Ex> &&_Right) noexcept;
        template<> unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]>, void>(unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &&_Right) noexcept;
        template <class _Uty, class _Ex, class  = _Enable_conversion<_Uty, _Ex, is_assignable<std::default_delete<unsigned char const[]> &, _Ex> >> std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=(unique_ptr<_Uty, _Ex> &&_Right) noexcept;
        template<> std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=<unsigned char const[], std::default_delete<unsigned char const[]>, void>(unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &&_Right) noexcept;
        template <class _Dx2 = std::default_delete<unsigned char const[]>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr(std::nullptr_t) noexcept;
        template<> constexpr unique_ptr<std::default_delete<unsigned char const[]>, 0>(std::nullptr_t) noexcept : std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::_Mybase(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer())         {
        }
;
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=(std::nullptr_t) noexcept;
        void reset(std::nullptr_t) noexcept;
        void swap(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &_Right) noexcept;
        ~unique_ptr<unsigned char const[], default_delete<unsigned char const[]> >() noexcept         {
            this->_Delete();
        }
        const unsigned char &operator[](size_t _Idx) const;
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer get() const noexcept         {
            return (this->_Myptr());
        }
        explicit operator bool() const noexcept;
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer release() noexcept         {
            std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer _Ans = this->get();
            this->_Myptr() = std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer();
            return (_Ans);
        }
        template <class _Uty, class  = _Enable_ctor_reset<_Uty, std::false_type>> void reset(_Uty _Ptr) noexcept;
        unique_ptr(const std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &) = delete
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=(const std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &) = delete
    private:
        void _Delete()         {
            if (this->get() != std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer()) {
                this->get_deleter()(this->get());
            }
        }
    }
template<> class unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> : public _Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > {
    public:
        typedef _Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > _Mybase;
        typedef typename _Mybase::pointer pointer;
        typedef v8::WasmStreaming::WasmStreamingImpl element_type;
        typedef std::default_delete<v8::WasmStreaming::WasmStreamingImpl> deleter_type;
        using _Mybase::get_deleter;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr() noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr(std::nullptr_t) noexcept;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &operator=(std::nullptr_t) noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, _Unique_ptr_enable_default_t<_Dx2> = 0> explicit unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer _Ptr) noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, enable_if_t<is_constructible_v<_Dx2, const _Dx2 &>, int> = 0> unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer _Ptr, const std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &_Dt) noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, enable_if_t<conjunction_v<negation<is_reference<_Dx2> >, is_constructible<_Dx2, _Dx2> >, int> = 0> unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer _Ptr, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &&_Dt) noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2> > >, int> = 0> unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer, remove_reference_t<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &&) = delete
        unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &&_Right) noexcept;
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer>, conditional_t<is_reference_v<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >, is_same<_Dx2, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >, is_convertible<_Dx2, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > > >, int> = 0> unique_ptr(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept;
        template<> unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, 0>(unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &&_Right) noexcept;
        template <class _Ty2, enable_if_t<conjunction_v<is_convertible<_Ty2 *, v8::WasmStreaming::WasmStreamingImpl *>, is_same<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, default_delete<v8::WasmStreaming::WasmStreamingImpl> > >, int> = 0> unique_ptr(auto_ptr<_Ty2> &&_Right) noexcept;
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_assignable<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &, _Dx2>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer> >, int> = 0> std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &operator=(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &operator=(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &&_Right) noexcept;
        void swap(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &_Right) noexcept;
        ~unique_ptr<WasmStreamingImpl, default_delete<WasmStreamingImpl> >() noexcept;
        add_lvalue_reference_t<v8::WasmStreaming::WasmStreamingImpl> operator*() const;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer operator->() const noexcept;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer get() const noexcept;
        explicit operator bool() const noexcept;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer release() noexcept;
        void reset(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer _Ptr) noexcept;
        unique_ptr(const std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &) = delete
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &operator=(const std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &) = delete
    };
    template <class _Ty> class shared_ptr
template<> class shared_ptr<v8::internal::wasm::NativeModule> : public _Ptr_base<v8::internal::wasm::NativeModule> {
    private:
        using _Mybase = _Ptr_base<v8::internal::wasm::NativeModule>;
    public:
        using typename _Mybase::element_type;
        constexpr shared_ptr() noexcept : _Ptr_base<v8::internal::wasm::NativeModule>()         {
        }
        constexpr shared_ptr(std::nullptr_t) noexcept;
        template <class _Ux, enable_if_t<conjunction_v<conditional_t<is_array_v<v8::internal::wasm::NativeModule>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux> >, _SP_convertible<_Ux, v8::internal::wasm::NativeModule> >, int> = 0> explicit shared_ptr(_Ux *_Px);
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, v8::internal::wasm::NativeModule> >, int> = 0> shared_ptr(_Ux *_Px, _Dx _Dt);
        template <class _Ux, class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, v8::internal::wasm::NativeModule> >, int> = 0> shared_ptr(_Ux *_Px, _Dx _Dt, _Alloc _Ax);
        template <class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr(std::nullptr_t, _Dx _Dt);
        template <class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr(std::nullptr_t, _Dx _Dt, _Alloc _Ax);
        template <class _Ty2> shared_ptr(const shared_ptr<_Ty2> &_Right, std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type *_Px) noexcept;
        shared_ptr(const std::shared_ptr<v8::internal::wasm::NativeModule> &_Other) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, NativeModule>::value, int> = 0> shared_ptr(const shared_ptr<_Ty2> &_Other) noexcept;
        template<> shared_ptr<v8::internal::wasm::NativeModule, 0>(const shared_ptr<v8::internal::wasm::NativeModule> &_Other) noexcept;
        shared_ptr(std::shared_ptr<v8::internal::wasm::NativeModule> &&_Right) noexcept : _Ptr_base<v8::internal::wasm::NativeModule>()         {
            this->_Move_construct_from(::std::move(_Right));
        }
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, NativeModule>::value, int> = 0> shared_ptr(shared_ptr<_Ty2> &&_Right) noexcept;
        template<> shared_ptr<v8::internal::wasm::NativeModule, 0>(shared_ptr<v8::internal::wasm::NativeModule> &&_Right) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, NativeModule>::value, int> = 0> explicit shared_ptr(const weak_ptr<_Ty2> &_Other);
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, v8::internal::wasm::NativeModule *>, int> = 0> shared_ptr(auto_ptr<_Ty2> &&_Other);
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, v8::internal::wasm::NativeModule>, is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type *> >, int> = 0> shared_ptr(unique_ptr<_Ux, _Dx> &&_Other);
        ~shared_ptr<NativeModule>() noexcept         {
            this->_Decref();
        }
        std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(const std::shared_ptr<v8::internal::wasm::NativeModule> &_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(const shared_ptr<_Ty2> &_Right) noexcept;
        template<> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=<v8::internal::wasm::NativeModule>(const shared_ptr<v8::internal::wasm::NativeModule> &_Right) noexcept;
        std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(std::shared_ptr<v8::internal::wasm::NativeModule> &&_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(shared_ptr<_Ty2> &&_Right) noexcept;
        template<> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=<v8::internal::wasm::NativeModule>(shared_ptr<v8::internal::wasm::NativeModule> &&_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(auto_ptr<_Ty2> &&_Right);
        template <class _Ux, class _Dx> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(unique_ptr<_Ux, _Dx> &&_Right);
        void swap(std::shared_ptr<v8::internal::wasm::NativeModule> &_Other) noexcept;
        void reset() noexcept;
        template <class _Ux> void reset(_Ux *_Px);
        template <class _Ux, class _Dx> void reset(_Ux *_Px, _Dx _Dt);
        template <class _Ux, class _Dx, class _Alloc> void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax);
        using _Mybase::get;
        template <class _Ty2 = v8::internal::wasm::NativeModule, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2> >, int> = 0> _Ty2 &operator*() const noexcept;
        template <class _Ty2 = v8::internal::wasm::NativeModule, enable_if_t<!is_array_v<_Ty2>, int> = 0> _Ty2 *operator->() const noexcept;
        template <class _Ty2 = v8::internal::wasm::NativeModule, class _Elem = std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type, enable_if_t<is_array_v<_Ty2>, int> = 0> _Elem &operator[](ptrdiff_t _Idx) const;
        bool unique() const noexcept;
        explicit operator bool() const noexcept;
    private:
        template <class _Ux> void _Setp(_Ux *_Px, std::true_type);
        template <class _Ux> void _Setp(_Ux *_Px, std::false_type);
        template <class _UxptrOrNullptr, class _Dx> void _Setpd(_UxptrOrNullptr _Px, _Dx _Dt);
        template <class _UxptrOrNullptr, class _Dx, class _Alloc> void _Setpda(_UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax);
        friend template <class _Ty0, class ..._Types> shared_ptr<_Ty0> make_shared(_Types &&..._Args);
        friend template <class _Ty0, class _Alloc, class ..._Types> shared_ptr<_Ty0> allocate_shared(const _Alloc &_Al_arg, _Types &&..._Args);
        template <class _Ux> void _Set_ptr_rep_and_enable_shared(_Ux *_Px, std::_Ref_count_base *_Rx);
        void _Set_ptr_rep_and_enable_shared(std::nullptr_t, std::_Ref_count_base *_Rx);
    }
template<> class shared_ptr<v8::internal::wasm::StreamingDecoder> : public _Ptr_base<v8::internal::wasm::StreamingDecoder> {
    private:
        using _Mybase = _Ptr_base<v8::internal::wasm::StreamingDecoder>;
    public:
        using typename _Mybase::element_type;
        constexpr shared_ptr() noexcept;
        constexpr shared_ptr(std::nullptr_t) noexcept;
        template <class _Ux, enable_if_t<conjunction_v<conditional_t<is_array_v<v8::internal::wasm::StreamingDecoder>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux> >, _SP_convertible<_Ux, v8::internal::wasm::StreamingDecoder> >, int> = 0> explicit shared_ptr(_Ux *_Px);
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, v8::internal::wasm::StreamingDecoder> >, int> = 0> shared_ptr(_Ux *_Px, _Dx _Dt);
        template <class _Ux, class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, v8::internal::wasm::StreamingDecoder> >, int> = 0> shared_ptr(_Ux *_Px, _Dx _Dt, _Alloc _Ax);
        template <class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr(std::nullptr_t, _Dx _Dt);
        template <class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr(std::nullptr_t, _Dx _Dt, _Alloc _Ax);
        template <class _Ty2> shared_ptr(const shared_ptr<_Ty2> &_Right, std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type *_Px) noexcept;
        shared_ptr(const std::shared_ptr<v8::internal::wasm::StreamingDecoder> &_Other) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, StreamingDecoder>::value, int> = 0> shared_ptr(const shared_ptr<_Ty2> &_Other) noexcept;
        template<> shared_ptr<v8::internal::wasm::StreamingDecoder, 0>(const shared_ptr<v8::internal::wasm::StreamingDecoder> &_Other) noexcept;
        shared_ptr(std::shared_ptr<v8::internal::wasm::StreamingDecoder> &&_Right) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, StreamingDecoder>::value, int> = 0> shared_ptr(shared_ptr<_Ty2> &&_Right) noexcept;
        template<> shared_ptr<v8::internal::wasm::StreamingDecoder, 0>(shared_ptr<v8::internal::wasm::StreamingDecoder> &&_Right) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, StreamingDecoder>::value, int> = 0> explicit shared_ptr(const weak_ptr<_Ty2> &_Other);
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, v8::internal::wasm::StreamingDecoder *>, int> = 0> shared_ptr(auto_ptr<_Ty2> &&_Other);
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, v8::internal::wasm::StreamingDecoder>, is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type *> >, int> = 0> shared_ptr(unique_ptr<_Ux, _Dx> &&_Other);
        ~shared_ptr<StreamingDecoder>() noexcept;
        std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(const std::shared_ptr<v8::internal::wasm::StreamingDecoder> &_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(const shared_ptr<_Ty2> &_Right) noexcept;
        template<> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=<v8::internal::wasm::StreamingDecoder>(const shared_ptr<v8::internal::wasm::StreamingDecoder> &_Right) noexcept;
        std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(std::shared_ptr<v8::internal::wasm::StreamingDecoder> &&_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(shared_ptr<_Ty2> &&_Right) noexcept;
        template<> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=<v8::internal::wasm::StreamingDecoder>(shared_ptr<v8::internal::wasm::StreamingDecoder> &&_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(auto_ptr<_Ty2> &&_Right);
        template <class _Ux, class _Dx> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(unique_ptr<_Ux, _Dx> &&_Right);
        void swap(std::shared_ptr<v8::internal::wasm::StreamingDecoder> &_Other) noexcept;
        void reset() noexcept;
        template <class _Ux> void reset(_Ux *_Px);
        template <class _Ux, class _Dx> void reset(_Ux *_Px, _Dx _Dt);
        template <class _Ux, class _Dx, class _Alloc> void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax);
        using _Mybase::get;
        template <class _Ty2 = v8::internal::wasm::StreamingDecoder, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2> >, int> = 0> _Ty2 &operator*() const noexcept;
        template <class _Ty2 = v8::internal::wasm::StreamingDecoder, enable_if_t<!is_array_v<_Ty2>, int> = 0> _Ty2 *operator->() const noexcept;
        template <class _Ty2 = v8::internal::wasm::StreamingDecoder, class _Elem = std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type, enable_if_t<is_array_v<_Ty2>, int> = 0> _Elem &operator[](ptrdiff_t _Idx) const;
        bool unique() const noexcept;
        explicit operator bool() const noexcept;
    private:
        template <class _Ux> void _Setp(_Ux *_Px, std::true_type);
        template <class _Ux> void _Setp(_Ux *_Px, std::false_type);
        template <class _UxptrOrNullptr, class _Dx> void _Setpd(_UxptrOrNullptr _Px, _Dx _Dt);
        template <class _UxptrOrNullptr, class _Dx, class _Alloc> void _Setpda(_UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax);
        friend template <class _Ty0, class ..._Types> shared_ptr<_Ty0> make_shared(_Types &&..._Args);
        friend template <class _Ty0, class _Alloc, class ..._Types> shared_ptr<_Ty0> allocate_shared(const _Alloc &_Al_arg, _Types &&..._Args);
        template <class _Ux> void _Set_ptr_rep_and_enable_shared(_Ux *_Px, std::_Ref_count_base *_Rx);
        void _Set_ptr_rep_and_enable_shared(std::nullptr_t, std::_Ref_count_base *_Rx);
    };
    template <class _Ty> class weak_ptr;
    template <class _Yty, class  = void> struct _Can_enable_shared : std::false_type {
    };
    template <class _Yty> struct _Can_enable_shared<_Yty, void> : is_convertible<remove_cv_t<_Yty> *, typename _Yty::_Esft_type *>::type {
    };
    template <class _Other, class _Yty> void _Enable_shared_from_this1(const shared_ptr<_Other> &_This, _Yty *_Ptr, std::true_type)     {
        if (_Ptr && _Ptr->_Wptr.expired()) {
            _Ptr->_Wptr = shared_ptr<remove_cv_t<_Yty> >(_This, const_cast<remove_cv_t<_Yty> *>(_Ptr));
        }
    }
    template <class _Other, class _Yty> void _Enable_shared_from_this1(const shared_ptr<_Other> &, _Yty *, std::false_type)     {
    }
    template <class _Other, class _Yty> void _Enable_shared_from_this(const shared_ptr<_Other> &_This, _Yty *_Ptr)     {
        _Enable_shared_from_this1(_This, _Ptr, bool_constant<conjunction_v<negation<is_array<_Other> >, negation<is_volatile<_Yty> >, _Can_enable_shared<_Yty> > >({}));
    }
    template <class _Ty> class _Ptr_base {
    public:
        using element_type = remove_extent_t<_Ty>;
        long use_count() const noexcept         {
            return (this->_Rep ? this->_Rep->_Use_count() : 0);
        }
        template <class _Ty2> bool owner_before(const _Ptr_base<_Ty2> &_Right) const noexcept         {
            return (this->_Rep < _Right._Rep);
        }
        _Ptr_base<_Ty>(const _Ptr_base<_Ty> &) = delete
        _Ptr_base<_Ty> &operator=(const _Ptr_base<_Ty> &) = delete
    protected:
        std::_Ptr_base::element_type *get() const noexcept         {
            return (this->_Ptr);
        }
        _Ptr_base<_Ty>() noexcept = default
        ~_Ptr_base<_Ty>() = default
        template <class _Ty2> void _Move_construct_from(_Ptr_base<_Ty2> &&_Right)         {
            this->_Ptr = _Right._Ptr;
            this->_Rep = _Right._Rep;
            _Right._Ptr = nullptr;
            _Right._Rep = nullptr;
        }
        template <class _Ty2> void _Copy_construct_from(const shared_ptr<_Ty2> &_Other)         {
            if (_Other._Rep) {
                _Other._Rep->_Incref();
            }
            this->_Ptr = _Other._Ptr;
            this->_Rep = _Other._Rep;
        }
        template <class _Ty2> void _Alias_construct_from(const shared_ptr<_Ty2> &_Other, std::_Ptr_base::element_type *_Px)         {
            if (_Other._Rep) {
                _Other._Rep->_Incref();
            }
            this->_Ptr = _Px;
            this->_Rep = _Other._Rep;
        }
        friend template <class _Ty0> class weak_ptr;
        template <class _Ty2> bool _Construct_from_weak(const weak_ptr<_Ty2> &_Other)         {
            if (_Other._Rep && _Other._Rep->_Incref_nz()) {
                this->_Ptr = _Other._Ptr;
                this->_Rep = _Other._Rep;
                return (true);
            }
            return (false);
        }
        void _Decref()         {
            if (this->_Rep) {
                this->_Rep->_Decref();
            }
        }
        void _Swap(_Ptr_base<_Ty> &_Right) noexcept         {
            ::std::swap(this->_Ptr, _Right._Ptr);
            ::std::swap(this->_Rep, _Right._Rep);
        }
        void _Set_ptr_rep(std::_Ptr_base::element_type *_Other_ptr, std::_Ref_count_base *_Other_rep)         {
            this->_Ptr = _Other_ptr;
            this->_Rep = _Other_rep;
        }
        template <class _Ty2> void _Weakly_construct_from(const _Ptr_base<_Ty2> &_Other)         {
            if (_Other._Rep) {
                _Other._Rep->_Incwref();
            }
            this->_Ptr = _Other._Ptr;
            this->_Rep = _Other._Rep;
        }
        void _Decwref()         {
            if (this->_Rep) {
                this->_Rep->_Decwref();
            }
        }
    private:
        std::_Ptr_base::element_type *_Ptr {nullptr};
        std::_Ref_count_base *_Rep {nullptr};
        friend template <class _Ty0> class _Ptr_base;
        friend template <class _Dx, class _Ty0> _Dx *get_deleter(const shared_ptr<_Ty0> &_Sx) noexcept;
    };
template<> class _Ptr_base<v8::internal::wasm::NativeModule> {
    public:
        using element_type = remove_extent_t<v8::internal::wasm::NativeModule>;
        long use_count() const noexcept;
        template <class _Ty2> bool owner_before(const _Ptr_base<_Ty2> &_Right) const noexcept;
        _Ptr_base(const std::_Ptr_base<v8::internal::wasm::NativeModule> &) = delete
        std::_Ptr_base<v8::internal::wasm::NativeModule> &operator=(const std::_Ptr_base<v8::internal::wasm::NativeModule> &) = delete
    protected:
        std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type *get() const noexcept;
        _Ptr_base() noexcept = default        ~_Ptr_base<NativeModule>() noexcept = default
        template <class _Ty2> void _Move_construct_from(_Ptr_base<_Ty2> &&_Right);
        template<> void _Move_construct_from<v8::internal::wasm::NativeModule>(_Ptr_base<v8::internal::wasm::NativeModule> &&_Right)         {
            this->_Ptr = _Right._Ptr;
            this->_Rep = _Right._Rep;
            _Right._Ptr = nullptr;
            _Right._Rep = nullptr;
        }
;
        template <class _Ty2> void _Copy_construct_from(const shared_ptr<_Ty2> &_Other);
        template <class _Ty2> void _Alias_construct_from(const shared_ptr<_Ty2> &_Other, std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type *_Px);
        friend template <class _Ty0> class weak_ptr;
        template <class _Ty2> bool _Construct_from_weak(const weak_ptr<_Ty2> &_Other);
        void _Decref()         {
            if (this->_Rep) {
                this->_Rep->_Decref();
            }
        }
        void _Swap(std::_Ptr_base<v8::internal::wasm::NativeModule> &_Right) noexcept;
        void _Set_ptr_rep(std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type *_Other_ptr, std::_Ref_count_base *_Other_rep);
        template <class _Ty2> void _Weakly_construct_from(const _Ptr_base<_Ty2> &_Other);
        void _Decwref();
    private:
        std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type *_Ptr {nullptr};
        std::_Ref_count_base *_Rep {nullptr};
        friend template <class _Ty0> class _Ptr_base;
        friend template <class _Dx, class _Ty0> _Dx *get_deleter(const shared_ptr<_Ty0> &_Sx) noexcept;
    };
template<> class _Ptr_base<v8::internal::wasm::StreamingDecoder> {
    public:
        using element_type = remove_extent_t<v8::internal::wasm::StreamingDecoder>;
        long use_count() const noexcept;
        template <class _Ty2> bool owner_before(const _Ptr_base<_Ty2> &_Right) const noexcept;
        _Ptr_base(const std::_Ptr_base<v8::internal::wasm::StreamingDecoder> &) = delete
        std::_Ptr_base<v8::internal::wasm::StreamingDecoder> &operator=(const std::_Ptr_base<v8::internal::wasm::StreamingDecoder> &) = delete
    protected:
        std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type *get() const noexcept;
        _Ptr_base() = default
        ~_Ptr_base<StreamingDecoder>() noexcept = default
        template <class _Ty2> void _Move_construct_from(_Ptr_base<_Ty2> &&_Right);
        template <class _Ty2> void _Copy_construct_from(const shared_ptr<_Ty2> &_Other);
        template <class _Ty2> void _Alias_construct_from(const shared_ptr<_Ty2> &_Other, std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type *_Px);
        friend template <class _Ty0> class weak_ptr;
        template <class _Ty2> bool _Construct_from_weak(const weak_ptr<_Ty2> &_Other);
        void _Decref();
        void _Swap(std::_Ptr_base<v8::internal::wasm::StreamingDecoder> &_Right) noexcept;
        void _Set_ptr_rep(std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type *_Other_ptr, std::_Ref_count_base *_Other_rep);
        template <class _Ty2> void _Weakly_construct_from(const _Ptr_base<_Ty2> &_Other);
        void _Decwref();
    private:
        std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type *_Ptr {nullptr};
        std::_Ref_count_base *_Rep {nullptr};
        friend template <class _Ty0> class _Ptr_base;
        friend template <class _Dx, class _Ty0> _Dx *get_deleter(const shared_ptr<_Ty0> &_Sx) noexcept;
    };
    template <class _Yty, class  = void> struct _Can_scalar_delete : std::false_type {
    };
    template <class _Yty> struct _Can_scalar_delete<_Yty, void> : std::true_type {
    };
    template <class _Yty, class  = void> struct _Can_array_delete : std::false_type {
    };
    template <class _Yty> struct _Can_array_delete<_Yty, void> : std::true_type {
    };
    template <class _Fx, class _Arg, class  = void> struct _Can_call_function_object : std::false_type {
    };
    template <class _Fx, class _Arg> struct _Can_call_function_object<_Fx, _Arg, void> : std::true_type {
    };
    template <class _Yty, class _Ty> struct _SP_convertible : is_convertible<_Yty *, _Ty *>::type {
    };
    template <class _Yty, class _Uty> struct _SP_convertible<_Yty, type-parameter-0-1 []> : is_convertible<_Yty (*)[], _Uty (*)[]>::type {
    };
    template <class _Yty, class _Uty, size_t _Ext> struct _SP_convertible<_Yty, type-parameter-0-1 [_Ext]> : is_convertible<_Yty (*)[_Ext], _Uty (*)[_Ext]>::type {
    };
    template <class _Yty, class _Ty> struct _SP_pointer_compatible : is_convertible<_Yty *, _Ty *>::type {
    };
template<> struct _SP_pointer_compatible<v8::internal::wasm::NativeModule, v8::internal::wasm::NativeModule> : is_convertible<NativeModule *, NativeModule *>::type {
    };
template<> struct _SP_pointer_compatible<v8::internal::wasm::StreamingDecoder, v8::internal::wasm::StreamingDecoder> : is_convertible<StreamingDecoder *, StreamingDecoder *>::type {
    };
    template <class _Uty, size_t _Ext> struct _SP_pointer_compatible<type-parameter-0-0 [_SizeOfArray], type-parameter-0-0 []> : std::true_type {
    };
    template <class _Uty, size_t _Ext> struct _SP_pointer_compatible<type-parameter-0-0 [_SizeOfArray], type-parameter-0-0 const[]> : std::true_type {
    };
    template <class _Uty, size_t _Ext> struct _SP_pointer_compatible<type-parameter-0-0 [_SizeOfArray], type-parameter-0-0 volatile[]> : std::true_type {
    };
    template <class _Uty, size_t _Ext> struct _SP_pointer_compatible<type-parameter-0-0 [_SizeOfArray], type-parameter-0-0 const volatile[]> : std::true_type {
    };
    template <class _Ty> class shared_ptr : public _Ptr_base<_Ty> {
    private:
        using _Mybase = _Ptr_base<_Ty>;
    public:
        using typename _Mybase::element_type;
        constexpr shared_ptr<_Ty>() noexcept         {
        }
        constexpr shared_ptr<_Ty>(std::nullptr_t) noexcept         {
        }
        template <class _Ux, enable_if_t<conjunction_v<conditional_t<is_array_v<_Ty>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux> >, _SP_convertible<_Ux, _Ty> >, int> = 0> explicit shared_ptr<_Ty>(_Ux *_Px)         {
            _Setp(_Px, is_array<_Ty>({}));
        }
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, _Ty> >, int> = 0> shared_ptr<_Ty>(_Ux *_Px, _Dx _Dt)         {
            _Setpd(_Px, ::std::move(_Dt));
        }
        template <class _Ux, class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, _Ty> >, int> = 0> shared_ptr<_Ty>(_Ux *_Px, _Dx _Dt, _Alloc _Ax)         {
            _Setpda(_Px, ::std::move(_Dt), _Ax);
        }
        template <class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr<_Ty>(std::nullptr_t, _Dx _Dt)         {
            _Setpd(nullptr, ::std::move(_Dt));
        }
        template <class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr<_Ty>(std::nullptr_t, _Dx _Dt, _Alloc _Ax)         {
            _Setpda(nullptr, ::std::move(_Dt), _Ax);
        }
        template <class _Ty2> shared_ptr<_Ty>(const shared_ptr<_Ty2> &_Right, std::shared_ptr::element_type *_Px) noexcept         {
            this->_Alias_construct_from(_Right, _Px);
        }
        shared_ptr<_Ty>(const shared_ptr<_Ty> &_Other) noexcept         {
            this->_Copy_construct_from(_Other);
        }
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0> shared_ptr<_Ty>(const shared_ptr<_Ty2> &_Other) noexcept         {
            this->_Copy_construct_from(_Other);
        }
        shared_ptr<_Ty>(shared_ptr<_Ty> &&_Right) noexcept         {
            this->_Move_construct_from(::std::move(_Right));
        }
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0> shared_ptr<_Ty>(shared_ptr<_Ty2> &&_Right) noexcept         {
            this->_Move_construct_from(::std::move(_Right));
        }
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0> explicit shared_ptr<_Ty>(const weak_ptr<_Ty2> &_Other)         {
            if (!this->_Construct_from_weak(_Other)) {
                throw std::bad_weak_ptr{};
            }
        }
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, _Ty *>, int> = 0> shared_ptr<_Ty>(auto_ptr<_Ty2> &&_Other)         {
            _Ty2 *_Px = _Other.get();
            _Set_ptr_rep_and_enable_shared(_Px, new _Ref_count<_Ty2>((_Px)));
            _Other.release();
        }
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, _Ty>, is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, std::shared_ptr::element_type *> >, int> = 0> shared_ptr<_Ty>(unique_ptr<_Ux, _Dx> &&_Other)         {
            using _Fancy_t = typename unique_ptr<_Ux, _Dx>::pointer;
            using _Raw_t = typename unique_ptr<_Ux, _Dx>::element_type *;
            using _Deleter_t = conditional_t<is_reference_v<_Dx>, decltype(::std::ref(_Other.get_deleter())), _Dx>;
            const _Fancy_t _Fancy = _Other.get();
            if (_Fancy) {
                const _Raw_t _Raw = _Fancy;
                const auto _Rx = new _Ref_count_resource<_Fancy_t, _Deleter_t>((_Fancy, _Other.get_deleter()));
                _Set_ptr_rep_and_enable_shared(_Raw, _Rx);
                _Other.release();
            }
        }
        ~shared_ptr<_Ty>() noexcept         {
            this->_Decref();
        }
        shared_ptr<_Ty> &operator=(const shared_ptr<_Ty> &_Right) noexcept         {
            shared_ptr<_Ty>(_Right).swap(*this);
            return (*this);
        }
        template <class _Ty2> shared_ptr<_Ty> &operator=(const shared_ptr<_Ty2> &_Right) noexcept         {
            shared_ptr<_Ty>(_Right).swap(*this);
            return (*this);
        }
        shared_ptr<_Ty> &operator=(shared_ptr<_Ty> &&_Right) noexcept         {
            shared_ptr<_Ty>(::std::move(_Right)).swap(*this);
            return (*this);
        }
        template <class _Ty2> shared_ptr<_Ty> &operator=(shared_ptr<_Ty2> &&_Right) noexcept         {
            shared_ptr<_Ty>(::std::move(_Right)).swap(*this);
            return (*this);
        }
        template <class _Ty2> shared_ptr<_Ty> &operator=(auto_ptr<_Ty2> &&_Right)         {
            shared_ptr<_Ty>(::std::move(_Right)).swap(*this);
            return (*this);
        }
        template <class _Ux, class _Dx> shared_ptr<_Ty> &operator=(unique_ptr<_Ux, _Dx> &&_Right)         {
            shared_ptr<_Ty>(::std::move(_Right)).swap(*this);
            return (*this);
        }
        void swap(shared_ptr<_Ty> &_Other) noexcept         {
            this->_Swap(_Other);
        }
        void reset() noexcept         {
            shared_ptr<_Ty>().swap(*this);
        }
        template <class _Ux> void reset(_Ux *_Px)         {
            shared_ptr<_Ty>(_Px).swap(*this);
        }
        template <class _Ux, class _Dx> void reset(_Ux *_Px, _Dx _Dt)         {
            shared_ptr<_Ty>(_Px, _Dt).swap(*this);
        }
        template <class _Ux, class _Dx, class _Alloc> void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax)         {
            shared_ptr<_Ty>(_Px, _Dt, _Ax).swap(*this);
        }
        using _Mybase::get;
        template <class _Ty2 = _Ty, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2> >, int> = 0> _Ty2 &operator*() const noexcept         {
            return (*get());
        }
        template <class _Ty2 = _Ty, enable_if_t<!is_array_v<_Ty2>, int> = 0> _Ty2 *operator->() const noexcept         {
            return (get());
        }
        template <class _Ty2 = _Ty, class _Elem = std::shared_ptr::element_type, enable_if_t<is_array_v<_Ty2>, int> = 0> _Elem &operator[](ptrdiff_t _Idx) const         {
            return (get()[_Idx]);
        }
        bool unique() const noexcept         {
            return (this->use_count() == 1);
        }
        explicit operator bool() const noexcept         {
            return (get() != nullptr);
        }
    private:
        template <class _Ux> void _Setp(_Ux *_Px, std::true_type)         {
            _Setpd(_Px, default_delete<_Ux []>({}));
        }
        template <class _Ux> void _Setp(_Ux *_Px, std::false_type)         {
            try {
                _Set_ptr_rep_and_enable_shared(_Px, new _Ref_count<_Ux>((_Px)));
            } catch (...) {
                delete _Px;
                throw;
            }
        }
        template <class _UxptrOrNullptr, class _Dx> void _Setpd(_UxptrOrNullptr _Px, _Dx _Dt)         {
            try {
                _Set_ptr_rep_and_enable_shared(_Px, new _Ref_count_resource<_UxptrOrNullptr, _Dx>((_Px, ::std::move(_Dt))));
            } catch (...) {
                _Dt(_Px);
                throw;
            }
        }
        template <class _UxptrOrNullptr, class _Dx, class _Alloc> void _Setpda(_UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax)         {
            using _Refd = _Ref_count_resource_alloc<_UxptrOrNullptr, _Dx, _Alloc>;
            using _Alref_alloc = _Rebind_alloc_t<_Alloc, _Refd>;
            using _Alref_traits = allocator_traits<_Alref_alloc>;
            _Alref_alloc _Alref(_Ax);
            try {
                const auto _Pfancy = _Alref_traits::allocate(_Alref, 1);
                _Refd *const _Pref = _Unfancy(_Pfancy);
                try {
                    _Alref_traits::construct(_Alref, _Pref, _Px, ::std::move(_Dt), _Ax);
                    _Set_ptr_rep_and_enable_shared(_Px, _Pref);
                } catch (...) {
                    _Alref_traits::deallocate(_Alref, _Pfancy, 1);
                    throw;
                }
            } catch (...) {
                _Dt(_Px);
                throw;
            }
        }
        friend template <class _Ty0, class ..._Types> shared_ptr<_Ty0> make_shared(_Types &&..._Args);
        friend template <class _Ty0, class _Alloc, class ..._Types> shared_ptr<_Ty0> allocate_shared(const _Alloc &_Al_arg, _Types &&..._Args);
        template <class _Ux> void _Set_ptr_rep_and_enable_shared(_Ux *_Px, std::_Ref_count_base *_Rx)         {
            this->_Set_ptr_rep(_Px, _Rx);
            _Enable_shared_from_this(*this, _Px);
        }
        void _Set_ptr_rep_and_enable_shared(std::nullptr_t, std::_Ref_count_base *_Rx)         {
            this->_Set_ptr_rep(nullptr, _Rx);
        }
    };
template<> class shared_ptr<v8::internal::wasm::NativeModule> : public _Ptr_base<v8::internal::wasm::NativeModule> {
    private:
        using _Mybase = _Ptr_base<v8::internal::wasm::NativeModule>;
    public:
        using typename _Mybase::element_type;
        constexpr shared_ptr() noexcept : _Ptr_base<v8::internal::wasm::NativeModule>()         {
        }
        constexpr shared_ptr(std::nullptr_t) noexcept;
        template <class _Ux, enable_if_t<conjunction_v<conditional_t<is_array_v<v8::internal::wasm::NativeModule>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux> >, _SP_convertible<_Ux, v8::internal::wasm::NativeModule> >, int> = 0> explicit shared_ptr(_Ux *_Px);
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, v8::internal::wasm::NativeModule> >, int> = 0> shared_ptr(_Ux *_Px, _Dx _Dt);
        template <class _Ux, class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, v8::internal::wasm::NativeModule> >, int> = 0> shared_ptr(_Ux *_Px, _Dx _Dt, _Alloc _Ax);
        template <class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr(std::nullptr_t, _Dx _Dt);
        template <class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr(std::nullptr_t, _Dx _Dt, _Alloc _Ax);
        template <class _Ty2> shared_ptr(const shared_ptr<_Ty2> &_Right, std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type *_Px) noexcept;
        shared_ptr(const std::shared_ptr<v8::internal::wasm::NativeModule> &_Other) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, NativeModule>::value, int> = 0> shared_ptr(const shared_ptr<_Ty2> &_Other) noexcept;
        template<> shared_ptr<v8::internal::wasm::NativeModule, 0>(const shared_ptr<v8::internal::wasm::NativeModule> &_Other) noexcept;
        shared_ptr(std::shared_ptr<v8::internal::wasm::NativeModule> &&_Right) noexcept : _Ptr_base<v8::internal::wasm::NativeModule>()         {
            this->_Move_construct_from(::std::move(_Right));
        }
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, NativeModule>::value, int> = 0> shared_ptr(shared_ptr<_Ty2> &&_Right) noexcept;
        template<> shared_ptr<v8::internal::wasm::NativeModule, 0>(shared_ptr<v8::internal::wasm::NativeModule> &&_Right) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, NativeModule>::value, int> = 0> explicit shared_ptr(const weak_ptr<_Ty2> &_Other);
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, v8::internal::wasm::NativeModule *>, int> = 0> shared_ptr(auto_ptr<_Ty2> &&_Other);
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, v8::internal::wasm::NativeModule>, is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type *> >, int> = 0> shared_ptr(unique_ptr<_Ux, _Dx> &&_Other);
        ~shared_ptr<NativeModule>() noexcept         {
            this->_Decref();
        }
        std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(const std::shared_ptr<v8::internal::wasm::NativeModule> &_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(const shared_ptr<_Ty2> &_Right) noexcept;
        template<> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=<v8::internal::wasm::NativeModule>(const shared_ptr<v8::internal::wasm::NativeModule> &_Right) noexcept;
        std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(std::shared_ptr<v8::internal::wasm::NativeModule> &&_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(shared_ptr<_Ty2> &&_Right) noexcept;
        template<> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=<v8::internal::wasm::NativeModule>(shared_ptr<v8::internal::wasm::NativeModule> &&_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(auto_ptr<_Ty2> &&_Right);
        template <class _Ux, class _Dx> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(unique_ptr<_Ux, _Dx> &&_Right);
        void swap(std::shared_ptr<v8::internal::wasm::NativeModule> &_Other) noexcept;
        void reset() noexcept;
        template <class _Ux> void reset(_Ux *_Px);
        template <class _Ux, class _Dx> void reset(_Ux *_Px, _Dx _Dt);
        template <class _Ux, class _Dx, class _Alloc> void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax);
        using _Mybase::get;
        template <class _Ty2 = v8::internal::wasm::NativeModule, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2> >, int> = 0> _Ty2 &operator*() const noexcept;
        template <class _Ty2 = v8::internal::wasm::NativeModule, enable_if_t<!is_array_v<_Ty2>, int> = 0> _Ty2 *operator->() const noexcept;
        template <class _Ty2 = v8::internal::wasm::NativeModule, class _Elem = std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type, enable_if_t<is_array_v<_Ty2>, int> = 0> _Elem &operator[](ptrdiff_t _Idx) const;
        bool unique() const noexcept;
        explicit operator bool() const noexcept;
    private:
        template <class _Ux> void _Setp(_Ux *_Px, std::true_type);
        template <class _Ux> void _Setp(_Ux *_Px, std::false_type);
        template <class _UxptrOrNullptr, class _Dx> void _Setpd(_UxptrOrNullptr _Px, _Dx _Dt);
        template <class _UxptrOrNullptr, class _Dx, class _Alloc> void _Setpda(_UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax);
        friend template <class _Ty0, class ..._Types> shared_ptr<_Ty0> make_shared(_Types &&..._Args);
        friend template <class _Ty0, class _Alloc, class ..._Types> shared_ptr<_Ty0> allocate_shared(const _Alloc &_Al_arg, _Types &&..._Args);
        template <class _Ux> void _Set_ptr_rep_and_enable_shared(_Ux *_Px, std::_Ref_count_base *_Rx);
        void _Set_ptr_rep_and_enable_shared(std::nullptr_t, std::_Ref_count_base *_Rx);
    };
template<> class shared_ptr<v8::internal::wasm::StreamingDecoder> : public _Ptr_base<v8::internal::wasm::StreamingDecoder> {
    private:
        using _Mybase = _Ptr_base<v8::internal::wasm::StreamingDecoder>;
    public:
        using typename _Mybase::element_type;
        constexpr shared_ptr() noexcept;
        constexpr shared_ptr(std::nullptr_t) noexcept;
        template <class _Ux, enable_if_t<conjunction_v<conditional_t<is_array_v<v8::internal::wasm::StreamingDecoder>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux> >, _SP_convertible<_Ux, v8::internal::wasm::StreamingDecoder> >, int> = 0> explicit shared_ptr(_Ux *_Px);
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, v8::internal::wasm::StreamingDecoder> >, int> = 0> shared_ptr(_Ux *_Px, _Dx _Dt);
        template <class _Ux, class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, v8::internal::wasm::StreamingDecoder> >, int> = 0> shared_ptr(_Ux *_Px, _Dx _Dt, _Alloc _Ax);
        template <class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr(std::nullptr_t, _Dx _Dt);
        template <class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr(std::nullptr_t, _Dx _Dt, _Alloc _Ax);
        template <class _Ty2> shared_ptr(const shared_ptr<_Ty2> &_Right, std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type *_Px) noexcept;
        shared_ptr(const std::shared_ptr<v8::internal::wasm::StreamingDecoder> &_Other) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, StreamingDecoder>::value, int> = 0> shared_ptr(const shared_ptr<_Ty2> &_Other) noexcept;
        template<> shared_ptr<v8::internal::wasm::StreamingDecoder, 0>(const shared_ptr<v8::internal::wasm::StreamingDecoder> &_Other) noexcept;
        shared_ptr(std::shared_ptr<v8::internal::wasm::StreamingDecoder> &&_Right) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, StreamingDecoder>::value, int> = 0> shared_ptr(shared_ptr<_Ty2> &&_Right) noexcept;
        template<> shared_ptr<v8::internal::wasm::StreamingDecoder, 0>(shared_ptr<v8::internal::wasm::StreamingDecoder> &&_Right) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, StreamingDecoder>::value, int> = 0> explicit shared_ptr(const weak_ptr<_Ty2> &_Other);
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, v8::internal::wasm::StreamingDecoder *>, int> = 0> shared_ptr(auto_ptr<_Ty2> &&_Other);
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, v8::internal::wasm::StreamingDecoder>, is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type *> >, int> = 0> shared_ptr(unique_ptr<_Ux, _Dx> &&_Other);
        ~shared_ptr<StreamingDecoder>() noexcept;
        std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(const std::shared_ptr<v8::internal::wasm::StreamingDecoder> &_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(const shared_ptr<_Ty2> &_Right) noexcept;
        template<> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=<v8::internal::wasm::StreamingDecoder>(const shared_ptr<v8::internal::wasm::StreamingDecoder> &_Right) noexcept;
        std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(std::shared_ptr<v8::internal::wasm::StreamingDecoder> &&_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(shared_ptr<_Ty2> &&_Right) noexcept;
        template<> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=<v8::internal::wasm::StreamingDecoder>(shared_ptr<v8::internal::wasm::StreamingDecoder> &&_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(auto_ptr<_Ty2> &&_Right);
        template <class _Ux, class _Dx> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(unique_ptr<_Ux, _Dx> &&_Right);
        void swap(std::shared_ptr<v8::internal::wasm::StreamingDecoder> &_Other) noexcept;
        void reset() noexcept;
        template <class _Ux> void reset(_Ux *_Px);
        template <class _Ux, class _Dx> void reset(_Ux *_Px, _Dx _Dt);
        template <class _Ux, class _Dx, class _Alloc> void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax);
        using _Mybase::get;
        template <class _Ty2 = v8::internal::wasm::StreamingDecoder, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2> >, int> = 0> _Ty2 &operator*() const noexcept;
        template <class _Ty2 = v8::internal::wasm::StreamingDecoder, enable_if_t<!is_array_v<_Ty2>, int> = 0> _Ty2 *operator->() const noexcept;
        template <class _Ty2 = v8::internal::wasm::StreamingDecoder, class _Elem = std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type, enable_if_t<is_array_v<_Ty2>, int> = 0> _Elem &operator[](ptrdiff_t _Idx) const;
        bool unique() const noexcept;
        explicit operator bool() const noexcept;
    private:
        template <class _Ux> void _Setp(_Ux *_Px, std::true_type);
        template <class _Ux> void _Setp(_Ux *_Px, std::false_type);
        template <class _UxptrOrNullptr, class _Dx> void _Setpd(_UxptrOrNullptr _Px, _Dx _Dt);
        template <class _UxptrOrNullptr, class _Dx, class _Alloc> void _Setpda(_UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax);
        friend template <class _Ty0, class ..._Types> shared_ptr<_Ty0> make_shared(_Types &&..._Args);
        friend template <class _Ty0, class _Alloc, class ..._Types> shared_ptr<_Ty0> allocate_shared(const _Alloc &_Al_arg, _Types &&..._Args);
        template <class _Ux> void _Set_ptr_rep_and_enable_shared(_Ux *_Px, std::_Ref_count_base *_Rx);
        void _Set_ptr_rep_and_enable_shared(std::nullptr_t, std::_Ref_count_base *_Rx);
    };
    template <class _Ty1, class _Ty2> bool operator==(const shared_ptr<_Ty1> &_Left, const shared_ptr<_Ty2> &_Right) noexcept     {
        return (_Left.get() == _Right.get());
    }
    template <class _Ty1, class _Ty2> bool operator!=(const shared_ptr<_Ty1> &_Left, const shared_ptr<_Ty2> &_Right) noexcept     {
        return (_Left.get() != _Right.get());
    }
    template <class _Ty1, class _Ty2> bool operator<(const shared_ptr<_Ty1> &_Left, const shared_ptr<_Ty2> &_Right) noexcept     {
        return (_Left.get() < _Right.get());
    }
    template <class _Ty1, class _Ty2> bool operator>=(const shared_ptr<_Ty1> &_Left, const shared_ptr<_Ty2> &_Right) noexcept     {
        return (_Left.get() >= _Right.get());
    }
    template <class _Ty1, class _Ty2> bool operator>(const shared_ptr<_Ty1> &_Left, const shared_ptr<_Ty2> &_Right) noexcept     {
        return (_Left.get() > _Right.get());
    }
    template <class _Ty1, class _Ty2> bool operator<=(const shared_ptr<_Ty1> &_Left, const shared_ptr<_Ty2> &_Right) noexcept     {
        return (_Left.get() <= _Right.get());
    }
    template <class _Ty> bool operator==(const shared_ptr<_Ty> &_Left, std::nullptr_t) noexcept     {
        return (_Left.get() == nullptr);
    }
    template <class _Ty> bool operator==(std::nullptr_t, const shared_ptr<_Ty> &_Right) noexcept     {
        return (nullptr == _Right.get());
    }
    template <class _Ty> bool operator!=(const shared_ptr<_Ty> &_Left, std::nullptr_t) noexcept     {
        return (_Left.get() != nullptr);
    }
    template <class _Ty> bool operator!=(std::nullptr_t, const shared_ptr<_Ty> &_Right) noexcept     {
        return (nullptr != _Right.get());
    }
    template <class _Ty> bool operator<(const shared_ptr<_Ty> &_Left, std::nullptr_t) noexcept     {
        return (_Left.get() < static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr));
    }
    template <class _Ty> bool operator<(std::nullptr_t, const shared_ptr<_Ty> &_Right) noexcept     {
        return (static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr) < _Right.get());
    }
    template <class _Ty> bool operator>=(const shared_ptr<_Ty> &_Left, std::nullptr_t) noexcept     {
        return (_Left.get() >= static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr));
    }
    template <class _Ty> bool operator>=(std::nullptr_t, const shared_ptr<_Ty> &_Right) noexcept     {
        return (static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr) >= _Right.get());
    }
    template <class _Ty> bool operator>(const shared_ptr<_Ty> &_Left, std::nullptr_t) noexcept     {
        return (_Left.get() > static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr));
    }
    template <class _Ty> bool operator>(std::nullptr_t, const shared_ptr<_Ty> &_Right) noexcept     {
        return (static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr) > _Right.get());
    }
    template <class _Ty> bool operator<=(const shared_ptr<_Ty> &_Left, std::nullptr_t) noexcept     {
        return (_Left.get() <= static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr));
    }
    template <class _Ty> bool operator<=(std::nullptr_t, const shared_ptr<_Ty> &_Right) noexcept     {
        return (static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr) <= _Right.get());
    }
    template <class _Elem, class _Traits, class _Ty> basic_ostream<_Elem, _Traits> &operator<<(basic_ostream<_Elem, _Traits> &_Out, const shared_ptr<_Ty> &_Px)     {
        return (_Out << _Px.get());
    }
    template <class _Ty> void swap(shared_ptr<_Ty> &_Left, shared_ptr<_Ty> &_Right) noexcept     {
        _Left.swap(_Right);
    }
    template <class _Ty1, class _Ty2> shared_ptr<_Ty1> static_pointer_cast(const shared_ptr<_Ty2> &_Other) noexcept     {
        const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type *>(_Other.get());
        return (shared_ptr<_Ty1>(_Other, _Ptr));
    }
    template <class _Ty1, class _Ty2> shared_ptr<_Ty1> const_pointer_cast(const shared_ptr<_Ty2> &_Other) noexcept     {
        const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type *>(_Other.get());
        return (shared_ptr<_Ty1>(_Other, _Ptr));
    }
    template <class _Ty1, class _Ty2> shared_ptr<_Ty1> reinterpret_pointer_cast(const shared_ptr<_Ty2> &_Other) noexcept     {
        const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type *>(_Other.get());
        return (shared_ptr<_Ty1>(_Other, _Ptr));
    }
    template <class _Ty1, class _Ty2> shared_ptr<_Ty1> dynamic_pointer_cast(const shared_ptr<_Ty2> &_Other) noexcept     {
        const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type *>(_Other.get());
        if (_Ptr) {
            return (shared_ptr<_Ty1>(_Other, _Ptr));
        }
        return (shared_ptr<_Ty1>());
    }
    template <class _Dx, class _Ty> _Dx *get_deleter(const shared_ptr<_Ty> &_Sx) noexcept     {
        if (_Sx._Rep) {
            return (static_cast<_Dx *>(_Sx._Rep->_Get_deleter(typeid(_Dx))));
        }
        return (nullptr);
    }
    template <class _Ty> class _Ref_count_obj : public std::_Ref_count_base {
    public:
        template <class ..._Types> explicit _Ref_count_obj<_Ty>(_Types &&..._Args) : std::_Ref_count_base()         {
            ::new (static_cast<void *>(&this->_Storage)) _Ty((::std::forward<_Types>(_Args)...));
        }
        _Ty *_Getptr()         {
            return (reinterpret_cast<_Ty *>(&this->_Storage));
        }
    private:
        virtual void _Destroy() noexcept override         {
            this->_Getptr()->~_Ty();
        }
        virtual void _Delete_this() noexcept override         {
            delete this;
        }
        aligned_union_t<1, _Ty> _Storage;
    };
    template <class _Ty, class _Alloc> class _Ref_count_obj_alloc : public std::_Ref_count_base {
    public:
        template <class ..._Types> explicit _Ref_count_obj_alloc<_Ty, _Alloc>(const _Alloc &_Al_arg, _Types &&..._Args) : std::_Ref_count_base(), _Mypair(std::_One_then_variadic_args_t(), _Al_arg)         {
            ::new (static_cast<void *>(&this->_Mypair._Get_second())) _Ty((::std::forward<_Types>(_Args)...));
        }
        _Ty *_Getptr()         {
            return (reinterpret_cast<_Ty *>(&this->_Mypair._Get_second()));
        }
    private:
        using _Myalty = _Rebind_alloc_t<_Alloc, _Ref_count_obj_alloc<_Ty, _Alloc> >;
        using _Mystoragety = aligned_union_t<1, _Ty>;
        virtual void _Destroy() noexcept override         {
            this->_Getptr()->~_Ty();
        }
        virtual void _Delete_this() noexcept override         {
            std::_Ref_count_obj_alloc::_Myalty _Al = this->_Mypair._Get_first();
            allocator_traits<_Myalty>::destroy(_Al, this);
            _Deallocate_plain(_Al, this);
        }
        _Compressed_pair<std::_Ref_count_obj_alloc::_Myalty, std::_Ref_count_obj_alloc::_Mystoragety> _Mypair;
    };
    template <class _Ty, class ..._Types> inline shared_ptr<_Ty> make_shared(_Types &&..._Args)     {
        const auto _Rx = new _Ref_count_obj<_Ty>((::std::forward<_Types>(_Args)...));
        shared_ptr<_Ty> _Ret;
        _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Getptr(), _Rx);
        return (_Ret);
    }
    template <class _Ty, class _Alloc, class ..._Types> inline shared_ptr<_Ty> allocate_shared(const _Alloc &_Al_arg, _Types &&..._Args)     {
        using _Refoa = _Ref_count_obj_alloc<_Ty, _Alloc>;
        using _Alref_alloc = _Rebind_alloc_t<_Alloc, _Refoa>;
        using _Alref_traits = allocator_traits<_Alref_alloc>;
        _Alref_alloc _Alref(_Al_arg);
        const auto _Rx = _Alref_traits::allocate(_Alref, 1);
        try {
            _Alref_traits::construct(_Alref, _Unfancy(_Rx), _Al_arg, ::std::forward<_Types>(_Args)...);
        } catch (...) {
            _Alref_traits::deallocate(_Alref, _Rx, 1);
            throw;
        }
        shared_ptr<_Ty> _Ret;
        _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Getptr(), _Unfancy(_Rx));
        return (_Ret);
    }
    template <class _Ty> class weak_ptr : public _Ptr_base<_Ty> {
    public:
        constexpr weak_ptr<_Ty>() noexcept         {
        }
        weak_ptr<_Ty>(const weak_ptr<_Ty> &_Other) noexcept         {
            this->_Weakly_construct_from(_Other);
        }
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0> weak_ptr<_Ty>(const shared_ptr<_Ty2> &_Other) noexcept         {
            this->_Weakly_construct_from(_Other);
        }
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0> weak_ptr<_Ty>(const weak_ptr<_Ty2> &_Other) noexcept         {
            this->_Weakly_construct_from(_Other.lock());
        }
        weak_ptr<_Ty>(weak_ptr<_Ty> &&_Other) noexcept         {
            this->_Move_construct_from(::std::move(_Other));
        }
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0> weak_ptr<_Ty>(weak_ptr<_Ty2> &&_Other) noexcept         {
            this->_Weakly_construct_from(_Other.lock());
            _Other.reset();
        }
        ~weak_ptr<_Ty>() noexcept         {
            this->_Decwref();
        }
        weak_ptr<_Ty> &operator=(const weak_ptr<_Ty> &_Right) noexcept         {
            weak_ptr<_Ty>(_Right).swap(*this);
            return (*this);
        }
        template <class _Ty2> weak_ptr<_Ty> &operator=(const weak_ptr<_Ty2> &_Right) noexcept         {
            weak_ptr<_Ty>(_Right).swap(*this);
            return (*this);
        }
        weak_ptr<_Ty> &operator=(weak_ptr<_Ty> &&_Right) noexcept         {
            weak_ptr<_Ty>(::std::move(_Right)).swap(*this);
            return (*this);
        }
        template <class _Ty2> weak_ptr<_Ty> &operator=(weak_ptr<_Ty2> &&_Right) noexcept         {
            weak_ptr<_Ty>(::std::move(_Right)).swap(*this);
            return (*this);
        }
        template <class _Ty2> weak_ptr<_Ty> &operator=(const shared_ptr<_Ty2> &_Right) noexcept         {
            weak_ptr<_Ty>(_Right).swap(*this);
            return (*this);
        }
        void reset() noexcept         {
            weak_ptr<_Ty>().swap(*this);
        }
        void swap(weak_ptr<_Ty> &_Other) noexcept         {
            this->_Swap(_Other);
        }
        bool expired() const noexcept         {
            return (this->use_count() == 0);
        }
        shared_ptr<_Ty> lock() const noexcept         {
            shared_ptr<_Ty> _Ret;
            (void)_Ret._Construct_from_weak(*this);
            return (_Ret);
        }
    };
    template <class _Ty> void swap(weak_ptr<_Ty> &_Left, weak_ptr<_Ty> &_Right) noexcept     {
        _Left.swap(_Right);
    }
    template <class _Ty> class enable_shared_from_this {
    public:
        using _Esft_type = enable_shared_from_this<_Ty>;
        shared_ptr<_Ty> shared_from_this()         {
            return (shared_ptr<_Ty>(this->_Wptr));
        }
        shared_ptr<const _Ty> shared_from_this() const         {
            return (shared_ptr<const _Ty>(this->_Wptr));
        }
        weak_ptr<_Ty> weak_from_this() noexcept         {
            return (this->_Wptr);
        }
        weak_ptr<const _Ty> weak_from_this() const noexcept         {
            return (this->_Wptr);
        }
    protected:
        constexpr enable_shared_from_this<_Ty>() noexcept : _Wptr()         {
        }
        enable_shared_from_this<_Ty>(const enable_shared_from_this<_Ty> &) noexcept : _Wptr()         {
        }
        enable_shared_from_this<_Ty> &operator=(const enable_shared_from_this<_Ty> &) noexcept         {
            return (*this);
        }
        ~enable_shared_from_this<_Ty>() = default
    private:
        friend template <class _Other, class _Yty> void _Enable_shared_from_this1(const shared_ptr<_Other> &_This, _Yty *_Ptr, std::true_type);
        mutable weak_ptr<_Ty> _Wptr;
    };
    template <class _Ty> struct default_delete {
        default_delete<_Ty>() noexcept = default
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, _Ty *>, int> = 0> default_delete<_Ty>(const default_delete<_Ty2> &) noexcept         {
        }
        void operator()(_Ty *_Ptr) const noexcept         {
            static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
            delete _Ptr;
        }
    };
template<> struct default_delete<v8::internal::ScriptStreamingData> {
        default_delete() noexcept = default
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, v8::internal::ScriptStreamingData *>, int> = 0> default_delete(const default_delete<_Ty2> &) noexcept;
        template<> default_delete<v8::internal::ScriptStreamingData, 0>(const default_delete<v8::internal::ScriptStreamingData> &) noexcept;
        void operator()(v8::internal::ScriptStreamingData *_Ptr) const noexcept;
    };
template<> struct default_delete<unsigned char const[]> {
        default_delete() noexcept = default
        template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], const unsigned char (*)[]>, int> = 0> default_delete(const default_delete<_Uty []> &) noexcept;
        template<> default_delete<const unsigned char, 0>(const default_delete<const unsigned char []> &) noexcept;
        template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], const unsigned char (*)[]>, int> = 0> void operator()(_Uty *_Ptr) const noexcept;
        template<> void operator()<const unsigned char, 0>(const unsigned char *_Ptr) const noexcept         {
            static_assert(0 < sizeof(const unsigned char), "can't delete an incomplete type");
            delete [] _Ptr;
        }
;
    };
template<> struct default_delete<v8::WasmStreaming::WasmStreamingImpl> {
        default_delete() noexcept = default
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, v8::WasmStreaming::WasmStreamingImpl *>, int> = 0> default_delete(const default_delete<_Ty2> &) noexcept;
        template<> default_delete<v8::WasmStreaming::WasmStreamingImpl, 0>(const default_delete<v8::WasmStreaming::WasmStreamingImpl> &) noexcept;
        void operator()(v8::WasmStreaming::WasmStreamingImpl *_Ptr) const noexcept;
    };
    template <class _Ty> struct default_delete<type-parameter-0-0 []> {
        default_delete<type-parameter-0-0 []>() noexcept = default
        template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0> default_delete<type-parameter-0-0 []>(const default_delete<_Uty []> &) noexcept         {
        }
        template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0> void operator()(_Uty *_Ptr) const noexcept         {
            static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
            delete [] _Ptr;
        }
    };
    template <class _Ty, class _Dx_noref, class  = void> struct _Get_deleter_pointer_type {
        typedef _Ty *type;
    };
template<> struct _Get_deleter_pointer_type<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData>, void> {
        typedef v8::internal::ScriptStreamingData *type;
    };
template<> struct _Get_deleter_pointer_type<const unsigned char, std::default_delete<unsigned char const[]>, void> {
        typedef const unsigned char *type;
    };
template<> struct _Get_deleter_pointer_type<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, void> {
        typedef v8::WasmStreaming::WasmStreamingImpl *type;
    };
    template <class _Ty, class _Dx_noref> struct _Get_deleter_pointer_type<_Ty, _Dx_noref, void> {
        typedef typename _Dx_noref::pointer type;
    };
    template <class _Ty, class _Dx> class _Unique_ptr_base {
    public:
        typedef remove_reference_t<_Dx> _Dx_noref;
        typedef typename _Get_deleter_pointer_type<_Ty, _Dx_noref>::type pointer;
        template <class _Ptr2, class _Dx2> _Unique_ptr_base<_Ty, _Dx>(_Ptr2 _Ptr, _Dx2 &&_Dt) : _Mypair(std::_One_then_variadic_args_t(), ::std::forward<_Dx2>(_Dt), _Ptr)         {
        }
        template <class _Ptr2> constexpr _Unique_ptr_base<_Ty, _Dx>(_Ptr2 _Ptr) : _Mypair(std::_Zero_then_variadic_args_t(), _Ptr)         {
        }
        _Dx &get_deleter() noexcept         {
            return (this->_Mypair._Get_first());
        }
        const _Dx &get_deleter() const noexcept         {
            return (this->_Mypair._Get_first());
        }
        std::_Unique_ptr_base::pointer &_Myptr() noexcept         {
            return (this->_Mypair._Get_second());
        }
        const std::_Unique_ptr_base::pointer &_Myptr() const noexcept         {
            return (this->_Mypair._Get_second());
        }
        _Compressed_pair<_Dx, std::_Unique_ptr_base::pointer> _Mypair;
    };
template<> class _Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData>> {
    public:
        typedef remove_reference_t<std::default_delete<v8::internal::ScriptStreamingData> > _Dx_noref;
        typedef typename _Get_deleter_pointer_type<ScriptStreamingData, _Dx_noref>::type pointer;
        template <class _Ptr2, class _Dx2> _Unique_ptr_base(_Ptr2 _Ptr, _Dx2 &&_Dt);
        template <class _Ptr2> constexpr _Unique_ptr_base(_Ptr2 _Ptr);
        template<> constexpr _Unique_ptr_base<std::_Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >>(std::_Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > _Ptr);
        std::default_delete<v8::internal::ScriptStreamingData> &get_deleter() noexcept;
        const std::default_delete<v8::internal::ScriptStreamingData> &get_deleter() const noexcept;
        std::_Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer &_Myptr() noexcept;
        const std::_Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer &_Myptr() const noexcept         {
            return (this->_Mypair._Get_second());
        }
        _Compressed_pair<std::default_delete<v8::internal::ScriptStreamingData>, std::_Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer> _Mypair;
    };
template<> class _Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]>> {
    public:
        typedef remove_reference_t<std::default_delete<unsigned char const[]> > _Dx_noref;
        typedef typename _Get_deleter_pointer_type<const unsigned char, _Dx_noref>::type pointer;
        template <class _Ptr2, class _Dx2> _Unique_ptr_base(_Ptr2 _Ptr, _Dx2 &&_Dt);
        template<> _Unique_ptr_base<const unsigned char *, std::default_delete<unsigned char const[]>>(const unsigned char *_Ptr, std::default_delete<unsigned char const[]> &&_Dt) : _Mypair(std::_One_then_variadic_args_t(), ::std::forward<std::default_delete<unsigned char const[]> >(_Dt), _Ptr)         {
        }
;
        template <class _Ptr2> constexpr _Unique_ptr_base(_Ptr2 _Ptr);
        template<> constexpr _Unique_ptr_base<std::_Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> >>(std::_Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> > _Ptr);
        template<> constexpr _Unique_ptr_base<const unsigned char *>(const unsigned char *_Ptr) : _Mypair(std::_Zero_then_variadic_args_t(), _Ptr)         {
        }
;
        std::default_delete<unsigned char const[]> &get_deleter() noexcept         {
            return (this->_Mypair._Get_first());
        }
        const std::default_delete<unsigned char const[]> &get_deleter() const noexcept;
        std::_Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> >::pointer &_Myptr() noexcept         {
            return (this->_Mypair._Get_second());
        }
        const std::_Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> >::pointer &_Myptr() const noexcept         {
            return (this->_Mypair._Get_second());
        }
        _Compressed_pair<std::default_delete<unsigned char const[]>, std::_Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> >::pointer> _Mypair;
    };
template<> class _Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> {
    public:
        typedef remove_reference_t<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > _Dx_noref;
        typedef typename _Get_deleter_pointer_type<WasmStreamingImpl, _Dx_noref>::type pointer;
        template <class _Ptr2, class _Dx2> _Unique_ptr_base(_Ptr2 _Ptr, _Dx2 &&_Dt);
        template <class _Ptr2> constexpr _Unique_ptr_base(_Ptr2 _Ptr);
        template<> constexpr _Unique_ptr_base<std::_Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >>(std::_Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > _Ptr);
        std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &get_deleter() noexcept;
        const std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &get_deleter() const noexcept;
        std::_Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer &_Myptr() noexcept;
        const std::_Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer &_Myptr() const noexcept;
        _Compressed_pair<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::_Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer> _Mypair;
    };
    template <class _Dx2> using _Unique_ptr_enable_default_t = enable_if_t<conjunction_v<negation<is_pointer<_Dx2> >, is_default_constructible<_Dx2> >, int>;
    template <class _Ty, class _Dx = default_delete<_Ty>> class unique_ptr : public _Unique_ptr_base<_Ty, _Dx> {
    public:
        typedef _Unique_ptr_base<_Ty, _Dx> _Mybase;
        typedef typename _Mybase::pointer pointer;
        typedef _Ty element_type;
        typedef _Dx deleter_type;
        using _Mybase::get_deleter;
        template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr<_Ty, _Dx>() noexcept : std::unique_ptr::_Mybase(std::unique_ptr::pointer())         {
        }
        template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr<_Ty, _Dx>(std::nullptr_t) noexcept : std::unique_ptr::_Mybase(std::unique_ptr::pointer())         {
        }
        unique_ptr<_Ty, _Dx> &operator=(std::nullptr_t) noexcept         {
            this->reset();
            return (*this);
        }
        template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0> explicit unique_ptr<_Ty, _Dx>(std::unique_ptr::pointer _Ptr) noexcept : std::unique_ptr::_Mybase(_Ptr)         {
        }
        template <class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2 &>, int> = 0> unique_ptr<_Ty, _Dx>(std::unique_ptr::pointer _Ptr, const _Dx &_Dt) noexcept : std::unique_ptr::_Mybase(_Ptr, _Dt)         {
        }
        template <class _Dx2 = _Dx, enable_if_t<conjunction_v<negation<is_reference<_Dx2> >, is_constructible<_Dx2, _Dx2> >, int> = 0> unique_ptr<_Ty, _Dx>(std::unique_ptr::pointer _Ptr, _Dx &&_Dt) noexcept : std::unique_ptr::_Mybase(_Ptr, ::std::move(_Dt))         {
        }
        template <class _Dx2 = _Dx, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2> > >, int> = 0> unique_ptr<_Ty, _Dx>(std::unique_ptr::pointer, remove_reference_t<_Dx> &&) = delete
        unique_ptr<_Ty, _Dx>(unique_ptr<_Ty, _Dx> &&_Right) noexcept : std::unique_ptr::_Mybase(_Right.release(), ::std::forward<_Dx>(_Right.get_deleter()))         {
        }
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr::pointer>, conditional_t<is_reference_v<_Dx>, is_same<_Dx2, _Dx>, is_convertible<_Dx2, _Dx> > >, int> = 0> unique_ptr<_Ty, _Dx>(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept : std::unique_ptr::_Mybase(_Right.release(), ::std::forward<_Dx2>(_Right.get_deleter()))         {
        }
        template <class _Ty2, enable_if_t<conjunction_v<is_convertible<_Ty2 *, _Ty *>, is_same<_Dx, default_delete<_Ty> > >, int> = 0> unique_ptr<_Ty, _Dx>(auto_ptr<_Ty2> &&_Right) noexcept : std::unique_ptr::_Mybase(_Right.release())         {
        }
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_assignable<_Dx &, _Dx2>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr::pointer> >, int> = 0> unique_ptr<_Ty, _Dx> &operator=(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept         {
            this->reset(_Right.release());
            this->get_deleter() = ::std::forward<_Dx2>(_Right.get_deleter());
            return (*this);
        }
        unique_ptr<_Ty, _Dx> &operator=(unique_ptr<_Ty, _Dx> &&_Right) noexcept         {
            if (this != ::std::addressof(_Right)) {
                this->reset(_Right.release());
                this->get_deleter() = ::std::forward<_Dx>(_Right.get_deleter());
            }
            return (*this);
        }
        void swap(unique_ptr<_Ty, _Dx> &_Right) noexcept         {
            _Swap_adl(this->_Myptr(), _Right._Myptr());
            _Swap_adl(this->get_deleter(), _Right.get_deleter());
        }
        ~unique_ptr<_Ty, _Dx>() noexcept         {
            if (this->get() != std::unique_ptr::pointer()) {
                this->get_deleter()(this->get());
            }
        }
        add_lvalue_reference_t<_Ty> operator*() const         {
            return (*this->get());
        }
        std::unique_ptr::pointer operator->() const noexcept         {
            return (this->_Myptr());
        }
        std::unique_ptr::pointer get() const noexcept         {
            return (this->_Myptr());
        }
        explicit operator bool() const noexcept         {
            return (this->get() != std::unique_ptr::pointer());
        }
        std::unique_ptr::pointer release() noexcept         {
            std::unique_ptr::pointer _Ans = this->get();
            this->_Myptr() = std::unique_ptr::pointer();
            return (_Ans);
        }
        void reset(std::unique_ptr::pointer _Ptr = std::unique_ptr::pointer()) noexcept         {
            std::unique_ptr::pointer _Old = this->get();
            this->_Myptr() = _Ptr;
            if (_Old != std::unique_ptr::pointer()) {
                this->get_deleter()(_Old);
            }
        }
        unique_ptr<_Ty, _Dx>(const unique_ptr<_Ty, _Dx> &) = delete
        unique_ptr<_Ty, _Dx> &operator=(const unique_ptr<_Ty, _Dx> &) = delete
    };
template<> class unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData>> : public _Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > {
    public:
        typedef _Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > _Mybase;
        typedef typename _Mybase::pointer pointer;
        typedef v8::internal::ScriptStreamingData element_type;
        typedef std::default_delete<v8::internal::ScriptStreamingData> deleter_type;
        using _Mybase::get_deleter;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr() noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr(std::nullptr_t) noexcept;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=(std::nullptr_t) noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, _Unique_ptr_enable_default_t<_Dx2> = 0> explicit unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer _Ptr) noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, enable_if_t<is_constructible_v<_Dx2, const _Dx2 &>, int> = 0> unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer _Ptr, const std::default_delete<v8::internal::ScriptStreamingData> &_Dt) noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, enable_if_t<conjunction_v<negation<is_reference<_Dx2> >, is_constructible<_Dx2, _Dx2> >, int> = 0> unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer _Ptr, std::default_delete<v8::internal::ScriptStreamingData> &&_Dt) noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2> > >, int> = 0> unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer, remove_reference_t<std::default_delete<v8::internal::ScriptStreamingData> > &&) = delete
        unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &&_Right) noexcept;
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer>, conditional_t<is_reference_v<std::default_delete<v8::internal::ScriptStreamingData> >, is_same<_Dx2, std::default_delete<v8::internal::ScriptStreamingData> >, is_convertible<_Dx2, std::default_delete<v8::internal::ScriptStreamingData> > > >, int> = 0> unique_ptr(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept;
        template<> unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData>, 0>(unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &&_Right) noexcept;
        template <class _Ty2, enable_if_t<conjunction_v<is_convertible<_Ty2 *, v8::internal::ScriptStreamingData *>, is_same<std::default_delete<v8::internal::ScriptStreamingData>, default_delete<v8::internal::ScriptStreamingData> > >, int> = 0> unique_ptr(auto_ptr<_Ty2> &&_Right) noexcept;
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_assignable<std::default_delete<v8::internal::ScriptStreamingData> &, _Dx2>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer> >, int> = 0> std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept;
        template<> std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData>, 0>(unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &&_Right) noexcept;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &&_Right) noexcept;
        void swap(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &_Right) noexcept;
        ~unique_ptr<ScriptStreamingData, default_delete<ScriptStreamingData> >() noexcept;
        add_lvalue_reference_t<v8::internal::ScriptStreamingData> operator*() const;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer operator->() const noexcept;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer get() const noexcept         {
            return (this->_Myptr());
        }
        explicit operator bool() const noexcept;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer release() noexcept;
        void reset(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer _Ptr) noexcept;
        unique_ptr(const std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &) = delete
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=(const std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &) = delete
    };
template<> class unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]>> : public _Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> > {
    public:
        typedef _Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> > _Mybase;
        typedef typename _Mybase::pointer pointer;
        typedef const unsigned char element_type;
        typedef std::default_delete<unsigned char const[]> deleter_type;
        using _Mybase::get_deleter;
        template <class _Dx2 = std::default_delete<unsigned char const[]>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr() noexcept;
        template<> constexpr unique_ptr<std::default_delete<unsigned char const[]>, 0>() noexcept;
        template <class _Uty, class _Is_nullptr = is_same<_Uty, std::nullptr_t>> using _Enable_ctor_reset = enable_if_t<is_same_v<_Uty, std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer> || _Is_nullptr::value || (is_same_v<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer, std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::element_type *> && is_pointer_v<_Uty> && is_convertible_v<remove_pointer_t<_Uty> (*)[], std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::element_type (*)[]>)>;
        template <class _Uty, class _Dx2 = std::default_delete<unsigned char const[]>, _Unique_ptr_enable_default_t<_Dx2> = 0, class  = _Enable_ctor_reset<_Uty>> explicit unique_ptr(_Uty _Ptr) noexcept;
        template <class _Uty, class _Dx2 = std::default_delete<unsigned char const[]>, enable_if_t<is_constructible_v<_Dx2, const _Dx2 &>, int> = 0, class  = _Enable_ctor_reset<_Uty>> unique_ptr(_Uty _Ptr, const std::default_delete<unsigned char const[]> &_Dt) noexcept;
        template <class _Uty, class _Dx2 = std::default_delete<unsigned char const[]>, enable_if_t<conjunction_v<negation<is_reference<_Dx2> >, is_constructible<_Dx2, _Dx2> >, int> = 0, class  = _Enable_ctor_reset<_Uty>> unique_ptr(_Uty _Ptr, std::default_delete<unsigned char const[]> &&_Dt) noexcept;
        template <class _Uty, class _Dx2 = std::default_delete<unsigned char const[]>, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2> > >, int> = 0> unique_ptr(_Uty, remove_reference_t<std::default_delete<unsigned char const[]> > &&) = delete
        unique_ptr(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &&_Right) noexcept : std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::_Mybase(_Right.release(), ::std::forward<std::default_delete<unsigned char const[]> >(_Right.get_deleter()))         {
        }
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &&_Right) noexcept;
        template <class _Uty, class _Ex, class _More, class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer, class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type> using _Enable_conversion = enable_if_t<conjunction_v<is_array<_Uty>, is_same<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer, std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::element_type *>, is_same<_UP_pointer, _UP_element_type *>, is_convertible<_UP_element_type (*)[], std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::element_type (*)[]>, _More> >;
        template <class _Uty, class _Ex, class  = _Enable_conversion<_Uty, _Ex, conditional_t<is_reference_v<std::default_delete<unsigned char const[]> >, is_same<_Ex, std::default_delete<unsigned char const[]> >, is_convertible<_Ex, std::default_delete<unsigned char const[]> > > >> unique_ptr(unique_ptr<_Uty, _Ex> &&_Right) noexcept;
        template<> unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]>, void>(unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &&_Right) noexcept;
        template <class _Uty, class _Ex, class  = _Enable_conversion<_Uty, _Ex, is_assignable<std::default_delete<unsigned char const[]> &, _Ex> >> std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=(unique_ptr<_Uty, _Ex> &&_Right) noexcept;
        template<> std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=<unsigned char const[], std::default_delete<unsigned char const[]>, void>(unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &&_Right) noexcept;
        template <class _Dx2 = std::default_delete<unsigned char const[]>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr(std::nullptr_t) noexcept;
        template<> constexpr unique_ptr<std::default_delete<unsigned char const[]>, 0>(std::nullptr_t) noexcept : std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::_Mybase(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer())         {
        }
;
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=(std::nullptr_t) noexcept;
        void reset(std::nullptr_t) noexcept;
        void swap(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &_Right) noexcept;
        ~unique_ptr<unsigned char const[], default_delete<unsigned char const[]> >() noexcept         {
            this->_Delete();
        }
        const unsigned char &operator[](size_t _Idx) const;
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer get() const noexcept         {
            return (this->_Myptr());
        }
        explicit operator bool() const noexcept;
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer release() noexcept         {
            std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer _Ans = this->get();
            this->_Myptr() = std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer();
            return (_Ans);
        }
        template <class _Uty, class  = _Enable_ctor_reset<_Uty, std::false_type>> void reset(_Uty _Ptr) noexcept;
        unique_ptr(const std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &) = delete
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=(const std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &) = delete
    private:
        void _Delete()         {
            if (this->get() != std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer()) {
                this->get_deleter()(this->get());
            }
        }
    };
template<> class unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> : public _Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > {
    public:
        typedef _Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > _Mybase;
        typedef typename _Mybase::pointer pointer;
        typedef v8::WasmStreaming::WasmStreamingImpl element_type;
        typedef std::default_delete<v8::WasmStreaming::WasmStreamingImpl> deleter_type;
        using _Mybase::get_deleter;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr() noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr(std::nullptr_t) noexcept;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &operator=(std::nullptr_t) noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, _Unique_ptr_enable_default_t<_Dx2> = 0> explicit unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer _Ptr) noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, enable_if_t<is_constructible_v<_Dx2, const _Dx2 &>, int> = 0> unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer _Ptr, const std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &_Dt) noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, enable_if_t<conjunction_v<negation<is_reference<_Dx2> >, is_constructible<_Dx2, _Dx2> >, int> = 0> unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer _Ptr, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &&_Dt) noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2> > >, int> = 0> unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer, remove_reference_t<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &&) = delete
        unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &&_Right) noexcept;
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer>, conditional_t<is_reference_v<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >, is_same<_Dx2, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >, is_convertible<_Dx2, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > > >, int> = 0> unique_ptr(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept;
        template<> unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, 0>(unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &&_Right) noexcept;
        template <class _Ty2, enable_if_t<conjunction_v<is_convertible<_Ty2 *, v8::WasmStreaming::WasmStreamingImpl *>, is_same<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, default_delete<v8::WasmStreaming::WasmStreamingImpl> > >, int> = 0> unique_ptr(auto_ptr<_Ty2> &&_Right) noexcept;
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_assignable<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &, _Dx2>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer> >, int> = 0> std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &operator=(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &operator=(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &&_Right) noexcept;
        void swap(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &_Right) noexcept;
        ~unique_ptr<WasmStreamingImpl, default_delete<WasmStreamingImpl> >() noexcept;
        add_lvalue_reference_t<v8::WasmStreaming::WasmStreamingImpl> operator*() const;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer operator->() const noexcept;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer get() const noexcept;
        explicit operator bool() const noexcept;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer release() noexcept;
        void reset(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer _Ptr) noexcept;
        unique_ptr(const std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &) = delete
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &operator=(const std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &) = delete
    };
    template <class _Ty, class _Dx> class unique_ptr<type-parameter-0-0 [], _Dx> : public _Unique_ptr_base<_Ty, _Dx> {
    public:
        typedef _Unique_ptr_base<_Ty, _Dx> _Mybase;
        typedef typename _Mybase::pointer pointer;
        typedef _Ty element_type;
        typedef _Dx deleter_type;
        using _Mybase::get_deleter;
        template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr<type-parameter-0-0 [], type-parameter-0-1>() noexcept : std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::_Mybase(std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer())         {
        }
        template <class _Uty, class _Is_nullptr = is_same<_Uty, std::nullptr_t>> using _Enable_ctor_reset = enable_if_t<is_same_v<_Uty, std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer> || _Is_nullptr::value || (is_same_v<std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer, std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::element_type *> && is_pointer_v<_Uty> && is_convertible_v<remove_pointer_t<_Uty> (*)[], std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::element_type (*)[]>)>;
        template <class _Uty, class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0, class  = _Enable_ctor_reset<_Uty>> explicit unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(_Uty _Ptr) noexcept : std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::_Mybase(_Ptr)         {
        }
        template <class _Uty, class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2 &>, int> = 0, class  = _Enable_ctor_reset<_Uty>> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(_Uty _Ptr, const _Dx &_Dt) noexcept : std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::_Mybase(_Ptr, _Dt)         {
        }
        template <class _Uty, class _Dx2 = _Dx, enable_if_t<conjunction_v<negation<is_reference<_Dx2> >, is_constructible<_Dx2, _Dx2> >, int> = 0, class  = _Enable_ctor_reset<_Uty>> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(_Uty _Ptr, _Dx &&_Dt) noexcept : std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::_Mybase(_Ptr, ::std::move(_Dt))         {
        }
        template <class _Uty, class _Dx2 = _Dx, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2> > >, int> = 0> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(_Uty, remove_reference_t<_Dx> &&) = delete
        unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &&_Right) noexcept : std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::_Mybase(_Right.release(), ::std::forward<_Dx>(_Right.get_deleter()))         {
        }
        unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &operator=(unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &&_Right) noexcept         {
            if (this != ::std::addressof(_Right)) {
                reset(_Right.release());
                this->get_deleter() = ::std::move(_Right.get_deleter());
            }
            return (*this);
        }
        template <class _Uty, class _Ex, class _More, class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer, class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type> using _Enable_conversion = enable_if_t<conjunction_v<is_array<_Uty>, is_same<std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer, std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::element_type *>, is_same<_UP_pointer, _UP_element_type *>, is_convertible<_UP_element_type (*)[], std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::element_type (*)[]>, _More> >;
        template <class _Uty, class _Ex, class  = _Enable_conversion<_Uty, _Ex, conditional_t<is_reference_v<_Dx>, is_same<_Ex, _Dx>, is_convertible<_Ex, _Dx> > >> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(unique_ptr<_Uty, _Ex> &&_Right) noexcept : std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::_Mybase(_Right.release(), ::std::forward<_Ex>(_Right.get_deleter()))         {
        }
        template <class _Uty, class _Ex, class  = _Enable_conversion<_Uty, _Ex, is_assignable<_Dx &, _Ex> >> unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &operator=(unique_ptr<_Uty, _Ex> &&_Right) noexcept         {
            reset(_Right.release());
            this->get_deleter() = ::std::forward<_Ex>(_Right.get_deleter());
            return (*this);
        }
        template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(std::nullptr_t) noexcept : std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::_Mybase(std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer())         {
        }
        unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &operator=(std::nullptr_t) noexcept         {
            reset();
            return (*this);
        }
        void reset(std::nullptr_t = nullptr) noexcept         {
            reset(std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer());
        }
        void swap(unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &_Right) noexcept         {
            _Swap_adl(this->_Myptr(), _Right._Myptr());
            _Swap_adl(this->get_deleter(), _Right.get_deleter());
        }
        ~unique_ptr<type-parameter-0-0 [], type-parameter-0-1>() noexcept         {
            this->_Delete();
        }
        _Ty &operator[](size_t _Idx) const         {
            return (this->get()[_Idx]);
        }
        std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer get() const noexcept         {
            return (this->_Myptr());
        }
        explicit operator bool() const noexcept         {
            return (this->get() != std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer());
        }
        std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer release() noexcept         {
            std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer _Ans = this->get();
            this->_Myptr() = std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer();
            return (_Ans);
        }
        template <class _Uty, class  = _Enable_ctor_reset<_Uty, std::false_type>> void reset(_Uty _Ptr) noexcept         {
            std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer _Old = this->get();
            this->_Myptr() = _Ptr;
            if (_Old != std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer()) {
                this->get_deleter()(_Old);
            }
        }
        unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(const unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &) = delete
        unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &operator=(const unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &) = delete
    private:
        void _Delete()         {
            if (this->get() != std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer()) {
                this->get_deleter()(this->get());
            }
        }
    };
    template <class _Ty, class ..._Types, enable_if_t<!is_array_v<_Ty>, int> = 0> inline unique_ptr<_Ty> make_unique(_Types &&..._Args)     {
        return (unique_ptr<_Ty>(new _Ty((::std::forward<_Types>(_Args)...))));
    }
    template <class _Ty, enable_if_t<is_array_v<_Ty> && extent_v<_Ty> == 0, int> = 0> inline unique_ptr<_Ty> make_unique(size_t _Size)     {
        typedef remove_extent_t<_Ty> _Elem;
        return (unique_ptr<_Ty>(new _Elem [_Size](())));
    }
    template <class _Ty, class ..._Types, enable_if_t<extent_v<_Ty> != 0, int> = 0> void make_unique(_Types &&...) = delete
    template <class _Alloc> struct _Allocator_deleter {
        _Alloc _Al;
        using pointer = typename allocator_traits<_Alloc>::pointer;
        void operator()(std::_Allocator_deleter::pointer _Ptr) noexcept         {
            allocator_traits<_Alloc>::destroy(this->_Al, _Unfancy(_Ptr));
            this->_Al.deallocate(_Ptr, 1);
        }
    };
    template <class _Alloc> using _Unique_ptr_alloc = unique_ptr<typename _Alloc::value_type, _Allocator_deleter<_Alloc> >;
    template <class _Alloc, class ..._Args> _Unique_ptr_alloc<_Alloc> _Make_unique_alloc(_Alloc &_Al, _Args &&..._Vals)     {
        auto _Ptr = _Al.allocate(1);
        try {
            allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Ptr), ::std::forward<_Args>(_Vals)...);
        } catch (...) {
            _Al.deallocate(_Ptr, 1);
            throw;
        }
        return (_Unique_ptr_alloc<_Alloc>(_Ptr, _Allocator_deleter<_Alloc>({_Al})));
    }
    template <class _Ty, class _Dx, enable_if_t<_Is_swappable<_Dx>::value, int> = 0> void swap(unique_ptr<_Ty, _Dx> &_Left, unique_ptr<_Ty, _Dx> &_Right) noexcept     {
        _Left.swap(_Right);
    }
    template <class _Ty1, class _Dx1, class _Ty2, class _Dx2> bool operator==(const unique_ptr<_Ty1, _Dx1> &_Left, const unique_ptr<_Ty2, _Dx2> &_Right)     {
        return (_Left.get() == _Right.get());
    }
    template <class _Ty1, class _Dx1, class _Ty2, class _Dx2> bool operator!=(const unique_ptr<_Ty1, _Dx1> &_Left, const unique_ptr<_Ty2, _Dx2> &_Right)     {
        return (!(_Left == _Right));
    }
    template <class _Ty1, class _Dx1, class _Ty2, class _Dx2> bool operator<(const unique_ptr<_Ty1, _Dx1> &_Left, const unique_ptr<_Ty2, _Dx2> &_Right)     {
        typedef typename unique_ptr<_Ty1, _Dx1>::pointer _Ptr1;
        typedef typename unique_ptr<_Ty2, _Dx2>::pointer _Ptr2;
        typedef common_type_t<_Ptr1, _Ptr2> _Common;
        return (less<_Common>()(_Left.get(), _Right.get()));
    }
    template <class _Ty1, class _Dx1, class _Ty2, class _Dx2> bool operator>=(const unique_ptr<_Ty1, _Dx1> &_Left, const unique_ptr<_Ty2, _Dx2> &_Right)     {
        return (!(_Left < _Right));
    }
    template <class _Ty1, class _Dx1, class _Ty2, class _Dx2> bool operator>(const unique_ptr<_Ty1, _Dx1> &_Left, const unique_ptr<_Ty2, _Dx2> &_Right)     {
        return (_Right < _Left);
    }
    template <class _Ty1, class _Dx1, class _Ty2, class _Dx2> bool operator<=(const unique_ptr<_Ty1, _Dx1> &_Left, const unique_ptr<_Ty2, _Dx2> &_Right)     {
        return (!(_Right < _Left));
    }
    template <class _Ty, class _Dx> bool operator==(const unique_ptr<_Ty, _Dx> &_Left, std::nullptr_t) noexcept     {
        return (!_Left);
    }
    template <class _Ty, class _Dx> bool operator==(std::nullptr_t, const unique_ptr<_Ty, _Dx> &_Right) noexcept     {
        return (!_Right);
    }
    template <class _Ty, class _Dx> bool operator!=(const unique_ptr<_Ty, _Dx> &_Left, std::nullptr_t _Right) noexcept     {
        return (!(_Left == _Right));
    }
    template <class _Ty, class _Dx> bool operator!=(std::nullptr_t _Left, const unique_ptr<_Ty, _Dx> &_Right) noexcept     {
        return (!(_Left == _Right));
    }
    template <class _Ty, class _Dx> bool operator<(const unique_ptr<_Ty, _Dx> &_Left, std::nullptr_t _Right)     {
        typedef typename unique_ptr<_Ty, _Dx>::pointer _Ptr;
        return (less<_Ptr>()(_Left.get(), _Right));
    }
    template <class _Ty, class _Dx> bool operator<(std::nullptr_t _Left, const unique_ptr<_Ty, _Dx> &_Right)     {
        typedef typename unique_ptr<_Ty, _Dx>::pointer _Ptr;
        return (less<_Ptr>()(_Left, _Right.get()));
    }
    template <class _Ty, class _Dx> bool operator>=(const unique_ptr<_Ty, _Dx> &_Left, std::nullptr_t _Right)     {
        return (!(_Left < _Right));
    }
    template <class _Ty, class _Dx> bool operator>=(std::nullptr_t _Left, const unique_ptr<_Ty, _Dx> &_Right)     {
        return (!(_Left < _Right));
    }
    template <class _Ty, class _Dx> bool operator>(const unique_ptr<_Ty, _Dx> &_Left, std::nullptr_t _Right)     {
        return (_Right < _Left);
    }
    template <class _Ty, class _Dx> bool operator>(std::nullptr_t _Left, const unique_ptr<_Ty, _Dx> &_Right)     {
        return (_Right < _Left);
    }
    template <class _Ty, class _Dx> bool operator<=(const unique_ptr<_Ty, _Dx> &_Left, std::nullptr_t _Right)     {
        return (!(_Right < _Left));
    }
    template <class _Ty, class _Dx> bool operator<=(std::nullptr_t _Left, const unique_ptr<_Ty, _Dx> &_Right)     {
        return (!(_Right < _Left));
    }
    template <class _OutTy, class _PxTy, class  = void> struct _Can_stream_unique_ptr : std::false_type {
    };
    template <class _OutTy, class _PxTy> struct _Can_stream_unique_ptr<_OutTy, _PxTy, void> : std::true_type {
    };
    template <class _Elem, class _Traits, class _Yty, class _Dx, enable_if_t<_Can_stream_unique_ptr<basic_ostream<_Elem, _Traits> &, const unique_ptr<_Yty, _Dx> &>::value, int> = 0> basic_ostream<_Elem, _Traits> &operator<<(basic_ostream<_Elem, _Traits> &_Out, const unique_ptr<_Yty, _Dx> &_Px)     {
        _Out << _Px.get();
        return (_Out);
    }
    enum class pointer_safety : int {
        relaxed,
        preferred,
        strict
    };
    inline void declare_reachable(void *)     {
    }
    template <class _Ty> inline _Ty *undeclare_reachable(_Ty *_Ptr)     {
        return (_Ptr);
    }
    inline void declare_no_pointers(char *, size_t)     {
    }
    inline void undeclare_no_pointers(char *, size_t)     {
    }
    inline std::pointer_safety get_pointer_safety() noexcept     {
        return (pointer_safety::relaxed);
    }
    template <class _Ty = void> struct owner_less;
    template <class _Ty> struct owner_less<shared_ptr<type-parameter-0-0>> {
        typedef shared_ptr<_Ty> first_argument_type;
        typedef shared_ptr<_Ty> second_argument_type;
        typedef bool result_type;
        bool operator()(const shared_ptr<_Ty> &_Left, const shared_ptr<_Ty> &_Right) const noexcept         {
            return (_Left.owner_before(_Right));
        }
        bool operator()(const shared_ptr<_Ty> &_Left, const weak_ptr<_Ty> &_Right) const noexcept         {
            return (_Left.owner_before(_Right));
        }
        bool operator()(const weak_ptr<_Ty> &_Left, const shared_ptr<_Ty> &_Right) const noexcept         {
            return (_Left.owner_before(_Right));
        }
    };
    template <class _Ty> struct owner_less<weak_ptr<type-parameter-0-0>> {
        typedef weak_ptr<_Ty> first_argument_type;
        typedef weak_ptr<_Ty> second_argument_type;
        typedef bool result_type;
        bool operator()(const weak_ptr<_Ty> &_Left, const weak_ptr<_Ty> &_Right) const noexcept         {
            return (_Left.owner_before(_Right));
        }
        bool operator()(const weak_ptr<_Ty> &_Left, const shared_ptr<_Ty> &_Right) const noexcept         {
            return (_Left.owner_before(_Right));
        }
        bool operator()(const shared_ptr<_Ty> &_Left, const weak_ptr<_Ty> &_Right) const noexcept         {
            return (_Left.owner_before(_Right));
        }
    };
    template<> struct owner_less<void> {
        using is_transparent = int;
        template <class _Ty, class _Uty> bool operator()(const shared_ptr<_Ty> &_Left, const shared_ptr<_Uty> &_Right) const noexcept         {
            return (_Left.owner_before(_Right));
        }
        template <class _Ty, class _Uty> bool operator()(const shared_ptr<_Ty> &_Left, const weak_ptr<_Uty> &_Right) const noexcept         {
            return (_Left.owner_before(_Right));
        }
        template <class _Ty, class _Uty> bool operator()(const weak_ptr<_Ty> &_Left, const shared_ptr<_Uty> &_Right) const noexcept         {
            return (_Left.owner_before(_Right));
        }
        template <class _Ty, class _Uty> bool operator()(const weak_ptr<_Ty> &_Left, const weak_ptr<_Uty> &_Right) const noexcept         {
            return (_Left.owner_before(_Right));
        }
    };
    template <class _Ty, class _Dx> struct hash<unique_ptr<type-parameter-0-0, type-parameter-0-1>> : _Conditionally_enabled_hash<unique_ptr<_Ty, _Dx>, is_default_constructible_v<hash<typename unique_ptr<_Ty, _Dx>::pointer> > > {
        static size_t _Do_hash(const unique_ptr<_Ty, _Dx> &_Keyval) noexcept(_Is_nothrow_hashable<typename unique_ptr<_Ty, _Dx>::pointer>::value_Do_hash(const unique_ptr<_Ty, _Dx> &_Keyval) noexcept(_Is_nothrow_hashable<typename unique_ptr<_Ty, _Dx>::pointer>::value)         {
            return (hash<typename unique_ptr<_Ty, _Dx>::pointer>({})(_Keyval.get()));
        }
    };
    template <class _Ty> struct hash<shared_ptr<type-parameter-0-0>> {
        typedef shared_ptr<_Ty> argument_type;
        typedef size_t result_type;
        size_t operator()(const shared_ptr<_Ty> &_Keyval) const noexcept         {
            return (hash<typename shared_ptr<_Ty>::element_type *>()(_Keyval.get()));
        }
    };
    inline void *align(size_t _Bound, size_t _Size, void *&_Ptr, size_t &_Space) noexcept     {
        size_t _Off = static_cast<size_t>(reinterpret_cast<uintptr_t>(_Ptr) & (_Bound - 1));
        if (_Off != 0) {
            _Off = _Bound - _Off;
        }
        if (_Space < _Off || _Space - _Off < _Size) {
            return (nullptr);
        }
        _Ptr = static_cast<char *>(_Ptr) + _Off;
        _Space -= _Off;
        return (_Ptr);
    }
    extern "C" {
        void _Lock_shared_ptr_spin_lock();
        void _Unlock_shared_ptr_spin_lock();
    }
    struct _Shared_ptr_spin_lock {
        _Shared_ptr_spin_lock()         {
            _Lock_shared_ptr_spin_lock();
        }
        ~_Shared_ptr_spin_lock() noexcept         {
            _Unlock_shared_ptr_spin_lock();
        }
    };
    template <class _Ty> inline bool atomic_is_lock_free(const shared_ptr<_Ty> *)     {
        return (false);
    }
    template <class _Ty> inline shared_ptr<_Ty> atomic_load_explicit(const shared_ptr<_Ty> *_Ptr, std::memory_order)     {
        std::_Shared_ptr_spin_lock _Lock;
        shared_ptr<_Ty> _Result = *_Ptr;
        return (_Result);
    }
    template <class _Ty> inline shared_ptr<_Ty> atomic_load(const shared_ptr<_Ty> *_Ptr)     {
        return (::std::atomic_load_explicit(_Ptr, memory_order_seq_cst));
    }
    template <class _Ty> inline void atomic_store_explicit(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other, std::memory_order)     {
        std::_Shared_ptr_spin_lock _Lock;
        _Ptr->swap(_Other);
    }
    template <class _Ty> inline void atomic_store(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other)     {
        ::std::atomic_store_explicit(_Ptr, ::std::move(_Other), memory_order_seq_cst);
    }
    template <class _Ty> inline shared_ptr<_Ty> atomic_exchange_explicit(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other, std::memory_order)     {
        std::_Shared_ptr_spin_lock _Lock;
        _Ptr->swap(_Other);
        return (_Other);
    }
    template <class _Ty> inline shared_ptr<_Ty> atomic_exchange(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other)     {
        return (::std::atomic_exchange_explicit(_Ptr, ::std::move(_Other), memory_order_seq_cst));
    }
    template <class _Ty> inline bool atomic_compare_exchange_weak_explicit(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp, shared_ptr<_Ty> _Value, std::memory_order, std::memory_order)     {
        shared_ptr<_Ty> _Old_exp;
        std::_Shared_ptr_spin_lock _Lock;
        bool _Success = _Ptr->get() == _Exp->get() && !_Ptr->owner_before(*_Exp) && !_Exp->owner_before(*_Ptr);
        if (_Success)
            _Ptr->swap(_Value);
        else {
            _Exp->swap(_Old_exp);
            *_Exp = *_Ptr;
        }
        return (_Success);
    }
    template <class _Ty> inline bool atomic_compare_exchange_weak(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp, shared_ptr<_Ty> _Value)     {
        return (::std::atomic_compare_exchange_weak_explicit(_Ptr, _Exp, ::std::move(_Value), memory_order_seq_cst, memory_order_seq_cst));
    }
    template <class _Ty> inline bool atomic_compare_exchange_strong_explicit(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp, shared_ptr<_Ty> _Value, std::memory_order, std::memory_order)     {
        return (::std::atomic_compare_exchange_weak_explicit(_Ptr, _Exp, ::std::move(_Value), memory_order_seq_cst, memory_order_seq_cst));
    }
    template <class _Ty> inline bool atomic_compare_exchange_strong(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp, shared_ptr<_Ty> _Value)     {
        return (::std::atomic_compare_exchange_strong_explicit(_Ptr, _Exp, ::std::move(_Value), memory_order_seq_cst, memory_order_seq_cst));
    }
    namespace tr1 {
        using ::std::allocate_shared;
        using ::std::bad_weak_ptr;
        using ::std::const_pointer_cast;
        using ::std::dynamic_pointer_cast;
        using ::std::enable_shared_from_this;
        using ::std::get_deleter;
        using ::std::make_shared;
        using ::std::shared_ptr;
        using ::std::static_pointer_cast;
        using ::std::swap;
        using ::std::weak_ptr;
    }
}
namespace std {
    template <class _Traits> using _Traits_ch_t = typename _Traits::char_type;
    template <class _Traits> using _Traits_ptr_t = const typename _Traits::char_type *;
    template <class _Traits> constexpr bool _Traits_equal(const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size, const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept     {
        return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);
    }
    template <class _Traits> constexpr int _Traits_compare(const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size, const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept     {
        const int _Ans = _Traits::compare(_Left, _Right, _Min_value(_Left_size, _Right_size));
        if (_Ans != 0) {
            return (_Ans);
        }
        if (_Left_size < _Right_size) {
            return (-1);
        }
        if (_Left_size > _Right_size) {
            return (1);
        }
        return (0);
    }
    template <class _Traits> constexpr size_t _Traits_find(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size) noexcept     {
        if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {
            return (static_cast<size_t>(-1));
        }
        if (_Needle_size == 0) {
            return (_Start_at);
        }
        const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
        for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try) {
            _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
            if (!_Match_try) {
                return (static_cast<size_t>(-1));
            }
            if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
                return (static_cast<size_t>(_Match_try - _Haystack));
            }
        }
    }
    template <class _Traits> constexpr size_t _Traits_find_ch(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept     {
        if (_Start_at < _Hay_size) {
            const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
            if (_Found_at) {
                return (static_cast<size_t>(_Found_at - _Haystack));
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_rfind(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size) noexcept     {
        if (_Needle_size == 0) {
            return (_Min_value(_Start_at, _Hay_size));
        }
        if (_Needle_size <= _Hay_size) {
            for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - _Needle_size); ; --_Match_try) {
                if (_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
                    return (static_cast<size_t>(_Match_try - _Haystack));
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_rfind_ch(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept     {
        if (_Hay_size != 0) {
            for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try) {
                if (_Traits::eq(*_Match_try, _Ch)) {
                    return (static_cast<size_t>(_Match_try - _Haystack));
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Elem, bool = _Is_character<_Elem>::value> class _String_bitmap {
    public:
        constexpr bool _Mark(const _Elem *_First, const _Elem *const _Last)         {
            for (; _First != _Last; ++_First) {
                this->_Matches[static_cast<unsigned char>(*_First)] = true;
            }
            return (true);
        }
        constexpr bool _Match(const _Elem _Ch) const         {
            return (this->_Matches[static_cast<unsigned char>(_Ch)]);
        }
    private:
        bool _Matches[256] = {};
    };
    template <class _Elem> class _String_bitmap<_Elem, false> {
    public:
        static_assert(is_unsigned_v<_Elem>, "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. Visual C++ accepts other unsigned integral types as an extension.");
        constexpr bool _Mark(const _Elem *_First, const _Elem *const _Last)         {
            for (; _First != _Last; ++_First) {
                const auto _Ch = *_First;
                if (_Ch >= 256U) {
                    return (false);
                }
                this->_Matches[static_cast<unsigned char>(_Ch)] = true;
            }
            return (true);
        }
        constexpr bool _Match(const _Elem _Ch) const         {
            return (_Ch < 256U && this->_Matches[_Ch]);
        }
    private:
        bool _Matches[256] = {};
    };
    template <class _Traits> constexpr size_t _Traits_find_first_of(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, std::false_type) noexcept     {
        if (_Needle_size != 0 && _Start_at < _Hay_size) {
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return (static_cast<size_t>(_Match_try - _Haystack));
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_find_first_of(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, std::true_type) noexcept     {
        if (_Needle_size != 0 && _Start_at < _Hay_size) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) {
                return (_Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, std::false_type{}));
            }
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (_Matches._Match(*_Match_try)) {
                    return (static_cast<size_t>(_Match_try - _Haystack));
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_find_last_of(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, std::false_type) noexcept     {
        if (_Needle_size != 0 && _Hay_size != 0) {
            for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try) {
                if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return (static_cast<size_t>(_Match_try - _Haystack));
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_find_last_of(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, std::true_type) noexcept     {
        if (_Needle_size != 0 && _Hay_size != 0) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) {
                return (_Traits_find_last_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, std::false_type{}));
            }
            for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try) {
                if (_Matches._Match(*_Match_try)) {
                    return (static_cast<size_t>(_Match_try - _Haystack));
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_find_first_not_of(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, std::false_type) noexcept     {
        if (_Start_at < _Hay_size) {
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return (static_cast<size_t>(_Match_try - _Haystack));
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_find_first_not_of(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, std::true_type) noexcept     {
        if (_Start_at < _Hay_size) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) {
                return (_Traits_find_first_not_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, std::false_type{}));
            }
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (!_Matches._Match(*_Match_try)) {
                    return (static_cast<size_t>(_Match_try - _Haystack));
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_find_not_ch(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept     {
        if (_Start_at < _Hay_size) {
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (!_Traits::eq(*_Match_try, _Ch)) {
                    return (static_cast<size_t>(_Match_try - _Haystack));
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_find_last_not_of(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, std::false_type) noexcept     {
        if (_Hay_size != 0) {
            for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try) {
                if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return (static_cast<size_t>(_Match_try - _Haystack));
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_find_last_not_of(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, std::true_type) noexcept     {
        if (_Hay_size != 0) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) {
                return (_Traits_find_last_not_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, std::false_type{}));
            }
            for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try) {
                if (!_Matches._Match(*_Match_try)) {
                    return (static_cast<size_t>(_Match_try - _Haystack));
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_rfind_not_ch(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept     {
        if (_Hay_size != 0) {
            for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try) {
                if (!_Traits::eq(*_Match_try, _Ch)) {
                    return (static_cast<size_t>(_Match_try - _Haystack));
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Mystr> class _String_const_iterator : public std::_Iterator_base {
    public:
        using iterator_category = std::random_access_iterator_tag;
        using value_type = typename _Mystr::value_type;
        using difference_type = typename _Mystr::difference_type;
        using pointer = typename _Mystr::const_pointer;
        using reference = const std::_String_const_iterator::value_type &;
        _String_const_iterator<_Mystr>() : _Ptr()         {
        }
        _String_const_iterator<_Mystr>(std::_String_const_iterator::pointer _Parg, const std::_Container_base *_Pstring) : _Ptr(_Parg)         {
            this->_Adopt(_Pstring);
        }
        std::_String_const_iterator::reference operator*() const         {
            ;
            return (*this->_Ptr);
        }
        std::_String_const_iterator::pointer operator->() const         {
            return (pointer_traits<pointer>::pointer_to(**this));
        }
        _String_const_iterator<_Mystr> &operator++()         {
            ++this->_Ptr;
            return (*this);
        }
        _String_const_iterator<_Mystr> operator++(int)         {
            _String_const_iterator<_Mystr> _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        _String_const_iterator<_Mystr> &operator--()         {
            --this->_Ptr;
            return (*this);
        }
        _String_const_iterator<_Mystr> operator--(int)         {
            _String_const_iterator<_Mystr> _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        void _Verify_offset(const std::_String_const_iterator::difference_type _Off) const noexcept         {
            (void)_Off;
        }
        _String_const_iterator<_Mystr> &operator+=(const std::_String_const_iterator::difference_type _Off)         {
            this->_Ptr += _Off;
            return (*this);
        }
        _String_const_iterator<_Mystr> operator+(const std::_String_const_iterator::difference_type _Off) const         {
            _String_const_iterator<_Mystr> _Tmp = *this;
            return (_Tmp += _Off);
        }
        _String_const_iterator<_Mystr> &operator-=(const std::_String_const_iterator::difference_type _Off)         {
            return (*this += - _Off);
        }
        _String_const_iterator<_Mystr> operator-(const std::_String_const_iterator::difference_type _Off) const         {
            _String_const_iterator<_Mystr> _Tmp = *this;
            return (_Tmp -= _Off);
        }
        std::_String_const_iterator::difference_type operator-(const _String_const_iterator<_Mystr> &_Right) const         {
            this->_Compat(_Right);
            return (this->_Ptr - _Right._Ptr);
        }
        std::_String_const_iterator::reference operator[](const std::_String_const_iterator::difference_type _Off) const         {
            return (*(*this + _Off));
        }
        bool operator==(const _String_const_iterator<_Mystr> &_Right) const         {
            this->_Compat(_Right);
            return (this->_Ptr == _Right._Ptr);
        }
        bool operator!=(const _String_const_iterator<_Mystr> &_Right) const         {
            return (!(*this == _Right));
        }
        bool operator<(const _String_const_iterator<_Mystr> &_Right) const         {
            this->_Compat(_Right);
            return (this->_Ptr < _Right._Ptr);
        }
        bool operator>(const _String_const_iterator<_Mystr> &_Right) const         {
            return (_Right < *this);
        }
        bool operator<=(const _String_const_iterator<_Mystr> &_Right) const         {
            return (!(_Right < *this));
        }
        bool operator>=(const _String_const_iterator<_Mystr> &_Right) const         {
            return (!(*this < _Right));
        }
        void _Compat(const _String_const_iterator<_Mystr> &_Right) const         {
            (void)_Right;
        }
        std::_String_const_iterator::pointer _Unwrapped() const         {
            return (this->_Ptr);
        }
        void _Seek_to(std::_String_const_iterator::pointer _It)         {
            this->_Ptr = _It;
        }
        std::_String_const_iterator::pointer _Ptr;
    };
    template <class _Mystr> inline _String_const_iterator<_Mystr> operator+(typename _String_const_iterator<_Mystr>::difference_type _Off, _String_const_iterator<_Mystr> _Next)     {
        return (_Next += _Off);
    }
    template <class _Mystr> class _String_iterator : public _String_const_iterator<_Mystr> {
    public:
        using _Mybase = _String_const_iterator<_Mystr>;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = typename _Mystr::value_type;
        using difference_type = typename _Mystr::difference_type;
        using pointer = typename _Mystr::pointer;
        using reference = std::_String_iterator::value_type &;
        _String_iterator<_Mystr>()         {
        }
        _String_iterator<_Mystr>(std::_String_iterator::pointer _Parg, const std::_Container_base *_Pstring) : std::_String_iterator::_Mybase(_Parg, _Pstring)         {
        }
        std::_String_iterator::reference operator*() const         {
            return (const_cast<std::_String_iterator::reference>(_Mybase::operator*()));
        }
        std::_String_iterator::pointer operator->() const         {
            return (pointer_traits<pointer>::pointer_to(**this));
        }
        _String_iterator<_Mystr> &operator++()         {
            ++*(std::_String_iterator::_Mybase *)this;
            return (*this);
        }
        _String_iterator<_Mystr> operator++(int)         {
            _String_iterator<_Mystr> _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        _String_iterator<_Mystr> &operator--()         {
            --*(std::_String_iterator::_Mybase *)this;
            return (*this);
        }
        _String_iterator<_Mystr> operator--(int)         {
            _String_iterator<_Mystr> _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        _String_iterator<_Mystr> &operator+=(const std::_String_iterator::difference_type _Off)         {
            *(std::_String_iterator::_Mybase *)this += _Off;
            return (*this);
        }
        _String_iterator<_Mystr> operator+(const std::_String_iterator::difference_type _Off) const         {
            _String_iterator<_Mystr> _Tmp = *this;
            return (_Tmp += _Off);
        }
        _String_iterator<_Mystr> &operator-=(const std::_String_iterator::difference_type _Off)         {
            return (*this += - _Off);
        }
        _String_iterator<_Mystr> operator-(const std::_String_iterator::difference_type _Off) const         {
            _String_iterator<_Mystr> _Tmp = *this;
            return (_Tmp -= _Off);
        }
        std::_String_iterator::difference_type operator-(const std::_String_iterator::_Mybase &_Right) const         {
            return (*(std::_String_iterator::_Mybase *)this - _Right);
        }
        std::_String_iterator::reference operator[](const std::_String_iterator::difference_type _Off) const         {
            return (*(*this + _Off));
        }
        std::_String_iterator::pointer _Unwrapped() const         {
            return (_Const_cast(this->_Ptr));
        }
    };
    template <class _Mystr> inline _String_iterator<_Mystr> operator+(typename _String_iterator<_Mystr>::difference_type _Off, _String_iterator<_Mystr> _Next)     {
        return (_Next += _Off);
    }
    template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer, class _Reference, class _Const_reference> struct _String_iter_types {
        using value_type = _Value_type;
        using size_type = _Size_type;
        using difference_type = _Difference_type;
        using pointer = _Pointer;
        using const_pointer = _Const_pointer;
    };
    template <class _Ty, class _Alloc> struct _String_base_types {
        using _Alty = _Rebind_alloc_t<_Alloc, _Ty>;
        using _Alty_traits = allocator_traits<std::_String_base_types::_Alty>;
        using _Val_types = conditional_t<_Is_simple_alloc_v<std::_String_base_types::_Alty>, _Simple_types<_Ty>, _String_iter_types<_Ty, typename _Alty_traits::size_type, typename _Alty_traits::difference_type, typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Ty &, const _Ty &> >;
    };
template<> struct _String_base_types<char, std::allocator<char>> {
        using _Alty = _Rebind_alloc_t<std::allocator<char>, char>;
        using _Alty_traits = allocator_traits<std::_String_base_types<char, std::allocator<char> >::_Alty>;
        using _Val_types = conditional_t<_Is_simple_alloc_v<std::_String_base_types<char, std::allocator<char> >::_Alty>, _Simple_types<char>, _String_iter_types<char, typename _Alty_traits::size_type, typename _Alty_traits::difference_type, typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, char &, const char &> >;
    };
    template <class _Val_types> class _String_val : public std::_Container_base {
    public:
        using value_type = typename _Val_types::value_type;
        using size_type = typename _Val_types::size_type;
        using difference_type = typename _Val_types::difference_type;
        using pointer = typename _Val_types::pointer;
        using const_pointer = typename _Val_types::const_pointer;
        using reference = std::_String_val::value_type &;
        using const_reference = const std::_String_val::value_type &;
        _String_val<_Val_types>() : _Bx(), _Mysize(0), _Myres(0)         {
        }
        enum  {
            _BUF_SIZE = 16 / sizeof(std::_String_val::value_type) < 1 ? 1 : 16 / sizeof(std::_String_val::value_type)
        };
        enum  {
            _ALLOC_MASK = sizeof(std::_String_val::value_type) <= 1 ? 15 : sizeof(std::_String_val::value_type) <= 2 ? 7 : sizeof(std::_String_val::value_type) <= 4 ? 3 : sizeof(std::_String_val::value_type) <= 8 ? 1 : 0
        };
        std::_String_val::value_type *_Myptr()         {
            std::_String_val::value_type *_Result = this->_Bx._Buf;
            if (this->_Large_string_engaged()) {
                _Result = _Unfancy(this->_Bx._Ptr);
            }
            return (_Result);
        }
        const std::_String_val::value_type *_Myptr() const         {
            const std::_String_val::value_type *_Result = this->_Bx._Buf;
            if (this->_Large_string_engaged()) {
                _Result = _Unfancy(this->_Bx._Ptr);
            }
            return (_Result);
        }
        bool _Large_string_engaged() const         {
            return (_BUF_SIZE <= this->_Myres);
        }
        void _Check_offset(const std::_String_val::size_type _Off) const         {
            if (this->_Mysize < _Off) {
                _Xran();
            }
        }
        void _Check_offset_exclusive(const std::_String_val::size_type _Off) const         {
            if (this->_Mysize <= _Off) {
                _Xran();
            }
        }
        static void _Xran() [[noreturn]]         {
            _Xout_of_range("invalid string position");
        }
        std::_String_val::size_type _Clamp_suffix_size(const std::_String_val::size_type _Off, const std::_String_val::size_type _Size) const noexcept         {
            return (_Min_value(_Size, this->_Mysize - _Off));
        }
        union _Bxty {
            _Bxty()             {
            }
            ~_Bxty() noexcept             {
            }
            std::_String_val::value_type _Buf[_BUF_SIZE];
            std::_String_val::pointer _Ptr;
            char _Alias[_BUF_SIZE];
        } _Bx;
        std::_String_val::size_type _Mysize;
        std::_String_val::size_type _Myres;
    };
template<> class _String_val<std::_Simple_types<char>> : public std::_Container_base {
    public:
        using value_type = typename _Simple_types<char>::value_type;
        using size_type = typename _Simple_types<char>::size_type;
        using difference_type = typename _Simple_types<char>::difference_type;
        using pointer = typename _Simple_types<char>::pointer;
        using const_pointer = typename _Simple_types<char>::const_pointer;
        using reference = std::_String_val<std::_Simple_types<char> >::value_type &;
        using const_reference = const std::_String_val<std::_Simple_types<char> >::value_type &;
        _String_val();
        enum  {
            _BUF_SIZE = 16 / sizeof(std::_String_val<std::_Simple_types<char> >::value_type) < 1 ? 1 : 16 / sizeof(std::_String_val<std::_Simple_types<char> >::value_type)
        };
        enum  {
            _ALLOC_MASK = sizeof(std::_String_val<std::_Simple_types<char> >::value_type) <= 1 ? 15 : sizeof(std::_String_val<std::_Simple_types<char> >::value_type) <= 2 ? 7 : sizeof(std::_String_val<std::_Simple_types<char> >::value_type) <= 4 ? 3 : sizeof(std::_String_val<std::_Simple_types<char> >::value_type) <= 8 ? 1 : 0
        };
        std::_String_val<std::_Simple_types<char> >::value_type *_Myptr();
        const std::_String_val<std::_Simple_types<char> >::value_type *_Myptr() const         {
            const std::_String_val<std::_Simple_types<char> >::value_type *_Result = this->_Bx._Buf;
            if (this->_Large_string_engaged()) {
                _Result = _Unfancy(this->_Bx._Ptr);
            }
            return (_Result);
        }
        bool _Large_string_engaged() const         {
            return (_BUF_SIZE <= this->_Myres);
        }
        void _Check_offset(const std::_String_val<std::_Simple_types<char> >::size_type _Off) const;
        void _Check_offset_exclusive(const std::_String_val<std::_Simple_types<char> >::size_type _Off) const;
        static void _Xran() [[noreturn]];
        std::_String_val<std::_Simple_types<char> >::size_type _Clamp_suffix_size(const std::_String_val<std::_Simple_types<char> >::size_type _Off, const std::_String_val<std::_Simple_types<char> >::size_type _Size) const noexcept;
        union _Bxty {
            std::_String_val<std::_Simple_types<char> >::value_type _Buf[16];
            std::_String_val<std::_Simple_types<char> >::pointer _Ptr;
            char _Alias[16];
        };
        union _Bxty _Bx;
        std::_String_val<std::_Simple_types<char> >::size_type _Mysize;
        std::_String_val<std::_Simple_types<char> >::size_type _Myres;
    };
    template <class _Alloc_types> class _String_alloc {
    public:
        using _Alty = typename _Alloc_types::_Alty;
        using _Alty_traits = typename _Alloc_types::_Alty_traits;
        using _Alproxy = _Rebind_alloc_t<std::_String_alloc::_Alty, std::_Container_proxy>;
        using _Alproxy_traits = allocator_traits<std::_String_alloc::_Alproxy>;
        using _Val_types = typename _Alloc_types::_Val_types;
        using _Mydata_t = _String_val<std::_String_alloc::_Val_types>;
        using _Bxty = typename _Mydata_t::_Bxty;
        using value_type = typename _Val_types::value_type;
        using size_type = typename _Val_types::size_type;
        using difference_type = typename _Val_types::difference_type;
        using pointer = typename _Val_types::pointer;
        using const_pointer = typename _Val_types::const_pointer;
        using reference = std::_String_alloc::value_type &;
        using const_reference = const std::_String_alloc::value_type &;
        using iterator = _String_iterator<std::_String_alloc::_Mydata_t>;
        using const_iterator = _String_const_iterator<std::_String_alloc::_Mydata_t>;
        enum  {
            _BUF_SIZE = _Mydata_t::_BUF_SIZE
        };
        enum  {
            _ALLOC_MASK = _Mydata_t::_ALLOC_MASK
        };
        _String_alloc<_Alloc_types>() : _Mypair(std::_Zero_then_variadic_args_t())         {
        }
        template <class _Any_alloc, class  = enable_if_t<!is_same_v<remove_cv_t<remove_reference_t<_Any_alloc> >, _String_alloc<_Alloc_types> > >> _String_alloc<_Alloc_types>(_Any_alloc &&_Al) : _Mypair(std::_One_then_variadic_args_t(), ::std::forward<_Any_alloc>(_Al))         {
        }
        void _Copy_alloc(const std::_String_alloc::_Alty &_Al)         {
            _Pocca(_Getal(), _Al);
        }
        void _Move_alloc(std::_String_alloc::_Alty &_Al)         {
            _Pocma(_Getal(), _Al);
        }
        void _Orphan_all()         {
            _Get_data()._Orphan_all();
        }
        void _Swap_all(_String_alloc<_Alloc_types> &_Right)         {
            _Get_data()._Swap_all(_Right._Get_data());
        }
        std::_String_alloc::_Alty &_Getal() noexcept         {
            return (this->_Mypair._Get_first());
        }
        const std::_String_alloc::_Alty &_Getal() const noexcept         {
            return (this->_Mypair._Get_first());
        }
        std::_String_alloc::_Mydata_t &_Get_data() noexcept         {
            return (this->_Mypair._Get_second());
        }
        const std::_String_alloc::_Mydata_t &_Get_data() const noexcept         {
            return (this->_Mypair._Get_second());
        }
    private:
        _Compressed_pair<std::_String_alloc::_Alty, std::_String_alloc::_Mydata_t> _Mypair;
    };
template<> class _String_alloc<std::_String_base_types<char, std::allocator<char> >> {
    public:
        using _Alty = typename _String_base_types<char, allocator<char> >::_Alty;
        using _Alty_traits = typename _String_base_types<char, allocator<char> >::_Alty_traits;
        using _Alproxy = _Rebind_alloc_t<std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Alty, std::_Container_proxy>;
        using _Alproxy_traits = allocator_traits<std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Alproxy>;
        using _Val_types = typename _String_base_types<char, allocator<char> >::_Val_types;
        using _Mydata_t = _String_val<std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Val_types>;
        using _Bxty = typename _Mydata_t::_Bxty;
        using value_type = typename _Val_types::value_type;
        using size_type = typename _Val_types::size_type;
        using difference_type = typename _Val_types::difference_type;
        using pointer = typename _Val_types::pointer;
        using const_pointer = typename _Val_types::const_pointer;
        using reference = std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::value_type &;
        using const_reference = const std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::value_type &;
        using iterator = _String_iterator<std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Mydata_t>;
        using const_iterator = _String_const_iterator<std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Mydata_t>;
        enum  {
            _BUF_SIZE = _Mydata_t::_BUF_SIZE
        };
        enum  {
            _ALLOC_MASK = _Mydata_t::_ALLOC_MASK
        };
        _String_alloc();
        template <class _Any_alloc, class  = enable_if_t<!is_same_v<remove_cv_t<remove_reference_t<_Any_alloc> >, std::_String_alloc<std::_String_base_types<char, std::allocator<char> > > > >> _String_alloc(_Any_alloc &&_Al);
        void _Copy_alloc(const std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Alty &_Al);
        void _Move_alloc(std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Alty &_Al);
        void _Orphan_all();
        void _Swap_all(std::_String_alloc<std::_String_base_types<char, std::allocator<char> > > &_Right);
        std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Alty &_Getal() noexcept;
        const std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Alty &_Getal() const noexcept;
        std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Mydata_t &_Get_data() noexcept;
        const std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Mydata_t &_Get_data() const noexcept         {
            return (this->_Mypair._Get_second());
        }
    private:
        _Compressed_pair<std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Alty, std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Mydata_t> _Mypair;
    };
    template <class _Ty> constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty);
    template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>> class basic_string : public _String_alloc<_String_base_types<_Elem, _Alloc> > {
    public:
        static_assert(!0 || is_same_v<_Elem, typename _Alloc::value_type>, "basic_string<T, Traits, Allocator> requires that Allocator's value_type match T (See N4659 26.2.1 [container.requirements.general]/16 allocator_type) Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0 to suppress this diagnostic.");
        static_assert(is_same_v<_Elem, typename _Traits::char_type>, "N4659 24.3.2.1 [string.require]/3 requires that the supplied char_traits character type match the string's character type.");
        using _Mybase = _String_alloc<_String_base_types<_Elem, _Alloc> >;
        using traits_type = _Traits;
        using allocator_type = _Alloc;
        using _Alty = typename _Mybase::_Alty;
        using _Alty_traits = typename _Mybase::_Alty_traits;
        using _Mydata_t = typename _Mybase::_Mydata_t;
        using value_type = typename _Mybase::value_type;
        using size_type = typename _Mybase::size_type;
        using difference_type = typename _Mybase::difference_type;
        using pointer = typename _Mybase::pointer;
        using const_pointer = typename _Mybase::const_pointer;
        using reference = std::basic_string::value_type &;
        using const_reference = const std::basic_string::value_type &;
        using iterator = typename _Mybase::iterator;
        using const_iterator = typename _Mybase::const_iterator;
        using reverse_iterator = ::std::reverse_iterator<iterator>;
        using const_reverse_iterator = ::std::reverse_iterator<const_iterator>;
        using _Use_memcpy_move = bool_constant<_Is_specialization_v<_Traits, char_traits> && is_trivial_v<std::basic_string::pointer> >;
        static constexpr size_t _Memcpy_move_offset = _Size_after_ebco_v<std::_Container_base>;
        static constexpr size_t _Memcpy_move_size = sizeof(std::basic_string::_Mydata_t) - _Memcpy_move_offset;
        template <class _Iter> using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem *const, _Elem *const, const _Elem *, _Elem *> >;
        basic_string<_Elem, _Traits, _Alloc>(const basic_string<_Elem, _Traits, _Alloc> &_Right) : std::basic_string::_Mybase(_Alty_traits::select_on_container_copy_construction(_Right._Getal()))         {
            this->_Construct_lv_contents(_Right);
        }
        basic_string<_Elem, _Traits, _Alloc>(const basic_string<_Elem, _Traits, _Alloc> &_Right, const _Alloc &_Al) : std::basic_string::_Mybase(_Al)         {
            this->_Construct_lv_contents(_Right);
        }
        basic_string<_Elem, _Traits, _Alloc>() noexcept(is_nothrow_default_constructible_v<std::basic_string::_Alty>basic_string<_Elem, _Traits, _Alloc>() noexcept(is_nothrow_default_constructible_v<std::basic_string::_Alty>) : std::basic_string::_Mybase()         {
            this->_Tidy_init();
        }
        explicit basic_string<_Elem, _Traits, _Alloc>(const _Alloc &_Al) noexcept : std::basic_string::_Mybase(_Al)         {
            this->_Tidy_init();
        }
        basic_string<_Elem, _Traits, _Alloc>(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Roff, const _Alloc &_Al = _Alloc()) : std::basic_string::_Mybase(_Al)         {
            this->_Tidy_init();
            assign(_Right, _Roff, npos);
        }
        basic_string<_Elem, _Traits, _Alloc>(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Roff, const std::basic_string::size_type _Count, const _Alloc &_Al = _Alloc()) : std::basic_string::_Mybase(_Al)         {
            this->_Tidy_init();
            assign(_Right, _Roff, _Count);
        }
        basic_string<_Elem, _Traits, _Alloc>(const _Elem *const _Ptr, const std::basic_string::size_type _Count) : std::basic_string::_Mybase()         {
            this->_Tidy_init();
            assign(_Ptr, _Count);
        }
        basic_string<_Elem, _Traits, _Alloc>(const _Elem *const _Ptr, const std::basic_string::size_type _Count, const _Alloc &_Al) : std::basic_string::_Mybase(_Al)         {
            this->_Tidy_init();
            assign(_Ptr, _Count);
        }
        basic_string<_Elem, _Traits, _Alloc>(const _Elem *const _Ptr) : std::basic_string::_Mybase()         {
            this->_Tidy_init();
            assign(_Ptr);
        }
        basic_string<_Elem, _Traits, _Alloc>(const _Elem *const _Ptr, const _Alloc &_Al) : std::basic_string::_Mybase(_Al)         {
            this->_Tidy_init();
            assign(_Ptr);
        }
        basic_string<_Elem, _Traits, _Alloc>(const std::basic_string::size_type _Count, const _Elem _Ch) : std::basic_string::_Mybase()         {
            this->_Tidy_init();
            assign(_Count, _Ch);
        }
        basic_string<_Elem, _Traits, _Alloc>(const std::basic_string::size_type _Count, const _Elem _Ch, const _Alloc &_Al) : std::basic_string::_Mybase(_Al)         {
            this->_Tidy_init();
            assign(_Count, _Ch);
        }
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> basic_string<_Elem, _Traits, _Alloc>(_Iter _First, _Iter _Last, const _Alloc &_Al = _Alloc()) : std::basic_string::_Mybase(_Al)         {
            this->_Tidy_init();
            _Adl_verify_range(_First, _Last);
            _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>());
        }
        template <class _Iter> void _Construct(_Iter _First, const _Iter _Last, std::input_iterator_tag)         {
            try {
                for (; _First != _Last; ++_First) {
                    this->push_back(static_cast<_Elem>(*_First));
                }
            } catch (...) {
                this->_Tidy_deallocate();
                throw;
            }
        }
        template <class _Iter> void _Construct(const _Iter _First, const _Iter _Last, std::forward_iterator_tag)         {
            const std::basic_string::size_type _Count = _Convert_size<std::basic_string::size_type>(static_cast<size_t>(::std::distance(_First, _Last)));
            this->reserve(_Count);
            _Construct(_First, _Last, std::input_iterator_tag());
        }
        void _Construct(_Elem *const _First, _Elem *const _Last, std::random_access_iterator_tag)         {
            if (_First != _Last) {
                assign(_First, _Convert_size<std::basic_string::size_type>(static_cast<size_t>(_Last - _First)));
            }
        }
        void _Construct(const _Elem *const _First, const _Elem *const _Last, std::random_access_iterator_tag)         {
            if (_First != _Last) {
                assign(_First, _Convert_size<std::basic_string::size_type>(static_cast<size_t>(_Last - _First)));
            }
        }
        basic_string<_Elem, _Traits, _Alloc>(basic_string<_Elem, _Traits, _Alloc> &&_Right) noexcept : std::basic_string::_Mybase(::std::move(_Right._Getal()))         {
            _Assign_rv_contents_with_alloc_always_equal(::std::move(_Right), std::basic_string::_Use_memcpy_move({}));
        }
        basic_string<_Elem, _Traits, _Alloc>(basic_string<_Elem, _Traits, _Alloc> &&_Right, const _Alloc &_Al) noexcept(_Alty_traits::is_always_equal::valuebasic_string<_Elem, _Traits, _Alloc>(basic_string<_Elem, _Traits, _Alloc> &&_Right, const _Alloc &_Al) noexcept(_Alty_traits::is_always_equal::value) : std::basic_string::_Mybase(_Al)         {
            _Assign_rv_contents(::std::move(_Right), typename _Alty_traits::is_always_equal({}));
        }
        basic_string<_Elem, _Traits, _Alloc> &operator=(basic_string<_Elem, _Traits, _Alloc> &&_Right) noexcept(_Always_equal_after_move<std::basic_string::_Alty>operator=(basic_string<_Elem, _Traits, _Alloc> &&_Right) noexcept(_Always_equal_after_move<std::basic_string::_Alty>)         {
            if (this != ::std::addressof(_Right)) {
                this->_Tidy_deallocate();
                this->_Move_alloc(_Right._Getal());
                _Assign_rv_contents(::std::move(_Right), bool_constant<_Always_equal_after_move<std::basic_string::_Alty> >({}));
            }
            return (*this);
        }
        basic_string<_Elem, _Traits, _Alloc> &assign(basic_string<_Elem, _Traits, _Alloc> &&_Right) noexcept(_Always_equal_after_move<std::basic_string::_Alty>assign(basic_string<_Elem, _Traits, _Alloc> &&_Right) noexcept(_Always_equal_after_move<std::basic_string::_Alty>)         {
            *this = ::std::move(_Right);
            return (*this);
        }
        void _Assign_rv_contents(basic_string<_Elem, _Traits, _Alloc> &&_Right, std::true_type) noexcept         {
            _Assign_rv_contents_with_alloc_always_equal(::std::move(_Right), std::basic_string::_Use_memcpy_move({}));
        }
        void _Assign_rv_contents(basic_string<_Elem, _Traits, _Alloc> &&_Right, std::false_type)         {
            if (this->_Getal() == _Right._Getal()) {
                _Assign_rv_contents_with_alloc_always_equal(::std::move(_Right), std::basic_string::_Use_memcpy_move({}));
            } else {
                this->_Construct_lv_contents(_Right);
            }
        }
        void _Assign_rv_contents_with_alloc_always_equal(basic_string<_Elem, _Traits, _Alloc> &&_Right, std::true_type) noexcept         {
            auto &_Right_data = _Right._Get_data();
            const auto _My_data_mem = reinterpret_cast<unsigned char *>(::std::addressof(this->_Get_data())) + _Memcpy_move_offset;
            const auto _Right_data_mem = reinterpret_cast<unsigned char *>(::std::addressof(_Right_data)) + _Memcpy_move_offset;
            ::memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);
            _Right._Tidy_init();
        }
        void _Assign_rv_contents_with_alloc_always_equal(basic_string<_Elem, _Traits, _Alloc> &&_Right, std::false_type) noexcept         {
            auto &_My_data = this->_Get_data();
            auto &_Right_data = _Right._Get_data();
            if (_Right_data._Large_string_engaged()) {
                _Alty_traits::construct(this->_Getal(), ::std::addressof(_My_data._Bx._Ptr), _Right_data._Bx._Ptr);
                _Right_data._Bx._Ptr = std::basic_string::pointer();
                this->_Swap_all(_Right);
            } else {
                _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
                _Right._Orphan_all();
            }
            _My_data._Mysize = _Right_data._Mysize;
            _My_data._Myres = _Right_data._Myres;
            _Right._Tidy_init();
        }
        void _Construct_lv_contents(const basic_string<_Elem, _Traits, _Alloc> &_Right)         {
            auto &_My_data = this->_Get_data();
            auto &_Right_data = _Right._Get_data();
            const std::basic_string::size_type _Right_size = _Right_data._Mysize;
            const _Elem *const _Right_ptr = _Right_data._Myptr();
            if (_Right_size < this->_BUF_SIZE) {
                _Traits::copy(_My_data._Bx._Buf, _Right_ptr, this->_BUF_SIZE);
                _My_data._Mysize = _Right_size;
                _My_data._Myres = this->_BUF_SIZE - 1;
                return;
            }
            auto &_Al = this->_Getal();
            const std::basic_string::size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, this->max_size());
            const std::basic_string::pointer _New_array = _Al.allocate(_New_capacity + 1);
            _Alty_traits::construct(_Al, ::std::addressof(_My_data._Bx._Ptr), _New_array);
            _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);
            _My_data._Mysize = _Right_size;
            _My_data._Myres = _New_capacity;
        }
        basic_string<_Elem, _Traits, _Alloc>(initializer_list<_Elem> _Ilist, const _Alloc &_Al = std::basic_string::allocator_type()) : std::basic_string::_Mybase(_Al)         {
            this->_Tidy_init();
            assign(_Ilist.begin(), _Convert_size<std::basic_string::size_type>(_Ilist.size()));
        }
        basic_string<_Elem, _Traits, _Alloc> &operator=(initializer_list<_Elem> _Ilist)         {
            return (assign(_Ilist.begin(), _Convert_size<std::basic_string::size_type>(_Ilist.size())));
        }
        basic_string<_Elem, _Traits, _Alloc> &operator+=(initializer_list<_Elem> _Ilist)         {
            return (append(_Ilist.begin(), _Convert_size<std::basic_string::size_type>(_Ilist.size())));
        }
        basic_string<_Elem, _Traits, _Alloc> &assign(initializer_list<_Elem> _Ilist)         {
            return (assign(_Ilist.begin(), _Convert_size<std::basic_string::size_type>(_Ilist.size())));
        }
        basic_string<_Elem, _Traits, _Alloc> &append(initializer_list<_Elem> _Ilist)         {
            return (append(_Ilist.begin(), _Convert_size<std::basic_string::size_type>(_Ilist.size())));
        }
        std::basic_string::iterator insert(const std::basic_string::const_iterator _Where, const initializer_list<_Elem> _Ilist)         {
            const std::basic_string::difference_type _Off = _Where - begin();
            insert(static_cast<std::basic_string::size_type>(_Off), _Ilist.begin(), _Convert_size<std::basic_string::size_type>(_Ilist.size()));
            return (begin() + _Off);
        }
        basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last, const initializer_list<_Elem> _Ilist)         {
            return (replace(static_cast<std::basic_string::size_type>(_First - begin()), static_cast<std::basic_string::size_type>(_Last - _First), _Ilist.begin(), _Convert_size<std::basic_string::size_type>(_Ilist.size())));
        }
        ~basic_string<_Elem, _Traits, _Alloc>() noexcept         {
            this->_Tidy_deallocate();
        }
        static constexpr auto npos(static_cast<std::basic_string::size_type>(-1));
        basic_string<_Elem, _Traits, _Alloc> &operator=(const basic_string<_Elem, _Traits, _Alloc> &_Right)         {
            if (this != ::std::addressof(_Right)) {
                if (_Alty_traits::propagate_on_container_copy_assignment::value && this->_Getal() != _Right._Getal()) {
                    this->_Tidy_deallocate();
                }
                this->_Copy_alloc(_Right._Getal());
                auto &_Right_data = _Right._Get_data();
                assign(_Right_data._Myptr(), _Right_data._Mysize);
            }
            return (*this);
        }
        basic_string<_Elem, _Traits, _Alloc> &operator=(const _Elem *const _Ptr)         {
            return (assign(_Ptr));
        }
        basic_string<_Elem, _Traits, _Alloc> &operator=(const _Elem _Ch)         {
            auto &_My_data = this->_Get_data();
            _My_data._Mysize = 1;
            _Elem *const _Ptr = _My_data._Myptr();
            _Traits::assign(_Ptr[0], _Ch);
            _Traits::assign(_Ptr[1], _Elem());
            return (*this);
        }
        basic_string<_Elem, _Traits, _Alloc> &operator+=(const basic_string<_Elem, _Traits, _Alloc> &_Right)         {
            return (append(_Right));
        }
        basic_string<_Elem, _Traits, _Alloc> &operator+=(const _Elem *const _Ptr)         {
            return (append(_Ptr));
        }
        basic_string<_Elem, _Traits, _Alloc> &operator+=(_Elem _Ch)         {
            this->push_back(_Ch);
            return (*this);
        }
        basic_string<_Elem, _Traits, _Alloc> &append(const basic_string<_Elem, _Traits, _Alloc> &_Right)         {
            auto &_Right_data = _Right._Get_data();
            return (append(_Right_data._Myptr(), _Right_data._Mysize));
        }
        basic_string<_Elem, _Traits, _Alloc> &append(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Roff, std::basic_string::size_type _Count = npos)         {
            auto &_Right_data = _Right._Get_data();
            _Right_data._Check_offset(_Roff);
            _Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
            return (append(_Right_data._Myptr() + _Roff, _Count));
        }
        basic_string<_Elem, _Traits, _Alloc> &append(const _Elem *const _Ptr, const std::basic_string::size_type _Count)         {
            auto &_My_data = this->_Get_data();
            const std::basic_string::size_type _Old_size = _My_data._Mysize;
            if (_Count <= _My_data._Myres - _Old_size) {
                _My_data._Mysize = _Old_size + _Count;
                _Elem *const _Old_ptr = _My_data._Myptr();
                _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
                _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
                return (*this);
            }
            return (_Reallocate_grow_by(_Count, [] (_Elem *const _New_ptr, const _Elem *const _Old_ptr, const std::basic_string::size_type _Old_size, const _Elem *const _Ptr, const std::basic_string::size_type _Count)                 {
                    _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                    _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
                    _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
                }
, _Ptr, _Count));
        }
        basic_string<_Elem, _Traits, _Alloc> &append(const _Elem *const _Ptr)         {
            return (append(_Ptr, _Convert_size<std::basic_string::size_type>(_Traits::length(_Ptr))));
        }
        basic_string<_Elem, _Traits, _Alloc> &append(const std::basic_string::size_type _Count, const _Elem _Ch)         {
            auto &_My_data = this->_Get_data();
            const std::basic_string::size_type _Old_size = _My_data._Mysize;
            if (_Count <= _My_data._Myres - _Old_size) {
                _My_data._Mysize = _Old_size + _Count;
                _Elem *const _Old_ptr = _My_data._Myptr();
                _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
                _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
                return (*this);
            }
            return (_Reallocate_grow_by(_Count, [] (_Elem *const _New_ptr, const _Elem *const _Old_ptr, const std::basic_string::size_type _Old_size, const std::basic_string::size_type _Count, const _Elem _Ch)                 {
                    _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                    _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
                    _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
                }
, _Count, _Ch));
        }
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> basic_string<_Elem, _Traits, _Alloc> &append(const _Iter _First, const _Iter _Last)         {
            return (replace(end(), end(), _First, _Last));
        }
        basic_string<_Elem, _Traits, _Alloc> &assign(const basic_string<_Elem, _Traits, _Alloc> &_Right)         {
            *this = _Right;
            return (*this);
        }
        basic_string<_Elem, _Traits, _Alloc> &assign(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Roff, std::basic_string::size_type _Count = npos)         {
            auto &_Right_data = _Right._Get_data();
            _Right_data._Check_offset(_Roff);
            _Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
            return (assign(_Right_data._Myptr() + _Roff, _Count));
        }
        basic_string<_Elem, _Traits, _Alloc> &assign(const _Elem *const _Ptr, const std::basic_string::size_type _Count)         {
            auto &_My_data = this->_Get_data();
            if (_Count <= _My_data._Myres) {
                _Elem *const _Old_ptr = _My_data._Myptr();
                _My_data._Mysize = _Count;
                _Traits::move(_Old_ptr, _Ptr, _Count);
                _Traits::assign(_Old_ptr[_Count], _Elem());
                return (*this);
            }
            return (_Reallocate_for(_Count, [] (_Elem *const _New_ptr, const std::basic_string::size_type _Count, const _Elem *const _Ptr)                 {
                    _Traits::copy(_New_ptr, _Ptr, _Count);
                    _Traits::assign(_New_ptr[_Count], _Elem());
                }
, _Ptr));
        }
        basic_string<_Elem, _Traits, _Alloc> &assign(const _Elem *const _Ptr)         {
            return (assign(_Ptr, _Convert_size<std::basic_string::size_type>(_Traits::length(_Ptr))));
        }
        basic_string<_Elem, _Traits, _Alloc> &assign(const std::basic_string::size_type _Count, const _Elem _Ch)         {
            auto &_My_data = this->_Get_data();
            if (_Count <= _My_data._Myres) {
                _Elem *const _Old_ptr = _My_data._Myptr();
                _My_data._Mysize = _Count;
                _Traits::assign(_Old_ptr, _Count, _Ch);
                _Traits::assign(_Old_ptr[_Count], _Elem());
                return (*this);
            }
            return (_Reallocate_for(_Count, [] (_Elem *const _New_ptr, const std::basic_string::size_type _Count, const _Elem _Ch)                 {
                    _Traits::assign(_New_ptr, _Count, _Ch);
                    _Traits::assign(_New_ptr[_Count], _Elem());
                }
, _Ch));
        }
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> basic_string<_Elem, _Traits, _Alloc> &assign(const _Iter _First, const _Iter _Last)         {
            return (replace(begin(), end(), _First, _Last));
        }
        basic_string<_Elem, _Traits, _Alloc> &insert(const std::basic_string::size_type _Off, const basic_string<_Elem, _Traits, _Alloc> &_Right)         {
            auto &_Right_data = _Right._Get_data();
            return (insert(_Off, _Right_data._Myptr(), _Right_data._Mysize));
        }
        basic_string<_Elem, _Traits, _Alloc> &insert(const std::basic_string::size_type _Off, const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Roff, std::basic_string::size_type _Count = npos)         {
            auto &_Right_data = _Right._Get_data();
            _Right_data._Check_offset(_Roff);
            _Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
            return (insert(_Off, _Right_data._Myptr() + _Roff, _Count));
        }
        basic_string<_Elem, _Traits, _Alloc> &insert(const std::basic_string::size_type _Off, const _Elem *const _Ptr, const std::basic_string::size_type _Count)         {
            auto &_My_data = this->_Get_data();
            _My_data._Check_offset(_Off);
            const std::basic_string::size_type _Old_size = _My_data._Mysize;
            if (_Count <= _My_data._Myres - _Old_size) {
                _My_data._Mysize = _Old_size + _Count;
                _Elem *const _Old_ptr = _My_data._Myptr();
                _Elem *const _Insert_at = _Old_ptr + _Off;
                std::basic_string::size_type _Ptr_shifted_after;
                if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
                    _Ptr_shifted_after = _Count;
                } else if (_Insert_at <= _Ptr) {
                    _Ptr_shifted_after = 0;
                } else {
                    _Ptr_shifted_after = static_cast<std::basic_string::size_type>(_Insert_at - _Ptr);
                }
                _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1);
                _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
                _Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
                return (*this);
            }
            return (_Reallocate_grow_by(_Count, [] (_Elem *const _New_ptr, const _Elem *const _Old_ptr, const std::basic_string::size_type _Old_size, const std::basic_string::size_type _Off, const _Elem *const _Ptr, const std::basic_string::size_type _Count)                 {
                    _Traits::copy(_New_ptr, _Old_ptr, _Off);
                    _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                    _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
                }
, _Off, _Ptr, _Count));
        }
        basic_string<_Elem, _Traits, _Alloc> &insert(const std::basic_string::size_type _Off, const _Elem *const _Ptr)         {
            return (insert(_Off, _Ptr, _Convert_size<std::basic_string::size_type>(_Traits::length(_Ptr))));
        }
        basic_string<_Elem, _Traits, _Alloc> &insert(const std::basic_string::size_type _Off, const std::basic_string::size_type _Count, const _Elem _Ch)         {
            auto &_My_data = this->_Get_data();
            _My_data._Check_offset(_Off);
            const std::basic_string::size_type _Old_size = _My_data._Mysize;
            if (_Count <= _My_data._Myres - _Old_size) {
                _My_data._Mysize = _Old_size + _Count;
                _Elem *const _Old_ptr = _My_data._Myptr();
                _Elem *const _Insert_at = _Old_ptr + _Off;
                _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1);
                _Traits::assign(_Insert_at, _Count, _Ch);
                return (*this);
            }
            return (_Reallocate_grow_by(_Count, [] (_Elem *const _New_ptr, const _Elem *const _Old_ptr, const std::basic_string::size_type _Old_size, const std::basic_string::size_type _Off, const std::basic_string::size_type _Count, const _Elem _Ch)                 {
                    _Traits::copy(_New_ptr, _Old_ptr, _Off);
                    _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                    _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
                }
, _Off, _Count, _Ch));
        }
        std::basic_string::iterator insert(const std::basic_string::const_iterator _Where, const _Elem _Ch)         {
            const std::basic_string::difference_type _Off = _Where - begin();
            insert(static_cast<std::basic_string::size_type>(_Off), 1, _Ch);
            return (begin() + _Off);
        }
        std::basic_string::iterator insert(const std::basic_string::const_iterator _Where, const std::basic_string::size_type _Count, const _Elem _Ch)         {
            const std::basic_string::difference_type _Off = _Where - begin();
            insert(static_cast<std::basic_string::size_type>(_Off), _Count, _Ch);
            return (begin() + _Off);
        }
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> std::basic_string::iterator insert(const std::basic_string::const_iterator _Where, const _Iter _First, const _Iter _Last)         {
            const std::basic_string::difference_type _Off = _Where - begin();
            replace(_Where, _Where, _First, _Last);
            return (begin() + _Off);
        }
        basic_string<_Elem, _Traits, _Alloc> &erase(const std::basic_string::size_type _Off = 0)         {
            auto &_My_data = this->_Get_data();
            _My_data._Check_offset(_Off);
            this->_Eos(_Off);
            return (*this);
        }
        basic_string<_Elem, _Traits, _Alloc> &erase(const std::basic_string::size_type _Off, std::basic_string::size_type _Count)         {
            auto &_My_data = this->_Get_data();
            _My_data._Check_offset(_Off);
            _Count = _My_data._Clamp_suffix_size(_Off, _Count);
            const std::basic_string::size_type _Old_size = _My_data._Mysize;
            _Elem *const _My_ptr = _My_data._Myptr();
            _Elem *const _Erase_at = _My_ptr + _Off;
            const std::basic_string::size_type _New_size = _Old_size - _Count;
            _My_data._Mysize = _New_size;
            _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1);
            return (*this);
        }
        std::basic_string::iterator erase(const std::basic_string::const_iterator _Where)         {
            const std::basic_string::difference_type _Off = _Where - begin();
            erase(static_cast<std::basic_string::size_type>(_Off), 1);
            return (begin() + _Off);
        }
        std::basic_string::iterator erase(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last)         {
            _Adl_verify_range(_First, _Last);
            const std::basic_string::difference_type _Off = _First - begin();
            erase(static_cast<std::basic_string::size_type>(_Off), static_cast<std::basic_string::size_type>(_Last - _First));
            return (begin() + _Off);
        }
        void clear() noexcept         {
            this->_Eos(0);
        }
        basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::size_type _Off, const std::basic_string::size_type _N0, const basic_string<_Elem, _Traits, _Alloc> &_Right)         {
            auto &_Right_data = _Right._Get_data();
            return (replace(_Off, _N0, _Right_data._Myptr(), _Right_data._Mysize));
        }
        basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::size_type _Off, std::basic_string::size_type _N0, const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Roff, std::basic_string::size_type _Count = npos)         {
            auto &_Right_data = _Right._Get_data();
            _Right_data._Check_offset(_Roff);
            _Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
            return (replace(_Off, _N0, _Right_data._Myptr() + _Roff, _Count));
        }
        basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::size_type _Off, std::basic_string::size_type _N0, const _Elem *const _Ptr, const std::basic_string::size_type _Count)         {
            auto &_My_data = this->_Get_data();
            _My_data._Check_offset(_Off);
            _N0 = _My_data._Clamp_suffix_size(_Off, _N0);
            if (_N0 == _Count) {
                _Traits::move(_My_data._Myptr() + _Off, _Ptr, _Count);
                return (*this);
            }
            const std::basic_string::size_type _Old_size = _My_data._Mysize;
            const std::basic_string::size_type _Suffix_size = _Old_size - _N0 - _Off + 1;
            if (_Count < _N0) {
                _My_data._Mysize = _Old_size - (_N0 - _Count);
                _Elem *const _Old_ptr = _My_data._Myptr();
                _Elem *const _Insert_at = _Old_ptr + _Off;
                _Traits::move(_Insert_at, _Ptr, _Count);
                _Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Suffix_size);
                return (*this);
            }
            const std::basic_string::size_type _Growth = static_cast<std::basic_string::size_type>(_Count - _N0);
            if (_Growth <= _My_data._Myres - _Old_size) {
                _My_data._Mysize = _Old_size + _Growth;
                _Elem *const _Old_ptr = _My_data._Myptr();
                _Elem *const _Insert_at = _Old_ptr + _Off;
                _Elem *const _Suffix_at = _Insert_at + _N0;
                std::basic_string::size_type _Ptr_shifted_after;
                if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
                    _Ptr_shifted_after = _Count;
                } else if (_Suffix_at <= _Ptr) {
                    _Ptr_shifted_after = 0;
                } else {
                    _Ptr_shifted_after = static_cast<std::basic_string::size_type>(_Suffix_at - _Ptr);
                }
                _Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);
                _Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);
                _Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
                return (*this);
            }
            return (_Reallocate_grow_by(_Growth, [] (_Elem *const _New_ptr, const _Elem *const _Old_ptr, const std::basic_string::size_type _Old_size, const std::basic_string::size_type _Off, const std::basic_string::size_type _N0, const _Elem *const _Ptr, const std::basic_string::size_type _Count)                 {
                    _Traits::copy(_New_ptr, _Old_ptr, _Off);
                    _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                    _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
                }
, _Off, _N0, _Ptr, _Count));
        }
        basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::size_type _Off, const std::basic_string::size_type _N0, const _Elem *const _Ptr)         {
            return (replace(_Off, _N0, _Ptr, _Convert_size<std::basic_string::size_type>(_Traits::length(_Ptr))));
        }
        basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::size_type _Off, std::basic_string::size_type _N0, const std::basic_string::size_type _Count, const _Elem _Ch)         {
            auto &_My_data = this->_Get_data();
            _My_data._Check_offset(_Off);
            _N0 = _My_data._Clamp_suffix_size(_Off, _N0);
            if (_Count == _N0) {
                _Traits::assign(_My_data._Myptr() + _Off, _Count, _Ch);
                return (*this);
            }
            const std::basic_string::size_type _Old_size = _My_data._Mysize;
            if (_Count < _N0 || _Count - _N0 <= _My_data._Myres - _Old_size) {
                _My_data._Mysize = _Old_size + _Count - _N0;
                _Elem *const _Old_ptr = _My_data._Myptr();
                _Elem *const _Insert_at = _Old_ptr + _Off;
                _Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Old_size - _N0 - _Off + 1);
                _Traits::assign(_Insert_at, _Count, _Ch);
                return (*this);
            }
            return (_Reallocate_grow_by(_Count - _N0, [] (_Elem *const _New_ptr, const _Elem *const _Old_ptr, const std::basic_string::size_type _Old_size, const std::basic_string::size_type _Off, const std::basic_string::size_type _N0, const std::basic_string::size_type _Count, const _Elem _Ch)                 {
                    _Traits::copy(_New_ptr, _Old_ptr, _Off);
                    _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                    _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
                }
, _Off, _N0, _Count, _Ch));
        }
        basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last, const basic_string<_Elem, _Traits, _Alloc> &_Right)         {
            return (replace(static_cast<std::basic_string::size_type>(_First - begin()), static_cast<std::basic_string::size_type>(_Last - _First), _Right));
        }
        basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last, const _Elem *const _Ptr, const std::basic_string::size_type _Count)         {
            return (replace(static_cast<std::basic_string::size_type>(_First - begin()), static_cast<std::basic_string::size_type>(_Last - _First), _Ptr, _Count));
        }
        basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last, const _Elem *const _Ptr)         {
            return (replace(static_cast<std::basic_string::size_type>(_First - begin()), static_cast<std::basic_string::size_type>(_Last - _First), _Ptr));
        }
        basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last, const std::basic_string::size_type _Count, const _Elem _Ch)         {
            return (replace(static_cast<std::basic_string::size_type>(_First - begin()), static_cast<std::basic_string::size_type>(_Last - _First), _Count, _Ch));
        }
        template <class _Iter> basic_string<_Elem, _Traits, _Alloc> &_Replace_range(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last, const _Iter _First2, const _Iter _Last2, std::false_type)         {
            const basic_string<_Elem, _Traits, _Alloc> _Right(_First2, _Last2, this->get_allocator());
            replace(_First, _Last, _Right);
            return (*this);
        }
        template <class _Ptr> basic_string<_Elem, _Traits, _Alloc> &_Replace_range(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last, const _Ptr _First2, const _Ptr _Last2, std::true_type)         {
            return (replace(static_cast<std::basic_string::size_type>(_First - this->cbegin()), static_cast<std::basic_string::size_type>(_Last - _First), _First2, static_cast<std::basic_string::size_type>(_Last2 - _First2)));
        }
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last, const _Iter _First2, const _Iter _Last2)         {
            _Adl_verify_range(_First2, _Last2);
            const auto _UFirst2 = _Get_unwrapped(_First2);
            const auto _ULast2 = _Get_unwrapped(_Last2);
            return (_Replace_range(_First, _Last, _UFirst2, _ULast2, _Is_elem_cptr<decltype(_UFirst2)>()));
        }
        std::basic_string::iterator begin() noexcept         {
            auto _My_data = ::std::addressof(this->_Get_data());
            return (std::basic_string::iterator(_Refancy<std::basic_string::pointer>(_My_data->_Myptr()), _My_data));
        }
        std::basic_string::const_iterator begin() const noexcept         {
            auto _My_data = ::std::addressof(this->_Get_data());
            return (std::basic_string::const_iterator(_Refancy<std::basic_string::const_pointer>(_My_data->_Myptr()), _My_data));
        }
        std::basic_string::iterator end() noexcept         {
            auto _My_data = ::std::addressof(this->_Get_data());
            return (std::basic_string::iterator(_Refancy<std::basic_string::pointer>(_My_data->_Myptr()) + static_cast<std::basic_string::difference_type>(_My_data->_Mysize), _My_data));
        }
        std::basic_string::const_iterator end() const noexcept         {
            auto _My_data = ::std::addressof(this->_Get_data());
            return (std::basic_string::const_iterator(_Refancy<std::basic_string::const_pointer>(_My_data->_Myptr()) + static_cast<std::basic_string::difference_type>(_My_data->_Mysize), _My_data));
        }
        _Elem *_Unchecked_begin() noexcept         {
            return (this->_Get_data()._Myptr());
        }
        const _Elem *_Unchecked_begin() const noexcept         {
            return (this->_Get_data()._Myptr());
        }
        _Elem *_Unchecked_end() noexcept         {
            auto &_My_data = this->_Get_data();
            return (_My_data._Myptr() + _My_data._Mysize);
        }
        const _Elem *_Unchecked_end() const noexcept         {
            const auto &_My_data = this->_Get_data();
            return (_My_data._Myptr() + _My_data._Mysize);
        }
        std::basic_string::reverse_iterator rbegin() noexcept         {
            return (std::basic_string::reverse_iterator(end()));
        }
        std::basic_string::const_reverse_iterator rbegin() const noexcept         {
            return (std::basic_string::const_reverse_iterator(end()));
        }
        std::basic_string::reverse_iterator rend() noexcept         {
            return (std::basic_string::reverse_iterator(begin()));
        }
        std::basic_string::const_reverse_iterator rend() const noexcept         {
            return (std::basic_string::const_reverse_iterator(begin()));
        }
        std::basic_string::const_iterator cbegin() const noexcept         {
            return (begin());
        }
        std::basic_string::const_iterator cend() const noexcept         {
            return (end());
        }
        std::basic_string::const_reverse_iterator crbegin() const noexcept         {
            return (rbegin());
        }
        std::basic_string::const_reverse_iterator crend() const noexcept         {
            return (rend());
        }
        void shrink_to_fit()         {
            auto &_My_data = this->_Get_data();
            if (!_My_data._Large_string_engaged()) {
                return;
            }
            if (_My_data._Mysize < this->_BUF_SIZE) {
                this->_Become_small();
                return;
            }
            const std::basic_string::size_type _Target_capacity = _Min_value(_My_data._Mysize | this->_ALLOC_MASK, this->max_size());
            if (_Target_capacity < _My_data._Myres) {
                auto &_Al = this->_Getal();
                const std::basic_string::pointer _New_ptr = _Al.allocate(_Target_capacity + 1);
                this->_Orphan_all();
                _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
                _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);
                _My_data._Bx._Ptr = _New_ptr;
                _My_data._Myres = _Target_capacity;
            }
        }
        std::basic_string::reference at(const std::basic_string::size_type _Off)         {
            auto &_My_data = this->_Get_data();
            _My_data._Check_offset_exclusive(_Off);
            return (_My_data._Myptr()[_Off]);
        }
        std::basic_string::const_reference at(const std::basic_string::size_type _Off) const         {
            auto &_My_data = this->_Get_data();
            _My_data._Check_offset_exclusive(_Off);
            return (_My_data._Myptr()[_Off]);
        }
        std::basic_string::reference operator[](const std::basic_string::size_type _Off)         {
            auto &_My_data = this->_Get_data();
            return (_My_data._Myptr()[_Off]);
        }
        std::basic_string::const_reference operator[](const std::basic_string::size_type _Off) const         {
            auto &_My_data = this->_Get_data();
            return (_My_data._Myptr()[_Off]);
        }
        void push_back(const _Elem _Ch)         {
            auto &_My_data = this->_Get_data();
            const std::basic_string::size_type _Old_size = _My_data._Mysize;
            if (_Old_size < _My_data._Myres) {
                _My_data._Mysize = _Old_size + 1;
                _Elem *const _Ptr = _My_data._Myptr();
                _Traits::assign(_Ptr[_Old_size], _Ch);
                _Traits::assign(_Ptr[_Old_size + 1], _Elem());
                return;
            }
            _Reallocate_grow_by(1, [] (_Elem *const _New_ptr, const _Elem *const _Old_ptr, const std::basic_string::size_type _Old_size, const _Elem _Ch)                 {
                    _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                    _Traits::assign(_New_ptr[_Old_size], _Ch);
                    _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
                }
, _Ch);
        }
        void pop_back()         {
            auto &_My_data = this->_Get_data();
            const std::basic_string::size_type _Old_size = _My_data._Mysize;
            this->_Eos(_Old_size - 1);
        }
        std::basic_string::reference front()         {
            return (*begin());
        }
        std::basic_string::const_reference front() const         {
            return (*begin());
        }
        std::basic_string::reference back()         {
            return (*(end() - 1));
        }
        std::basic_string::const_reference back() const         {
            return (*(end() - 1));
        }
        const _Elem *c_str() const noexcept         {
            return (this->_Get_data()._Myptr());
        }
        const _Elem *data() const noexcept         {
            return (this->_Get_data()._Myptr());
        }
        std::basic_string::size_type length() const noexcept         {
            return (this->_Get_data()._Mysize);
        }
        std::basic_string::size_type size() const noexcept         {
            return (this->_Get_data()._Mysize);
        }
        std::basic_string::size_type max_size() const noexcept         {
            const std::basic_string::size_type _Alloc_max = _Alty_traits::max_size(this->_Getal());
            const std::basic_string::size_type _Storage_max = _Max_value(_Alloc_max, static_cast<std::basic_string::size_type>(this->_BUF_SIZE));
            return (_Min_value(static_cast<std::basic_string::size_type>((numeric_limits<difference_type>::max)()), _Storage_max - 1));
        }
        void resize(const std::basic_string::size_type _Newsize, const _Elem _Ch = _Elem())         {
            const std::basic_string::size_type _Old_size = this->size();
            if (_Newsize <= _Old_size) {
                this->_Eos(_Newsize);
            } else {
                append(_Newsize - _Old_size, _Ch);
            }
        }
        std::basic_string::size_type capacity() const noexcept         {
            return (this->_Get_data()._Myres);
        }
        void reserve(const std::basic_string::size_type _Newcap = 0)         {
            auto &_My_data = this->_Get_data();
            if (_My_data._Mysize > _Newcap) {
                return;
            }
            if (_My_data._Myres == _Newcap) {
                return;
            }
            if (_My_data._Myres < _Newcap) {
                const std::basic_string::size_type _Old_size = _My_data._Mysize;
                _Reallocate_grow_by(_Newcap - _Old_size, [] (_Elem *const _New_ptr, const _Elem *const _Old_ptr, const std::basic_string::size_type _Old_size)                     {
                        _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
                    }
);
                _My_data._Mysize = _Old_size;
                return;
            }
            if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged()) {
                this->_Become_small();
                return;
            }
        }
        bool empty() const noexcept         {
            return (this->size() == 0);
        }
        std::basic_string::size_type copy(_Elem *const _Ptr, std::basic_string::size_type _Count, const std::basic_string::size_type _Off = 0) const         {
            auto &_My_data = this->_Get_data();
            _My_data._Check_offset(_Off);
            _Count = _My_data._Clamp_suffix_size(_Off, _Count);
            _Traits::copy(_Ptr, _My_data._Myptr() + _Off, _Count);
            return (_Count);
        }
        std::basic_string::size_type _Copy_s(_Elem *const _Dest, const std::basic_string::size_type _Dest_size, std::basic_string::size_type _Count, const std::basic_string::size_type _Off = 0) const         {
            auto &_My_data = this->_Get_data();
            _My_data._Check_offset(_Off);
            _Count = _My_data._Clamp_suffix_size(_Off, _Count);
            _Traits::_Copy_s(_Dest, _Dest_size, _My_data._Myptr() + _Off, _Count);
            return (_Count);
        }
        void _Swap_data(basic_string<_Elem, _Traits, _Alloc> &_Right, std::true_type)         {
            const auto _My_data_mem = reinterpret_cast<unsigned char *>(::std::addressof(this->_Get_data())) + _Memcpy_move_offset;
            const auto _Right_data_mem = reinterpret_cast<unsigned char *>(::std::addressof(_Right._Get_data())) + _Memcpy_move_offset;
            unsigned char _Temp_mem[_Memcpy_move_size];
            ::memcpy(_Temp_mem, _My_data_mem, _Memcpy_move_size);
            ::memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);
            ::memcpy(_Right_data_mem, _Temp_mem, _Memcpy_move_size);
        }
        void _Swap_bx_large_with_small(std::basic_string::_Mydata_t &_Starts_large, std::basic_string::_Mydata_t &_Starts_small)         {
            const std::basic_string::pointer _Ptr = _Starts_large._Bx._Ptr;
            auto &_Al = this->_Getal();
            _Alty_traits::destroy(_Al, ::std::addressof(_Starts_large._Bx._Ptr));
            _Traits::copy(_Starts_large._Bx._Buf, _Starts_small._Bx._Buf, this->_BUF_SIZE);
            _Alty_traits::construct(_Al, ::std::addressof(_Starts_small._Bx._Ptr), _Ptr);
        }
        void _Swap_data(basic_string<_Elem, _Traits, _Alloc> &_Right, std::false_type)         {
            auto &_My_data = this->_Get_data();
            auto &_Right_data = _Right._Get_data();
            const bool _My_large = _My_data._Large_string_engaged();
            const bool _Right_large = _Right_data._Large_string_engaged();
            if (_My_large) {
                if (_Right_large) {
                    _Swap_adl(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
                } else {
                    this->_Swap_bx_large_with_small(_My_data, _Right_data);
                }
            } else {
                if (_Right_large) {
                    this->_Swap_bx_large_with_small(_Right_data, _My_data);
                } else {
                    _Elem _Temp_buf[this->_BUF_SIZE];
                    _Traits::copy(_Temp_buf, _My_data._Bx._Buf, this->_BUF_SIZE);
                    _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, this->_BUF_SIZE);
                    _Traits::copy(_Right_data._Bx._Buf, _Temp_buf, this->_BUF_SIZE);
                }
            }
            ::std::swap(_My_data._Mysize, _Right_data._Mysize);
            ::std::swap(_My_data._Myres, _Right_data._Myres);
        }
        void swap(basic_string<_Elem, _Traits, _Alloc> &_Right) noexcept         {
            if (this != ::std::addressof(_Right)) {
                _Pocs(this->_Getal(), _Right._Getal());
            }
            _Swap_data(_Right, std::basic_string::_Use_memcpy_move({}));
        }
        std::basic_string::size_type find(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Off = 0) const noexcept         {
            auto &_My_data = this->_Get_data();
            auto &_Right_data = _Right._Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Right_data._Myptr(), _Right_data._Mysize)));
        }
        std::basic_string::size_type find(const _Elem *const _Ptr, const std::basic_string::size_type _Off, const std::basic_string::size_type _Count) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count)));
        }
        std::basic_string::size_type find(const _Elem *const _Ptr, const std::basic_string::size_type _Off = 0) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
        }
        std::basic_string::size_type find(const _Elem _Ch, const std::basic_string::size_type _Off = 0) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
        }
        std::basic_string::size_type rfind(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Off = npos) const noexcept         {
            auto &_My_data = this->_Get_data();
            auto &_Right_data = _Right._Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_rfind<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Right_data._Myptr(), _Right_data._Mysize)));
        }
        std::basic_string::size_type rfind(const _Elem *const _Ptr, const std::basic_string::size_type _Off, const std::basic_string::size_type _Count) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_rfind<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count)));
        }
        std::basic_string::size_type rfind(const _Elem *const _Ptr, const std::basic_string::size_type _Off = npos) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_rfind<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
        }
        std::basic_string::size_type rfind(const _Elem _Ch, const std::basic_string::size_type _Off = npos) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_rfind_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
        }
        std::basic_string::size_type find_first_of(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Off = 0) const noexcept         {
            auto &_My_data = this->_Get_data();
            auto &_Right_data = _Right._Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>({}))));
        }
        std::basic_string::size_type find_first_of(const _Elem *const _Ptr, const std::basic_string::size_type _Off, const std::basic_string::size_type _Count) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>({}))));
        }
        std::basic_string::size_type find_first_of(const _Elem *const _Ptr, const std::basic_string::size_type _Off = 0) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>({}))));
        }
        std::basic_string::size_type find_first_of(const _Elem _Ch, const std::basic_string::size_type _Off = 0) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
        }
        std::basic_string::size_type find_last_of(const basic_string<_Elem, _Traits, _Alloc> &_Right, std::basic_string::size_type _Off = npos) const noexcept         {
            auto &_My_data = this->_Get_data();
            auto &_Right_data = _Right._Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find_last_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>({}))));
        }
        std::basic_string::size_type find_last_of(const _Elem *const _Ptr, const std::basic_string::size_type _Off, const std::basic_string::size_type _Count) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find_last_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>({}))));
        }
        std::basic_string::size_type find_last_of(const _Elem *const _Ptr, const std::basic_string::size_type _Off = npos) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find_last_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>({}))));
        }
        std::basic_string::size_type find_last_of(const _Elem _Ch, const std::basic_string::size_type _Off = npos) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_rfind_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
        }
        std::basic_string::size_type find_first_not_of(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Off = 0) const noexcept         {
            auto &_My_data = this->_Get_data();
            auto &_Right_data = _Right._Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>({}))));
        }
        std::basic_string::size_type find_first_not_of(const _Elem *const _Ptr, const std::basic_string::size_type _Off, const std::basic_string::size_type _Count) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>({}))));
        }
        std::basic_string::size_type find_first_not_of(const _Elem *const _Ptr, std::basic_string::size_type _Off = 0) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>({}))));
        }
        std::basic_string::size_type find_first_not_of(const _Elem _Ch, const std::basic_string::size_type _Off = 0) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find_not_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
        }
        std::basic_string::size_type find_last_not_of(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Off = npos) const noexcept         {
            auto &_My_data = this->_Get_data();
            auto &_Right_data = _Right._Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find_last_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>({}))));
        }
        std::basic_string::size_type find_last_not_of(const _Elem *const _Ptr, const std::basic_string::size_type _Off, const std::basic_string::size_type _Count) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find_last_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>({}))));
        }
        std::basic_string::size_type find_last_not_of(const _Elem *const _Ptr, const std::basic_string::size_type _Off = npos) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_find_last_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>({}))));
        }
        std::basic_string::size_type find_last_not_of(const _Elem _Ch, const std::basic_string::size_type _Off = npos) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (static_cast<std::basic_string::size_type>(_Traits_rfind_not_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
        }
        basic_string<_Elem, _Traits, _Alloc> substr(const std::basic_string::size_type _Off = 0, const std::basic_string::size_type _Count = npos) const         {
            return (basic_string<_Elem, _Traits, _Alloc>(*this, _Off, _Count, this->get_allocator()));
        }
        bool _Equal(const basic_string<_Elem, _Traits, _Alloc> &_Right) const noexcept         {
            auto &_My_data = this->_Get_data();
            auto &_Right_data = _Right._Get_data();
            return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Right_data._Myptr(), _Right_data._Mysize));
        }
        bool _Equal(const _Elem *const _Ptr) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));
        }
        int compare(const basic_string<_Elem, _Traits, _Alloc> &_Right) const noexcept         {
            auto &_My_data = this->_Get_data();
            auto &_Right_data = _Right._Get_data();
            return (_Traits_compare<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Right_data._Myptr(), _Right_data._Mysize));
        }
        int compare(std::basic_string::size_type _Off, std::basic_string::size_type _N0, const basic_string<_Elem, _Traits, _Alloc> &_Right) const         {
            auto &_My_data = this->_Get_data();
            _My_data._Check_offset(_Off);
            auto &_Right_data = _Right._Get_data();
            return (_Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0), _Right_data._Myptr(), _Right_data._Mysize));
        }
        int compare(const std::basic_string::size_type _Off, const std::basic_string::size_type _N0, const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Roff, const std::basic_string::size_type _Count = npos) const         {
            auto &_My_data = this->_Get_data();
            auto &_Right_data = _Right._Get_data();
            _My_data._Check_offset(_Off);
            _Right_data._Check_offset(_Roff);
            return (_Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0), _Right_data._Myptr() + _Roff, _Right_data._Clamp_suffix_size(_Roff, _Count)));
        }
        int compare(const _Elem *const _Ptr) const noexcept         {
            auto &_My_data = this->_Get_data();
            return (_Traits_compare<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));
        }
        int compare(const std::basic_string::size_type _Off, const std::basic_string::size_type _N0, const _Elem *const _Ptr) const         {
            auto &_My_data = this->_Get_data();
            _My_data._Check_offset(_Off);
            return (_Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0), _Ptr, _Traits::length(_Ptr)));
        }
        int compare(const std::basic_string::size_type _Off, const std::basic_string::size_type _N0, const _Elem *const _Ptr, const std::basic_string::size_type _Count) const         {
            auto &_My_data = this->_Get_data();
            _My_data._Check_offset(_Off);
            return (_Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0), _Ptr, _Count));
        }
        std::basic_string::allocator_type get_allocator() const noexcept         {
            return (static_cast<std::basic_string::allocator_type>(this->_Getal()));
        }
        std::basic_string::size_type _Calculate_growth(const std::basic_string::size_type _Requested) const         {
            const std::basic_string::size_type _Max = this->max_size();
            auto &_My_data = this->_Get_data();
            const std::basic_string::size_type _Masked = _Requested | this->_ALLOC_MASK;
            if (_Masked > _Max) {
                return (_Max);
            }
            const std::basic_string::size_type _Old = _My_data._Myres;
            if (_Old > _Max - _Old / 2) {
                return (_Max);
            }
            return (_Max_value(_Masked, _Old + _Old / 2));
        }
        template <class _Fty, class ..._ArgTys> basic_string<_Elem, _Traits, _Alloc> &_Reallocate_for(const std::basic_string::size_type _New_size, _Fty _Fn, _ArgTys ..._Args)         {
            if (_New_size > this->max_size()) {
                _Xlen();
            }
            auto &_My_data = this->_Get_data();
            const std::basic_string::size_type _Old_capacity = _My_data._Myres;
            const std::basic_string::size_type _New_capacity = this->_Calculate_growth(_New_size);
            auto &_Al = this->_Getal();
            const std::basic_string::pointer _New_ptr = _Al.allocate(_New_capacity + 1);
            _My_data._Orphan_all();
            _My_data._Mysize = _New_size;
            _My_data._Myres = _New_capacity;
            _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
            if (this->_BUF_SIZE <= _Old_capacity) {
                _Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);
                _My_data._Bx._Ptr = _New_ptr;
            } else {
                _Alty_traits::construct(_Al, ::std::addressof(_My_data._Bx._Ptr), _New_ptr);
            }
            return (*this);
        }
        template <class _Fty, class ..._ArgTys> basic_string<_Elem, _Traits, _Alloc> &_Reallocate_grow_by(const std::basic_string::size_type _Size_increase, _Fty _Fn, _ArgTys ..._Args)         {
            auto &_My_data = this->_Get_data();
            const std::basic_string::size_type _Old_size = _My_data._Mysize;
            if (this->max_size() - _Old_size < _Size_increase) {
                _Xlen();
            }
            const std::basic_string::size_type _New_size = _Old_size + _Size_increase;
            const std::basic_string::size_type _Old_capacity = _My_data._Myres;
            const std::basic_string::size_type _New_capacity = this->_Calculate_growth(_New_size);
            auto &_Al = this->_Getal();
            const std::basic_string::pointer _New_ptr = _Al.allocate(_New_capacity + 1);
            _My_data._Orphan_all();
            _My_data._Mysize = _New_size;
            _My_data._Myres = _New_capacity;
            _Elem *const _Raw_new = _Unfancy(_New_ptr);
            if (this->_BUF_SIZE <= _Old_capacity) {
                const std::basic_string::pointer _Old_ptr = _My_data._Bx._Ptr;
                _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
                _Al.deallocate(_Old_ptr, _Old_capacity + 1);
                _My_data._Bx._Ptr = _New_ptr;
            } else {
                _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
                _Alty_traits::construct(_Al, ::std::addressof(_My_data._Bx._Ptr), _New_ptr);
            }
            return (*this);
        }
        void _Become_small()         {
            auto &_My_data = this->_Get_data();
            _My_data._Orphan_all();
            const std::basic_string::pointer _Ptr = _My_data._Bx._Ptr;
            auto &_Al = this->_Getal();
            _Alty_traits::destroy(_Al, ::std::addressof(_My_data._Bx._Ptr));
            _Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);
            _Al.deallocate(_Ptr, _My_data._Myres + 1);
            _My_data._Myres = this->_BUF_SIZE - 1;
        }
        void _Eos(const std::basic_string::size_type _Newsize)         {
            auto &_My_data = this->_Get_data();
            _Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());
        }
        void _Tidy_init()         {
            auto &_My_data = this->_Get_data();
            _My_data._Mysize = 0;
            _My_data._Myres = this->_BUF_SIZE - 1;
            _Traits::assign(_My_data._Bx._Buf[0], _Elem());
        }
        void _Tidy_deallocate()         {
            this->_Orphan_all();
            auto &_My_data = this->_Get_data();
            if (_My_data._Large_string_engaged()) {
                const std::basic_string::pointer _Ptr = _My_data._Bx._Ptr;
                auto &_Al = this->_Getal();
                _Alty_traits::destroy(_Al, ::std::addressof(_My_data._Bx._Ptr));
                _Al.deallocate(_Ptr, _My_data._Myres + 1);
            }
            _My_data._Mysize = 0;
            _My_data._Myres = this->_BUF_SIZE - 1;
            _Traits::assign(_My_data._Bx._Buf[0], _Elem());
        }
        static void _Xlen() [[noreturn]]         {
            _Xlength_error("string too long");
        }
    };
template<> class basic_string<char, std::char_traits<char>, std::allocator<char>> : public _String_alloc<_String_base_types<char, std::allocator<char> > > {
    public:
        static_assert(!0 || is_same_v<char, typename allocator<char>::value_type>, "basic_string<T, Traits, Allocator> requires that Allocator's value_type match T (See N4659 26.2.1 [container.requirements.general]/16 allocator_type) Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0 to suppress this diagnostic.");
        static_assert(is_same_v<char, typename char_traits<char>::char_type>, "N4659 24.3.2.1 [string.require]/3 requires that the supplied char_traits character type match the string's character type.");
        using _Mybase = _String_alloc<_String_base_types<char, std::allocator<char> > >;
        using traits_type = std::char_traits<char>;
        using allocator_type = std::allocator<char>;
        using _Alty = typename _Mybase::_Alty;
        using _Alty_traits = typename _Mybase::_Alty_traits;
        using _Mydata_t = typename _Mybase::_Mydata_t;
        using value_type = typename _Mybase::value_type;
        using size_type = typename _Mybase::size_type;
        using difference_type = typename _Mybase::difference_type;
        using pointer = typename _Mybase::pointer;
        using const_pointer = typename _Mybase::const_pointer;
        using reference = std::basic_string<char, std::char_traits<char>, std::allocator<char> >::value_type &;
        using const_reference = const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::value_type &;
        using iterator = typename _Mybase::iterator;
        using const_iterator = typename _Mybase::const_iterator;
        using reverse_iterator = ::std::reverse_iterator<iterator>;
        using const_reverse_iterator = ::std::reverse_iterator<const_iterator>;
        using _Use_memcpy_move = bool_constant<_Is_specialization_v<std::char_traits<char>, char_traits> && is_trivial_v<std::basic_string<char, std::char_traits<char>, std::allocator<char> >::pointer> >;
        static constexpr size_t _Memcpy_move_offset = _Size_after_ebco_v;
        static constexpr size_t _Memcpy_move_size = sizeof(std::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Mydata_t) - _Memcpy_move_offset;
        template <class _Iter> using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const char *const, char *const, const char *, char *> >;
        basic_string(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        basic_string(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::allocator<char> &_Al);
        basic_string();
        explicit basic_string(const std::allocator<char> &_Al) noexcept;
        basic_string(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Roff, const std::allocator<char> &_Al);
        basic_string(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Roff, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const std::allocator<char> &_Al);
        basic_string(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        basic_string(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const std::allocator<char> &_Al);
        basic_string(const char *const _Ptr);
        basic_string(const char *const _Ptr, const std::allocator<char> &_Al);
        basic_string(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const char _Ch);
        basic_string(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const char _Ch, const std::allocator<char> &_Al);
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> basic_string(_Iter _First, _Iter _Last, const std::allocator<char> &_Al);
        template <class _Iter> void _Construct(_Iter _First, const _Iter _Last, std::input_iterator_tag);
        template <class _Iter> void _Construct(const _Iter _First, const _Iter _Last, std::forward_iterator_tag);
        void _Construct(char *const _First, char *const _Last, std::random_access_iterator_tag);
        void _Construct(const char *const _First, const char *const _Last, std::random_access_iterator_tag);
        basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &&_Right) noexcept;
        basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &&_Right, const std::allocator<char> &_Al);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator=(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &&_Right);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &assign(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &&_Right);
        void _Assign_rv_contents(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &&_Right, std::true_type) noexcept;
        void _Assign_rv_contents(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &&_Right, std::false_type);
        void _Assign_rv_contents_with_alloc_always_equal(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &&_Right, std::true_type) noexcept;
        void _Assign_rv_contents_with_alloc_always_equal(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &&_Right, std::false_type) noexcept;
        void _Construct_lv_contents(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        basic_string(initializer_list<char> _Ilist, const std::allocator<char> &_Al);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator=(initializer_list<char> _Ilist);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator+=(initializer_list<char> _Ilist);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &assign(initializer_list<char> _Ilist);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &append(initializer_list<char> _Ilist);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Where, const initializer_list<char> _Ilist);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last, const initializer_list<char> _Ilist);
        ~basic_string<char, char_traits<char>, allocator<char> >() noexcept;
        static constexpr auto nposstatic_cast<std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type>(-1);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator=(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator=(const char *const _Ptr);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator=(const char _Ch);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator+=(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator+=(const char *const _Ptr);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator+=(char _Ch);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &append(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &append(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Roff, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &append(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &append(const char *const _Ptr);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &append(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const char _Ch);
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> std::basic_string<char, std::char_traits<char>, std::allocator<char> > &append(const _Iter _First, const _Iter _Last);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &assign(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &assign(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Roff, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &assign(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &assign(const char *const _Ptr);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &assign(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const char _Ch);
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> std::basic_string<char, std::char_traits<char>, std::allocator<char> > &assign(const _Iter _First, const _Iter _Last);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Roff, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const char *const _Ptr);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const char _Ch);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Where, const char _Ch);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Where, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const char _Ch);
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> std::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Where, const _Iter _First, const _Iter _Last);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &erase(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &erase(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator erase(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Where);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator erase(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last);
        void clear() noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Roff, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const char *const _Ptr);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const char _Ch);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last, const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last, const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last, const char *const _Ptr);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const char _Ch);
        template <class _Iter> std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Replace_range(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last, const _Iter _First2, const _Iter _Last2, std::false_type);
        template <class _Ptr> std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Replace_range(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last, const _Ptr _First2, const _Ptr _Last2, std::true_type);
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last, const _Iter _First2, const _Iter _Last2);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator begin() noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator begin() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator end() noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator end() const noexcept;
        char *_Unchecked_begin() noexcept;
        const char *_Unchecked_begin() const noexcept;
        char *_Unchecked_end() noexcept;
        const char *_Unchecked_end() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::reverse_iterator rbegin() noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reverse_iterator rbegin() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::reverse_iterator rend() noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reverse_iterator rend() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator cbegin() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator cend() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reverse_iterator crbegin() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reverse_iterator crend() const noexcept;
        void shrink_to_fit();
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::reference at(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reference at(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::reference operator[](const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reference operator[](const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const;
        void push_back(const char _Ch);
        void pop_back();
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::reference front();
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reference front() const;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::reference back();
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reference back() const;
        const char *c_str() const noexcept         {
            return (this->_Get_data()._Myptr());
        }
        const char *data() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type length() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type size() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type max_size() const noexcept;
        void resize(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Newsize, const char _Ch);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type capacity() const noexcept;
        void reserve(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Newcap);
        bool empty() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type copy(char *const _Ptr, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Copy_s(char *const _Dest, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Dest_size, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const;
        void _Swap_data(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, std::true_type);
        void _Swap_bx_large_with_small(std::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Mydata_t &_Starts_large, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Mydata_t &_Starts_small);
        void _Swap_data(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, std::false_type);
        void swap(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right) noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find(const char _Ch, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type rfind(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type rfind(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type rfind(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type rfind(const char _Ch, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_of(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_of(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_of(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_of(const char _Ch, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_of(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_of(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_of(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_of(const char _Ch, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_not_of(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_not_of(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_not_of(const char *const _Ptr, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_not_of(const char _Ch, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_not_of(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_not_of(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_not_of(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_not_of(const char _Ch, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > substr(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const;
        bool _Equal(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right) const noexcept;
        bool _Equal(const char *const _Ptr) const noexcept;
        int compare(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right) const noexcept;
        int compare(std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right) const;
        int compare(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Roff, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const;
        int compare(const char *const _Ptr) const noexcept;
        int compare(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const char *const _Ptr) const;
        int compare(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::allocator_type get_allocator() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Calculate_growth(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Requested) const;
        template <class _Fty, class ..._ArgTys> std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Reallocate_for(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _New_size, _Fty _Fn, _ArgTys ..._Args);
        template <class _Fty, class ..._ArgTys> std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Reallocate_grow_by(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Size_increase, _Fty _Fn, _ArgTys ..._Args);
        void _Become_small();
        void _Eos(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Newsize);
        void _Tidy_init();
        void _Tidy_deallocate();
        static void _Xlen() [[noreturn]];
    };
    constexpr size_t _Size_after_ebco_v = is_empty_v<std::_Container_base0> ? 0 : sizeof(std::_Container_base0);
    template <class _Elem, class _Traits, class _Alloc> inline void swap(basic_string<_Elem, _Traits, _Alloc> &_Left, basic_string<_Elem, _Traits, _Alloc> &_Right) noexcept     {
        _Left.swap(_Right);
    }
    template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(const basic_string<_Elem, _Traits, _Alloc> &_Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     {
        basic_string<_Elem, _Traits, _Alloc> _Ans;
        _Ans.reserve(_Left.size() + _Right.size());
        _Ans += _Left;
        _Ans += _Right;
        return (_Ans);
    }
    template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(const _Elem *const _Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     {
        using _String_type = basic_string<_Elem, _Traits, _Alloc>;
        using _Size_type = typename _String_type::size_type;
        _String_type _Ans;
        _Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));
        _Ans += _Left;
        _Ans += _Right;
        return (_Ans);
    }
    template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(const _Elem _Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     {
        basic_string<_Elem, _Traits, _Alloc> _Ans;
        _Ans.reserve(1 + _Right.size());
        _Ans += _Left;
        _Ans += _Right;
        return (_Ans);
    }
    template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(const basic_string<_Elem, _Traits, _Alloc> &_Left, const _Elem *const _Right)     {
        using _String_type = basic_string<_Elem, _Traits, _Alloc>;
        using _Size_type = typename _String_type::size_type;
        _String_type _Ans;
        _Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));
        _Ans += _Left;
        _Ans += _Right;
        return (_Ans);
    }
    template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(const basic_string<_Elem, _Traits, _Alloc> &_Left, const _Elem _Right)     {
        basic_string<_Elem, _Traits, _Alloc> _Ans;
        _Ans.reserve(_Left.size() + 1);
        _Ans += _Left;
        _Ans += _Right;
        return (_Ans);
    }
    template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(const basic_string<_Elem, _Traits, _Alloc> &_Left, basic_string<_Elem, _Traits, _Alloc> &&_Right)     {
        return (::std::move(_Right.insert(0, _Left)));
    }
    template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc> &&_Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     {
        return (::std::move(_Left.append(_Right)));
    }
    template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc> &&_Left, basic_string<_Elem, _Traits, _Alloc> &&_Right)     {
        if (_Right.size() <= _Left.capacity() - _Left.size() || _Right.capacity() - _Right.size() < _Left.size())
            return (::std::move(_Left.append(_Right)));
        else
            return (::std::move(_Right.insert(0, _Left)));
    }
    template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(const _Elem *const _Left, basic_string<_Elem, _Traits, _Alloc> &&_Right)     {
        return (::std::move(_Right.insert(0, _Left)));
    }
    template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(const _Elem _Left, basic_string<_Elem, _Traits, _Alloc> &&_Right)     {
        using size_type = typename allocator_traits<_Alloc>::size_type;
        return (::std::move(_Right.insert(static_cast<size_type>(0), static_cast<size_type>(1), _Left)));
    }
    template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc> &&_Left, const _Elem *const _Right)     {
        return (::std::move(_Left.append(_Right)));
    }
    template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc> &&_Left, const _Elem _Right)     {
        _Left.push_back(_Right);
        return (::std::move(_Left));
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator==(const basic_string<_Elem, _Traits, _Alloc> &_Left, const basic_string<_Elem, _Traits, _Alloc> &_Right) noexcept     {
        return (_Left._Equal(_Right));
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator==(const _Elem *const _Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     {
        return (_Right._Equal(_Left));
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator==(const basic_string<_Elem, _Traits, _Alloc> &_Left, const _Elem *const _Right)     {
        return (_Left._Equal(_Right));
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator!=(const basic_string<_Elem, _Traits, _Alloc> &_Left, const basic_string<_Elem, _Traits, _Alloc> &_Right) noexcept     {
        return (!(_Left == _Right));
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator!=(const _Elem *const _Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     {
        return (!(_Left == _Right));
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator!=(const basic_string<_Elem, _Traits, _Alloc> &_Left, const _Elem *const _Right)     {
        return (!(_Left == _Right));
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator<(const basic_string<_Elem, _Traits, _Alloc> &_Left, const basic_string<_Elem, _Traits, _Alloc> &_Right) noexcept     {
        return (_Left.compare(_Right) < 0);
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator<(const _Elem *const _Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     {
        return (_Right.compare(_Left) > 0);
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator<(const basic_string<_Elem, _Traits, _Alloc> &_Left, const _Elem *const _Right)     {
        return (_Left.compare(_Right) < 0);
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator>(const basic_string<_Elem, _Traits, _Alloc> &_Left, const basic_string<_Elem, _Traits, _Alloc> &_Right) noexcept     {
        return (_Right < _Left);
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator>(const _Elem *const _Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     {
        return (_Right < _Left);
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator>(const basic_string<_Elem, _Traits, _Alloc> &_Left, const _Elem *const _Right)     {
        return (_Right < _Left);
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator<=(const basic_string<_Elem, _Traits, _Alloc> &_Left, const basic_string<_Elem, _Traits, _Alloc> &_Right) noexcept     {
        return (!(_Right < _Left));
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator<=(const _Elem *const _Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     {
        return (!(_Right < _Left));
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator<=(const basic_string<_Elem, _Traits, _Alloc> &_Left, const _Elem *const _Right)     {
        return (!(_Right < _Left));
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator>=(const basic_string<_Elem, _Traits, _Alloc> &_Left, const basic_string<_Elem, _Traits, _Alloc> &_Right) noexcept     {
        return (!(_Left < _Right));
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator>=(const _Elem *const _Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     {
        return (!(_Left < _Right));
    }
    template <class _Elem, class _Traits, class _Alloc> inline bool operator>=(const basic_string<_Elem, _Traits, _Alloc> &_Left, const _Elem *const _Right)     {
        return (!(_Left < _Right));
    }
    using string = basic_string<char, char_traits<char>, allocator<char> >;
    using wstring = basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >;
    using u16string = basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >;
    using u32string = basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >;
    template <class _Elem, class _Traits, class _Alloc> struct hash<basic_string<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2>> {
        typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
        typedef size_t result_type;
        size_t operator()(const basic_string<_Elem, _Traits, _Alloc> &_Keyval) const noexcept         {
            return (_Hash_array_representation(_Keyval.c_str(), _Keyval.size()));
        }
    };
}
namespace std {
    class logic_error : public std::exception {
    public:
        typedef std::exception _Mybase;
        explicit logic_error(const std::string &_Message) : std::logic_error::_Mybase(_Message.c_str())         {
        }
        explicit logic_error(const char *_Message) : std::logic_error::_Mybase(_Message)         {
        }
    };
    class domain_error : public std::logic_error {
    public:
        typedef std::logic_error _Mybase;
        explicit domain_error(const std::string &_Message) : std::domain_error::_Mybase(_Message.c_str())         {
        }
        explicit domain_error(const char *_Message) : std::domain_error::_Mybase(_Message)         {
        }
    };
    class invalid_argument : public std::logic_error {
    public:
        typedef std::logic_error _Mybase;
        explicit invalid_argument(const std::string &_Message) : std::invalid_argument::_Mybase(_Message.c_str())         {
        }
        explicit invalid_argument(const char *_Message) : std::invalid_argument::_Mybase(_Message)         {
        }
    };
    class length_error : public std::logic_error {
    public:
        typedef std::logic_error _Mybase;
        explicit length_error(const std::string &_Message) : std::length_error::_Mybase(_Message.c_str())         {
        }
        explicit length_error(const char *_Message) : std::length_error::_Mybase(_Message)         {
        }
    };
    class out_of_range : public std::logic_error {
    public:
        typedef std::logic_error _Mybase;
        explicit out_of_range(const std::string &_Message) : std::out_of_range::_Mybase(_Message.c_str())         {
        }
        explicit out_of_range(const char *_Message) : std::out_of_range::_Mybase(_Message)         {
        }
    };
    class runtime_error : public std::exception {
    public:
        typedef std::exception _Mybase;
        explicit runtime_error(const std::string &_Message) : std::runtime_error::_Mybase(_Message.c_str())         {
        }
        explicit runtime_error(const char *_Message) : std::runtime_error::_Mybase(_Message)         {
        }
    };
    class overflow_error : public std::runtime_error {
    public:
        typedef std::runtime_error _Mybase;
        explicit overflow_error(const std::string &_Message) : std::overflow_error::_Mybase(_Message.c_str())         {
        }
        explicit overflow_error(const char *_Message) : std::overflow_error::_Mybase(_Message)         {
        }
    };
    class underflow_error : public std::runtime_error {
    public:
        typedef std::runtime_error _Mybase;
        explicit underflow_error(const std::string &_Message) : std::underflow_error::_Mybase(_Message.c_str())         {
        }
        explicit underflow_error(const char *_Message) : std::underflow_error::_Mybase(_Message)         {
        }
    };
    class range_error : public std::runtime_error {
    public:
        typedef std::runtime_error _Mybase;
        explicit range_error(const std::string &_Message) : std::range_error::_Mybase(_Message.c_str())         {
        }
        explicit range_error(const char *_Message) : std::range_error::_Mybase(_Message)         {
        }
    };
}
namespace std {
    template <class _Myvec> class _Vector_const_iterator : public std::_Iterator_base {
    public:
        using iterator_category = std::random_access_iterator_tag;
        using value_type = typename _Myvec::value_type;
        using difference_type = typename _Myvec::difference_type;
        using pointer = typename _Myvec::const_pointer;
        using reference = const std::_Vector_const_iterator::value_type &;
        using _Tptr = typename _Myvec::pointer;
        _Vector_const_iterator<_Myvec>() : _Ptr()         {
        }
        _Vector_const_iterator<_Myvec>(std::_Vector_const_iterator::_Tptr _Parg, const std::_Container_base *_Pvector) : _Ptr(_Parg)         {
            this->_Adopt(_Pvector);
        }
        std::_Vector_const_iterator::reference operator*() const         {
            return (*this->_Ptr);
        }
        std::_Vector_const_iterator::pointer operator->() const         {
            return (this->_Ptr);
        }
        _Vector_const_iterator<_Myvec> &operator++()         {
            ++this->_Ptr;
            return (*this);
        }
        _Vector_const_iterator<_Myvec> operator++(int)         {
            _Vector_const_iterator<_Myvec> _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        _Vector_const_iterator<_Myvec> &operator--()         {
            --this->_Ptr;
            return (*this);
        }
        _Vector_const_iterator<_Myvec> operator--(int)         {
            _Vector_const_iterator<_Myvec> _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        void _Verify_offset(const std::_Vector_const_iterator::difference_type _Off) const         {
            (void)_Off;
        }
        _Vector_const_iterator<_Myvec> &operator+=(const std::_Vector_const_iterator::difference_type _Off)         {
            this->_Verify_offset(_Off);
            this->_Ptr += _Off;
            return (*this);
        }
        _Vector_const_iterator<_Myvec> operator+(const std::_Vector_const_iterator::difference_type _Off) const         {
            _Vector_const_iterator<_Myvec> _Tmp = *this;
            return (_Tmp += _Off);
        }
        _Vector_const_iterator<_Myvec> &operator-=(const std::_Vector_const_iterator::difference_type _Off)         {
            return (*this += - _Off);
        }
        _Vector_const_iterator<_Myvec> operator-(const std::_Vector_const_iterator::difference_type _Off) const         {
            _Vector_const_iterator<_Myvec> _Tmp = *this;
            return (_Tmp -= _Off);
        }
        std::_Vector_const_iterator::difference_type operator-(const _Vector_const_iterator<_Myvec> &_Right) const         {
            this->_Compat(_Right);
            return (this->_Ptr - _Right._Ptr);
        }
        std::_Vector_const_iterator::reference operator[](const std::_Vector_const_iterator::difference_type _Off) const         {
            return (*(*this + _Off));
        }
        bool operator==(const _Vector_const_iterator<_Myvec> &_Right) const         {
            this->_Compat(_Right);
            return (this->_Ptr == _Right._Ptr);
        }
        bool operator!=(const _Vector_const_iterator<_Myvec> &_Right) const         {
            return (!(*this == _Right));
        }
        bool operator<(const _Vector_const_iterator<_Myvec> &_Right) const         {
            this->_Compat(_Right);
            return (this->_Ptr < _Right._Ptr);
        }
        bool operator>(const _Vector_const_iterator<_Myvec> &_Right) const         {
            return (_Right < *this);
        }
        bool operator<=(const _Vector_const_iterator<_Myvec> &_Right) const         {
            return (!(_Right < *this));
        }
        bool operator>=(const _Vector_const_iterator<_Myvec> &_Right) const         {
            return (!(*this < _Right));
        }
        void _Compat(const _Vector_const_iterator<_Myvec> &_Right) const         {
            (void)_Right;
        }
        std::_Vector_const_iterator::pointer _Unwrapped() const         {
            return (this->_Ptr);
        }
        void _Seek_to(std::_Vector_const_iterator::pointer _It)         {
            this->_Ptr = _Const_cast(_It);
        }
        std::_Vector_const_iterator::_Tptr _Ptr;
    };
    template <class _Myvec> inline _Vector_const_iterator<_Myvec> operator+(typename _Vector_const_iterator<_Myvec>::difference_type _Off, _Vector_const_iterator<_Myvec> _Next)     {
        return (_Next += _Off);
    }
    template <class _Myvec> class _Vector_iterator : public _Vector_const_iterator<_Myvec> {
    public:
        using _Mybase = _Vector_const_iterator<_Myvec>;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = typename _Myvec::value_type;
        using difference_type = typename _Myvec::difference_type;
        using pointer = typename _Myvec::pointer;
        using reference = std::_Vector_iterator::value_type &;
        _Vector_iterator<_Myvec>()         {
        }
        _Vector_iterator<_Myvec>(std::_Vector_iterator::pointer _Parg, const std::_Container_base *_Pvector) : std::_Vector_iterator::_Mybase(_Parg, _Pvector)         {
        }
        std::_Vector_iterator::reference operator*() const         {
            return (const_cast<std::_Vector_iterator::reference>(_Mybase::operator*()));
        }
        std::_Vector_iterator::pointer operator->() const         {
            return (_Const_cast(_Mybase::operator->()));
        }
        _Vector_iterator<_Myvec> &operator++()         {
            ++*(std::_Vector_iterator::_Mybase *)this;
            return (*this);
        }
        _Vector_iterator<_Myvec> operator++(int)         {
            _Vector_iterator<_Myvec> _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        _Vector_iterator<_Myvec> &operator--()         {
            --*(std::_Vector_iterator::_Mybase *)this;
            return (*this);
        }
        _Vector_iterator<_Myvec> operator--(int)         {
            _Vector_iterator<_Myvec> _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        _Vector_iterator<_Myvec> &operator+=(const std::_Vector_iterator::difference_type _Off)         {
            *(std::_Vector_iterator::_Mybase *)this += _Off;
            return (*this);
        }
        _Vector_iterator<_Myvec> operator+(const std::_Vector_iterator::difference_type _Off) const         {
            _Vector_iterator<_Myvec> _Tmp = *this;
            return (_Tmp += _Off);
        }
        _Vector_iterator<_Myvec> &operator-=(const std::_Vector_iterator::difference_type _Off)         {
            return (*this += - _Off);
        }
        _Vector_iterator<_Myvec> operator-(const std::_Vector_iterator::difference_type _Off) const         {
            _Vector_iterator<_Myvec> _Tmp = *this;
            return (_Tmp -= _Off);
        }
        std::_Vector_iterator::difference_type operator-(const std::_Vector_iterator::_Mybase &_Right) const         {
            return (*(std::_Vector_iterator::_Mybase *)this - _Right);
        }
        std::_Vector_iterator::reference operator[](const std::_Vector_iterator::difference_type _Off) const         {
            return (*(*this + _Off));
        }
        std::_Vector_iterator::pointer _Unwrapped() const         {
            return (this->_Ptr);
        }
    };
    template <class _Myvec> inline _Vector_iterator<_Myvec> operator+(typename _Vector_iterator<_Myvec>::difference_type _Off, _Vector_iterator<_Myvec> _Next)     {
        return (_Next += _Off);
    }
    template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer, class _Reference, class _Const_reference> struct _Vec_iter_types {
        using value_type = _Value_type;
        using size_type = _Size_type;
        using difference_type = _Difference_type;
        using pointer = _Pointer;
        using const_pointer = _Const_pointer;
    };
    template <class _Ty, class _Alloc> struct _Vec_base_types {
        using _Alty = _Rebind_alloc_t<_Alloc, _Ty>;
        using _Alty_traits = allocator_traits<std::_Vec_base_types::_Alty>;
        using _Val_types = conditional_t<_Is_simple_alloc_v<std::_Vec_base_types::_Alty>, _Simple_types<_Ty>, _Vec_iter_types<_Ty, typename _Alty_traits::size_type, typename _Alty_traits::difference_type, typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Ty &, const _Ty &> >;
    };
    template <class _Val_types> class _Vector_val : public std::_Container_base {
    public:
        using value_type = typename _Val_types::value_type;
        using size_type = typename _Val_types::size_type;
        using difference_type = typename _Val_types::difference_type;
        using pointer = typename _Val_types::pointer;
        using const_pointer = typename _Val_types::const_pointer;
        using reference = std::_Vector_val::value_type &;
        using const_reference = const std::_Vector_val::value_type &;
        _Vector_val<_Val_types>() : _Myfirst(), _Mylast(), _Myend()         {
        }
        std::_Vector_val::pointer _Myfirst;
        std::_Vector_val::pointer _Mylast;
        std::_Vector_val::pointer _Myend;
    };
    template <class _Alloc_types> class _Vector_alloc {
    public:
        using _Alty = typename _Alloc_types::_Alty;
        using _Alty_traits = typename _Alloc_types::_Alty_traits;
        using _Alproxy = _Rebind_alloc_t<std::_Vector_alloc::_Alty, std::_Container_proxy>;
        using _Alproxy_traits = allocator_traits<std::_Vector_alloc::_Alproxy>;
        using _Val_types = typename _Alloc_types::_Val_types;
        using size_type = typename _Val_types::size_type;
        using difference_type = typename _Val_types::difference_type;
        using pointer = typename _Val_types::pointer;
        using const_pointer = typename _Val_types::const_pointer;
        using iterator = _Vector_iterator<_Vector_val<std::_Vector_alloc::_Val_types> >;
        using const_iterator = _Vector_const_iterator<_Vector_val<std::_Vector_alloc::_Val_types> >;
        _Vector_alloc<_Alloc_types>() : _Mypair(std::_Zero_then_variadic_args_t())         {
        }
        template <class _Any_alloc, class  = enable_if_t<!is_same_v<remove_cv_t<remove_reference_t<_Any_alloc> >, _Vector_alloc<_Alloc_types> > >> _Vector_alloc<_Alloc_types>(_Any_alloc &&_Al) : _Mypair(std::_One_then_variadic_args_t(), ::std::forward<_Any_alloc>(_Al))         {
        }
        void _Copy_alloc(const std::_Vector_alloc::_Alty &_Al)         {
            _Pocca(_Getal(), _Al);
        }
        void _Move_alloc(std::_Vector_alloc::_Alty &_Al)         {
            _Pocma(_Getal(), _Al);
        }
        void _Orphan_all()         {
            _Get_data()._Orphan_all();
        }
        void _Swap_all(_Vector_alloc<_Alloc_types> &_Right)         {
            _Get_data()._Swap_all(_Right._Get_data());
        }
        std::_Vector_alloc::_Alty &_Getal() noexcept         {
            return (this->_Mypair._Get_first());
        }
        const std::_Vector_alloc::_Alty &_Getal() const noexcept         {
            return (this->_Mypair._Get_first());
        }
        _Vector_val<std::_Vector_alloc::_Val_types> &_Get_data() noexcept         {
            return (this->_Mypair._Get_second());
        }
        const _Vector_val<std::_Vector_alloc::_Val_types> &_Get_data() const noexcept         {
            return (this->_Mypair._Get_second());
        }
        std::_Vector_alloc::iterator _Make_iterator(const std::_Vector_alloc::pointer _Ptr) noexcept         {
            return (std::_Vector_alloc::iterator(_Ptr, ::std::addressof(this->_Mypair._Get_second())));
        }
        std::_Vector_alloc::iterator _Make_iterator_offset(const std::_Vector_alloc::size_type _Offset) noexcept         {
            auto &_My_data = this->_Mypair._Get_second();
            return (std::_Vector_alloc::iterator(_My_data._Myfirst + _Offset, ::std::addressof(_My_data)));
        }
        std::_Vector_alloc::pointer &_Myfirst() noexcept         {
            return (_Get_data()._Myfirst);
        }
        const std::_Vector_alloc::pointer &_Myfirst() const noexcept         {
            return (_Get_data()._Myfirst);
        }
        std::_Vector_alloc::pointer &_Mylast() noexcept         {
            return (_Get_data()._Mylast);
        }
        const std::_Vector_alloc::pointer &_Mylast() const noexcept         {
            return (_Get_data()._Mylast);
        }
        std::_Vector_alloc::pointer &_Myend() noexcept         {
            return (_Get_data()._Myend);
        }
        const std::_Vector_alloc::pointer &_Myend() const noexcept         {
            return (_Get_data()._Myend);
        }
    private:
        _Compressed_pair<std::_Vector_alloc::_Alty, _Vector_val<std::_Vector_alloc::_Val_types> > _Mypair;
    };
    template <class _Ptrty> inline auto _Unfancy_maybe_null(_Ptrty _Ptr)     {
        return (_Ptr ? ::std::addressof(*_Ptr) : nullptr);
    }
    template <class _Ty> inline _Ty *_Unfancy_maybe_null(_Ty *_Ptr)     {
        return (_Ptr);
    }
    template <class _Ty, class _Alloc = allocator<_Ty>> class vector : public _Vector_alloc<_Vec_base_types<_Ty, _Alloc> > {
    private:
        using _Mybase = _Vector_alloc<_Vec_base_types<_Ty, _Alloc> >;
        using _Alty = typename _Mybase::_Alty;
        using _Alty_traits = typename _Mybase::_Alty_traits;
    public:
        static_assert(!0 || is_same_v<_Ty, typename _Alloc::value_type>, "vector<T, Allocator> requires that Allocator's value_type match T (See N4659 26.2.1 [container.requirements.general]/16 allocator_type) Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0 to suppress this diagnostic.");
        using value_type = _Ty;
        using allocator_type = _Alloc;
        using pointer = typename _Mybase::pointer;
        using const_pointer = typename _Mybase::const_pointer;
        using reference = _Ty &;
        using const_reference = const _Ty &;
        using size_type = typename _Mybase::size_type;
        using difference_type = typename _Mybase::difference_type;
        using iterator = typename _Mybase::iterator;
        using const_iterator = typename _Mybase::const_iterator;
        using reverse_iterator = ::std::reverse_iterator<iterator>;
        using const_reverse_iterator = ::std::reverse_iterator<const_iterator>;
        vector<_Ty, _Alloc>() noexcept(is_nothrow_default_constructible_v<std::vector::_Alty>vector<_Ty, _Alloc>() noexcept(is_nothrow_default_constructible_v<std::vector::_Alty>) : std::vector::_Mybase()         {
        }
        explicit vector<_Ty, _Alloc>(const _Alloc &_Al) noexcept : std::vector::_Mybase(_Al)         {
        }
        explicit vector<_Ty, _Alloc>(const std::vector::size_type _Count, const _Alloc &_Al = _Alloc()) : std::vector::_Mybase(_Al)         {
            if (this->_Buy(_Count)) {
                try {
                    this->_Mylast() = this->_Udefault(this->_Myfirst(), _Count);
                } catch (...) {
                    this->_Tidy();
                    throw;
                }
            }
        }
        vector<_Ty, _Alloc>(const std::vector::size_type _Count, const _Ty &_Val, const _Alloc &_Al = _Alloc()) : std::vector::_Mybase(_Al)         {
            if (this->_Buy(_Count)) {
                try {
                    this->_Mylast() = this->_Ufill(this->_Myfirst(), _Count, _Val);
                } catch (...) {
                    this->_Tidy();
                    throw;
                }
            }
        }
    private:
        template <class _Iter> void _Range_construct_or_tidy(_Iter _First, _Iter _Last, std::input_iterator_tag)         {
            try {
                for (; _First != _Last; ++_First) {
                    emplace_back(*_First);
                }
            } catch (...) {
                this->_Tidy();
                throw;
            }
        }
        template <class _Iter> void _Range_construct_or_tidy(_Iter _First, _Iter _Last, std::forward_iterator_tag)         {
            if (this->_Buy(_Convert_size<std::vector::size_type>(static_cast<size_t>(::std::distance(_First, _Last))))) {
                try {
                    this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
                } catch (...) {
                    this->_Tidy();
                    throw;
                }
            }
        }
    public:
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> vector<_Ty, _Alloc>(_Iter _First, _Iter _Last, const _Alloc &_Al = _Alloc()) : std::vector::_Mybase(_Al)         {
            _Adl_verify_range(_First, _Last);
            _Range_construct_or_tidy(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>({}));
        }
        vector<_Ty, _Alloc>(initializer_list<_Ty> _Ilist, const _Alloc &_Al = _Alloc()) : std::vector::_Mybase(_Al)         {
            _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), std::random_access_iterator_tag{});
        }
        vector<_Ty, _Alloc>(const vector<_Ty, _Alloc> &_Right) : std::vector::_Mybase(_Alty_traits::select_on_container_copy_construction(_Right._Getal()))         {
            if (this->_Buy(_Right.size())) {
                try {
                    this->_Mylast() = _Ucopy(_Right._Myfirst(), _Right._Mylast(), this->_Myfirst());
                } catch (...) {
                    this->_Tidy();
                    throw;
                }
            }
        }
        vector<_Ty, _Alloc>(const vector<_Ty, _Alloc> &_Right, const _Alloc &_Al) : std::vector::_Mybase(_Al)         {
            if (this->_Buy(_Right.size())) {
                try {
                    this->_Mylast() = _Ucopy(_Right._Myfirst(), _Right._Mylast(), this->_Myfirst());
                } catch (...) {
                    this->_Tidy();
                    throw;
                }
            }
        }
    private:
        void _Move_from(vector<_Ty, _Alloc> &&_Right, std::true_type) noexcept         {
            this->_Swap_all(_Right);
            this->_Myfirst() = _Right._Myfirst();
            this->_Mylast() = _Right._Mylast();
            this->_Myend() = _Right._Myend();
            _Right._Myfirst() = std::vector::pointer();
            _Right._Mylast() = std::vector::pointer();
            _Right._Myend() = std::vector::pointer();
        }
        void _Move_from(vector<_Ty, _Alloc> &&_Right, std::false_type)         {
            if (this->_Getal() == _Right._Getal()) {
                _Move_from(::std::move(_Right), std::true_type{});
            } else if (this->_Buy(_Right.size())) {
                this->_Mylast() = this->_Umove(_Right._Myfirst(), _Right._Mylast(), this->_Myfirst());
            }
        }
    public:
        vector<_Ty, _Alloc>(vector<_Ty, _Alloc> &&_Right) noexcept : std::vector::_Mybase(::std::move(_Right._Getal()))         {
            _Move_from(::std::move(_Right), std::true_type{});
        }
        vector<_Ty, _Alloc>(vector<_Ty, _Alloc> &&_Right, const _Alloc &_Al) noexcept(_Alty_traits::is_always_equal::valuevector<_Ty, _Alloc>(vector<_Ty, _Alloc> &&_Right, const _Alloc &_Al) noexcept(_Alty_traits::is_always_equal::value) : std::vector::_Mybase(_Al)         {
            if (_Alty_traits::is_always_equal::value) {
                _Move_from(::std::move(_Right), std::true_type{});
            } else {
                try {
                    _Move_from(::std::move(_Right), std::false_type{});
                } catch (...) {
                    this->_Tidy();
                    throw;
                }
            }
        }
    private:
        void _Move_assign_from(vector<_Ty, _Alloc> &&_Right, std::true_type) noexcept         {
            _Move_from(::std::move(_Right), std::true_type{});
        }
        void _Move_assign_from(vector<_Ty, _Alloc> &&_Right, std::false_type)         {
            if (this->_Getal() == _Right._Getal()) {
                _Move_from(::std::move(_Right), std::true_type{});
                return;
            }
            const std::vector::pointer _First = _Right._Myfirst();
            const std::vector::pointer _Last = _Right._Mylast();
            const std::vector::size_type _Newsize = _Right.size();
            this->_Orphan_all();
            const std::vector::size_type _Oldsize = this->size();
            const std::vector::size_type _Oldcapacity = this->capacity();
            if (_Newsize > _Oldcapacity) {
                if (_Newsize > this->max_size()) {
                    _Xlength();
                }
                const std::vector::size_type _Newcapacity = this->_Calculate_growth(_Newsize);
                if (this->_Myfirst() != std::vector::pointer()) {
                    this->_Destroy(this->_Myfirst(), this->_Mylast());
                    this->_Getal().deallocate(this->_Myfirst(), _Oldcapacity);
                }
                this->_Buy(_Newcapacity);
                this->_Mylast() = this->_Umove(_First, _Last, this->_Myfirst());
            } else if (_Newsize > _Oldsize) {
                const std::vector::pointer _Mid = _First + _Oldsize;
                _Move_unchecked(_First, _Mid, this->_Myfirst());
                this->_Mylast() = this->_Umove(_Mid, _Last, this->_Mylast());
            } else {
                const std::vector::pointer _Newlast = this->_Myfirst() + _Newsize;
                _Move_unchecked(_First, _Last, this->_Myfirst());
                this->_Destroy(_Newlast, this->_Mylast());
                this->_Mylast() = _Newlast;
            }
        }
    public:
        vector<_Ty, _Alloc> &operator=(vector<_Ty, _Alloc> &&_Right) noexcept(_Always_equal_after_move<std::vector::_Alty>operator=(vector<_Ty, _Alloc> &&_Right) noexcept(_Always_equal_after_move<std::vector::_Alty>)         {
            if (this != ::std::addressof(_Right)) {
                if (_Always_equal_after_move<std::vector::_Alty> || this->_Getal() == _Right._Getal()) {
                    this->_Tidy();
                }
                this->_Move_alloc(_Right._Getal());
                _Move_assign_from(::std::move(_Right), bool_constant<_Always_equal_after_move<std::vector::_Alty> >({}));
            }
            return (*this);
        }
        ~vector<_Ty, _Alloc>() noexcept         {
            this->_Tidy();
        }
    private:
        template <class ..._Valty> decltype(auto) _Emplace_back_with_unused_capacity(_Valty &&..._Val)         {
            _Alty_traits::construct(this->_Getal(), _Unfancy(this->_Mylast()), ::std::forward<_Valty>(_Val)...);
            this->_Orphan_range(this->_Mylast(), this->_Mylast());
            _Ty &_Result = *this->_Mylast();
            ++this->_Mylast();
            (void)_Result;
        }
    public:
        template <class ..._Valty> decltype(auto) emplace_back(_Valty &&..._Val)         {
            if (this->_Has_unused_capacity()) {
                return (_Emplace_back_with_unused_capacity(::std::forward<_Valty>(_Val)...));
            }
            _Ty &_Result = *_Emplace_reallocate(this->_Mylast(), ::std::forward<_Valty>(_Val)...);
            (void)_Result;
        }
        void push_back(const _Ty &_Val)         {
            emplace_back(_Val);
        }
        void push_back(_Ty &&_Val)         {
            emplace_back(::std::move(_Val));
        }
        template <class ..._Valty> std::vector::pointer _Emplace_reallocate(const std::vector::pointer _Whereptr, _Valty &&..._Val)         {
            const std::vector::size_type _Whereoff = static_cast<std::vector::size_type>(_Whereptr - this->_Myfirst());
            std::vector::_Alty &_Al = this->_Getal();
            const std::vector::size_type _Oldsize = this->size();
            if (_Oldsize == this->max_size()) {
                _Xlength();
            }
            const std::vector::size_type _Newsize = _Oldsize + 1;
            const std::vector::size_type _Newcapacity = this->_Calculate_growth(_Newsize);
            const std::vector::pointer _Newvec = _Al.allocate(_Newcapacity);
            const std::vector::pointer _Constructed_last = _Newvec + _Whereoff + 1;
            std::vector::pointer _Constructed_first = _Constructed_last;
            try {
                _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), ::std::forward<_Valty>(_Val)...);
                _Constructed_first = _Newvec + _Whereoff;
                if (_Whereptr == this->_Mylast()) {
                    this->_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
                } else {
                    this->_Umove(this->_Myfirst(), _Whereptr, _Newvec);
                    _Constructed_first = _Newvec;
                    this->_Umove(_Whereptr, this->_Mylast(), _Newvec + _Whereoff + 1);
                }
            } catch (...) {
                this->_Destroy(_Constructed_first, _Constructed_last);
                _Al.deallocate(_Newvec, _Newcapacity);
                throw;
            }
            this->_Change_array(_Newvec, _Newsize, _Newcapacity);
            return (this->_Myfirst() + _Whereoff);
        }
        template <class ..._Valty> std::vector::iterator emplace(std::vector::const_iterator _Where, _Valty &&..._Val)         {
            const std::vector::pointer _Whereptr = _Where._Ptr;
            const std::vector::pointer _Oldlast = this->_Mylast();
            if (this->_Has_unused_capacity()) {
                if (_Whereptr == _Oldlast) {
                    _Emplace_back_with_unused_capacity(::std::forward<_Valty>(_Val)...);
                } else {
                    _Ty _Obj(::std::forward<_Valty>(_Val)...);
                    this->_Orphan_range(_Whereptr, _Oldlast);
                    _Alty_traits::construct(this->_Getal(), _Unfancy(_Oldlast), ::std::move(_Oldlast[-1]));
                    ++this->_Mylast();
                    _Move_backward_unchecked(_Whereptr, _Oldlast - 1, _Oldlast);
                    *_Whereptr = ::std::move(_Obj);
                }
                return (this->_Make_iterator(_Whereptr));
            }
            return (this->_Make_iterator(_Emplace_reallocate(_Whereptr, ::std::forward<_Valty>(_Val)...)));
        }
        std::vector::iterator insert(std::vector::const_iterator _Where, const _Ty &_Val)         {
            return (emplace(_Where, _Val));
        }
        std::vector::iterator insert(std::vector::const_iterator _Where, _Ty &&_Val)         {
            return (emplace(_Where, ::std::move(_Val)));
        }
        std::vector::iterator insert(std::vector::const_iterator _Where, const std::vector::size_type _Count, const _Ty &_Val)         {
            const std::vector::size_type _Whereoff = static_cast<std::vector::size_type>(_Where._Ptr - this->_Myfirst());
            const bool _One_at_back = _Count == 1 && _Where._Ptr == this->_Mylast();
            if (_Count == 0) {
            } else if (_Count > this->_Unused_capacity()) {
                const std::vector::size_type _Oldsize = this->size();
                if (_Count > this->max_size() - _Oldsize) {
                    _Xlength();
                }
                const std::vector::size_type _Newsize = _Oldsize + _Count;
                const std::vector::size_type _Newcapacity = this->_Calculate_growth(_Newsize);
                const std::vector::pointer _Newvec = this->_Getal().allocate(_Newcapacity);
                const std::vector::pointer _Constructed_last = _Newvec + _Whereoff + _Count;
                std::vector::pointer _Constructed_first = _Constructed_last;
                try {
                    this->_Ufill(_Newvec + _Whereoff, _Count, _Val);
                    _Constructed_first = _Newvec + _Whereoff;
                    if (_One_at_back) {
                        this->_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
                    } else {
                        this->_Umove(this->_Myfirst(), _Where._Ptr, _Newvec);
                        _Constructed_first = _Newvec;
                        this->_Umove(_Where._Ptr, this->_Mylast(), _Newvec + _Whereoff + _Count);
                    }
                } catch (...) {
                    this->_Destroy(_Constructed_first, _Constructed_last);
                    this->_Getal().deallocate(_Newvec, _Newcapacity);
                    throw;
                }
                this->_Change_array(_Newvec, _Newsize, _Newcapacity);
            } else if (_One_at_back) {
                _Emplace_back_with_unused_capacity(_Val);
            } else {
                const _Ty _Tmp = _Val;
                const std::vector::pointer _Oldlast = this->_Mylast();
                const std::vector::size_type _Affected_elements = static_cast<std::vector::size_type>(_Oldlast - _Where._Ptr);
                this->_Orphan_range(_Where._Ptr, _Oldlast);
                if (_Count > _Affected_elements) {
                    this->_Mylast() = this->_Ufill(_Oldlast, _Count - _Affected_elements, _Tmp);
                    this->_Mylast() = this->_Umove(_Where._Ptr, _Oldlast, this->_Mylast());
                    _Fill_unchecked(_Where._Ptr, _Oldlast, _Tmp);
                } else {
                    this->_Mylast() = this->_Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
                    _Move_backward_unchecked(_Where._Ptr, _Oldlast - _Count, _Oldlast);
                    _Fill_unchecked(_Where._Ptr, _Where._Ptr + _Count, _Tmp);
                }
            }
            return (this->_Make_iterator_offset(_Whereoff));
        }
    private:
        template <class _Iter> void _Insert_range(std::vector::const_iterator _Where, _Iter _First, _Iter _Last, std::input_iterator_tag)         {
            if (_First == _Last) {
                return;
            }
            const std::vector::size_type _Whereoff = static_cast<std::vector::size_type>(_Where._Ptr - this->_Myfirst());
            const std::vector::size_type _Oldsize = this->size();
            for (; _First != _Last; ++_First) {
                emplace_back(*_First);
            }
            this->_Orphan_range(this->_Myfirst() + _Whereoff, this->_Myfirst() + _Oldsize);
            _Rotate_unchecked(this->_Myfirst() + _Whereoff, this->_Myfirst() + _Oldsize, this->_Mylast());
        }
        template <class _Iter> void _Insert_range(std::vector::const_iterator _Where, _Iter _First, _Iter _Last, std::forward_iterator_tag)         {
            const std::vector::size_type _Count = _Convert_size<std::vector::size_type>(static_cast<size_t>(::std::distance(_First, _Last)));
            const std::vector::size_type _Whereoff = static_cast<std::vector::size_type>(_Where._Ptr - this->_Myfirst());
            const bool _One_at_back = _Count == 1 && _Where._Ptr == this->_Mylast();
            if (_Count == 0) {
            } else if (_Count > this->_Unused_capacity()) {
                const std::vector::size_type _Oldsize = this->size();
                if (_Count > this->max_size() - _Oldsize) {
                    _Xlength();
                }
                const std::vector::size_type _Newsize = _Oldsize + _Count;
                const std::vector::size_type _Newcapacity = this->_Calculate_growth(_Newsize);
                const std::vector::pointer _Newvec = this->_Getal().allocate(_Newcapacity);
                const std::vector::pointer _Constructed_last = _Newvec + _Whereoff + _Count;
                std::vector::pointer _Constructed_first = _Constructed_last;
                try {
                    _Ucopy(_First, _Last, _Newvec + _Whereoff);
                    _Constructed_first = _Newvec + _Whereoff;
                    if (_One_at_back) {
                        this->_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
                    } else {
                        this->_Umove(this->_Myfirst(), _Where._Ptr, _Newvec);
                        _Constructed_first = _Newvec;
                        this->_Umove(_Where._Ptr, this->_Mylast(), _Newvec + _Whereoff + _Count);
                    }
                } catch (...) {
                    this->_Destroy(_Constructed_first, _Constructed_last);
                    this->_Getal().deallocate(_Newvec, _Newcapacity);
                    throw;
                }
                this->_Change_array(_Newvec, _Newsize, _Newcapacity);
            } else {
                const std::vector::pointer _Oldlast = this->_Mylast();
                const std::vector::size_type _Affected_elements = static_cast<std::vector::size_type>(_Oldlast - _Where._Ptr);
                if (_Count < _Affected_elements) {
                    this->_Mylast() = this->_Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
                    _Move_backward_unchecked(_Where._Ptr, _Oldlast - _Count, _Oldlast);
                    this->_Destroy(_Where._Ptr, _Where._Ptr + _Count);
                    try {
                        _Ucopy(_First, _Last, _Where._Ptr);
                    } catch (...) {
                        try {
                            this->_Umove(_Where._Ptr + _Count, _Where._Ptr + 2 * _Count, _Where._Ptr);
                        } catch (...) {
                            this->_Orphan_range(_Where._Ptr, _Oldlast);
                            this->_Destroy(_Where._Ptr + _Count, this->_Mylast());
                            this->_Mylast() = _Where._Ptr;
                            throw;
                        }
                        _Move_unchecked(_Where._Ptr + 2 * _Count, this->_Mylast(), _Where._Ptr + _Count);
                        this->_Destroy(_Oldlast, this->_Mylast());
                        this->_Mylast() = _Oldlast;
                        throw;
                    }
                } else {
                    const std::vector::pointer _Relocated = _Where._Ptr + _Count;
                    this->_Mylast() = this->_Umove(_Where._Ptr, _Oldlast, _Relocated);
                    this->_Destroy(_Where._Ptr, _Oldlast);
                    try {
                        _Ucopy(_First, _Last, _Where._Ptr);
                    } catch (...) {
                        try {
                            this->_Umove(_Relocated, this->_Mylast(), _Where._Ptr);
                        } catch (...) {
                            this->_Orphan_range(_Where._Ptr, _Oldlast);
                            this->_Destroy(_Relocated, this->_Mylast());
                            this->_Mylast() = _Where._Ptr;
                            throw;
                        }
                        this->_Destroy(_Relocated, this->_Mylast());
                        this->_Mylast() = _Oldlast;
                        throw;
                    }
                }
                this->_Orphan_range(_Where._Ptr, _Oldlast);
            }
        }
    public:
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> std::vector::iterator insert(std::vector::const_iterator _Where, _Iter _First, _Iter _Last)         {
            _Adl_verify_range(_First, _Last);
            const std::vector::size_type _Whereoff = static_cast<std::vector::size_type>(_Where._Ptr - this->_Myfirst());
            _Insert_range(_Where, _Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>({}));
            return (this->_Make_iterator_offset(_Whereoff));
        }
        std::vector::iterator insert(std::vector::const_iterator _Where, initializer_list<_Ty> _Ilist)         {
            return (insert(_Where, _Ilist.begin(), _Ilist.end()));
        }
        void assign(const std::vector::size_type _Newsize, const _Ty &_Val)         {
            this->_Orphan_all();
            const std::vector::size_type _Oldsize = this->size();
            const std::vector::size_type _Oldcapacity = this->capacity();
            if (_Newsize > _Oldcapacity) {
                if (_Newsize > this->max_size()) {
                    _Xlength();
                }
                const std::vector::size_type _Newcapacity = this->_Calculate_growth(_Newsize);
                if (this->_Myfirst() != std::vector::pointer()) {
                    this->_Destroy(this->_Myfirst(), this->_Mylast());
                    this->_Getal().deallocate(this->_Myfirst(), _Oldcapacity);
                }
                this->_Buy(_Newcapacity);
                this->_Mylast() = this->_Ufill(this->_Myfirst(), _Newsize, _Val);
            } else if (_Newsize > _Oldsize) {
                _Fill_unchecked(this->_Myfirst(), this->_Mylast(), _Val);
                this->_Mylast() = this->_Ufill(this->_Mylast(), _Newsize - _Oldsize, _Val);
            } else {
                const std::vector::pointer _Newlast = this->_Myfirst() + _Newsize;
                _Fill_unchecked(this->_Myfirst(), _Newlast, _Val);
                this->_Destroy(_Newlast, this->_Mylast());
                this->_Mylast() = _Newlast;
            }
        }
    private:
        template <class _Iter> void _Assign_range(_Iter _First, _Iter _Last, std::input_iterator_tag)         {
            this->_Orphan_all();
            std::vector::pointer _Next = this->_Myfirst();
            for (; _First != _Last && _Next != this->_Mylast(); ++_First , (void)++_Next) {
                *_Next = *_First;
            }
            this->_Destroy(_Next, this->_Mylast());
            this->_Mylast() = _Next;
            for (; _First != _Last; ++_First) {
                emplace_back(*_First);
            }
        }
        template <class _Iter> void _Assign_range(_Iter _First, _Iter _Last, std::forward_iterator_tag)         {
            const std::vector::size_type _Newsize = _Convert_size<std::vector::size_type>(static_cast<size_t>(::std::distance(_First, _Last)));
            this->_Orphan_all();
            const std::vector::size_type _Oldsize = this->size();
            const std::vector::size_type _Oldcapacity = this->capacity();
            if (_Newsize > _Oldcapacity) {
                if (_Newsize > this->max_size()) {
                    _Xlength();
                }
                const std::vector::size_type _Newcapacity = this->_Calculate_growth(_Newsize);
                if (this->_Myfirst() != std::vector::pointer()) {
                    this->_Destroy(this->_Myfirst(), this->_Mylast());
                    this->_Getal().deallocate(this->_Myfirst(), _Oldcapacity);
                }
                this->_Buy(_Newcapacity);
                this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
            } else if (_Newsize > _Oldsize) {
                const _Iter _Mid = ::std::next(_First, static_cast<std::vector::difference_type>(_Oldsize));
                _Copy_unchecked(_First, _Mid, this->_Myfirst());
                this->_Mylast() = _Ucopy(_Mid, _Last, this->_Mylast());
            } else {
                const std::vector::pointer _Newlast = this->_Myfirst() + _Newsize;
                _Copy_unchecked(_First, _Last, this->_Myfirst());
                this->_Destroy(_Newlast, this->_Mylast());
                this->_Mylast() = _Newlast;
            }
        }
    public:
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> void assign(_Iter _First, _Iter _Last)         {
            _Adl_verify_range(_First, _Last);
            _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>({}));
        }
        void assign(initializer_list<_Ty> _Ilist)         {
            _Assign_range(_Ilist.begin(), _Ilist.end(), std::random_access_iterator_tag{});
        }
        vector<_Ty, _Alloc> &operator=(const vector<_Ty, _Alloc> &_Right)         {
            if (this != ::std::addressof(_Right)) {
                if (_Alty_traits::propagate_on_container_copy_assignment::value && this->_Getal() != _Right._Getal()) {
                    this->_Tidy();
                }
                this->_Copy_alloc(_Right._Getal());
                assign(_Right._Myfirst(), _Right._Mylast());
            }
            return (*this);
        }
        vector<_Ty, _Alloc> &operator=(initializer_list<_Ty> _Ilist)         {
            _Assign_range(_Ilist.begin(), _Ilist.end(), std::random_access_iterator_tag{});
            return (*this);
        }
    private:
        template <class _Lambda> void _Resize(const std::vector::size_type _Newsize, _Lambda _Udefault_or_fill)         {
            const std::vector::size_type _Oldsize = this->size();
            const std::vector::size_type _Oldcapacity = this->capacity();
            if (_Newsize > _Oldcapacity) {
                if (_Newsize > this->max_size()) {
                    _Xlength();
                }
                const std::vector::size_type _Newcapacity = this->_Calculate_growth(_Newsize);
                const std::vector::pointer _Newvec = this->_Getal().allocate(_Newcapacity);
                const std::vector::pointer _Appended_first = _Newvec + _Oldsize;
                std::vector::pointer _Appended_last = _Appended_first;
                try {
                    _Appended_last = _Udefault_or_fill(_Appended_first, _Newsize - _Oldsize);
                    this->_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
                } catch (...) {
                    this->_Destroy(_Appended_first, _Appended_last);
                    this->_Getal().deallocate(_Newvec, _Newcapacity);
                    throw;
                }
                this->_Change_array(_Newvec, _Newsize, _Newcapacity);
            } else if (_Newsize > _Oldsize) {
                const std::vector::pointer _Oldlast = this->_Mylast();
                this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);
                this->_Orphan_range(_Oldlast, _Oldlast);
            } else if (_Newsize == _Oldsize) {
            } else {
                const std::vector::pointer _Newlast = this->_Myfirst() + _Newsize;
                this->_Orphan_range(_Newlast, this->_Mylast());
                this->_Destroy(_Newlast, this->_Mylast());
                this->_Mylast() = _Newlast;
            }
        }
    public:
        void resize(const std::vector::size_type _Newsize)         {
            const auto _Lambda_default = [this] (std::vector::pointer _Dest, const std::vector::size_type _Count)                 {
                    return (this->_Udefault(_Dest, _Count));
                }
;
            _Resize(_Newsize, _Lambda_default);
        }
        void resize(const std::vector::size_type _Newsize, const _Ty &_Val)         {
            auto _Lambda_fill = [this, &_Val] (std::vector::pointer _Dest, const std::vector::size_type _Count)                 {
                    return (this->_Ufill(_Dest, _Count, _Val));
                }
;
            _Resize(_Newsize, _Lambda_fill);
        }
    private:
        void _Reallocate_exactly(const std::vector::size_type _Newcapacity)         {
            const std::vector::size_type _Size = this->size();
            const std::vector::pointer _Newvec = this->_Getal().allocate(_Newcapacity);
            try {
                this->_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
            } catch (...) {
                this->_Getal().deallocate(_Newvec, _Newcapacity);
                throw;
            }
            this->_Change_array(_Newvec, _Size, _Newcapacity);
        }
    public:
        void reserve(const std::vector::size_type _Newcapacity)         {
            if (_Newcapacity > this->capacity()) {
                if (_Newcapacity > this->max_size()) {
                    _Xlength();
                }
                this->_Reallocate_exactly(_Newcapacity);
            }
        }
        void shrink_to_fit()         {
            if (this->_Has_unused_capacity()) {
                if (this->empty()) {
                    this->_Tidy();
                } else {
                    this->_Reallocate_exactly(this->size());
                }
            }
        }
        void pop_back()         {
            _Alty_traits::destroy(this->_Getal(), _Unfancy(this->_Mylast() - 1));
            --this->_Mylast();
        }
        std::vector::iterator erase(std::vector::const_iterator _Where)         {
            _Move_unchecked(_Where._Ptr + 1, this->_Mylast(), _Where._Ptr);
            _Alty_traits::destroy(this->_Getal(), _Unfancy(this->_Mylast() - 1));
            --this->_Mylast();
            return (std::vector::iterator(_Where._Ptr, ::std::addressof(this->_Get_data())));
        }
        std::vector::iterator erase(std::vector::const_iterator _First, std::vector::const_iterator _Last)         {
            if (_First._Ptr != _Last._Ptr) {
                this->_Orphan_range(_First._Ptr, this->_Mylast());
                const std::vector::pointer _Newlast = _Move_unchecked(_Last._Ptr, this->_Mylast(), _First._Ptr);
                this->_Destroy(_Newlast, this->_Mylast());
                this->_Mylast() = _Newlast;
            }
            return (std::vector::iterator(_First._Ptr, ::std::addressof(this->_Get_data())));
        }
        void clear() noexcept         {
            this->_Orphan_all();
            this->_Destroy(this->_Myfirst(), this->_Mylast());
            this->_Mylast() = this->_Myfirst();
        }
        void swap(vector<_Ty, _Alloc> &_Right) noexcept         {
            if (this != ::std::addressof(_Right)) {
                _Pocs(this->_Getal(), _Right._Getal());
                this->_Swap_all(_Right);
                _Swap_adl(this->_Myfirst(), _Right._Myfirst());
                _Swap_adl(this->_Mylast(), _Right._Mylast());
                _Swap_adl(this->_Myend(), _Right._Myend());
            }
        }
        _Ty *data() noexcept         {
            return (_Unfancy_maybe_null(this->_Myfirst()));
        }
        const _Ty *data() const noexcept         {
            return (_Unfancy_maybe_null(this->_Myfirst()));
        }
        std::vector::iterator begin() noexcept         {
            return (std::vector::iterator(this->_Myfirst(), ::std::addressof(this->_Get_data())));
        }
        std::vector::const_iterator begin() const noexcept         {
            return (std::vector::const_iterator(this->_Myfirst(), ::std::addressof(this->_Get_data())));
        }
        std::vector::iterator end() noexcept         {
            return (std::vector::iterator(this->_Mylast(), ::std::addressof(this->_Get_data())));
        }
        std::vector::const_iterator end() const noexcept         {
            return (std::vector::const_iterator(this->_Mylast(), ::std::addressof(this->_Get_data())));
        }
        std::vector::reverse_iterator rbegin() noexcept         {
            return (std::vector::reverse_iterator(end()));
        }
        std::vector::const_reverse_iterator rbegin() const noexcept         {
            return (std::vector::const_reverse_iterator(end()));
        }
        std::vector::reverse_iterator rend() noexcept         {
            return (std::vector::reverse_iterator(begin()));
        }
        std::vector::const_reverse_iterator rend() const noexcept         {
            return (std::vector::const_reverse_iterator(begin()));
        }
        std::vector::const_iterator cbegin() const noexcept         {
            return (begin());
        }
        std::vector::const_iterator cend() const noexcept         {
            return (end());
        }
        std::vector::const_reverse_iterator crbegin() const noexcept         {
            return (rbegin());
        }
        std::vector::const_reverse_iterator crend() const noexcept         {
            return (rend());
        }
        std::vector::pointer _Unchecked_begin() noexcept         {
            return (this->_Myfirst());
        }
        std::vector::const_pointer _Unchecked_begin() const noexcept         {
            return (this->_Myfirst());
        }
        std::vector::pointer _Unchecked_end() noexcept         {
            return (this->_Mylast());
        }
        std::vector::const_pointer _Unchecked_end() const noexcept         {
            return (this->_Mylast());
        }
        bool empty() const noexcept         {
            return (this->_Myfirst() == this->_Mylast());
        }
        std::vector::size_type size() const noexcept         {
            return (static_cast<std::vector::size_type>(this->_Mylast() - this->_Myfirst()));
        }
        std::vector::size_type max_size() const noexcept         {
            return (_Min_value(static_cast<std::vector::size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(this->_Getal())));
        }
        std::vector::size_type capacity() const noexcept         {
            return (static_cast<std::vector::size_type>(this->_Myend() - this->_Myfirst()));
        }
    private:
        std::vector::size_type _Unused_capacity() const noexcept         {
            return (static_cast<std::vector::size_type>(this->_Myend() - this->_Mylast()));
        }
        bool _Has_unused_capacity() const noexcept         {
            return (this->_Myend() != this->_Mylast());
        }
    public:
        _Ty &operator[](const std::vector::size_type _Pos)         {
            return (this->_Myfirst()[_Pos]);
        }
        const _Ty &operator[](const std::vector::size_type _Pos) const         {
            return (this->_Myfirst()[_Pos]);
        }
        _Ty &at(const std::vector::size_type _Pos)         {
            if (this->size() <= _Pos) {
                _Xrange();
            }
            return (this->_Myfirst()[_Pos]);
        }
        const _Ty &at(const std::vector::size_type _Pos) const         {
            if (this->size() <= _Pos) {
                _Xrange();
            }
            return (this->_Myfirst()[_Pos]);
        }
        _Ty &front()         {
            return (*this->_Myfirst());
        }
        const _Ty &front() const         {
            return (*this->_Myfirst());
        }
        _Ty &back()         {
            return (this->_Mylast()[-1]);
        }
        const _Ty &back() const         {
            return (this->_Mylast()[-1]);
        }
        std::vector::allocator_type get_allocator() const noexcept         {
            return (static_cast<std::vector::allocator_type>(this->_Getal()));
        }
    private:
        std::vector::pointer _Udefault(std::vector::pointer _Dest, const std::vector::size_type _Count)         {
            return (_Uninitialized_value_construct_n(_Dest, _Count, this->_Getal()));
        }
        std::vector::pointer _Ufill(std::vector::pointer _Dest, const std::vector::size_type _Count, const _Ty &_Val)         {
            return (_Uninitialized_fill_n(_Dest, _Count, _Val, this->_Getal()));
        }
        template <class _Iter> std::vector::pointer _Ucopy(_Iter _First, _Iter _Last, std::vector::pointer _Dest)         {
            return (_Uninitialized_copy(_First, _Last, _Dest, this->_Getal()));
        }
        std::vector::pointer _Umove(std::vector::pointer _First, std::vector::pointer _Last, std::vector::pointer _Dest)         {
            return (_Uninitialized_move(_First, _Last, _Dest, this->_Getal()));
        }
        void _Umove_if_noexcept1(std::vector::pointer _First, std::vector::pointer _Last, std::vector::pointer _Dest, std::true_type)         {
            _Uninitialized_move(_First, _Last, _Dest, this->_Getal());
        }
        void _Umove_if_noexcept1(std::vector::pointer _First, std::vector::pointer _Last, std::vector::pointer _Dest, std::false_type)         {
            _Uninitialized_copy(_First, _Last, _Dest, this->_Getal());
        }
        void _Umove_if_noexcept(std::vector::pointer _First, std::vector::pointer _Last, std::vector::pointer _Dest)         {
            _Umove_if_noexcept1(_First, _Last, _Dest, bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty> > > >({}));
        }
        void _Destroy(std::vector::pointer _First, std::vector::pointer _Last)         {
            _Destroy_range(_First, _Last, this->_Getal());
        }
        std::vector::size_type _Calculate_growth(const std::vector::size_type _Newsize) const         {
            const std::vector::size_type _Oldcapacity = this->capacity();
            if (_Oldcapacity > this->max_size() - _Oldcapacity / 2) {
                return (_Newsize);
            }
            const std::vector::size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;
            if (_Geometric < _Newsize) {
                return (_Newsize);
            }
            return (_Geometric);
        }
        bool _Buy(const std::vector::size_type _Newcapacity)         {
            this->_Myfirst() = std::vector::pointer();
            this->_Mylast() = std::vector::pointer();
            this->_Myend() = std::vector::pointer();
            if (_Newcapacity == 0) {
                return (false);
            }
            if (_Newcapacity > this->max_size()) {
                _Xlength();
            }
            this->_Myfirst() = this->_Getal().allocate(_Newcapacity);
            this->_Mylast() = this->_Myfirst();
            this->_Myend() = this->_Myfirst() + _Newcapacity;
            return (true);
        }
        void _Change_array(const std::vector::pointer _Newvec, const std::vector::size_type _Newsize, const std::vector::size_type _Newcapacity)         {
            this->_Orphan_all();
            if (this->_Myfirst() != std::vector::pointer()) {
                this->_Destroy(this->_Myfirst(), this->_Mylast());
                this->_Getal().deallocate(this->_Myfirst(), this->capacity());
            }
            this->_Myfirst() = _Newvec;
            this->_Mylast() = _Newvec + _Newsize;
            this->_Myend() = _Newvec + _Newcapacity;
        }
        void _Tidy()         {
            this->_Orphan_all();
            if (this->_Myfirst() != std::vector::pointer()) {
                this->_Destroy(this->_Myfirst(), this->_Mylast());
                this->_Getal().deallocate(this->_Myfirst(), this->capacity());
                this->_Myfirst() = std::vector::pointer();
                this->_Mylast() = std::vector::pointer();
                this->_Myend() = std::vector::pointer();
            }
        }
        static void _Xlength() [[noreturn]]         {
            _Xlength_error("vector<T> too long");
        }
        static void _Xrange() [[noreturn]]         {
            _Xout_of_range("invalid vector<T> subscript");
        }
        void _Orphan_range(std::vector::pointer, std::vector::pointer) const         {
        }
    };
    template <class _Ty, class _Alloc> inline void swap(vector<_Ty, _Alloc> &_Left, vector<_Ty, _Alloc> &_Right) noexcept     {
        _Left.swap(_Right);
    }
    template <class _Ty, class _Alloc> inline bool operator==(const vector<_Ty, _Alloc> &_Left, const vector<_Ty, _Alloc> &_Right)     {
        return (_Left.size() == _Right.size() && ::std::equal(_Left.begin(), _Left.end(), _Right.begin()));
    }
    template <class _Ty, class _Alloc> inline bool operator!=(const vector<_Ty, _Alloc> &_Left, const vector<_Ty, _Alloc> &_Right)     {
        return (!(_Left == _Right));
    }
    template <class _Ty, class _Alloc> inline bool operator<(const vector<_Ty, _Alloc> &_Left, const vector<_Ty, _Alloc> &_Right)     {
        return (::std::lexicographical_compare(_Left.begin(), _Left.end(), _Right.begin(), _Right.end()));
    }
    template <class _Ty, class _Alloc> inline bool operator>(const vector<_Ty, _Alloc> &_Left, const vector<_Ty, _Alloc> &_Right)     {
        return (_Right < _Left);
    }
    template <class _Ty, class _Alloc> inline bool operator<=(const vector<_Ty, _Alloc> &_Left, const vector<_Ty, _Alloc> &_Right)     {
        return (!(_Right < _Left));
    }
    template <class _Ty, class _Alloc> inline bool operator>=(const vector<_Ty, _Alloc> &_Left, const vector<_Ty, _Alloc> &_Right)     {
        return (!(_Left < _Right));
    }
    using _Vbase = unsigned int;
    constexpr int _VBITS = 8 * sizeof(std::_Vbase);
    template <class _Alloc0> struct _Wrap_alloc {
        using _Alloc = _Alloc0;
    };
    template <class _Alvbase_wrapped> class _Vb_iter_base : public std::_Iterator_base {
    public:
        using _Alvbase = typename _Alvbase_wrapped::_Alloc;
        using _Sizet = typename allocator_traits<_Alvbase>::size_type;
        using _Difft = typename allocator_traits<_Alvbase>::difference_type;
        using _Mycont = vector<bool, _Rebind_alloc_t<std::_Vb_iter_base::_Alvbase, bool> >;
        _Vb_iter_base<_Alvbase_wrapped>() : _Myptr(nullptr), _Myoff(0)         {
        }
        _Vb_iter_base<_Alvbase_wrapped>(const std::_Vbase *_Ptr, std::_Vb_iter_base::_Sizet _Off, const std::_Container_base *_Mypvbool) : _Myptr(_Ptr), _Myoff(_Off)         {
            this->_Adopt(_Mypvbool);
        }
        void _Advance(std::_Vb_iter_base::_Sizet _Off)         {
            this->_Myoff += _Off;
            this->_Myptr += this->_Myoff / _VBITS;
            this->_Myoff %= _VBITS;
        }
        int _Valid(std::_Vb_iter_base::_Sizet _Inc) const         {
            (void)_Inc;
            return (-1);
        }
        const std::_Vbase *_Myptr;
        std::_Vb_iter_base::_Sizet _Myoff;
    };
    template <class _Alvbase_wrapped> class _Vb_reference : public _Vb_iter_base<_Alvbase_wrapped> {
        using _Mybase = _Vb_iter_base<_Alvbase_wrapped>;
        _Vb_reference<_Alvbase_wrapped>() noexcept         {
        }
    public:
        _Vb_reference<_Alvbase_wrapped>(const std::_Vb_reference::_Mybase &_Right) : std::_Vb_reference::_Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont())         {
        }
        _Vb_reference<_Alvbase_wrapped> &operator=(const _Vb_reference<_Alvbase_wrapped> &_Right) noexcept         {
            return (*this = bool(_Right));
        }
        _Vb_reference<_Alvbase_wrapped> &operator=(bool _Val) noexcept         {
            if (_Val)
                *const_cast<std::_Vbase *>(this->_Getptr()) |= this->_Mask();
            else
                *const_cast<std::_Vbase *>(this->_Getptr()) &= ~this->_Mask();
            return (*this);
        }
        void flip() noexcept         {
            *const_cast<std::_Vbase *>(this->_Getptr()) ^= this->_Mask();
        }
        operator bool() const noexcept         {
            return ((*this->_Getptr() & this->_Mask()) != 0);
        }
        const std::_Vbase *_Getptr() const         {
            return (this->_Myptr);
        }
    protected:
        std::_Vbase _Mask() const         {
            return (static_cast<std::_Vbase>(1) << this->_Myoff);
        }
    };
    template <class _Alvbase_wrapped> inline void swap(_Vb_reference<_Alvbase_wrapped> _Left, _Vb_reference<_Alvbase_wrapped> _Right) noexcept     {
        bool _Val = _Left;
        _Left = _Right;
        _Right = _Val;
    }
    template <class _Alvbase_wrapped> class _Vb_const_iterator : public _Vb_iter_base<_Alvbase_wrapped> {
    private:
        using _Mybase = _Vb_iter_base<_Alvbase_wrapped>;
        using _Size_type = typename _Mybase::_Sizet;
    public:
        using _Reft = _Vb_reference<_Alvbase_wrapped>;
        using const_reference = bool;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = bool;
        using difference_type = typename _Mybase::_Difft;
        using pointer = std::_Vb_const_iterator::const_reference *;
        using reference = std::_Vb_const_iterator::const_reference;
        _Vb_const_iterator<_Alvbase_wrapped>()         {
        }
        _Vb_const_iterator<_Alvbase_wrapped>(const std::_Vbase *_Ptr, const std::_Container_base *_Mypvbool) : std::_Vb_const_iterator::_Mybase(_Ptr, 0, _Mypvbool)         {
        }
        std::_Vb_const_iterator::const_reference operator*() const         {
            return (std::_Vb_const_iterator::_Reft(*this));
        }
        _Vb_const_iterator<_Alvbase_wrapped> &operator++()         {
            this->_Inc();
            return (*this);
        }
        _Vb_const_iterator<_Alvbase_wrapped> operator++(int)         {
            _Vb_const_iterator<_Alvbase_wrapped> _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        _Vb_const_iterator<_Alvbase_wrapped> &operator--()         {
            this->_Dec();
            return (*this);
        }
        _Vb_const_iterator<_Alvbase_wrapped> operator--(int)         {
            _Vb_const_iterator<_Alvbase_wrapped> _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        _Vb_const_iterator<_Alvbase_wrapped> &operator+=(const std::_Vb_const_iterator::difference_type _Off)         {
            if (_Off < 0 && this->_Myoff < 0 - static_cast<std::_Vb_const_iterator::_Size_type>(_Off)) {
                this->_Myoff += _Off;
                this->_Myptr -= 1 + (static_cast<std::_Vb_const_iterator::_Size_type>(-1) - this->_Myoff) / _VBITS;
                this->_Myoff %= _VBITS;
            } else {
                this->_Myoff += _Off;
                this->_Myptr += this->_Myoff / _VBITS;
                this->_Myoff %= _VBITS;
            }
            return (*this);
        }
        _Vb_const_iterator<_Alvbase_wrapped> operator+(const std::_Vb_const_iterator::difference_type _Off) const         {
            _Vb_const_iterator<_Alvbase_wrapped> _Tmp = *this;
            return (_Tmp += _Off);
        }
        _Vb_const_iterator<_Alvbase_wrapped> &operator-=(const std::_Vb_const_iterator::difference_type _Off)         {
            return (*this += - _Off);
        }
        _Vb_const_iterator<_Alvbase_wrapped> operator-(const std::_Vb_const_iterator::difference_type _Off) const         {
            _Vb_const_iterator<_Alvbase_wrapped> _Tmp = *this;
            return (_Tmp -= _Off);
        }
        std::_Vb_const_iterator::difference_type operator-(const _Vb_const_iterator<_Alvbase_wrapped> &_Right) const         {
            this->_Compat(_Right);
            return (static_cast<std::_Vb_const_iterator::difference_type>(_VBITS * (this->_Myptr - _Right._Myptr)) + static_cast<std::_Vb_const_iterator::difference_type>(this->_Myoff) - static_cast<std::_Vb_const_iterator::difference_type>(_Right._Myoff));
        }
        std::_Vb_const_iterator::const_reference operator[](const std::_Vb_const_iterator::difference_type _Off) const         {
            return (*(*this + _Off));
        }
        bool operator==(const _Vb_const_iterator<_Alvbase_wrapped> &_Right) const         {
            this->_Compat(_Right);
            return (this->_Myptr == _Right._Myptr && this->_Myoff == _Right._Myoff);
        }
        bool operator!=(const _Vb_const_iterator<_Alvbase_wrapped> &_Right) const         {
            return (!(*this == _Right));
        }
        bool operator<(const _Vb_const_iterator<_Alvbase_wrapped> &_Right) const         {
            this->_Compat(_Right);
            return (this->_Myptr < _Right._Myptr || (this->_Myptr == _Right._Myptr && this->_Myoff < _Right._Myoff));
        }
        bool operator>(const _Vb_const_iterator<_Alvbase_wrapped> &_Right) const         {
            return (_Right < *this);
        }
        bool operator<=(const _Vb_const_iterator<_Alvbase_wrapped> &_Right) const         {
            return (!(_Right < *this));
        }
        bool operator>=(const _Vb_const_iterator<_Alvbase_wrapped> &_Right) const         {
            return (!(*this < _Right));
        }
        void _Compat(const _Vb_const_iterator<_Alvbase_wrapped> &_Right) const         {
            (void)_Right;
        }
        void _Dec()         {
            if (this->_Myoff != 0)
                --this->_Myoff;
            else {
                this->_Myoff = _VBITS - 1;
                --this->_Myptr;
            }
        }
        void _Inc()         {
            if (this->_Myoff < _VBITS - 1)
                ++this->_Myoff;
            else {
                this->_Myoff = 0;
                ++this->_Myptr;
            }
        }
    };
    template <class _Alvbase_wrapped> _Vb_const_iterator<_Alvbase_wrapped> operator+(typename _Vb_const_iterator<_Alvbase_wrapped>::difference_type _Off, _Vb_const_iterator<_Alvbase_wrapped> _Right)     {
        return (_Right += _Off);
    }
    template <class _Alvbase_wrapped> class _Vb_iterator : public _Vb_const_iterator<_Alvbase_wrapped> {
    public:
        using _Mybase = _Vb_const_iterator<_Alvbase_wrapped>;
        using _Reft = _Vb_reference<_Alvbase_wrapped>;
        using const_reference = bool;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = bool;
        using difference_type = typename _Mybase::difference_type;
        using pointer = std::_Vb_iterator::_Reft *;
        using reference = std::_Vb_iterator::_Reft;
        _Vb_iterator<_Alvbase_wrapped>()         {
        }
        _Vb_iterator<_Alvbase_wrapped>(std::_Vbase *_Ptr, std::_Container_base *_Mypvbool) : std::_Vb_iterator::_Mybase(_Ptr, _Mypvbool)         {
        }
        std::_Vb_iterator::reference operator*() const         {
            return (std::_Vb_iterator::_Reft(*this));
        }
        _Vb_iterator<_Alvbase_wrapped> &operator++()         {
            ++*(std::_Vb_iterator::_Mybase *)this;
            return (*this);
        }
        _Vb_iterator<_Alvbase_wrapped> operator++(int)         {
            _Vb_iterator<_Alvbase_wrapped> _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        _Vb_iterator<_Alvbase_wrapped> &operator--()         {
            --*(std::_Vb_iterator::_Mybase *)this;
            return (*this);
        }
        _Vb_iterator<_Alvbase_wrapped> operator--(int)         {
            _Vb_iterator<_Alvbase_wrapped> _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        _Vb_iterator<_Alvbase_wrapped> &operator+=(const std::_Vb_iterator::difference_type _Off)         {
            *(std::_Vb_iterator::_Mybase *)this += _Off;
            return (*this);
        }
        _Vb_iterator<_Alvbase_wrapped> operator+(const std::_Vb_iterator::difference_type _Off) const         {
            _Vb_iterator<_Alvbase_wrapped> _Tmp = *this;
            return (_Tmp += _Off);
        }
        _Vb_iterator<_Alvbase_wrapped> &operator-=(const std::_Vb_iterator::difference_type _Off)         {
            return (*this += - _Off);
        }
        _Vb_iterator<_Alvbase_wrapped> operator-(const std::_Vb_iterator::difference_type _Off) const         {
            _Vb_iterator<_Alvbase_wrapped> _Tmp = *this;
            return (_Tmp -= _Off);
        }
        std::_Vb_iterator::difference_type operator-(const std::_Vb_iterator::_Mybase &_Right) const         {
            return (*(std::_Vb_iterator::_Mybase *)this - _Right);
        }
        std::_Vb_iterator::reference operator[](const std::_Vb_iterator::difference_type _Off) const         {
            return (*(*this + _Off));
        }
    };
    template <class _Alvbase_wrapped> inline _Vb_iterator<_Alvbase_wrapped> operator+(typename _Vb_iterator<_Alvbase_wrapped>::difference_type _Off, _Vb_iterator<_Alvbase_wrapped> _Right)     {
        return (_Right += _Off);
    }
    template <class _Alloc> class _Vb_val : public std::_Container_base {
    public:
        using _Alproxy = _Rebind_alloc_t<_Alloc, std::_Container_proxy>;
        using _Alproxy_traits = allocator_traits<std::_Vb_val::_Alproxy>;
        using _Alvbase = _Rebind_alloc_t<_Alloc, std::_Vbase>;
        using _Alvbase_traits = allocator_traits<std::_Vb_val::_Alvbase>;
        using _Vectype = vector<std::_Vbase, std::_Vb_val::_Alvbase>;
        using _Alvbase_wrapped = _Wrap_alloc<std::_Vb_val::_Alvbase>;
        using size_type = typename _Alvbase_traits::size_type;
        _Vb_val<_Alloc>() noexcept(is_nothrow_default_constructible_v<std::_Vb_val::_Vectype>_Vb_val<_Alloc>() noexcept(is_nothrow_default_constructible_v<std::_Vb_val::_Vectype>) : _Myvec()         {
            this->_Alloc_proxy();
            this->_Mysize = 0;
        }
        _Vb_val<_Alloc>(const _Alloc &_Al) noexcept(is_nothrow_constructible_v<std::_Vb_val::_Vectype, std::_Vb_val::_Alvbase>_Vb_val<_Alloc>(const _Alloc &_Al) noexcept(is_nothrow_constructible_v<std::_Vb_val::_Vectype, std::_Vb_val::_Alvbase>) : _Myvec(static_cast<std::_Vb_val::_Alvbase>(_Al))         {
            this->_Alloc_proxy();
            this->_Mysize = 0;
        }
        _Vb_val<_Alloc>(std::_Vb_val::size_type _Count, const bool &_Val) : _Myvec(_Nw(_Count), static_cast<std::_Vbase>(_Val ? -1 : 0))         {
            this->_Alloc_proxy();
            this->_Mysize = 0;
        }
        _Vb_val<_Alloc>(std::_Vb_val::size_type _Count, const bool &_Val, const _Alloc &_Al) : _Myvec(_Nw(_Count), static_cast<std::_Vbase>(_Val ? -1 : 0), static_cast<std::_Vb_val::_Alvbase>(_Al))         {
            this->_Alloc_proxy();
            this->_Mysize = 0;
        }
        _Vb_val<_Alloc>(const _Vb_val<_Alloc> &_Right) : _Myvec(_Right._Myvec), _Mysize(_Right._Mysize)         {
            this->_Alloc_proxy();
        }
        _Vb_val<_Alloc>(const _Vb_val<_Alloc> &_Right, const _Alloc &_Al) : _Myvec(_Right._Myvec, static_cast<std::_Vb_val::_Alvbase>(_Al)), _Mysize(_Right._Mysize)         {
            this->_Alloc_proxy();
        }
        _Vb_val<_Alloc>(_Vb_val<_Alloc> &&_Right) noexcept(is_nothrow_move_constructible_v<std::_Vb_val::_Vectype>_Vb_val<_Alloc>(_Vb_val<_Alloc> &&_Right) noexcept(is_nothrow_move_constructible_v<std::_Vb_val::_Vectype>) : _Myvec(::std::move(_Right._Myvec)), _Mysize(_Right._Mysize)         {
            _Right._Mysize = 0;
            this->_Alloc_proxy();
        }
        _Vb_val<_Alloc>(_Vb_val<_Alloc> &&_Right, const _Alloc &_Al) noexcept(is_nothrow_constructible_v<std::_Vb_val::_Vectype, std::_Vb_val::_Vectype, std::_Vb_val::_Alvbase>_Vb_val<_Alloc>(_Vb_val<_Alloc> &&_Right, const _Alloc &_Al) noexcept(is_nothrow_constructible_v<std::_Vb_val::_Vectype, std::_Vb_val::_Vectype, std::_Vb_val::_Alvbase>) : _Myvec(::std::move(_Right._Myvec), static_cast<std::_Vb_val::_Alvbase>(_Al)), _Mysize(_Right._Mysize)         {
            _Right._Mysize = 0;
            this->_Alloc_proxy();
        }
        ~_Vb_val<_Alloc>() noexcept         {
            this->_Free_proxy();
        }
        void _Alloc_proxy()         {
        }
        void _Free_proxy()         {
        }
        static std::_Vb_val::size_type _Nw(std::_Vb_val::size_type _Count)         {
            return ((_Count + _VBITS - 1) / _VBITS);
        }
        std::_Vb_val::_Vectype _Myvec;
        std::_Vb_val::size_type _Mysize;
    };
    template <class _Alloc> class vector<bool, _Alloc> : public _Vb_val<_Alloc> {
    public:
        static_assert(!0 || is_same_v<bool, typename _Alloc::value_type>, "vector<bool, Allocator> requires that Allocator's value_type match bool (See N4659 26.2.1 [container.requirements.general]/16 allocator_type) Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0 to suppress this diagnostic.");
        using _Mybase = _Vb_val<_Alloc>;
        using _Alvbase_wrapped = typename _Mybase::_Alvbase_wrapped;
        using _Alvbase = typename _Mybase::_Alvbase;
        using _Alvbase_traits = typename _Mybase::_Alvbase_traits;
        using size_type = typename _Alvbase_traits::size_type;
        using difference_type = typename _Alvbase_traits::difference_type;
        using allocator_type = _Alloc;
        using reference = _Vb_reference<std::vector<bool, type-parameter-0-0>::_Alvbase_wrapped>;
        using const_reference = bool;
        using value_type = bool;
        using _Reft = std::vector<bool, type-parameter-0-0>::reference;
        using iterator = _Vb_iterator<std::vector<bool, type-parameter-0-0>::_Alvbase_wrapped>;
        using const_iterator = _Vb_const_iterator<std::vector<bool, type-parameter-0-0>::_Alvbase_wrapped>;
        using pointer = std::vector<bool, type-parameter-0-0>::iterator;
        using const_pointer = std::vector<bool, type-parameter-0-0>::const_iterator;
        using reverse_iterator = ::std::reverse_iterator<iterator>;
        using const_reverse_iterator = ::std::reverse_iterator<const_iterator>;
        static const int _VBITS = ::std::_VBITS;
        enum  {
            _EEN_VBITS = _VBITS
        };
        vector<bool, type-parameter-0-0>() noexcept(is_nothrow_default_constructible_v<std::vector<bool, type-parameter-0-0>::_Mybase>vector<bool, type-parameter-0-0>() noexcept(is_nothrow_default_constructible_v<std::vector<bool, type-parameter-0-0>::_Mybase>) : std::vector<bool, type-parameter-0-0>::_Mybase()         {
        }
        explicit vector<bool, type-parameter-0-0>(const _Alloc &_Al) noexcept(is_nothrow_constructible_v<std::vector<bool, type-parameter-0-0>::_Mybase, const _Alloc &>vector<bool, type-parameter-0-0>(const _Alloc &_Al) noexcept(is_nothrow_constructible_v<std::vector<bool, type-parameter-0-0>::_Mybase, const _Alloc &>) : std::vector<bool, type-parameter-0-0>::_Mybase(_Al)         {
        }
        explicit vector<bool, type-parameter-0-0>(std::vector<bool, type-parameter-0-0>::size_type _Count, const _Alloc &_Al = _Alloc()) : std::vector<bool, type-parameter-0-0>::_Mybase(_Count, false, _Al)         {
            this->_Trim(_Count);
        }
        vector<bool, type-parameter-0-0>(std::vector<bool, type-parameter-0-0>::size_type _Count, const bool &_Val, const _Alloc &_Al = _Alloc()) : std::vector<bool, type-parameter-0-0>::_Mybase(_Count, _Val, _Al)         {
            this->_Trim(_Count);
        }
        vector<bool, type-parameter-0-0>(const vector<bool, type-parameter-0-0> &_Right) : std::vector<bool, type-parameter-0-0>::_Mybase(_Right)         {
        }
        vector<bool, type-parameter-0-0>(const vector<bool, type-parameter-0-0> &_Right, const _Alloc &_Al) : std::vector<bool, type-parameter-0-0>::_Mybase(_Right, _Al)         {
        }
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> vector<bool, type-parameter-0-0>(_Iter _First, _Iter _Last, const _Alloc &_Al = _Alloc()) : std::vector<bool, type-parameter-0-0>::_Mybase(_Al)         {
            _BConstruct(_First, _Last);
        }
        template <class _Iter> void _BConstruct(_Iter _First, _Iter _Last)         {
            insert(begin(), _First, _Last);
        }
        vector<bool, type-parameter-0-0>(vector<bool, type-parameter-0-0> &&_Right) noexcept(is_nothrow_move_constructible_v<std::vector<bool, type-parameter-0-0>::_Mybase>vector<bool, type-parameter-0-0>(vector<bool, type-parameter-0-0> &&_Right) noexcept(is_nothrow_move_constructible_v<std::vector<bool, type-parameter-0-0>::_Mybase>) : std::vector<bool, type-parameter-0-0>::_Mybase(::std::move(_Right))         {
            this->_Swap_all(_Right);
        }
        vector<bool, type-parameter-0-0>(vector<bool, type-parameter-0-0> &&_Right, const _Alloc &_Al) noexcept(is_nothrow_constructible_v<std::vector<bool, type-parameter-0-0>::_Mybase, std::vector<bool, type-parameter-0-0>::_Mybase, const _Alloc &>vector<bool, type-parameter-0-0>(vector<bool, type-parameter-0-0> &&_Right, const _Alloc &_Al) noexcept(is_nothrow_constructible_v<std::vector<bool, type-parameter-0-0>::_Mybase, std::vector<bool, type-parameter-0-0>::_Mybase, const _Alloc &>) : std::vector<bool, type-parameter-0-0>::_Mybase(::std::move(_Right), _Al)         {
            const bool _Swap_iterators = _Alvbase_traits::is_always_equal::value || this->_Myvec._Getal() == _Right._Myvec._Getal();
            if (_Swap_iterators) {
                this->_Swap_all(_Right);
            }
        }
        vector<bool, type-parameter-0-0> &operator=(vector<bool, type-parameter-0-0> &&_Right) noexcept(is_nothrow_move_assignable_v<std::vector<bool, type-parameter-0-0>::_Mybase>operator=(vector<bool, type-parameter-0-0> &&_Right) noexcept(is_nothrow_move_assignable_v<std::vector<bool, type-parameter-0-0>::_Mybase>)         {
            if (this != ::std::addressof(_Right)) {
                this->clear();
                const bool _Reload = _Alvbase_traits::propagate_on_container_move_assignment::value && !_Alvbase_traits::is_always_equal::value && this->_Myvec._Getal() != _Right._Myvec._Getal();
                if (_Reload) {
                    this->_Free_proxy();
                }
                this->_Myvec = ::std::move(_Right._Myvec);
                if (_Reload) {
                    this->_Alloc_proxy();
                }
                this->_Mysize = _Right._Mysize;
                _Right._Mysize = 0;
                const bool _Swap_iterators = _Alvbase_traits::is_always_equal::value || this->_Myvec._Getal() == _Right._Myvec._Getal();
                if (_Swap_iterators) {
                    this->_Swap_all(_Right);
                }
            }
            return (*this);
        }
        template <class ..._Valty> decltype(auto) emplace_back(_Valty &&..._Val)         {
            bool _Tmp(::std::forward<_Valty>(_Val)...);
            this->push_back(_Tmp);
        }
        template <class ..._Valty> std::vector<bool, type-parameter-0-0>::iterator emplace(std::vector<bool, type-parameter-0-0>::const_iterator _Where, _Valty &&..._Val)         {
            bool _Tmp(::std::forward<_Valty>(_Val)...);
            return (insert(_Where, _Tmp));
        }
        vector<bool, type-parameter-0-0>(initializer_list<bool> _Ilist, const _Alloc &_Al = std::vector<bool, type-parameter-0-0>::allocator_type()) : std::vector<bool, type-parameter-0-0>::_Mybase(0, false, _Al)         {
            insert(begin(), _Ilist.begin(), _Ilist.end());
        }
        vector<bool, type-parameter-0-0> &operator=(initializer_list<bool> _Ilist)         {
            assign(_Ilist.begin(), _Ilist.end());
            return (*this);
        }
        void assign(initializer_list<bool> _Ilist)         {
            assign(_Ilist.begin(), _Ilist.end());
        }
        std::vector<bool, type-parameter-0-0>::iterator insert(std::vector<bool, type-parameter-0-0>::const_iterator _Where, initializer_list<bool> _Ilist)         {
            return (insert(_Where, _Ilist.begin(), _Ilist.end()));
        }
        ~vector<bool, type-parameter-0-0>() noexcept         {
        }
        vector<bool, type-parameter-0-0> &operator=(const vector<bool, type-parameter-0-0> &_Right)         {
            if (this != ::std::addressof(_Right)) {
                this->_Orphan_all();
                const bool _Reload = _Alvbase_traits::propagate_on_container_copy_assignment::value && this->_Myvec._Getal() != _Right._Myvec._Getal();
                if (_Reload) {
                    this->_Free_proxy();
                }
                this->_Myvec = _Right._Myvec;
                if (_Reload) {
                    this->_Alloc_proxy();
                }
                this->_Mysize = _Right._Mysize;
            }
            return (*this);
        }
        void reserve(std::vector<bool, type-parameter-0-0>::size_type _Count)         {
            this->_Myvec.reserve(this->_Nw(_Count));
        }
        std::vector<bool, type-parameter-0-0>::size_type capacity() const noexcept         {
            return (this->_Myvec.capacity() * _VBITS);
        }
        std::vector<bool, type-parameter-0-0>::iterator begin() noexcept         {
            return (std::vector<bool, type-parameter-0-0>::iterator(this->_Myvec.data(), this));
        }
        std::vector<bool, type-parameter-0-0>::const_iterator begin() const noexcept         {
            return (std::vector<bool, type-parameter-0-0>::const_iterator(this->_Myvec.data(), this));
        }
        std::vector<bool, type-parameter-0-0>::iterator end() noexcept         {
            return (begin() + static_cast<std::vector<bool, type-parameter-0-0>::difference_type>(this->_Mysize));
        }
        std::vector<bool, type-parameter-0-0>::const_iterator end() const noexcept         {
            return (begin() + static_cast<std::vector<bool, type-parameter-0-0>::difference_type>(this->_Mysize));
        }
        std::vector<bool, type-parameter-0-0>::const_iterator cbegin() const noexcept         {
            return (begin());
        }
        std::vector<bool, type-parameter-0-0>::const_iterator cend() const noexcept         {
            return (end());
        }
        std::vector<bool, type-parameter-0-0>::const_reverse_iterator crbegin() const noexcept         {
            return (rbegin());
        }
        std::vector<bool, type-parameter-0-0>::const_reverse_iterator crend() const noexcept         {
            return (rend());
        }
        void shrink_to_fit()         {
            if (this->_Myvec.capacity() != this->_Myvec.size()) {
                this->_Orphan_all();
                this->_Myvec.shrink_to_fit();
            }
        }
        std::vector<bool, type-parameter-0-0>::iterator _Make_iter(std::vector<bool, type-parameter-0-0>::const_iterator _Where)         {
            std::vector<bool, type-parameter-0-0>::iterator _Tmp = begin();
            if (0 < this->_Mysize)
                _Tmp += _Where - begin();
            return (_Tmp);
        }
        std::vector<bool, type-parameter-0-0>::reverse_iterator rbegin() noexcept         {
            return (std::vector<bool, type-parameter-0-0>::reverse_iterator(end()));
        }
        std::vector<bool, type-parameter-0-0>::const_reverse_iterator rbegin() const noexcept         {
            return (std::vector<bool, type-parameter-0-0>::const_reverse_iterator(end()));
        }
        std::vector<bool, type-parameter-0-0>::reverse_iterator rend() noexcept         {
            return (std::vector<bool, type-parameter-0-0>::reverse_iterator(begin()));
        }
        std::vector<bool, type-parameter-0-0>::const_reverse_iterator rend() const noexcept         {
            return (std::vector<bool, type-parameter-0-0>::const_reverse_iterator(begin()));
        }
        void resize(std::vector<bool, type-parameter-0-0>::size_type _Newsize, bool _Val = false)         {
            if (this->size() < _Newsize)
                this->_Insert_n(end(), _Newsize - this->size(), _Val);
            else if (_Newsize < this->size())
                erase(begin() + static_cast<std::vector<bool, type-parameter-0-0>::difference_type>(_Newsize), end());
        }
        std::vector<bool, type-parameter-0-0>::size_type size() const noexcept         {
            return (this->_Mysize);
        }
        std::vector<bool, type-parameter-0-0>::size_type max_size() const noexcept         {
            constexpr std::vector<bool, type-parameter-0-0>::size_type _Diff_max = static_cast<std::vector<bool, type-parameter-0-0>::size_type>((numeric_limits<difference_type>::max)());
            const std::vector<bool, type-parameter-0-0>::size_type _Ints_max = this->_Myvec.max_size();
            if (_Ints_max > _Diff_max / _VBITS) {
                return (_Diff_max);
            }
            return (_Ints_max * _VBITS);
        }
        bool empty() const noexcept         {
            return (this->size() == 0);
        }
        std::vector<bool, type-parameter-0-0>::allocator_type get_allocator() const noexcept         {
            return (static_cast<std::vector<bool, type-parameter-0-0>::allocator_type>(this->_Myvec.get_allocator()));
        }
        std::vector<bool, type-parameter-0-0>::const_reference at(std::vector<bool, type-parameter-0-0>::size_type _Off) const         {
            if (this->size() <= _Off)
                this->_Xran();
            return ((*this)[_Off]);
        }
        std::vector<bool, type-parameter-0-0>::reference at(std::vector<bool, type-parameter-0-0>::size_type _Off)         {
            if (this->size() <= _Off)
                this->_Xran();
            return ((*this)[_Off]);
        }
        std::vector<bool, type-parameter-0-0>::const_reference operator[](std::vector<bool, type-parameter-0-0>::size_type _Off) const         {
            std::vector<bool, type-parameter-0-0>::const_iterator _It = begin();
            _It._Advance(_Off);
            return (*_It);
        }
        std::vector<bool, type-parameter-0-0>::reference operator[](std::vector<bool, type-parameter-0-0>::size_type _Off)         {
            std::vector<bool, type-parameter-0-0>::iterator _It = begin();
            _It._Advance(_Off);
            return (*_It);
        }
        std::vector<bool, type-parameter-0-0>::reference front()         {
            return (*begin());
        }
        std::vector<bool, type-parameter-0-0>::const_reference front() const         {
            return (*begin());
        }
        std::vector<bool, type-parameter-0-0>::reference back()         {
            return (*(end() - 1));
        }
        std::vector<bool, type-parameter-0-0>::const_reference back() const         {
            return (*(end() - 1));
        }
        void push_back(const bool &_Val)         {
            insert(end(), _Val);
        }
        void pop_back()         {
            erase(end() - 1);
        }
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> void assign(_Iter _First, _Iter _Last)         {
            erase(begin(), end());
            insert(begin(), _First, _Last);
        }
        void assign(std::vector<bool, type-parameter-0-0>::size_type _Count, const bool &_Val)         {
            erase(begin(), end());
            this->_Insert_n(begin(), _Count, _Val);
        }
        std::vector<bool, type-parameter-0-0>::iterator insert(std::vector<bool, type-parameter-0-0>::const_iterator _Where, const bool &_Val)         {
            return (this->_Insert_n(_Where, static_cast<std::vector<bool, type-parameter-0-0>::size_type>(1), _Val));
        }
        std::vector<bool, type-parameter-0-0>::iterator insert(std::vector<bool, type-parameter-0-0>::const_iterator _Where, std::vector<bool, type-parameter-0-0>::size_type _Count, const bool &_Val)         {
            return (this->_Insert_n(_Where, _Count, _Val));
        }
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> std::vector<bool, type-parameter-0-0>::iterator insert(std::vector<bool, type-parameter-0-0>::const_iterator _Where, _Iter _First, _Iter _Last)         {
            std::vector<bool, type-parameter-0-0>::difference_type _Off = _Where - begin();
            _Insert(_Where, _First, _Last, _Iter_cat_t<_Iter>());
            return (begin() + _Off);
        }
        template <class _Iter> void _Insert(std::vector<bool, type-parameter-0-0>::const_iterator _Where, _Iter _First, _Iter _Last, std::input_iterator_tag)         {
            std::vector<bool, type-parameter-0-0>::difference_type _Off = _Where - begin();
            for (; _First != _Last; ++_First , (void)++_Off)
                insert(begin() + _Off, *_First);
        }
        template <class _Iter> void _Insert(std::vector<bool, type-parameter-0-0>::const_iterator _Where, _Iter _First, _Iter _Last, std::forward_iterator_tag)         {
            _Adl_verify_range(_First, _Last);
            std::vector<bool, type-parameter-0-0>::size_type _Count = _Convert_size<std::vector<bool, type-parameter-0-0>::size_type>(static_cast<size_t>(::std::distance(_First, _Last)));
            std::vector<bool, type-parameter-0-0>::size_type _Off = this->_Insert_x(_Where, _Count);
            _Copy_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), begin() + static_cast<std::vector<bool, type-parameter-0-0>::difference_type>(_Off));
        }
        std::vector<bool, type-parameter-0-0>::iterator erase(std::vector<bool, type-parameter-0-0>::const_iterator _Where_arg)         {
            std::vector<bool, type-parameter-0-0>::iterator _Where = this->_Make_iter(_Where_arg);
            std::vector<bool, type-parameter-0-0>::difference_type _Off = _Where - begin();
            ::std::copy(_Where + 1, end(), _Where);
            this->_Trim(this->_Mysize - 1);
            return (begin() + _Off);
        }
        std::vector<bool, type-parameter-0-0>::iterator erase(std::vector<bool, type-parameter-0-0>::const_iterator _First_arg, std::vector<bool, type-parameter-0-0>::const_iterator _Last_arg)         {
            std::vector<bool, type-parameter-0-0>::iterator _First = this->_Make_iter(_First_arg);
            std::vector<bool, type-parameter-0-0>::iterator _Last = this->_Make_iter(_Last_arg);
            std::vector<bool, type-parameter-0-0>::difference_type _Off = _First - begin();
            if (_First != _Last) {
                std::vector<bool, type-parameter-0-0>::iterator _Next = ::std::copy(_Last, end(), _First);
                this->_Trim(static_cast<std::vector<bool, type-parameter-0-0>::size_type>(_Next - begin()));
            }
            return (begin() + _Off);
        }
        void clear() noexcept         {
            erase(begin(), end());
        }
        void flip() noexcept         {
            for (auto &_Elem : this->_Myvec) {
                _Elem = ~_Elem;
            }
            this->_Trim(this->_Mysize);
        }
        void swap(vector<bool, type-parameter-0-0> &_Right) noexcept         {
            if (this != ::std::addressof(_Right)) {
                this->_Swap_all(_Right);
                this->_Myvec.swap(_Right._Myvec);
                ::std::swap(this->_Mysize, _Right._Mysize);
            }
        }
        static void swap(std::vector<bool, type-parameter-0-0>::reference _Left, std::vector<bool, type-parameter-0-0>::reference _Right) noexcept         {
            bool _Val = _Left;
            _Left = _Right;
            _Right = _Val;
        }
        friend  hash<vector<bool, _Alloc> >;
        std::vector<bool, type-parameter-0-0>::iterator _Insert_n(std::vector<bool, type-parameter-0-0>::const_iterator _Where, std::vector<bool, type-parameter-0-0>::size_type _Count, const bool &_Val)         {
            std::vector<bool, type-parameter-0-0>::size_type _Off = this->_Insert_x(_Where, _Count);
            const auto _Result = begin() + static_cast<std::vector<bool, type-parameter-0-0>::difference_type>(_Off);
            ::std::fill(_Result, _Result + static_cast<std::vector<bool, type-parameter-0-0>::difference_type>(_Count), _Val);
            return (_Result);
        }
        std::vector<bool, type-parameter-0-0>::size_type _Insert_x(std::vector<bool, type-parameter-0-0>::const_iterator _Where, std::vector<bool, type-parameter-0-0>::size_type _Count)         {
            std::vector<bool, type-parameter-0-0>::difference_type _Off = _Where - begin();
            if (_Count != 0) {
                if (this->max_size() - this->size() < _Count) {
                    this->_Xlen();
                }
                this->_Myvec.resize(this->_Nw(this->size() + _Count), 0);
                if (this->empty()) {
                    this->_Mysize += _Count;
                } else {
                    std::vector<bool, type-parameter-0-0>::iterator _Oldend = end();
                    this->_Mysize += _Count;
                    ::std::copy_backward(begin() + _Off, _Oldend, end());
                }
            }
            return (static_cast<std::vector<bool, type-parameter-0-0>::size_type>(_Off));
        }
        void _Orphan_range(std::vector<bool, type-parameter-0-0>::size_type, std::vector<bool, type-parameter-0-0>::size_type) const         {
        }
        void _Trim(std::vector<bool, type-parameter-0-0>::size_type _Size)         {
            if (this->max_size() < _Size)
                this->_Xlen();
            const std::vector<bool, type-parameter-0-0>::size_type _Words = this->_Nw(_Size);
            if (_Words < this->_Myvec.size())
                this->_Myvec.erase(this->_Myvec.begin() + static_cast<std::vector<bool, type-parameter-0-0>::difference_type>(_Words), this->_Myvec.end());
            this->_Mysize = _Size;
            _Size %= _VBITS;
            if (0 < _Size)
                this->_Myvec[_Words - 1] &= (static_cast<std::_Vbase>(1) << _Size) - 1;
        }
        void _Xlen() const [[noreturn]]         {
            _Xlength_error("vector<bool> too long");
        }
        void _Xran() const [[noreturn]]         {
            _Xout_of_range("invalid vector<bool> subscript");
        }
    };
    template <class _Alloc> inline bool operator==(const vector<bool, _Alloc> &_Left, const vector<bool, _Alloc> &_Right)     {
        return (_Left.size() == _Right.size() && _Left._Myvec == _Right._Myvec);
    }
    template <class _Alloc> inline bool operator!=(const vector<bool, _Alloc> &_Left, const vector<bool, _Alloc> &_Right)     {
        return (!(_Left == _Right));
    }
    template <class _Alloc> struct hash<vector<bool, type-parameter-0-0>> {
        typedef vector<bool, _Alloc> argument_type;
        typedef size_t result_type;
        size_t operator()(const vector<bool, _Alloc> &_Keyval) const noexcept         {
            return (_Hash_array_representation(_Keyval._Myvec.data(), _Keyval._Myvec.size()));
        }
    };
}
namespace v8 {
    class Context;
    class Data;
    class Isolate;
    namespace internal {
        class Isolate;
        typedef uintptr_t Address;
        static const v8::internal::Address kNullAddress = 0;
        const int kApiSystemPointerSize = sizeof(void *);
        const int kApiDoubleSize = sizeof(double);
        const int kApiInt32Size = sizeof(int32_t);
        const int kApiInt64Size = sizeof(int64_t);
        const int kHeapObjectTag = 1;
        const int kWeakHeapObjectTag = 3;
        const int kHeapObjectTagSize = 2;
        const intptr_t kHeapObjectTagMask = (1 << kHeapObjectTagSize) - 1;
        const int kSmiTag = 0;
        const int kSmiTagSize = 1;
        const intptr_t kSmiTagMask = (1 << kSmiTagSize) - 1;
        template <size_t tagged_ptr_size> struct SmiTagging;
        constexpr intptr_t kIntptrAllBitsSet = intptr_t{-1};
        constexpr uintptr_t kUintptrAllBitsSet = static_cast<uintptr_t>(kIntptrAllBitsSet);
        template<> struct SmiTagging<4> {
            enum  {
                kSmiShiftSize = 0,
                kSmiValueSize = 31
            };
            static constexpr intptr_t kSmiMinValue = static_cast<intptr_t>(kUintptrAllBitsSet << (kSmiValueSize - 1));
            static constexpr intptr_t kSmiMaxValue = -(kSmiMinValue + 1);
            static inline int SmiToInt(const internal::Address value) __attribute__((always_inline))             {
                int shift_bits = kSmiTagSize + kSmiShiftSize;
                return static_cast<int>(static_cast<intptr_t>(value)) >> shift_bits;
            }
            static inline constexpr bool IsValidSmi(intptr_t value) __attribute__((always_inline))             {
                return (static_cast<uintptr_t>(value) - static_cast<uintptr_t>(kSmiMinValue)) <= (static_cast<uintptr_t>(kSmiMaxValue) - static_cast<uintptr_t>(kSmiMinValue));
            }
        };
        template<> struct SmiTagging<8> {
            enum  {
                kSmiShiftSize = 31,
                kSmiValueSize = 32
            };
            static constexpr intptr_t kSmiMinValue = static_cast<intptr_t>(kUintptrAllBitsSet << (kSmiValueSize - 1));
            static constexpr intptr_t kSmiMaxValue = -(kSmiMinValue + 1);
            static inline int SmiToInt(const internal::Address value) __attribute__((always_inline))             {
                int shift_bits = kSmiTagSize + kSmiShiftSize;
                return static_cast<int>(static_cast<intptr_t>(value) >> shift_bits);
            }
            static inline constexpr bool IsValidSmi(intptr_t value) __attribute__((always_inline))             {
                return (value == static_cast<int32_t>(value));
            }
        };
        const int kApiTaggedSize = kApiSystemPointerSize;
        using PlatformSmiTagging = SmiTagging<kApiTaggedSize>;
        const int kSmiShiftSize = PlatformSmiTagging::kSmiShiftSize;
        const int kSmiValueSize = PlatformSmiTagging::kSmiValueSize;
        const int kSmiMinValue = static_cast<int>(PlatformSmiTagging::kSmiMinValue);
        const int kSmiMaxValue = static_cast<int>(PlatformSmiTagging::kSmiMaxValue);
        constexpr bool SmiValuesAre31Bits()         {
            return kSmiValueSize == 31;
        }
        constexpr bool SmiValuesAre32Bits()         {
            return kSmiValueSize == 32;
        }
        static inline constexpr internal::Address IntToSmi(int value) __attribute__((always_inline))         {
            return (static_cast<v8::internal::Address>(value) << (kSmiTagSize + kSmiShiftSize)) | kSmiTag;
        }
        class Internals {
        public:
            static const int kHeapObjectMapOffset = 0;
            static const int kMapInstanceTypeOffset = 1 * kApiTaggedSize + kApiInt32Size;
            static const int kStringResourceOffset = 1 * kApiTaggedSize + 2 * kApiInt32Size;
            static const int kOddballKindOffset = 4 * kApiTaggedSize + kApiDoubleSize;
            static const int kForeignAddressOffset = kApiTaggedSize;
            static const int kJSObjectHeaderSize = 3 * kApiTaggedSize;
            static const int kFixedArrayHeaderSize = 2 * kApiTaggedSize;
            static const int kEmbedderDataArrayHeaderSize = 2 * kApiTaggedSize;
            static const int kEmbedderDataSlotSize = kApiSystemPointerSize;
            static const int kNativeContextEmbedderDataOffset = 7 * kApiTaggedSize;
            static const int kFullStringRepresentationMask = 15;
            static const int kStringEncodingMask = 8;
            static const int kExternalTwoByteRepresentationTag = 2;
            static const int kExternalOneByteRepresentationTag = 10;
            static const uint32_t kNumIsolateDataSlots = 4;
            static const int kIsolateEmbedderDataOffset = 0;
            static const int kExternalMemoryOffset = kNumIsolateDataSlots * kApiSystemPointerSize;
            static const int kExternalMemoryLimitOffset = kExternalMemoryOffset + kApiInt64Size;
            static const int kExternalMemoryAtLastMarkCompactOffset = kExternalMemoryLimitOffset + kApiInt64Size;
            static const int kIsolateRootsOffset = kExternalMemoryAtLastMarkCompactOffset + kApiInt64Size;
            static const int kUndefinedValueRootIndex = 4;
            static const int kTheHoleValueRootIndex = 5;
            static const int kNullValueRootIndex = 6;
            static const int kTrueValueRootIndex = 7;
            static const int kFalseValueRootIndex = 8;
            static const int kEmptyStringRootIndex = 9;
            static const int kNodeClassIdOffset = 1 * kApiSystemPointerSize;
            static const int kNodeFlagsOffset = 1 * kApiSystemPointerSize + 3;
            static const int kNodeStateMask = 7;
            static const int kNodeStateIsWeakValue = 2;
            static const int kNodeStateIsPendingValue = 3;
            static const int kFirstNonstringType = 64;
            static const int kOddballType = 67;
            static const int kForeignType = 71;
            static const int kJSSpecialApiObjectType = 1040;
            static const int kJSApiObjectType = 1056;
            static const int kJSObjectType = 1057;
            static const int kUndefinedOddballKind = 5;
            static const int kNullOddballKind = 3;
            static const int kThrowOnError = 0;
            static const int kDontThrow = 1;
            static const int kInferShouldThrowMode = 2;
            static constexpr int kExternalAllocationSoftLimit = 64 * 1024 * 1024;
            static void CheckInitializedImpl(v8::Isolate *isolate);
            static inline void CheckInitialized(v8::Isolate *isolate) __attribute__((always_inline))             {
            }
            static inline bool HasHeapObjectTag(const internal::Address value) __attribute__((always_inline))             {
                return (value & kHeapObjectTagMask) == static_cast<v8::internal::Address>(kHeapObjectTag);
            }
            static inline int SmiValue(const internal::Address value) __attribute__((always_inline))             {
                return PlatformSmiTagging::SmiToInt(value);
            }
            static inline constexpr internal::Address IntToSmi(int value) __attribute__((always_inline))             {
                return internal::IntToSmi(value);
            }
            static inline constexpr bool IsValidSmi(intptr_t value) __attribute__((always_inline))             {
                return PlatformSmiTagging::IsValidSmi(value);
            }
            static inline int GetInstanceType(const internal::Address obj) __attribute__((always_inline))             {
                typedef internal::Address A;
                A map = ReadTaggedPointerField(obj, kHeapObjectMapOffset);
                return ReadRawField<uint16_t>(map, kMapInstanceTypeOffset);
            }
            static inline int GetOddballKind(const internal::Address obj) __attribute__((always_inline))             {
                return SmiValue(ReadTaggedSignedField(obj, kOddballKindOffset));
            }
            static inline bool IsExternalTwoByteString(int instance_type) __attribute__((always_inline))             {
                int representation = (instance_type & kFullStringRepresentationMask);
                return representation == kExternalTwoByteRepresentationTag;
            }
            static inline uint8_t GetNodeFlag(internal::Address *obj, int shift) __attribute__((always_inline))             {
                uint8_t *addr = reinterpret_cast<uint8_t *>(obj) + kNodeFlagsOffset;
                return *addr & static_cast<uint8_t>(1U << shift);
            }
            static inline void UpdateNodeFlag(internal::Address *obj, bool value, int shift) __attribute__((always_inline))             {
                uint8_t *addr = reinterpret_cast<uint8_t *>(obj) + kNodeFlagsOffset;
                uint8_t mask = static_cast<uint8_t>(1U << shift);
                *addr = static_cast<uint8_t>((*addr & ~mask) | (value << shift));
            }
            static inline uint8_t GetNodeState(internal::Address *obj) __attribute__((always_inline))             {
                uint8_t *addr = reinterpret_cast<uint8_t *>(obj) + kNodeFlagsOffset;
                return *addr & kNodeStateMask;
            }
            static inline void UpdateNodeState(internal::Address *obj, uint8_t value) __attribute__((always_inline))             {
                uint8_t *addr = reinterpret_cast<uint8_t *>(obj) + kNodeFlagsOffset;
                *addr = static_cast<uint8_t>((*addr & ~kNodeStateMask) | value);
            }
            static inline void SetEmbedderData(v8::Isolate *isolate, uint32_t slot, void *data) __attribute__((always_inline))             {
                internal::Address addr = reinterpret_cast<internal::Address>(isolate) + kIsolateEmbedderDataOffset + slot * kApiSystemPointerSize;
                *reinterpret_cast<void **>(addr) = data;
            }
            static inline void *GetEmbedderData(const v8::Isolate *isolate, uint32_t slot) __attribute__((always_inline))             {
                internal::Address addr = reinterpret_cast<internal::Address>(isolate) + kIsolateEmbedderDataOffset + slot * kApiSystemPointerSize;
                return *reinterpret_cast<void *const *>(addr);
            }
            static inline internal::Address *GetRoot(v8::Isolate *isolate, int index) __attribute__((always_inline))             {
                internal::Address addr = reinterpret_cast<internal::Address>(isolate) + kIsolateRootsOffset + index * kApiSystemPointerSize;
                return reinterpret_cast<internal::Address *>(addr);
            }
            template <typename T> static inline T ReadRawField(internal::Address heap_object_ptr, int offset) __attribute__((always_inline))             {
                internal::Address addr = heap_object_ptr + offset - kHeapObjectTag;
                return *reinterpret_cast<const T *>(addr);
            }
            template<> static inline unsigned short ReadRawField<unsigned short>(internal::Address heap_object_ptr, int offset) __attribute__((always_inline))             {
                internal::Address addr = heap_object_ptr + offset - kHeapObjectTag;
                return *reinterpret_cast<const unsigned short *>(addr);
            }
            template<> static inline unsigned long long ReadRawField<unsigned long long>(internal::Address heap_object_ptr, int offset) __attribute__((always_inline))             {
                internal::Address addr = heap_object_ptr + offset - kHeapObjectTag;
                return *reinterpret_cast<const unsigned long long *>(addr);
            }
            template<> static inline void *ReadRawField<void *>(internal::Address heap_object_ptr, int offset) __attribute__((always_inline))             {
                internal::Address addr = heap_object_ptr + offset - kHeapObjectTag;
                return *reinterpret_cast<void *const *>(addr);
            }
            static inline internal::Address ReadTaggedPointerField(internal::Address heap_object_ptr, int offset) __attribute__((always_inline))             {
                return ReadRawField<internal::Address>(heap_object_ptr, offset);
            }
            static inline internal::Address ReadTaggedSignedField(internal::Address heap_object_ptr, int offset) __attribute__((always_inline))             {
                return ReadRawField<internal::Address>(heap_object_ptr, offset);
            }
        };
        template <bool PerformCheck> struct CastCheck {
            template <class T> static void Perform(T *data);
        };
template<> struct CastCheck<true> {
            template <class T> static void Perform(T *data);
        };
template<> struct CastCheck<false> {
            template <class T> static void Perform(T *data);
        };
        template <> template <class T> void CastCheck<true>::Perform(T *data)         {
            T::Cast(data);
        }
        template <> template <class T> void CastCheck<false>::Perform(T *data)         {
        }
        template <class T> inline void PerformCastCheck(T *data) __attribute__((always_inline))         {
            CastCheck<std::is_base_of<Data, T>::value>::Perform(data);
        }
        internal::Isolate *IsolateFromNeverReadOnlySpaceObject(v8::internal::Address obj);
        bool ShouldThrowOnError(v8::internal::Isolate *isolate);
    }
}
namespace v8 {
    class AccessorSignature;
    class Array;
    class ArrayBuffer;
    class BigInt;
    class BigIntObject;
    class Boolean;
    class BooleanObject;
    class Context;
    class Data;
    class Date;
    class External;
    class Function;
    class FunctionTemplate;
    class HeapProfiler;
    class ImplementationUtilities;
    class Int32;
    class Integer;
    class Isolate;
    template <class T> class Maybe;
    class MicrotaskQueue;
    class Name;
    class Number;
    class NumberObject;
    class Object;
    class ObjectOperationDescriptor;
    class ObjectTemplate;
    class Platform;
    class Primitive;
    class Promise;
    class PropertyDescriptor;
    class Proxy;
    class RawOperationDescriptor;
    class Script;
    class SharedArrayBuffer;
    class Signature;
    class StartupData;
    class StackFrame;
    class StackTrace;
    class String;
    class StringObject;
    class Symbol;
    class SymbolObject;
    class PrimitiveArray;
    class Private;
    class Uint32;
    class Utils;
    class Value;
    class WasmModuleObject;
    template <class T> class Local
template<> class Local<v8::Primitive> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Primitive>(Local<v8::Primitive> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Primitive *operator->() const __attribute__((always_inline));
        inline v8::Primitive *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Primitive> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Primitive> New(v8::Isolate *isolate, Local<v8::Primitive> that);
        static inline Local<v8::Primitive> New(v8::Isolate *isolate, const PersistentBase<v8::Primitive> &that);
        static inline Local<v8::Primitive> New(v8::Isolate *isolate, const TracedGlobal<v8::Primitive> &that);
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Primitive *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<v8::Primitive> New(v8::Isolate *isolate, v8::Primitive *that);
        v8::Primitive *val_;
    }
template<> class Local<v8::Boolean> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Boolean>(Local<v8::Boolean> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline))         {
            return this->val_ == nullptr;
        }
        inline void Clear() __attribute__((always_inline));
        inline v8::Boolean *operator->() const __attribute__((always_inline))         {
            return this->val_;
        }
        inline v8::Boolean *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Boolean> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, Local<v8::Boolean> that) __attribute__((always_inline));
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, const PersistentBase<v8::Boolean> &that) __attribute__((always_inline));
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, const TracedGlobal<v8::Boolean> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Boolean *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, v8::Boolean *that) __attribute__((always_inline));
        v8::Boolean *val_;
    }
template<> class Local<v8::Value> {
    public:
        inline Local() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Value>(Local<v8::Value> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Value *operator->() const __attribute__((always_inline));
        inline v8::Value *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Value> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Value> New(v8::Isolate *isolate, Local<v8::Value> that) __attribute__((always_inline));
        static inline Local<v8::Value> New(v8::Isolate *isolate, const PersistentBase<v8::Value> &that) __attribute__((always_inline));
        static inline Local<v8::Value> New(v8::Isolate *isolate, const TracedGlobal<v8::Value> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Value *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<v8::Value> New(v8::Isolate *isolate, v8::Value *that) __attribute__((always_inline));
        v8::Value *val_;
    }
template<> class Local<v8::PrimitiveArray> {
    public:
        inline Local() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::PrimitiveArray>(Local<v8::PrimitiveArray> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::PrimitiveArray *operator->() const __attribute__((always_inline));
        inline v8::PrimitiveArray *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::PrimitiveArray> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::PrimitiveArray> New(v8::Isolate *isolate, Local<v8::PrimitiveArray> that) __attribute__((always_inline));
        static inline Local<v8::PrimitiveArray> New(v8::Isolate *isolate, const PersistentBase<v8::PrimitiveArray> &that) __attribute__((always_inline));
        static inline Local<v8::PrimitiveArray> New(v8::Isolate *isolate, const TracedGlobal<v8::PrimitiveArray> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::PrimitiveArray *that) __attribute__((always_inline));
        static inline Local<v8::PrimitiveArray> New(v8::Isolate *isolate, v8::PrimitiveArray *that) __attribute__((always_inline));
        v8::PrimitiveArray *val_;
    }
template<> class Local<v8::Integer> {
    public:
        inline Local() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Integer>(Local<v8::Integer> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Integer *operator->() const __attribute__((always_inline));
        inline v8::Integer *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Integer> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Integer> New(v8::Isolate *isolate, Local<v8::Integer> that) __attribute__((always_inline));
        static inline Local<v8::Integer> New(v8::Isolate *isolate, const PersistentBase<v8::Integer> &that) __attribute__((always_inline));
        static inline Local<v8::Integer> New(v8::Isolate *isolate, const TracedGlobal<v8::Integer> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Integer *that) __attribute__((always_inline));
        static inline Local<v8::Integer> New(v8::Isolate *isolate, v8::Integer *that) __attribute__((always_inline));
        v8::Integer *val_;
    }
template<> class Local<v8::String> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::String>(Local<v8::String> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::String *operator->() const __attribute__((always_inline));
        inline v8::String *operator*() const __attribute__((always_inline))         {
            return this->val_;
        }
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::String> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::String> New(v8::Isolate *isolate, Local<v8::String> that) __attribute__((always_inline));
        static inline Local<v8::String> New(v8::Isolate *isolate, const PersistentBase<v8::String> &that) __attribute__((always_inline));
        static inline Local<v8::String> New(v8::Isolate *isolate, const TracedGlobal<v8::String> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::String *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<v8::String> New(v8::Isolate *isolate, v8::String *that) __attribute__((always_inline));
        v8::String *val_;
    }
template<> class Local<v8::Context> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Context>(Local<v8::Context> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Context *operator->() const __attribute__((always_inline))         {
            return this->val_;
        }
        inline v8::Context *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Context> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Context> New(v8::Isolate *isolate, Local<v8::Context> that) __attribute__((always_inline));
        static inline Local<v8::Context> New(v8::Isolate *isolate, const PersistentBase<v8::Context> &that) __attribute__((always_inline));
        static inline Local<v8::Context> New(v8::Isolate *isolate, const TracedGlobal<v8::Context> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Context *that) __attribute__((always_inline));
        static inline Local<v8::Context> New(v8::Isolate *isolate, v8::Context *that) __attribute__((always_inline));
        v8::Context *val_;
    }
template<> class Local<v8::UnboundScript> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::UnboundScript *operator->() const __attribute__((always_inline));
        inline v8::UnboundScript *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::UnboundScript> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::UnboundScript> New(v8::Isolate *isolate, Local<v8::UnboundScript> that) __attribute__((always_inline));
        static inline Local<v8::UnboundScript> New(v8::Isolate *isolate, const PersistentBase<v8::UnboundScript> &that) __attribute__((always_inline));
        static inline Local<v8::UnboundScript> New(v8::Isolate *isolate, const TracedGlobal<v8::UnboundScript> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::UnboundScript *that) __attribute__((always_inline));
        static inline Local<v8::UnboundScript> New(v8::Isolate *isolate, v8::UnboundScript *that) __attribute__((always_inline));
        v8::UnboundScript *val_;
    }
template<> class Local<v8::Object> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Object>(Local<v8::Object> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Object *operator->() const __attribute__((always_inline));
        inline v8::Object *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Object> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Object> New(v8::Isolate *isolate, Local<v8::Object> that);
        static inline Local<v8::Object> New(v8::Isolate *isolate, const PersistentBase<v8::Object> &that);
        static inline Local<v8::Object> New(v8::Isolate *isolate, const TracedGlobal<v8::Object> &that);
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Object *that) __attribute__((always_inline));
        static inline Local<v8::Object> New(v8::Isolate *isolate, v8::Object *that);
        v8::Object *val_;
    }
template<> class Local<v8::Function> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Function>(Local<v8::Function> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Function *operator->() const __attribute__((always_inline));
        inline v8::Function *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Function> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Function> New(v8::Isolate *isolate, Local<v8::Function> that) __attribute__((always_inline));
        static inline Local<v8::Function> New(v8::Isolate *isolate, const PersistentBase<v8::Function> &that) __attribute__((always_inline));
        static inline Local<v8::Function> New(v8::Isolate *isolate, const TracedGlobal<v8::Function> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Function *that) __attribute__((always_inline));
        static inline Local<v8::Function> New(v8::Isolate *isolate, v8::Function *that) __attribute__((always_inline));
        v8::Function *val_;
    }
template<> class Local<v8::Name> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::String>(Local<v8::String> that) : val_(reinterpret_cast<v8::Name *>(* that)) __attribute__((always_inline))         {
            while (false)
                {
                    *(static_cast<v8::Name *volatile *>(0)) = static_cast<v8::String *>(0);
                }
            ;
        }
;
        template<> inline Local<v8::Name>(Local<v8::Name> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Name *operator->() const __attribute__((always_inline));
        inline v8::Name *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Name> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Name> New(v8::Isolate *isolate, Local<v8::Name> that);
        static inline Local<v8::Name> New(v8::Isolate *isolate, const PersistentBase<v8::Name> &that);
        static inline Local<v8::Name> New(v8::Isolate *isolate, const TracedGlobal<v8::Name> &that);
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Name *that) __attribute__((always_inline));
        static inline Local<v8::Name> New(v8::Isolate *isolate, v8::Name *that);
        v8::Name *val_;
    }
template<> class Local<v8::FunctionTemplate> {
    public:
        inline Local() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::FunctionTemplate>(Local<v8::FunctionTemplate> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::FunctionTemplate *operator->() const __attribute__((always_inline));
        inline v8::FunctionTemplate *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::FunctionTemplate> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::FunctionTemplate> New(v8::Isolate *isolate, Local<v8::FunctionTemplate> that) __attribute__((always_inline));
        static inline Local<v8::FunctionTemplate> New(v8::Isolate *isolate, const PersistentBase<v8::FunctionTemplate> &that) __attribute__((always_inline));
        static inline Local<v8::FunctionTemplate> New(v8::Isolate *isolate, const TracedGlobal<v8::FunctionTemplate> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::FunctionTemplate *that) __attribute__((always_inline));
        static inline Local<v8::FunctionTemplate> New(v8::Isolate *isolate, v8::FunctionTemplate *that) __attribute__((always_inline));
        v8::FunctionTemplate *val_;
    }
template<> class Local<v8::Promise> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Promise>(Local<v8::Promise> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Promise *operator->() const __attribute__((always_inline));
        inline v8::Promise *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Promise> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Promise> New(v8::Isolate *isolate, Local<v8::Promise> that) __attribute__((always_inline));
        static inline Local<v8::Promise> New(v8::Isolate *isolate, const PersistentBase<v8::Promise> &that) __attribute__((always_inline));
        static inline Local<v8::Promise> New(v8::Isolate *isolate, const TracedGlobal<v8::Promise> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Promise *that) __attribute__((always_inline));
        static inline Local<v8::Promise> New(v8::Isolate *isolate, v8::Promise *that) __attribute__((always_inline));
        v8::Promise *val_;
    }
template<> class Local<v8::Data> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Data>(Local<v8::Data> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Data *operator->() const __attribute__((always_inline));
        inline v8::Data *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Data> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Data> New(v8::Isolate *isolate, Local<v8::Data> that);
        static inline Local<v8::Data> New(v8::Isolate *isolate, const PersistentBase<v8::Data> &that);
        static inline Local<v8::Data> New(v8::Isolate *isolate, const TracedGlobal<v8::Data> &that);
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Data *that) __attribute__((always_inline));
        static inline Local<v8::Data> New(v8::Isolate *isolate, v8::Data *that);
        v8::Data *val_;
    }
template<> class Local<v8::AccessorSignature> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::AccessorSignature>(Local<v8::AccessorSignature> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::AccessorSignature *operator->() const __attribute__((always_inline));
        inline v8::AccessorSignature *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::AccessorSignature> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::AccessorSignature> New(v8::Isolate *isolate, Local<v8::AccessorSignature> that) __attribute__((always_inline));
        static inline Local<v8::AccessorSignature> New(v8::Isolate *isolate, const PersistentBase<v8::AccessorSignature> &that) __attribute__((always_inline));
        static inline Local<v8::AccessorSignature> New(v8::Isolate *isolate, const TracedGlobal<v8::AccessorSignature> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::AccessorSignature *that) __attribute__((always_inline));
        static inline Local<v8::AccessorSignature> New(v8::Isolate *isolate, v8::AccessorSignature *that) __attribute__((always_inline));
        v8::AccessorSignature *val_;
    }
template<> class Local<v8::Signature> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Signature>(Local<v8::Signature> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Signature *operator->() const __attribute__((always_inline));
        inline v8::Signature *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Signature> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Signature> New(v8::Isolate *isolate, Local<v8::Signature> that) __attribute__((always_inline));
        static inline Local<v8::Signature> New(v8::Isolate *isolate, const PersistentBase<v8::Signature> &that) __attribute__((always_inline));
        static inline Local<v8::Signature> New(v8::Isolate *isolate, const TracedGlobal<v8::Signature> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Signature *that) __attribute__((always_inline));
        static inline Local<v8::Signature> New(v8::Isolate *isolate, v8::Signature *that) __attribute__((always_inline));
        v8::Signature *val_;
    };
    template <class T> class MaybeLocal
template<> class MaybeLocal<v8::Value> {
    public:
        inline MaybeLocal() __attribute__((always_inline));
        template <class S> inline MaybeLocal(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((warn_unused_result)) __attribute__((always_inline));
        inline Local<v8::Value> ToLocalChecked() __attribute__((always_inline));
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline));
    private:
        v8::Value *val_;
    }
template<> class MaybeLocal<v8::String> {
    public:
        inline MaybeLocal() __attribute__((always_inline));
        template <class S> inline MaybeLocal(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((warn_unused_result)) __attribute__((always_inline));
        inline Local<v8::String> MaybeLocal<String>::ToLocalChecked()         {
            if ((__builtin_expect(!!(this->val_ == nullptr), 0)))
                V8::ToLocalEmpty();
            return Local<v8::String>(this->val_);
        }
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline));
    private:
        v8::String *val_;
    }
template<> class MaybeLocal<v8::Object> {
    public:
        inline MaybeLocal() __attribute__((always_inline));
        template <class S> inline MaybeLocal(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((warn_unused_result)) __attribute__((always_inline));
        inline Local<v8::Object> ToLocalChecked() __attribute__((always_inline));
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline));
    private:
        v8::Object *val_;
    }
template<> class MaybeLocal<v8::ObjectTemplate> {
    public:
        inline MaybeLocal() __attribute__((always_inline));
        template <class S> inline MaybeLocal(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((warn_unused_result)) __attribute__((always_inline));
        inline Local<v8::ObjectTemplate> ToLocalChecked() __attribute__((always_inline));
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline));
    private:
        v8::ObjectTemplate *val_;
    };
    template <class T> class Eternal;
    template <class T> class NonCopyablePersistentTraits;
    template <class T> class PersistentBase
template<> class PersistentBase<v8::Object> {
    public:
        inline void Reset() __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const Local<S> &other) __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const PersistentBase<S> &other) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Empty() __attribute__((always_inline));
        inline Local<v8::Object> Get(v8::Isolate *isolate) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <typename P> inline void SetWeak(P *parameter, typename WeakCallbackInfo<P>::Callback callback, v8::WeakCallbackType type) __attribute__((always_inline));
        inline void SetWeak() __attribute__((always_inline));
        template <typename P> inline P *ClearWeak() __attribute__((always_inline));
        inline void ClearWeak() __attribute__((always_inline));
        inline void AnnotateStrongRetainer(const char *label) __attribute__((always_inline));
        inline bool IsWeak() const __attribute__((always_inline));
        inline void SetWrapperClassId(uint16_t class_id) __attribute__((always_inline));
        inline uint16_t WrapperClassId() const __attribute__((always_inline));
        PersistentBase(const v8::PersistentBase<v8::Object> &other) = delete
        void operator=(const v8::PersistentBase<v8::Object> &) = delete
    private:
        friend  class Isolate;
        friend  class Utils;
        friend template <class F> class Local;
        friend template <class F1, class F2 = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Global;
        friend template <class F> class PersistentBase;
        friend template <class F> class ReturnValue;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend  class Object;
        inline explicit PersistentBase(v8::Object *val) __attribute__((always_inline));
        static inline v8::Object *New(v8::Isolate *isolate, v8::Object *that) __attribute__((always_inline));
        v8::Object *val_;
    }
template<> class PersistentBase<v8::Promise> {
    public:
        inline void Reset() __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const Local<S> &other) __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const PersistentBase<S> &other) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Empty() __attribute__((always_inline));
        inline Local<v8::Promise> Get(v8::Isolate *isolate) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <typename P> inline void SetWeak(P *parameter, typename WeakCallbackInfo<P>::Callback callback, v8::WeakCallbackType type) __attribute__((always_inline));
        inline void SetWeak() __attribute__((always_inline));
        template <typename P> inline P *ClearWeak() __attribute__((always_inline));
        inline void ClearWeak() __attribute__((always_inline));
        inline void AnnotateStrongRetainer(const char *label) __attribute__((always_inline));
        inline bool IsWeak() const __attribute__((always_inline));
        inline void SetWrapperClassId(uint16_t class_id) __attribute__((always_inline));
        inline uint16_t WrapperClassId() const __attribute__((always_inline));
        PersistentBase(const v8::PersistentBase<v8::Promise> &other) = delete
        void operator=(const v8::PersistentBase<v8::Promise> &) = delete
    private:
        friend  class Isolate;
        friend  class Utils;
        friend template <class F> class Local;
        friend template <class F1, class F2 = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Global;
        friend template <class F> class PersistentBase;
        friend template <class F> class ReturnValue;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend  class Object;
        inline explicit PersistentBase(v8::Promise *val) __attribute__((always_inline));
        static inline v8::Promise *New(v8::Isolate *isolate, v8::Promise *that) __attribute__((always_inline));
        v8::Promise *val_;
    };
    template <class T, class M = NonCopyablePersistentTraits<T>> class Persistent
template<> class Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise>> : public PersistentBase<v8::Promise> {
    public:
        inline Persistent() __attribute__((always_inline));
        template <class S> inline Persistent(v8::Isolate *isolate, Local<S> that) __attribute__((always_inline));
        template <class S, class M2> inline Persistent(v8::Isolate *isolate, const Persistent<S, M2> &that) __attribute__((always_inline));
        inline Persistent(const v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &that) __attribute__((always_inline));
        template <class S, class M2> inline Persistent(const Persistent<S, M2> &that) __attribute__((always_inline));
        template<> inline Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise>>(const Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &that) __attribute__((always_inline));
        inline v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &operator=(const v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &that) __attribute__((always_inline));
        template <class S, class M2> inline v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &operator=(const Persistent<S, M2> &that) __attribute__((always_inline));
        template<> inline v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &operator=<v8::Promise, v8::CopyablePersistentTraits<v8::Promise>>(const Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &that) __attribute__((always_inline));
        inline ~Persistent<Promise, CopyablePersistentTraits<Promise> >() noexcept __attribute__((always_inline));
        template <class S> static inline Persistent<v8::Promise> &Cast(const Persistent<S> &that) __attribute__((always_inline));
        template <class S> inline Persistent<S> &As() const __attribute__((always_inline));
    private:
        friend  class Isolate;
        friend  class Utils;
        friend template <class F> class Local;
        friend template <class F1, class F2 = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class ReturnValue;
        inline explicit Persistent(v8::Promise *that) __attribute__((always_inline));
        inline v8::Promise *operator*() const __attribute__((always_inline));
        template <class S, class M2> inline void Copy(const Persistent<S, M2> &that) __attribute__((always_inline));
    };
    template <class T> class Global;
    template <class T> class TracedGlobal
template<> class TracedGlobal<v8::Object> {
    public:
        TracedGlobal() = default
        ~TracedGlobal<Object>();
        template <class S> TracedGlobal(v8::Isolate *isolate, Local<S> that);
        inline TracedGlobal(v8::TracedGlobal<v8::Object> &&other) __attribute__((always_inline));
        template <class S> inline v8::TracedGlobal<v8::Object> &operator=(TracedGlobal<S> &&rhs) __attribute__((always_inline));
        TracedGlobal(const v8::TracedGlobal<v8::Object> &) = delete
        void operator=(const v8::TracedGlobal<v8::Object> &) = delete
        bool IsEmpty() const;
        inline void Reset() __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const Local<S> &other) __attribute__((always_inline));
        Local<v8::Object> Get(v8::Isolate *isolate) const;
        template <class S> inline TracedGlobal<S> &As() const __attribute__((always_inline));
        template <class S> inline bool operator==(const TracedGlobal<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const TracedGlobal<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        inline void SetWrapperClassId(uint16_t class_id) __attribute__((always_inline));
        inline uint16_t WrapperClassId() const __attribute__((always_inline));
        inline void SetFinalizationCallback(void *parameter, WeakCallbackInfo<void>::Callback callback) __attribute__((always_inline));
    private:
        static inline v8::Object *New(v8::Isolate *isolate, v8::Object *that, v8::Object **slot) __attribute__((always_inline));
        v8::Object *operator*() const;
        v8::Object *val_;
        friend  class EmbedderHeapTracer;
        friend template <typename F> class Local;
        friend  class Object;
        friend template <typename F> class ReturnValue;
    };
    template <class K, class V, class T> class PersistentValueMap;
    template <class K, class V, class T> class PersistentValueMapBase;
    template <class K, class V, class T> class GlobalValueMap;
    template <class V, class T> class PersistentValueVector;
    template <class T, class P> class WeakCallbackObject;
    class FunctionTemplate;
    class ObjectTemplate;
    template <typename T> class FunctionCallbackInfo;
    template <typename T> class PropertyCallbackInfo;
    class StackTrace;
    class StackFrame;
    class Isolate;
    class CallHandlerHelper;
    class EscapableHandleScope;
    template <typename T> class ReturnValue;
    namespace internal {
        class Arguments;
        class DeferredHandles;
        class Heap;
        class HeapObject;
        class ExternalString;
        class Isolate;
        class LocalEmbedderHeapTracer;
        class MicrotaskQueue;
        struct ScriptStreamingData;
        template <typename T> class CustomArguments;
        class PropertyCallbackArguments;
        class FunctionCallbackArguments;
        class GlobalHandles;
        class ScopedExternalStringLock;
        namespace wasm {
            class NativeModule;
            class StreamingDecoder;
        }
    }
    namespace debug {
        class ConsoleCallArguments;
    }
    template <class T> class Local {
    public:
        inline Local<T>() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local<T>(Local<S> that) : val_(reinterpret_cast<T *>(*that)) __attribute__((always_inline))         {
            while (false)
                {
                    *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
                }
            ;
        }
        inline bool IsEmpty() const __attribute__((always_inline))         {
            return this->val_ == nullptr;
        }
        inline void Clear() __attribute__((always_inline))         {
            this->val_ = nullptr;
        }
        inline T *operator->() const __attribute__((always_inline))         {
            return this->val_;
        }
        inline T *operator*() const __attribute__((always_inline))         {
            return this->val_;
        }
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline))         {
            internal::Address *a = reinterpret_cast<internal::Address *>(this->val_);
            internal::Address *b = reinterpret_cast<internal::Address *>(that.val_);
            if (a == nullptr)
                return b == nullptr;
            if (b == nullptr)
                return false;
            return *a == *b;
        }
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline))         {
            internal::Address *a = reinterpret_cast<internal::Address *>(this->val_);
            internal::Address *b = reinterpret_cast<internal::Address *>(that.val_);
            if (a == nullptr)
                return b == nullptr;
            if (b == nullptr)
                return false;
            return *a == *b;
        }
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline))         {
            return !operator==(that);
        }
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline))         {
            return !operator==(that);
        }
        template <class S> static inline Local<T> Cast(Local<S> that) __attribute__((always_inline))         {
            return Local<T>(T::Cast(*that));
        }
        template <class S> inline Local<S> As() const __attribute__((always_inline))         {
            return Local<S>::Cast(*this);
        }
        static inline Local<T> New(v8::Isolate *isolate, Local<T> that) __attribute__((always_inline));
        static inline Local<T> New(v8::Isolate *isolate, const PersistentBase<T> &that) __attribute__((always_inline));
        static inline Local<T> New(v8::Isolate *isolate, const TracedGlobal<T> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local<T>(T *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<T> New(v8::Isolate *isolate, T *that) __attribute__((always_inline));
        T *val_;
    };
template<> class Local<v8::Primitive> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Primitive>(Local<v8::Primitive> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Primitive *operator->() const __attribute__((always_inline));
        inline v8::Primitive *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Primitive> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Primitive> New(v8::Isolate *isolate, Local<v8::Primitive> that);
        static inline Local<v8::Primitive> New(v8::Isolate *isolate, const PersistentBase<v8::Primitive> &that);
        static inline Local<v8::Primitive> New(v8::Isolate *isolate, const TracedGlobal<v8::Primitive> &that);
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Primitive *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<v8::Primitive> New(v8::Isolate *isolate, v8::Primitive *that);
        v8::Primitive *val_;
    };
template<> class Local<v8::Boolean> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Boolean>(Local<v8::Boolean> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline))         {
            return this->val_ == nullptr;
        }
        inline void Clear() __attribute__((always_inline));
        inline v8::Boolean *operator->() const __attribute__((always_inline))         {
            return this->val_;
        }
        inline v8::Boolean *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Boolean> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, Local<v8::Boolean> that) __attribute__((always_inline));
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, const PersistentBase<v8::Boolean> &that) __attribute__((always_inline));
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, const TracedGlobal<v8::Boolean> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Boolean *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, v8::Boolean *that) __attribute__((always_inline));
        v8::Boolean *val_;
    };
template<> class Local<v8::Value> {
    public:
        inline Local() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Value>(Local<v8::Value> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Value *operator->() const __attribute__((always_inline));
        inline v8::Value *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Value> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Value> New(v8::Isolate *isolate, Local<v8::Value> that) __attribute__((always_inline));
        static inline Local<v8::Value> New(v8::Isolate *isolate, const PersistentBase<v8::Value> &that) __attribute__((always_inline));
        static inline Local<v8::Value> New(v8::Isolate *isolate, const TracedGlobal<v8::Value> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Value *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<v8::Value> New(v8::Isolate *isolate, v8::Value *that) __attribute__((always_inline));
        v8::Value *val_;
    };
template<> class Local<v8::PrimitiveArray> {
    public:
        inline Local() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::PrimitiveArray>(Local<v8::PrimitiveArray> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::PrimitiveArray *operator->() const __attribute__((always_inline));
        inline v8::PrimitiveArray *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::PrimitiveArray> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::PrimitiveArray> New(v8::Isolate *isolate, Local<v8::PrimitiveArray> that) __attribute__((always_inline));
        static inline Local<v8::PrimitiveArray> New(v8::Isolate *isolate, const PersistentBase<v8::PrimitiveArray> &that) __attribute__((always_inline));
        static inline Local<v8::PrimitiveArray> New(v8::Isolate *isolate, const TracedGlobal<v8::PrimitiveArray> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::PrimitiveArray *that) __attribute__((always_inline));
        static inline Local<v8::PrimitiveArray> New(v8::Isolate *isolate, v8::PrimitiveArray *that) __attribute__((always_inline));
        v8::PrimitiveArray *val_;
    };
template<> class Local<v8::Integer> {
    public:
        inline Local() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Integer>(Local<v8::Integer> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Integer *operator->() const __attribute__((always_inline));
        inline v8::Integer *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Integer> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Integer> New(v8::Isolate *isolate, Local<v8::Integer> that) __attribute__((always_inline));
        static inline Local<v8::Integer> New(v8::Isolate *isolate, const PersistentBase<v8::Integer> &that) __attribute__((always_inline));
        static inline Local<v8::Integer> New(v8::Isolate *isolate, const TracedGlobal<v8::Integer> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Integer *that) __attribute__((always_inline));
        static inline Local<v8::Integer> New(v8::Isolate *isolate, v8::Integer *that) __attribute__((always_inline));
        v8::Integer *val_;
    };
template<> class Local<v8::String> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::String>(Local<v8::String> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::String *operator->() const __attribute__((always_inline));
        inline v8::String *operator*() const __attribute__((always_inline))         {
            return this->val_;
        }
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::String> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::String> New(v8::Isolate *isolate, Local<v8::String> that) __attribute__((always_inline));
        static inline Local<v8::String> New(v8::Isolate *isolate, const PersistentBase<v8::String> &that) __attribute__((always_inline));
        static inline Local<v8::String> New(v8::Isolate *isolate, const TracedGlobal<v8::String> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::String *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<v8::String> New(v8::Isolate *isolate, v8::String *that) __attribute__((always_inline));
        v8::String *val_;
    };
template<> class Local<v8::Context> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Context>(Local<v8::Context> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Context *operator->() const __attribute__((always_inline))         {
            return this->val_;
        }
        inline v8::Context *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Context> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Context> New(v8::Isolate *isolate, Local<v8::Context> that) __attribute__((always_inline));
        static inline Local<v8::Context> New(v8::Isolate *isolate, const PersistentBase<v8::Context> &that) __attribute__((always_inline));
        static inline Local<v8::Context> New(v8::Isolate *isolate, const TracedGlobal<v8::Context> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Context *that) __attribute__((always_inline));
        static inline Local<v8::Context> New(v8::Isolate *isolate, v8::Context *that) __attribute__((always_inline));
        v8::Context *val_;
    };
template<> class Local<v8::UnboundScript> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::UnboundScript *operator->() const __attribute__((always_inline));
        inline v8::UnboundScript *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::UnboundScript> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::UnboundScript> New(v8::Isolate *isolate, Local<v8::UnboundScript> that) __attribute__((always_inline));
        static inline Local<v8::UnboundScript> New(v8::Isolate *isolate, const PersistentBase<v8::UnboundScript> &that) __attribute__((always_inline));
        static inline Local<v8::UnboundScript> New(v8::Isolate *isolate, const TracedGlobal<v8::UnboundScript> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::UnboundScript *that) __attribute__((always_inline));
        static inline Local<v8::UnboundScript> New(v8::Isolate *isolate, v8::UnboundScript *that) __attribute__((always_inline));
        v8::UnboundScript *val_;
    };
template<> class Local<v8::Object> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Object>(Local<v8::Object> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Object *operator->() const __attribute__((always_inline));
        inline v8::Object *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Object> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Object> New(v8::Isolate *isolate, Local<v8::Object> that);
        static inline Local<v8::Object> New(v8::Isolate *isolate, const PersistentBase<v8::Object> &that);
        static inline Local<v8::Object> New(v8::Isolate *isolate, const TracedGlobal<v8::Object> &that);
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Object *that) __attribute__((always_inline));
        static inline Local<v8::Object> New(v8::Isolate *isolate, v8::Object *that);
        v8::Object *val_;
    };
template<> class Local<v8::Function> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Function>(Local<v8::Function> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Function *operator->() const __attribute__((always_inline));
        inline v8::Function *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Function> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Function> New(v8::Isolate *isolate, Local<v8::Function> that) __attribute__((always_inline));
        static inline Local<v8::Function> New(v8::Isolate *isolate, const PersistentBase<v8::Function> &that) __attribute__((always_inline));
        static inline Local<v8::Function> New(v8::Isolate *isolate, const TracedGlobal<v8::Function> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Function *that) __attribute__((always_inline));
        static inline Local<v8::Function> New(v8::Isolate *isolate, v8::Function *that) __attribute__((always_inline));
        v8::Function *val_;
    };
template<> class Local<v8::Name> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::String>(Local<v8::String> that) : val_(reinterpret_cast<v8::Name *>(* that)) __attribute__((always_inline))         {
            while (false)
                {
                    *(static_cast<v8::Name *volatile *>(0)) = static_cast<v8::String *>(0);
                }
            ;
        }
;
        template<> inline Local<v8::Name>(Local<v8::Name> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Name *operator->() const __attribute__((always_inline));
        inline v8::Name *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Name> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Name> New(v8::Isolate *isolate, Local<v8::Name> that);
        static inline Local<v8::Name> New(v8::Isolate *isolate, const PersistentBase<v8::Name> &that);
        static inline Local<v8::Name> New(v8::Isolate *isolate, const TracedGlobal<v8::Name> &that);
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Name *that) __attribute__((always_inline));
        static inline Local<v8::Name> New(v8::Isolate *isolate, v8::Name *that);
        v8::Name *val_;
    };
template<> class Local<v8::FunctionTemplate> {
    public:
        inline Local() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::FunctionTemplate>(Local<v8::FunctionTemplate> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::FunctionTemplate *operator->() const __attribute__((always_inline));
        inline v8::FunctionTemplate *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::FunctionTemplate> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::FunctionTemplate> New(v8::Isolate *isolate, Local<v8::FunctionTemplate> that) __attribute__((always_inline));
        static inline Local<v8::FunctionTemplate> New(v8::Isolate *isolate, const PersistentBase<v8::FunctionTemplate> &that) __attribute__((always_inline));
        static inline Local<v8::FunctionTemplate> New(v8::Isolate *isolate, const TracedGlobal<v8::FunctionTemplate> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::FunctionTemplate *that) __attribute__((always_inline));
        static inline Local<v8::FunctionTemplate> New(v8::Isolate *isolate, v8::FunctionTemplate *that) __attribute__((always_inline));
        v8::FunctionTemplate *val_;
    };
template<> class Local<v8::Promise> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Promise>(Local<v8::Promise> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Promise *operator->() const __attribute__((always_inline));
        inline v8::Promise *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Promise> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Promise> New(v8::Isolate *isolate, Local<v8::Promise> that) __attribute__((always_inline));
        static inline Local<v8::Promise> New(v8::Isolate *isolate, const PersistentBase<v8::Promise> &that) __attribute__((always_inline));
        static inline Local<v8::Promise> New(v8::Isolate *isolate, const TracedGlobal<v8::Promise> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Promise *that) __attribute__((always_inline));
        static inline Local<v8::Promise> New(v8::Isolate *isolate, v8::Promise *that) __attribute__((always_inline));
        v8::Promise *val_;
    };
template<> class Local<v8::Data> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Data>(Local<v8::Data> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Data *operator->() const __attribute__((always_inline));
        inline v8::Data *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Data> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Data> New(v8::Isolate *isolate, Local<v8::Data> that);
        static inline Local<v8::Data> New(v8::Isolate *isolate, const PersistentBase<v8::Data> &that);
        static inline Local<v8::Data> New(v8::Isolate *isolate, const TracedGlobal<v8::Data> &that);
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Data *that) __attribute__((always_inline));
        static inline Local<v8::Data> New(v8::Isolate *isolate, v8::Data *that);
        v8::Data *val_;
    };
template<> class Local<v8::AccessorSignature> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::AccessorSignature>(Local<v8::AccessorSignature> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::AccessorSignature *operator->() const __attribute__((always_inline));
        inline v8::AccessorSignature *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::AccessorSignature> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::AccessorSignature> New(v8::Isolate *isolate, Local<v8::AccessorSignature> that) __attribute__((always_inline));
        static inline Local<v8::AccessorSignature> New(v8::Isolate *isolate, const PersistentBase<v8::AccessorSignature> &that) __attribute__((always_inline));
        static inline Local<v8::AccessorSignature> New(v8::Isolate *isolate, const TracedGlobal<v8::AccessorSignature> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::AccessorSignature *that) __attribute__((always_inline));
        static inline Local<v8::AccessorSignature> New(v8::Isolate *isolate, v8::AccessorSignature *that) __attribute__((always_inline));
        v8::AccessorSignature *val_;
    };
template<> class Local<v8::Signature> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Signature>(Local<v8::Signature> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Signature *operator->() const __attribute__((always_inline));
        inline v8::Signature *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Signature> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Signature> New(v8::Isolate *isolate, Local<v8::Signature> that) __attribute__((always_inline));
        static inline Local<v8::Signature> New(v8::Isolate *isolate, const PersistentBase<v8::Signature> &that) __attribute__((always_inline));
        static inline Local<v8::Signature> New(v8::Isolate *isolate, const TracedGlobal<v8::Signature> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Signature *that) __attribute__((always_inline));
        static inline Local<v8::Signature> New(v8::Isolate *isolate, v8::Signature *that) __attribute__((always_inline));
        v8::Signature *val_;
    };
    template <class T> using Handle = Local<T>;
    template <class T> class MaybeLocal {
    public:
        inline MaybeLocal<T>() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline MaybeLocal<T>(Local<S> that) : val_(reinterpret_cast<T *>(*that)) __attribute__((always_inline))         {
            while (false)
                {
                    *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
                }
            ;
        }
        inline bool IsEmpty() const __attribute__((always_inline))         {
            return this->val_ == nullptr;
        }
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((warn_unused_result)) __attribute__((always_inline))         {
            out->val_ = this->IsEmpty() ? nullptr : this->val_;
            return !this->IsEmpty();
        }
        inline Local<T> ToLocalChecked() __attribute__((always_inline));
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline))         {
            return this->IsEmpty() ? default_value : Local<S>(this->val_);
        }
    private:
        T *val_;
    };
template<> class MaybeLocal<v8::Value> {
    public:
        inline MaybeLocal() __attribute__((always_inline));
        template <class S> inline MaybeLocal(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((warn_unused_result)) __attribute__((always_inline));
        inline Local<v8::Value> ToLocalChecked() __attribute__((always_inline));
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline));
    private:
        v8::Value *val_;
    };
template<> class MaybeLocal<v8::String> {
    public:
        inline MaybeLocal() __attribute__((always_inline));
        template <class S> inline MaybeLocal(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((warn_unused_result)) __attribute__((always_inline));
        inline Local<v8::String> MaybeLocal<String>::ToLocalChecked()         {
            if ((__builtin_expect(!!(this->val_ == nullptr), 0)))
                V8::ToLocalEmpty();
            return Local<v8::String>(this->val_);
        }
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline));
    private:
        v8::String *val_;
    };
template<> class MaybeLocal<v8::Object> {
    public:
        inline MaybeLocal() __attribute__((always_inline));
        template <class S> inline MaybeLocal(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((warn_unused_result)) __attribute__((always_inline));
        inline Local<v8::Object> ToLocalChecked() __attribute__((always_inline));
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline));
    private:
        v8::Object *val_;
    };
template<> class MaybeLocal<v8::ObjectTemplate> {
    public:
        inline MaybeLocal() __attribute__((always_inline));
        template <class S> inline MaybeLocal(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((warn_unused_result)) __attribute__((always_inline));
        inline Local<v8::ObjectTemplate> ToLocalChecked() __attribute__((always_inline));
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline));
    private:
        v8::ObjectTemplate *val_;
    };
    template <class T> class Eternal {
    public:
        inline Eternal<T>() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Eternal<T>(v8::Isolate *isolate, Local<S> handle) : val_(nullptr) __attribute__((always_inline))         {
            Set(isolate, handle);
        }
        inline Local<T> Get(v8::Isolate *isolate) const __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline))         {
            return this->val_ == nullptr;
        }
        template <class S> inline void Set(v8::Isolate *isolate, Local<S> handle) __attribute__((always_inline));
    private:
        T *val_;
    };
    static const int kInternalFieldsInWeakCallback = 2;
    static const int kEmbedderFieldsInWeakCallback = 2;
    template <typename T> class WeakCallbackInfo {
    public:
        typedef void (*Callback)(const WeakCallbackInfo<T> &);
        WeakCallbackInfo<T>(v8::Isolate *isolate, T *parameter, void *embedder_fields[2], v8::WeakCallbackInfo::Callback *callback) : isolate_(isolate), parameter_(parameter), callback_(callback)         {
            for (int i = 0; i < kEmbedderFieldsInWeakCallback; ++i) {
                this->embedder_fields_[i] = embedder_fields[i];
            }
        }
        inline v8::Isolate *GetIsolate() const __attribute__((always_inline))         {
            return this->isolate_;
        }
        inline T *GetParameter() const __attribute__((always_inline))         {
            return this->parameter_;
        }
        inline void *GetInternalField(int index) const __attribute__((always_inline));
        void SetSecondPassCallback(v8::WeakCallbackInfo::Callback callback) const         {
            *this->callback_ = callback;
        }
    private:
        v8::Isolate *isolate_;
        T *parameter_;
        v8::WeakCallbackInfo::Callback *callback_;
        void *embedder_fields_[2];
    };
template<> class WeakCallbackInfo<void> {
    public:
        typedef void (*Callback)(const WeakCallbackInfo<void> &);
        WeakCallbackInfo(v8::Isolate *isolate, void *parameter, void *embedder_fields[2], v8::WeakCallbackInfo<void>::Callback *callback);
        inline v8::Isolate *GetIsolate() const __attribute__((always_inline));
        inline void *GetParameter() const __attribute__((always_inline));
        inline void *GetInternalField(int index) const __attribute__((always_inline));
        void SetSecondPassCallback(v8::WeakCallbackInfo<void>::Callback callback) const;
    private:
        v8::Isolate *isolate_;
        void *parameter_;
        v8::WeakCallbackInfo<void>::Callback *callback_;
        void *embedder_fields_[2];
    };
    enum class WeakCallbackType : int {
        kParameter,
        kInternalFields,
        kFinalizer
    };
    template <class T> class PersistentBase {
    public:
        inline void Reset() __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const Local<S> &other) __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const PersistentBase<S> &other) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline))         {
            return this->val_ == nullptr;
        }
        inline void Empty() __attribute__((always_inline))         {
            this->val_ = 0;
        }
        inline Local<T> Get(v8::Isolate *isolate) const __attribute__((always_inline))         {
            return Local<T>::New(isolate, *this);
        }
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline))         {
            internal::Address *a = reinterpret_cast<internal::Address *>(this->val_);
            internal::Address *b = reinterpret_cast<internal::Address *>(that.val_);
            if (a == nullptr)
                return b == nullptr;
            if (b == nullptr)
                return false;
            return *a == *b;
        }
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline))         {
            internal::Address *a = reinterpret_cast<internal::Address *>(this->val_);
            internal::Address *b = reinterpret_cast<internal::Address *>(that.val_);
            if (a == nullptr)
                return b == nullptr;
            if (b == nullptr)
                return false;
            return *a == *b;
        }
        template <class S> inline bool operator!=(const PersistentBase<S> &that) const __attribute__((always_inline))         {
            return !operator==(that);
        }
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline))         {
            return !operator==(that);
        }
        template <typename P> inline void SetWeak(P *parameter, typename WeakCallbackInfo<P>::Callback callback, v8::WeakCallbackType type) __attribute__((always_inline));
        inline void SetWeak() __attribute__((always_inline));
        template <typename P> inline P *ClearWeak() __attribute__((always_inline));
        inline void ClearWeak() __attribute__((always_inline))         {
            ClearWeak<void>();
        }
        inline void AnnotateStrongRetainer(const char *label) __attribute__((always_inline));
        inline bool IsWeak() const __attribute__((always_inline));
        inline void SetWrapperClassId(uint16_t class_id) __attribute__((always_inline));
        inline uint16_t WrapperClassId() const __attribute__((always_inline));
        PersistentBase<T>(const PersistentBase<T> &other) = delete
        void operator=(const PersistentBase<T> &) = delete
    private:
        friend  class Isolate;
        friend  class Utils;
        friend template <class F> class Local;
        friend template <class F1, class F2> class Persistent;
        friend template <class F> class Global;
        friend template <class F> class PersistentBase;
        friend template <class F> class ReturnValue;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend  class Object;
        inline explicit PersistentBase<T>(T *val) : val_(val) __attribute__((always_inline))         {
        }
        static inline T *New(v8::Isolate *isolate, T *that) __attribute__((always_inline));
        T *val_;
    };
template<> class PersistentBase<v8::Object> {
    public:
        inline void Reset() __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const Local<S> &other) __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const PersistentBase<S> &other) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Empty() __attribute__((always_inline));
        inline Local<v8::Object> Get(v8::Isolate *isolate) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <typename P> inline void SetWeak(P *parameter, typename WeakCallbackInfo<P>::Callback callback, v8::WeakCallbackType type) __attribute__((always_inline));
        inline void SetWeak() __attribute__((always_inline));
        template <typename P> inline P *ClearWeak() __attribute__((always_inline));
        inline void ClearWeak() __attribute__((always_inline));
        inline void AnnotateStrongRetainer(const char *label) __attribute__((always_inline));
        inline bool IsWeak() const __attribute__((always_inline));
        inline void SetWrapperClassId(uint16_t class_id) __attribute__((always_inline));
        inline uint16_t WrapperClassId() const __attribute__((always_inline));
        PersistentBase(const v8::PersistentBase<v8::Object> &other) = delete
        void operator=(const v8::PersistentBase<v8::Object> &) = delete
    private:
        friend  class Isolate;
        friend  class Utils;
        friend template <class F> class Local;
        friend template <class F1, class F2 = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Global;
        friend template <class F> class PersistentBase;
        friend template <class F> class ReturnValue;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend  class Object;
        inline explicit PersistentBase(v8::Object *val) __attribute__((always_inline));
        static inline v8::Object *New(v8::Isolate *isolate, v8::Object *that) __attribute__((always_inline));
        v8::Object *val_;
    };
template<> class PersistentBase<v8::Promise> {
    public:
        inline void Reset() __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const Local<S> &other) __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const PersistentBase<S> &other) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Empty() __attribute__((always_inline));
        inline Local<v8::Promise> Get(v8::Isolate *isolate) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <typename P> inline void SetWeak(P *parameter, typename WeakCallbackInfo<P>::Callback callback, v8::WeakCallbackType type) __attribute__((always_inline));
        inline void SetWeak() __attribute__((always_inline));
        template <typename P> inline P *ClearWeak() __attribute__((always_inline));
        inline void ClearWeak() __attribute__((always_inline));
        inline void AnnotateStrongRetainer(const char *label) __attribute__((always_inline));
        inline bool IsWeak() const __attribute__((always_inline));
        inline void SetWrapperClassId(uint16_t class_id) __attribute__((always_inline));
        inline uint16_t WrapperClassId() const __attribute__((always_inline));
        PersistentBase(const v8::PersistentBase<v8::Promise> &other) = delete
        void operator=(const v8::PersistentBase<v8::Promise> &) = delete
    private:
        friend  class Isolate;
        friend  class Utils;
        friend template <class F> class Local;
        friend template <class F1, class F2 = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Global;
        friend template <class F> class PersistentBase;
        friend template <class F> class ReturnValue;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend  class Object;
        inline explicit PersistentBase(v8::Promise *val) __attribute__((always_inline));
        static inline v8::Promise *New(v8::Isolate *isolate, v8::Promise *that) __attribute__((always_inline));
        v8::Promise *val_;
    };
    template <class T> class NonCopyablePersistentTraits {
    public:
        typedef Persistent<T, NonCopyablePersistentTraits<T> > NonCopyablePersistent;
        static const bool kResetInDestructor = false;
        template <class S, class M> static inline void Copy(const Persistent<S, M> &source, v8::NonCopyablePersistentTraits::NonCopyablePersistent *dest) __attribute__((always_inline))         {
            Uncompilable<v8::Object>();
        }
        template <class O> static inline void Uncompilable() __attribute__((always_inline))         {
            while (false)
                {
                    *(static_cast<O *volatile *>(0)) = static_cast<v8::Primitive *>(0);
                }
            ;
        }
    };
    template <class T> struct CopyablePersistentTraits {
        typedef Persistent<T, CopyablePersistentTraits<T> > CopyablePersistent;
        static const bool kResetInDestructor = true;
        template <class S, class M> static inline void Copy(const Persistent<S, M> &source, v8::CopyablePersistentTraits::CopyablePersistent *dest) __attribute__((always_inline))         {
        }
    };
    template <class T, class M = NonCopyablePersistentTraits<T>> class Persistent : public PersistentBase<T> {
    public:
        inline Persistent<T, M>() : PersistentBase<T>(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Persistent<T, M>(v8::Isolate *isolate, Local<S> that) : PersistentBase<T>(PersistentBase<T>::New(isolate, *that)) __attribute__((always_inline))         {
            while (false)
                {
                    *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
                }
            ;
        }
        template <class S, class M2> inline Persistent<T, M>(v8::Isolate *isolate, const Persistent<S, M2> &that) : PersistentBase<T>(PersistentBase<T>::New(isolate, *that)) __attribute__((always_inline))         {
            while (false)
                {
                    *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
                }
            ;
        }
        inline Persistent<T, M>(const Persistent<T, M> &that) : PersistentBase<T>(nullptr) __attribute__((always_inline))         {
            Copy(that);
        }
        template <class S, class M2> inline Persistent<T, M>(const Persistent<S, M2> &that) : PersistentBase<T>(0) __attribute__((always_inline))         {
            Copy(that);
        }
        inline Persistent<T, M> &operator=(const Persistent<T, M> &that) __attribute__((always_inline))         {
            Copy(that);
            return *this;
        }
        template <class S, class M2> inline Persistent<T, M> &operator=(const Persistent<S, M2> &that) __attribute__((always_inline))         {
            Copy(that);
            return *this;
        }
        inline ~Persistent<T, M>() __attribute__((always_inline))         {
            if (M::kResetInDestructor)
                this->Reset();
        }
        template <class S> static inline Persistent<T> &Cast(const Persistent<S> &that) __attribute__((always_inline))         {
            return reinterpret_cast<Persistent<T> &>(const_cast<Persistent<S> &>(that));
        }
        template <class S> inline Persistent<S> &As() const __attribute__((always_inline))         {
            return Persistent<S>::Cast(*this);
        }
    private:
        friend  class Isolate;
        friend  class Utils;
        friend template <class F> class Local;
        friend template <class F1, class F2> class Persistent;
        friend template <class F> class ReturnValue;
        inline explicit Persistent<T, M>(T *that) : PersistentBase<T>(that) __attribute__((always_inline))         {
        }
        inline T *operator*() const __attribute__((always_inline))         {
            return this->val_;
        }
        template <class S, class M2> inline void Copy(const Persistent<S, M2> &that) __attribute__((always_inline));
    };
template<> class Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise>> : public PersistentBase<v8::Promise> {
    public:
        inline Persistent() __attribute__((always_inline));
        template <class S> inline Persistent(v8::Isolate *isolate, Local<S> that) __attribute__((always_inline));
        template <class S, class M2> inline Persistent(v8::Isolate *isolate, const Persistent<S, M2> &that) __attribute__((always_inline));
        inline Persistent(const v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &that) __attribute__((always_inline));
        template <class S, class M2> inline Persistent(const Persistent<S, M2> &that) __attribute__((always_inline));
        template<> inline Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise>>(const Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &that) __attribute__((always_inline));
        inline v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &operator=(const v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &that) __attribute__((always_inline));
        template <class S, class M2> inline v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &operator=(const Persistent<S, M2> &that) __attribute__((always_inline));
        template<> inline v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &operator=<v8::Promise, v8::CopyablePersistentTraits<v8::Promise>>(const Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &that) __attribute__((always_inline));
        inline ~Persistent<Promise, CopyablePersistentTraits<Promise> >() noexcept __attribute__((always_inline));
        template <class S> static inline Persistent<v8::Promise> &Cast(const Persistent<S> &that) __attribute__((always_inline));
        template <class S> inline Persistent<S> &As() const __attribute__((always_inline));
    private:
        friend  class Isolate;
        friend  class Utils;
        friend template <class F> class Local;
        friend template <class F1, class F2 = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class ReturnValue;
        inline explicit Persistent(v8::Promise *that) __attribute__((always_inline));
        inline v8::Promise *operator*() const __attribute__((always_inline));
        template <class S, class M2> inline void Copy(const Persistent<S, M2> &that) __attribute__((always_inline));
    };
    template <class T> class Global : public PersistentBase<T> {
    public:
        inline Global<T>() : PersistentBase<T>(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Global<T>(v8::Isolate *isolate, Local<S> that) : PersistentBase<T>(PersistentBase<T>::New(isolate, *that)) __attribute__((always_inline))         {
            while (false)
                {
                    *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
                }
            ;
        }
        template <class S> inline Global<T>(v8::Isolate *isolate, const PersistentBase<S> &that) : PersistentBase<T>(PersistentBase<T>::New(isolate, that.val_)) __attribute__((always_inline))         {
            while (false)
                {
                    *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
                }
            ;
        }
        inline Global<T>(Global<T> &&other) __attribute__((always_inline));
        inline ~Global<T>() __attribute__((always_inline))         {
            this->Reset();
        }
        template <class S> inline Global<T> &operator=(Global<S> &&rhs) __attribute__((always_inline));
        Global<T> Pass()         {
            return static_cast<Global<T> &&>(*this);
        }
        typedef void MoveOnlyTypeForCPP03;
        Global<T>(const Global<T> &) = delete
        void operator=(const Global<T> &) = delete
    private:
        friend template <class F> class ReturnValue;
        inline T *operator*() const __attribute__((always_inline))         {
            return this->val_;
        }
    };
    template <class T> using UniquePersistent = Global<T>;
    template <typename T> class TracedGlobal {
    public:
        TracedGlobal<T>() = default
        ~TracedGlobal<T>()         {
            Reset();
        }
        template <class S> TracedGlobal<T>(v8::Isolate *isolate, Local<S> that) : val_(New(isolate, *that, &this->val_))         {
            while (false)
                {
                    *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
                }
            ;
        }
        inline TracedGlobal<T>(TracedGlobal<T> &&other) __attribute__((always_inline));
        template <class S> inline TracedGlobal<T> &operator=(TracedGlobal<S> &&rhs) __attribute__((always_inline));
        TracedGlobal<T>(const TracedGlobal<T> &) = delete
        void operator=(const TracedGlobal<T> &) = delete
        bool IsEmpty() const         {
            return this->val_ == nullptr;
        }
        inline void Reset() __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const Local<S> &other) __attribute__((always_inline));
        Local<T> Get(v8::Isolate *isolate) const         {
            return Local<T>::New(isolate, *this);
        }
        template <class S> inline TracedGlobal<S> &As() const __attribute__((always_inline))         {
            return reinterpret_cast<TracedGlobal<S> &>(const_cast<TracedGlobal<T> &>(*this));
        }
        template <class S> inline bool operator==(const TracedGlobal<S> &that) const __attribute__((always_inline))         {
            internal::Address *a = reinterpret_cast<internal::Address *>(this->val_);
            internal::Address *b = reinterpret_cast<internal::Address *>(that.val_);
            if (a == nullptr)
                return b == nullptr;
            if (b == nullptr)
                return false;
            return *a == *b;
        }
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline))         {
            internal::Address *a = reinterpret_cast<internal::Address *>(this->val_);
            internal::Address *b = reinterpret_cast<internal::Address *>(that.val_);
            if (a == nullptr)
                return b == nullptr;
            if (b == nullptr)
                return false;
            return *a == *b;
        }
        template <class S> inline bool operator!=(const TracedGlobal<S> &that) const __attribute__((always_inline))         {
            return !operator==(that);
        }
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline))         {
            return !operator==(that);
        }
        inline void SetWrapperClassId(uint16_t class_id) __attribute__((always_inline));
        inline uint16_t WrapperClassId() const __attribute__((always_inline));
        inline void SetFinalizationCallback(void *parameter, WeakCallbackInfo<void>::Callback callback) __attribute__((always_inline));
    private:
        static inline T *New(v8::Isolate *isolate, T *that, T **slot) __attribute__((always_inline));
        T *operator*() const         {
            return this->val_;
        }
        T *val_ = nullptr;
        friend  class EmbedderHeapTracer;
        friend template <typename F> class Local;
        friend  class Object;
        friend template <typename F> class ReturnValue;
    };
template<> class TracedGlobal<v8::Object> {
    public:
        TracedGlobal() = default
        ~TracedGlobal<Object>();
        template <class S> TracedGlobal(v8::Isolate *isolate, Local<S> that);
        inline TracedGlobal(v8::TracedGlobal<v8::Object> &&other) __attribute__((always_inline));
        template <class S> inline v8::TracedGlobal<v8::Object> &operator=(TracedGlobal<S> &&rhs) __attribute__((always_inline));
        TracedGlobal(const v8::TracedGlobal<v8::Object> &) = delete
        void operator=(const v8::TracedGlobal<v8::Object> &) = delete
        bool IsEmpty() const;
        inline void Reset() __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const Local<S> &other) __attribute__((always_inline));
        Local<v8::Object> Get(v8::Isolate *isolate) const;
        template <class S> inline TracedGlobal<S> &As() const __attribute__((always_inline));
        template <class S> inline bool operator==(const TracedGlobal<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const TracedGlobal<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        inline void SetWrapperClassId(uint16_t class_id) __attribute__((always_inline));
        inline uint16_t WrapperClassId() const __attribute__((always_inline));
        inline void SetFinalizationCallback(void *parameter, WeakCallbackInfo<void>::Callback callback) __attribute__((always_inline));
    private:
        static inline v8::Object *New(v8::Isolate *isolate, v8::Object *that, v8::Object **slot) __attribute__((always_inline));
        v8::Object *operator*() const;
        v8::Object *val_;
        friend  class EmbedderHeapTracer;
        friend template <typename F> class Local;
        friend  class Object;
        friend template <typename F> class ReturnValue;
    };
    class HandleScope {
    public:
        explicit HandleScope(v8::Isolate *isolate);
        ~HandleScope() noexcept;
        static int NumberOfHandles(v8::Isolate *isolate);
        inline v8::Isolate *GetIsolate() const __attribute__((always_inline))         {
            return reinterpret_cast<v8::Isolate *>(this->isolate_);
        }
        HandleScope(const v8::HandleScope &) = delete
        void operator=(const v8::HandleScope &) = delete
    protected:
        inline HandleScope() __attribute__((always_inline)) = default
        void Initialize(v8::Isolate *isolate);
        static internal::Address *CreateHandle(internal::Isolate *isolate, internal::Address value);
    private:
        void *operator new(size_t size);
        void *operator new[](size_t size);
        void operator delete(void *, size_t) noexcept;
        void operator delete[](void *, size_t) noexcept;
        internal::Isolate *isolate_;
        internal::Address *prev_next_;
        internal::Address *prev_limit_;
        friend template <class F> class Local;
        friend  class Object;
        friend  class Context;
    };
    class EscapableHandleScope : public v8::HandleScope {
    public:
        explicit EscapableHandleScope(v8::Isolate *isolate);
        inline ~EscapableHandleScope() noexcept __attribute__((always_inline)) = default
        template <class T> inline Local<T> Escape(Local<T> value) __attribute__((always_inline))         {
            internal::Address *slot = this->Escape(reinterpret_cast<internal::Address *>(*value));
            return Local<T>(reinterpret_cast<T *>(slot));
        }
        template <class T> inline MaybeLocal<T> EscapeMaybe(MaybeLocal<T> value) __attribute__((always_inline))         {
            return Escape(value.FromMaybe(Local<T>()));
        }
        EscapableHandleScope(const v8::EscapableHandleScope &) = delete
        void operator=(const v8::EscapableHandleScope &) = delete
    private:
        void *operator new(size_t size);
        void *operator new[](size_t size);
        void operator delete(void *, size_t) noexcept;
        void operator delete[](void *, size_t) noexcept;
        internal::Address *Escape(internal::Address *escape_value);
        internal::Address *escape_slot_;
    };
    class SealHandleScope {
    public:
        explicit SealHandleScope(v8::Isolate *isolate);
        ~SealHandleScope();
        SealHandleScope(const v8::SealHandleScope &) = delete
        void operator=(const v8::SealHandleScope &) = delete
    private:
        void *operator new(size_t size);
        void *operator new[](size_t size);
        void operator delete(void *, size_t) noexcept;
        void operator delete[](void *, size_t) noexcept;
        internal::Isolate *const isolate_;
        internal::Address *prev_limit_;
        int prev_sealed_level_;
    };
    class Data {
    private:
        Data();
    };
    class ScriptOrModule {
    public:
        Local<v8::Value> GetResourceName();
        Local<v8::PrimitiveArray> GetHostDefinedOptions();
    };
    class PrimitiveArray {
    public:
        static Local<v8::PrimitiveArray> New(v8::Isolate *isolate, int length);
        int Length() const;
        void Set(v8::Isolate *isolate, int index, Local<v8::Primitive> item);
        Local<v8::Primitive> Get(v8::Isolate *isolate, int index);
    };
    class ScriptOriginOptions {
    public:
        inline ScriptOriginOptions(bool is_shared_cross_origin = false, bool is_opaque = false, bool is_wasm = false, bool is_module = false) : flags_((is_shared_cross_origin ? kIsSharedCrossOrigin : 0) | (is_wasm ? kIsWasm : 0) | (is_opaque ? kIsOpaque : 0) | (is_module ? kIsModule : 0)) __attribute__((always_inline))         {
        }
        inline ScriptOriginOptions(int flags) : flags_(flags & (kIsSharedCrossOrigin | kIsOpaque | kIsWasm | kIsModule)) __attribute__((always_inline))         {
        }
        bool IsSharedCrossOrigin() const         {
            return (this->flags_ & kIsSharedCrossOrigin) != 0;
        }
        bool IsOpaque() const         {
            return (this->flags_ & kIsOpaque) != 0;
        }
        bool IsWasm() const         {
            return (this->flags_ & kIsWasm) != 0;
        }
        bool IsModule() const         {
            return (this->flags_ & kIsModule) != 0;
        }
        int Flags() const         {
            return this->flags_;
        }
    private:
        enum  {
            kIsSharedCrossOrigin = 1,
            kIsOpaque = 1 << 1,
            kIsWasm = 1 << 2,
            kIsModule = 1 << 3
        };
        const int flags_;
    };
    class ScriptOrigin {
    public:
        inline ScriptOrigin(Local<v8::Value> resource_name, Local<v8::Integer> resource_line_offset = Local<v8::Integer>(), Local<v8::Integer> resource_column_offset = Local<v8::Integer>(), Local<v8::Boolean> resource_is_shared_cross_origin = Local<v8::Boolean>(), Local<v8::Integer> script_id = Local<v8::Integer>(), Local<v8::Value> source_map_url = Local<v8::Value>(), Local<v8::Boolean> resource_is_opaque = Local<v8::Boolean>(), Local<v8::Boolean> is_wasm = Local<v8::Boolean>(), Local<v8::Boolean> is_module = Local<v8::Boolean>(), Local<v8::PrimitiveArray> host_defined_options = Local<v8::PrimitiveArray>()) __attribute__((always_inline));
        inline Local<v8::Value> ResourceName() const __attribute__((always_inline));
        inline Local<v8::Integer> ResourceLineOffset() const __attribute__((always_inline));
        inline Local<v8::Integer> ResourceColumnOffset() const __attribute__((always_inline));
        inline Local<v8::Integer> ScriptID() const __attribute__((always_inline));
        inline Local<v8::Value> SourceMapUrl() const __attribute__((always_inline));
        inline Local<v8::PrimitiveArray> HostDefinedOptions() const __attribute__((always_inline));
        inline v8::ScriptOriginOptions Options() const __attribute__((always_inline))         {
            return this->options_;
        }
    private:
        Local<v8::Value> resource_name_;
        Local<v8::Integer> resource_line_offset_;
        Local<v8::Integer> resource_column_offset_;
        v8::ScriptOriginOptions options_;
        Local<v8::Integer> script_id_;
        Local<v8::Value> source_map_url_;
        Local<v8::PrimitiveArray> host_defined_options_;
    };
    class UnboundScript {
    public:
        Local<v8::Script> BindToCurrentContext();
        int GetId();
        Local<v8::Value> GetScriptName();
        Local<v8::Value> GetSourceURL();
        Local<v8::Value> GetSourceMappingURL();
        int GetLineNumber(int code_pos);
        static const int kNoScriptId = 0;
    };
    class UnboundModuleScript {
    };
    class Location {
    public:
        int GetLineNumber()         {
            return this->line_number_;
        }
        int GetColumnNumber()         {
            return this->column_number_;
        }
        Location(int line_number, int column_number) : line_number_(line_number), column_number_(column_number)         {
        }
    private:
        int line_number_;
        int column_number_;
    };
    class Module {
    public:
        enum Status {
            kUninstantiated,
            kInstantiating,
            kInstantiated,
            kEvaluating,
            kEvaluated,
            kErrored
        };
        v8::Module::Status GetStatus() const;
        Local<v8::Value> GetException() const;
        int GetModuleRequestsLength() const;
        Local<v8::String> GetModuleRequest(int i) const;
        v8::Location GetModuleRequestLocation(int i) const;
        int GetIdentityHash() const;
        typedef MaybeLocal<v8::Module> (*ResolveCallback)(Local<v8::Context>, Local<v8::String>, Local<v8::Module>);
        Maybe<bool> InstantiateModule(Local<v8::Context> context, v8::Module::ResolveCallback callback) __attribute__((warn_unused_result));
        MaybeLocal<v8::Value> Evaluate(Local<v8::Context> context) __attribute__((warn_unused_result));
        Local<v8::Value> GetModuleNamespace();
        Local<v8::UnboundModuleScript> GetUnboundModuleScript();
    };
    class Script {
    public:
        static MaybeLocal<v8::Script> Compile(Local<v8::Context> context, Local<v8::String> source, v8::ScriptOrigin *origin = nullptr) __attribute__((warn_unused_result));
        MaybeLocal<v8::Value> Run(Local<v8::Context> context) __attribute__((warn_unused_result));
        Local<v8::UnboundScript> GetUnboundScript();
    };
    class ScriptCompiler {
    public:
        struct CachedData {
            enum BufferPolicy {
                BufferNotOwned,
                BufferOwned
            };
            CachedData() : data(nullptr), length(0), rejected(false), buffer_policy(BufferNotOwned)             {
            }
            CachedData(const uint8_t *data, int length, v8::ScriptCompiler::CachedData::BufferPolicy buffer_policy = BufferNotOwned);
            ~CachedData() noexcept;
            const uint8_t *data;
            int length;
            bool rejected;
            v8::ScriptCompiler::CachedData::BufferPolicy buffer_policy;
            CachedData(const v8::ScriptCompiler::CachedData &) = delete
            v8::ScriptCompiler::CachedData &operator=(const v8::ScriptCompiler::CachedData &) = delete
        };
        class Source {
        public:
            inline Source(Local<v8::String> source_string, const v8::ScriptOrigin &origin, v8::ScriptCompiler::CachedData *cached_data = nullptr) __attribute__((always_inline));
            inline Source(Local<v8::String> source_string, v8::ScriptCompiler::CachedData *cached_data = nullptr) __attribute__((always_inline));
            inline ~Source() noexcept __attribute__((always_inline));
            inline const v8::ScriptCompiler::CachedData *GetCachedData() const __attribute__((always_inline));
            inline const v8::ScriptOriginOptions &GetResourceOptions() const __attribute__((always_inline));
            Source(const v8::ScriptCompiler::Source &) = delete
            v8::ScriptCompiler::Source &operator=(const v8::ScriptCompiler::Source &) = delete
        private:
            friend  class ScriptCompiler;
            Local<v8::String> source_string;
            Local<v8::Value> resource_name;
            Local<v8::Integer> resource_line_offset;
            Local<v8::Integer> resource_column_offset;
            v8::ScriptOriginOptions resource_options;
            Local<v8::Value> source_map_url;
            Local<v8::PrimitiveArray> host_defined_options;
            v8::ScriptCompiler::CachedData *cached_data;
        };
        class ExternalSourceStream {
        public:
            virtual ~ExternalSourceStream() noexcept = default
            virtual size_t GetMoreData(const uint8_t **src) = 0;
            virtual bool SetBookmark();
            virtual void ResetToBookmark();
        };
        class StreamedSource {
        public:
            enum Encoding {
                ONE_BYTE,
                TWO_BYTE,
                UTF8
            };
            StreamedSource(v8::ScriptCompiler::ExternalSourceStream *source_stream, v8::ScriptCompiler::StreamedSource::Encoding encoding);
            StreamedSource(std::unique_ptr<ExternalSourceStream> source_stream, v8::ScriptCompiler::StreamedSource::Encoding encoding);
            ~StreamedSource();
            internal::ScriptStreamingData *impl() const             {
                return this->impl_.get();
            }
            StreamedSource(const v8::ScriptCompiler::StreamedSource &) = delete
            v8::ScriptCompiler::StreamedSource &operator=(const v8::ScriptCompiler::StreamedSource &) = delete
        private:
            std::unique_ptr<internal::ScriptStreamingData> impl_;
        };
        class final ScriptStreamingTask {
        public:
            void Run();
        private:
            friend  class ScriptCompiler;
            explicit ScriptStreamingTask(internal::ScriptStreamingData *data) : data_(data)             {
            }
            internal::ScriptStreamingData *data_;
        };
        enum CompileOptions {
            kNoCompileOptions = 0,
            kConsumeCodeCache,
            kEagerCompile
        };
        enum NoCacheReason {
            kNoCacheNoReason = 0,
            kNoCacheBecauseCachingDisabled,
            kNoCacheBecauseNoResource,
            kNoCacheBecauseInlineScript,
            kNoCacheBecauseModule,
            kNoCacheBecauseStreamingSource,
            kNoCacheBecauseInspector,
            kNoCacheBecauseScriptTooSmall,
            kNoCacheBecauseCacheTooCold,
            kNoCacheBecauseV8Extension,
            kNoCacheBecauseExtensionModule,
            kNoCacheBecausePacScript,
            kNoCacheBecauseInDocumentWrite,
            kNoCacheBecauseResourceWithNoCacheHandler,
            kNoCacheBecauseDeferredProduceCodeCache
        };
        static MaybeLocal<v8::UnboundScript> CompileUnboundScript(v8::Isolate *isolate, v8::ScriptCompiler::Source *source, v8::ScriptCompiler::CompileOptions options = kNoCompileOptions, v8::ScriptCompiler::NoCacheReason no_cache_reason = kNoCacheNoReason) __attribute__((warn_unused_result));
        static MaybeLocal<v8::Script> Compile(Local<v8::Context> context, v8::ScriptCompiler::Source *source, v8::ScriptCompiler::CompileOptions options = kNoCompileOptions, v8::ScriptCompiler::NoCacheReason no_cache_reason = kNoCacheNoReason) __attribute__((warn_unused_result));
        static v8::ScriptCompiler::ScriptStreamingTask *StartStreamingScript(v8::Isolate *isolate, v8::ScriptCompiler::StreamedSource *source, v8::ScriptCompiler::CompileOptions options = kNoCompileOptions);
        static MaybeLocal<v8::Script> Compile(Local<v8::Context> context, v8::ScriptCompiler::StreamedSource *source, Local<v8::String> full_source_string, const v8::ScriptOrigin &origin) __attribute__((warn_unused_result));
        static uint32_t CachedDataVersionTag();
        static MaybeLocal<v8::Module> CompileModule(v8::Isolate *isolate, v8::ScriptCompiler::Source *source, v8::ScriptCompiler::CompileOptions options = kNoCompileOptions, v8::ScriptCompiler::NoCacheReason no_cache_reason = kNoCacheNoReason) __attribute__((warn_unused_result));
        static MaybeLocal<v8::Function> CompileFunctionInContext(Local<v8::Context> context, v8::ScriptCompiler::Source *source, size_t arguments_count, Local<v8::String> arguments[], size_t context_extension_count, Local<v8::Object> context_extensions[], v8::ScriptCompiler::CompileOptions options = kNoCompileOptions, v8::ScriptCompiler::NoCacheReason no_cache_reason = kNoCacheNoReason) __attribute__((warn_unused_result));
        static v8::ScriptCompiler::CachedData *CreateCodeCache(Local<v8::UnboundScript> unbound_script);
        static v8::ScriptCompiler::CachedData *CreateCodeCache(Local<v8::UnboundModuleScript> unbound_module_script);
        static v8::ScriptCompiler::CachedData *CreateCodeCacheForFunction(Local<v8::Function> function);
    private:
        static MaybeLocal<v8::UnboundScript> CompileUnboundInternal(v8::Isolate *isolate, v8::ScriptCompiler::Source *source, v8::ScriptCompiler::CompileOptions options, v8::ScriptCompiler::NoCacheReason no_cache_reason) __attribute__((warn_unused_result));
    };
    class Message {
    public:
        Local<v8::String> Get() const;
        v8::Isolate *GetIsolate() const;
        MaybeLocal<v8::String> GetSourceLine(Local<v8::Context> context) const __attribute__((warn_unused_result));
        v8::ScriptOrigin GetScriptOrigin() const;
        Local<v8::Value> GetScriptResourceName() const;
        Local<v8::StackTrace> GetStackTrace() const;
        Maybe<int> GetLineNumber(Local<v8::Context> context) const __attribute__((warn_unused_result));
        int GetStartPosition() const;
        int GetEndPosition() const;
        int ErrorLevel() const;
        int GetStartColumn() const;
        Maybe<int> GetStartColumn(Local<v8::Context> context) const __attribute__((warn_unused_result));
        int GetEndColumn() const;
        Maybe<int> GetEndColumn(Local<v8::Context> context) const __attribute__((warn_unused_result));
        bool IsSharedCrossOrigin() const;
        bool IsOpaque() const;
        static void PrintCurrentStackTrace(v8::Isolate *isolate, FILE *out);
        static const int kNoLineNumberInfo = 0;
        static const int kNoColumnInfo = 0;
        static const int kNoScriptIdInfo = 0;
    };
    class StackTrace {
    public:
        enum StackTraceOptions {
            kLineNumber = 1,
            kColumnOffset = 1 << 1 | kLineNumber,
            kScriptName = 1 << 2,
            kFunctionName = 1 << 3,
            kIsEval = 1 << 4,
            kIsConstructor = 1 << 5,
            kScriptNameOrSourceURL = 1 << 6,
            kScriptId = 1 << 7,
            kExposeFramesAcrossSecurityOrigins = 1 << 8,
            kOverview = kLineNumber | kColumnOffset | kScriptName | kFunctionName,
            kDetailed = kOverview | kIsEval | kIsConstructor | kScriptNameOrSourceURL
        };
        Local<v8::StackFrame> GetFrame(v8::Isolate *isolate, uint32_t index) const;
        int GetFrameCount() const;
        static Local<v8::StackTrace> CurrentStackTrace(v8::Isolate *isolate, int frame_limit, v8::StackTrace::StackTraceOptions options = kDetailed);
    };
    class StackFrame {
    public:
        int GetLineNumber() const;
        int GetColumn() const;
        int GetScriptId() const;
        Local<v8::String> GetScriptName() const;
        Local<v8::String> GetScriptNameOrSourceURL() const;
        Local<v8::String> GetFunctionName() const;
        bool IsEval() const;
        bool IsConstructor() const;
        bool IsWasm() const;
        bool IsUserJavaScript() const;
    };
    enum StateTag {
        JS,
        GC,
        PARSER,
        BYTECODE_COMPILER,
        COMPILER,
        OTHER,
        EXTERNAL,
        IDLE
    };
    struct RegisterState {
        RegisterState() : pc(nullptr), sp(nullptr), fp(nullptr), lr(nullptr)         {
        }
        void *pc;
        void *sp;
        void *fp;
        void *lr;
    };
    struct SampleInfo {
        size_t frames_count;
        v8::StateTag vm_state;
        void *external_callback_entry;
    };
    struct MemoryRange {
        const void *start = nullptr;
        size_t length_in_bytes = 0;
    };
    struct JSEntryStub {
        v8::MemoryRange code;
    };
    struct UnwindState {
        v8::MemoryRange code_range;
        v8::MemoryRange embedded_code_range;
        v8::JSEntryStub js_entry_stub;
    };
    class JSON {
    public:
        static MaybeLocal<v8::Value> Parse(Local<v8::Context> context, Local<v8::String> json_string) __attribute__((warn_unused_result));
        static MaybeLocal<v8::String> Stringify(Local<v8::Context> context, Local<v8::Value> json_object, Local<v8::String> gap = Local<v8::String>()) __attribute__((warn_unused_result));
    };
    class ValueSerializer {
    public:
        class Delegate {
        public:
            virtual ~Delegate() noexcept = default
            virtual void ThrowDataCloneError(Local<v8::String> message) = 0;
            virtual Maybe<bool> WriteHostObject(v8::Isolate *isolate, Local<v8::Object> object);
            virtual Maybe<uint32_t> GetSharedArrayBufferId(v8::Isolate *isolate, Local<v8::SharedArrayBuffer> shared_array_buffer);
            virtual Maybe<uint32_t> GetWasmModuleTransferId(v8::Isolate *isolate, Local<v8::WasmModuleObject> module);
            virtual void *ReallocateBufferMemory(void *old_buffer, size_t size, size_t *actual_size);
            virtual void FreeBufferMemory(void *buffer);
        };
        explicit ValueSerializer(v8::Isolate *isolate);
        ValueSerializer(v8::Isolate *isolate, v8::ValueSerializer::Delegate *delegate);
        ~ValueSerializer();
        void WriteHeader();
        Maybe<bool> WriteValue(Local<v8::Context> context, Local<v8::Value> value) __attribute__((warn_unused_result));
        std::pair<uint8_t *, size_t> Release() __attribute__((warn_unused_result));
        void TransferArrayBuffer(uint32_t transfer_id, Local<v8::ArrayBuffer> array_buffer);
        void SetTreatArrayBufferViewsAsHostObjects(bool mode);
        void WriteUint32(uint32_t value);
        void WriteUint64(uint64_t value);
        void WriteDouble(double value);
        void WriteRawBytes(const void *source, size_t length);
        ValueSerializer(const v8::ValueSerializer &) = delete
        void operator=(const v8::ValueSerializer &) = delete
    private:
        struct PrivateData;
        v8::ValueSerializer::PrivateData *private_;
    };
    class ValueDeserializer {
    public:
        class Delegate {
        public:
            virtual ~Delegate() noexcept = default
            virtual MaybeLocal<v8::Object> ReadHostObject(v8::Isolate *isolate);
            virtual MaybeLocal<v8::WasmModuleObject> GetWasmModuleFromId(v8::Isolate *isolate, uint32_t transfer_id);
            virtual MaybeLocal<v8::SharedArrayBuffer> GetSharedArrayBufferFromId(v8::Isolate *isolate, uint32_t clone_id);
        };
        ValueDeserializer(v8::Isolate *isolate, const uint8_t *data, size_t size);
        ValueDeserializer(v8::Isolate *isolate, const uint8_t *data, size_t size, v8::ValueDeserializer::Delegate *delegate);
        ~ValueDeserializer();
        Maybe<bool> ReadHeader(Local<v8::Context> context) __attribute__((warn_unused_result));
        MaybeLocal<v8::Value> ReadValue(Local<v8::Context> context) __attribute__((warn_unused_result));
        void TransferArrayBuffer(uint32_t transfer_id, Local<v8::ArrayBuffer> array_buffer);
        void TransferSharedArrayBuffer(uint32_t id, Local<v8::SharedArrayBuffer> shared_array_buffer);
        void SetSupportsLegacyWireFormat(bool supports_legacy_wire_format);
        void SetExpectInlineWasm(bool allow_inline_wasm);
        uint32_t GetWireFormatVersion() const;
        bool ReadUint32(uint32_t *value) __attribute__((warn_unused_result));
        bool ReadUint64(uint64_t *value) __attribute__((warn_unused_result));
        bool ReadDouble(double *value) __attribute__((warn_unused_result));
        bool ReadRawBytes(size_t length, const void **data) __attribute__((warn_unused_result));
        ValueDeserializer(const v8::ValueDeserializer &) = delete
        void operator=(const v8::ValueDeserializer &) = delete
    private:
        struct PrivateData;
        v8::ValueDeserializer::PrivateData *private_;
    };
    class Value : public v8::Data {
    public:
        inline bool IsUndefined() const __attribute__((always_inline));
        inline bool IsNull() const __attribute__((always_inline));
        inline bool IsNullOrUndefined() const __attribute__((always_inline));
        bool IsTrue() const;
        bool IsFalse() const;
        bool IsName() const;
        inline bool IsString() const __attribute__((always_inline));
        bool IsSymbol() const;
        bool IsFunction() const;
        bool IsArray() const;
        bool IsObject() const;
        bool IsBigInt() const;
        bool IsBoolean() const;
        bool IsNumber() const;
        bool IsExternal() const;
        bool IsInt32() const;
        bool IsUint32() const;
        bool IsDate() const;
        bool IsArgumentsObject() const;
        bool IsBigIntObject() const;
        bool IsBooleanObject() const;
        bool IsNumberObject() const;
        bool IsStringObject() const;
        bool IsSymbolObject() const;
        bool IsNativeError() const;
        bool IsRegExp() const;
        bool IsAsyncFunction() const;
        bool IsGeneratorFunction() const;
        bool IsGeneratorObject() const;
        bool IsPromise() const;
        bool IsMap() const;
        bool IsSet() const;
        bool IsMapIterator() const;
        bool IsSetIterator() const;
        bool IsWeakMap() const;
        bool IsWeakSet() const;
        bool IsArrayBuffer() const;
        bool IsArrayBufferView() const;
        bool IsTypedArray() const;
        bool IsUint8Array() const;
        bool IsUint8ClampedArray() const;
        bool IsInt8Array() const;
        bool IsUint16Array() const;
        bool IsInt16Array() const;
        bool IsUint32Array() const;
        bool IsInt32Array() const;
        bool IsFloat32Array() const;
        bool IsFloat64Array() const;
        bool IsBigInt64Array() const;
        bool IsBigUint64Array() const;
        bool IsDataView() const;
        bool IsSharedArrayBuffer() const;
        bool IsProxy() const;
        bool IsWebAssemblyCompiledModule() const;
        bool IsModuleNamespaceObject() const;
        MaybeLocal<v8::BigInt> ToBigInt(Local<v8::Context> context) const __attribute__((warn_unused_result));
        MaybeLocal<v8::Number> ToNumber(Local<v8::Context> context) const __attribute__((warn_unused_result));
        MaybeLocal<v8::String> ToString(Local<v8::Context> context) const __attribute__((warn_unused_result));
        MaybeLocal<v8::String> ToDetailString(Local<v8::Context> context) const __attribute__((warn_unused_result));
        MaybeLocal<v8::Object> ToObject(Local<v8::Context> context) const __attribute__((warn_unused_result));
        MaybeLocal<v8::Integer> ToInteger(Local<v8::Context> context) const __attribute__((warn_unused_result));
        MaybeLocal<v8::Uint32> ToUint32(Local<v8::Context> context) const __attribute__((warn_unused_result));
        MaybeLocal<v8::Int32> ToInt32(Local<v8::Context> context) const __attribute__((warn_unused_result));
        Local<v8::Boolean> ToBoolean(v8::Isolate *isolate) const;
        MaybeLocal<v8::Uint32> ToArrayIndex(Local<v8::Context> context) const __attribute__((warn_unused_result));
        bool BooleanValue(v8::Isolate *isolate) const;
        Maybe<double> NumberValue(Local<v8::Context> context) const __attribute__((warn_unused_result));
        Maybe<int64_t> IntegerValue(Local<v8::Context> context) const __attribute__((warn_unused_result));
        Maybe<uint32_t> Uint32Value(Local<v8::Context> context) const __attribute__((warn_unused_result));
        Maybe<int32_t> Int32Value(Local<v8::Context> context) const __attribute__((warn_unused_result));
        Maybe<bool> Equals(Local<v8::Context> context, Local<v8::Value> that) const __attribute__((warn_unused_result));
        bool StrictEquals(Local<v8::Value> that) const;
        bool SameValue(Local<v8::Value> that) const;
        template <class T> static inline v8::Value *Cast(T *value) __attribute__((always_inline));
        Local<v8::String> TypeOf(v8::Isolate *);
        Maybe<bool> InstanceOf(Local<v8::Context> context, Local<v8::Object> object);
    private:
        inline bool QuickIsUndefined() const __attribute__((always_inline));
        inline bool QuickIsNull() const __attribute__((always_inline));
        inline bool QuickIsNullOrUndefined() const __attribute__((always_inline));
        inline bool QuickIsString() const __attribute__((always_inline));
        bool FullIsUndefined() const;
        bool FullIsNull() const;
        bool FullIsString() const;
    };
    class Primitive : public v8::Value {
    };
    class Boolean : public v8::Primitive {
    public:
        bool Value() const;
        static inline v8::Boolean *Cast(v8::Value *obj) __attribute__((always_inline));
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, bool value) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    class Name : public v8::Primitive {
    public:
        int GetIdentityHash();
        static inline v8::Name *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    enum class NewStringType : int {
        kNormal,
        kInternalized
    };
    class String : public v8::Name {
    public:
        static constexpr int kMaxLength = internal::kApiTaggedSize == 4 ? (1 << 28) - 16 : internal::kSmiMaxValue / 2 - 24;
        enum Encoding {
            UNKNOWN_ENCODING = 1,
            TWO_BYTE_ENCODING = 0,
            ONE_BYTE_ENCODING = 8
        };
        int Length() const;
        int Utf8Length(v8::Isolate *isolate) const;
        bool IsOneByte() const;
        bool ContainsOnlyOneByte() const;
        enum WriteOptions {
            NO_OPTIONS = 0,
            HINT_MANY_WRITES_EXPECTED = 1,
            NO_NULL_TERMINATION = 2,
            PRESERVE_ONE_BYTE_NULL = 4,
            REPLACE_INVALID_UTF8 = 8
        };
        int Write(v8::Isolate *isolate, uint16_t *buffer, int start = 0, int length = -1, int options = NO_OPTIONS) const;
        int WriteOneByte(v8::Isolate *isolate, uint8_t *buffer, int start = 0, int length = -1, int options = NO_OPTIONS) const;
        int WriteUtf8(v8::Isolate *isolate, char *buffer, int length = -1, int *nchars_ref = nullptr, int options = NO_OPTIONS) const;
        static inline Local<v8::String> Empty(v8::Isolate *isolate) __attribute__((always_inline));
        bool IsExternal() const;
        bool IsExternalOneByte() const;
        class ExternalStringResourceBase {
        public:
            virtual ~ExternalStringResourceBase() noexcept = default            virtual bool IsCacheable() const             {
                return true;
            }
            ExternalStringResourceBase(const v8::String::ExternalStringResourceBase &) = delete
            void operator=(const v8::String::ExternalStringResourceBase &) = delete
        protected:
            ExternalStringResourceBase() = default
            virtual void Dispose()             {
                delete this;
            }
            virtual void Lock() const             {
            }
            virtual void Unlock() const             {
            }
        private:
            friend  class internal::ExternalString;
            friend  class v8::String;
            friend  class internal::ScopedExternalStringLock;
        };
        class ExternalStringResource : public v8::String::ExternalStringResourceBase {
        public:
            ~ExternalStringResource() noexcept override = default
            virtual const uint16_t *data() const = 0;
            virtual size_t length() const = 0;
        protected:
            ExternalStringResource() = default
        };
        class ExternalOneByteStringResource : public v8::String::ExternalStringResourceBase {
        public:
            ~ExternalOneByteStringResource() noexcept override = default            virtual const char *data() const = 0;
            virtual size_t length() const = 0;
        protected:
            ExternalOneByteStringResource() = default
        };
        inline v8::String::ExternalStringResourceBase *GetExternalStringResourceBase(v8::String::Encoding *encoding_out) const __attribute__((always_inline));
        inline v8::String::ExternalStringResource *GetExternalStringResource() const __attribute__((always_inline));
        const v8::String::ExternalOneByteStringResource *GetExternalOneByteStringResource() const;
        static inline v8::String *Cast(v8::Value *obj) __attribute__((always_inline));
        static MaybeLocal<v8::String> NewFromUtf8(v8::Isolate *isolate, const char *data, v8::NewStringType type = NewStringType::kNormal, int length = -1) __attribute__((warn_unused_result));
        static MaybeLocal<v8::String> NewFromOneByte(v8::Isolate *isolate, const uint8_t *data, v8::NewStringType type = NewStringType::kNormal, int length = -1) __attribute__((warn_unused_result));
        static MaybeLocal<v8::String> NewFromTwoByte(v8::Isolate *isolate, const uint16_t *data, v8::NewStringType type = NewStringType::kNormal, int length = -1) __attribute__((warn_unused_result));
        static Local<v8::String> Concat(v8::Isolate *isolate, Local<v8::String> left, Local<v8::String> right);
        static MaybeLocal<v8::String> NewExternalTwoByte(v8::Isolate *isolate, v8::String::ExternalStringResource *resource) __attribute__((warn_unused_result));
        bool MakeExternal(v8::String::ExternalStringResource *resource);
        static MaybeLocal<v8::String> NewExternalOneByte(v8::Isolate *isolate, v8::String::ExternalOneByteStringResource *resource) __attribute__((warn_unused_result));
        bool MakeExternal(v8::String::ExternalOneByteStringResource *resource);
        bool CanMakeExternal();
        bool StringEquals(Local<v8::String> str);
        class Utf8Value {
        public:
            Utf8Value(v8::Isolate *isolate, Local<v8::Value> obj);
            ~Utf8Value();
            char *operator*()             {
                return this->str_;
            }
            const char *operator*() const             {
                return this->str_;
            }
            int length() const             {
                return this->length_;
            }
            Utf8Value(const v8::String::Utf8Value &) = delete
            void operator=(const v8::String::Utf8Value &) = delete
        private:
            char *str_;
            int length_;
        };
        class Value {
        public:
            Value(v8::Isolate *isolate, Local<v8::Value> obj);
            ~Value();
            uint16_t *operator*()             {
                return this->str_;
            }
            const uint16_t *operator*() const             {
                return this->str_;
            }
            int length() const             {
                return this->length_;
            }
            Value(const v8::String::Value &) = delete
            void operator=(const v8::String::Value &) = delete
        private:
            uint16_t *str_;
            int length_;
        };
    private:
        void VerifyExternalStringResourceBase(v8::String::ExternalStringResourceBase *v, v8::String::Encoding encoding) const;
        void VerifyExternalStringResource(v8::String::ExternalStringResource *val) const;
        v8::String::ExternalStringResource *GetExternalStringResourceSlow() const;
        v8::String::ExternalStringResourceBase *GetExternalStringResourceBaseSlow(String::Encoding *encoding_out) const;
        static void CheckCast(v8::Value *obj);
    };
    class Symbol : public v8::Name {
    public:
        Local<v8::Value> Name() const;
        static Local<v8::Symbol> New(v8::Isolate *isolate, Local<v8::String> name = Local<v8::String>());
        static Local<v8::Symbol> For(v8::Isolate *isolate, Local<v8::String> name);
        static Local<v8::Symbol> ForApi(v8::Isolate *isolate, Local<v8::String> name);
        static Local<v8::Symbol> GetAsyncIterator(v8::Isolate *isolate);
        static Local<v8::Symbol> GetHasInstance(v8::Isolate *isolate);
        static Local<v8::Symbol> GetIsConcatSpreadable(v8::Isolate *isolate);
        static Local<v8::Symbol> GetIterator(v8::Isolate *isolate);
        static Local<v8::Symbol> GetMatch(v8::Isolate *isolate);
        static Local<v8::Symbol> GetReplace(v8::Isolate *isolate);
        static Local<v8::Symbol> GetSearch(v8::Isolate *isolate);
        static Local<v8::Symbol> GetSplit(v8::Isolate *isolate);
        static Local<v8::Symbol> GetToPrimitive(v8::Isolate *isolate);
        static Local<v8::Symbol> GetToStringTag(v8::Isolate *isolate);
        static Local<v8::Symbol> GetUnscopables(v8::Isolate *isolate);
        static inline v8::Symbol *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Symbol();
        static void CheckCast(v8::Value *obj);
    };
    class Private : public v8::Data {
    public:
        Local<v8::Value> Name() const;
        static Local<v8::Private> New(v8::Isolate *isolate, Local<v8::String> name = Local<v8::String>());
        static Local<v8::Private> ForApi(v8::Isolate *isolate, Local<v8::String> name);
        static inline v8::Private *Cast(v8::Data *data) __attribute__((always_inline));
    private:
        Private();
        static void CheckCast(v8::Data *that);
    };
    class Number : public v8::Primitive {
    public:
        double Value() const;
        static Local<v8::Number> New(v8::Isolate *isolate, double value);
        static inline v8::Number *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Number();
        static void CheckCast(v8::Value *obj);
    };
    class Integer : public v8::Number {
    public:
        static Local<v8::Integer> New(v8::Isolate *isolate, int32_t value);
        static Local<v8::Integer> NewFromUnsigned(v8::Isolate *isolate, uint32_t value);
        int64_t Value() const;
        static inline v8::Integer *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Integer();
        static void CheckCast(v8::Value *obj);
    };
    class Int32 : public v8::Integer {
    public:
        int32_t Value() const;
        static inline v8::Int32 *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Int32();
        static void CheckCast(v8::Value *obj);
    };
    class Uint32 : public v8::Integer {
    public:
        uint32_t Value() const;
        static inline v8::Uint32 *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Uint32();
        static void CheckCast(v8::Value *obj);
    };
    class BigInt : public v8::Primitive {
    public:
        static Local<v8::BigInt> New(v8::Isolate *isolate, int64_t value);
        static Local<v8::BigInt> NewFromUnsigned(v8::Isolate *isolate, uint64_t value);
        static MaybeLocal<v8::BigInt> NewFromWords(Local<v8::Context> context, int sign_bit, int word_count, const uint64_t *words);
        uint64_t Uint64Value(bool *lossless = nullptr) const;
        int64_t Int64Value(bool *lossless = nullptr) const;
        int WordCount() const;
        void ToWordsArray(int *sign_bit, int *word_count, uint64_t *words) const;
        static inline v8::BigInt *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        BigInt();
        static void CheckCast(v8::Value *obj);
    };
    enum PropertyAttribute {
        None = 0,
        ReadOnly = 1 << 0,
        DontEnum = 1 << 1,
        DontDelete = 1 << 2
    };
    typedef void (*AccessorGetterCallback)(Local<v8::String>, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*AccessorNameGetterCallback)(Local<v8::Name>, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*AccessorSetterCallback)(Local<v8::String>, Local<v8::Value>, const PropertyCallbackInfo<void> &);
    typedef void (*AccessorNameSetterCallback)(Local<v8::Name>, Local<v8::Value>, const PropertyCallbackInfo<void> &);
    enum AccessControl {
        DEFAULT = 0,
        ALL_CAN_READ = 1,
        ALL_CAN_WRITE = 1 << 1,
        PROHIBITS_OVERWRITING = 1 << 2
    };
    enum PropertyFilter {
        ALL_PROPERTIES = 0,
        ONLY_WRITABLE = 1,
        ONLY_ENUMERABLE = 2,
        ONLY_CONFIGURABLE = 4,
        SKIP_STRINGS = 8,
        SKIP_SYMBOLS = 16
    };
    enum class SideEffectType : int {
        kHasSideEffect,
        kHasNoSideEffect,
        kHasSideEffectToReceiver
    };
    enum class KeyCollectionMode : int {
        kOwnOnly,
        kIncludePrototypes
    };
    enum class IndexFilter : int {
        kIncludeIndices,
        kSkipIndices
    };
    enum class KeyConversionMode : int {
        kConvertToString,
        kKeepNumbers
    };
    enum class IntegrityLevel : int {
        kFrozen,
        kSealed
    };
    class Object : public v8::Value {
    public:
        bool Set(Local<v8::Value> key, Local<v8::Value> value);
        Maybe<bool> Set(Local<v8::Context> context, Local<v8::Value> key, Local<v8::Value> value) __attribute__((warn_unused_result));
        bool Set(uint32_t index, Local<v8::Value> value);
        Maybe<bool> Set(Local<v8::Context> context, uint32_t index, Local<v8::Value> value) __attribute__((warn_unused_result));
        Maybe<bool> CreateDataProperty(Local<v8::Context> context, Local<v8::Name> key, Local<v8::Value> value) __attribute__((warn_unused_result));
        Maybe<bool> CreateDataProperty(Local<v8::Context> context, uint32_t index, Local<v8::Value> value) __attribute__((warn_unused_result));
        Maybe<bool> DefineOwnProperty(Local<v8::Context> context, Local<v8::Name> key, Local<v8::Value> value, v8::PropertyAttribute attributes = None) __attribute__((warn_unused_result));
        Maybe<bool> DefineProperty(Local<v8::Context> context, Local<v8::Name> key, v8::PropertyDescriptor &descriptor) __attribute__((warn_unused_result));
        Local<v8::Value> Get(Local<v8::Value> key);
        MaybeLocal<v8::Value> Get(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        Local<v8::Value> Get(uint32_t index);
        MaybeLocal<v8::Value> Get(Local<v8::Context> context, uint32_t index) __attribute__((warn_unused_result));
        Maybe<v8::PropertyAttribute> GetPropertyAttributes(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        MaybeLocal<v8::Value> GetOwnPropertyDescriptor(Local<v8::Context> context, Local<v8::Name> key) __attribute__((warn_unused_result));
        Maybe<bool> Has(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        Maybe<bool> Delete(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        Maybe<bool> Has(Local<v8::Context> context, uint32_t index) __attribute__((warn_unused_result));
        Maybe<bool> Delete(Local<v8::Context> context, uint32_t index) __attribute__((warn_unused_result));
        Maybe<bool> SetAccessor(Local<v8::Context> context, Local<v8::Name> name, v8::AccessorNameGetterCallback getter, v8::AccessorNameSetterCallback setter = nullptr, MaybeLocal<v8::Value> data = MaybeLocal<v8::Value>(), v8::AccessControl settings = DEFAULT, v8::PropertyAttribute attribute = None, v8::SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect, v8::SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect) __attribute__((warn_unused_result));
        void SetAccessorProperty(Local<v8::Name> name, Local<v8::Function> getter, Local<v8::Function> setter = Local<v8::Function>(), v8::PropertyAttribute attribute = None, v8::AccessControl settings = DEFAULT);
        Maybe<bool> SetNativeDataProperty(Local<v8::Context> context, Local<v8::Name> name, v8::AccessorNameGetterCallback getter, v8::AccessorNameSetterCallback setter = nullptr, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyAttribute attributes = None, v8::SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect, v8::SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect) __attribute__((warn_unused_result));
        Maybe<bool> SetLazyDataProperty(Local<v8::Context> context, Local<v8::Name> name, v8::AccessorNameGetterCallback getter, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyAttribute attributes = None, v8::SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect, v8::SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect) __attribute__((warn_unused_result));
        Maybe<bool> HasPrivate(Local<v8::Context> context, Local<v8::Private> key);
        Maybe<bool> SetPrivate(Local<v8::Context> context, Local<v8::Private> key, Local<v8::Value> value);
        Maybe<bool> DeletePrivate(Local<v8::Context> context, Local<v8::Private> key);
        MaybeLocal<v8::Value> GetPrivate(Local<v8::Context> context, Local<v8::Private> key);
        MaybeLocal<v8::Array> GetPropertyNames(Local<v8::Context> context) __attribute__((warn_unused_result));
        MaybeLocal<v8::Array> GetPropertyNames(Local<v8::Context> context, v8::KeyCollectionMode mode, v8::PropertyFilter property_filter, v8::IndexFilter index_filter, v8::KeyConversionMode key_conversion = KeyConversionMode::kKeepNumbers) __attribute__((warn_unused_result));
        MaybeLocal<v8::Array> GetOwnPropertyNames(Local<v8::Context> context) __attribute__((warn_unused_result));
        MaybeLocal<v8::Array> GetOwnPropertyNames(Local<v8::Context> context, v8::PropertyFilter filter, v8::KeyConversionMode key_conversion = KeyConversionMode::kKeepNumbers) __attribute__((warn_unused_result));
        Local<v8::Value> GetPrototype();
        Maybe<bool> SetPrototype(Local<v8::Context> context, Local<v8::Value> prototype) __attribute__((warn_unused_result));
        Local<v8::Object> FindInstanceInPrototypeChain(Local<v8::FunctionTemplate> tmpl);
        MaybeLocal<v8::String> ObjectProtoToString(Local<v8::Context> context) __attribute__((warn_unused_result));
        Local<v8::String> GetConstructorName();
        Maybe<bool> SetIntegrityLevel(Local<v8::Context> context, v8::IntegrityLevel level);
        int InternalFieldCount();
        static inline int InternalFieldCount(const PersistentBase<v8::Object> &object) __attribute__((always_inline))         {
            return object.val_->InternalFieldCount();
        }
        static inline int InternalFieldCount(const TracedGlobal<v8::Object> &object) __attribute__((always_inline))         {
            return object.val_->InternalFieldCount();
        }
        inline Local<v8::Value> GetInternalField(int index) __attribute__((always_inline));
        void SetInternalField(int index, Local<v8::Value> value);
        inline void *GetAlignedPointerFromInternalField(int index) __attribute__((always_inline));
        static inline void *GetAlignedPointerFromInternalField(const PersistentBase<v8::Object> &object, int index) __attribute__((always_inline))         {
            return object.val_->GetAlignedPointerFromInternalField(index);
        }
        static inline void *GetAlignedPointerFromInternalField(const TracedGlobal<v8::Object> &object, int index) __attribute__((always_inline))         {
            return object.val_->GetAlignedPointerFromInternalField(index);
        }
        void SetAlignedPointerInInternalField(int index, void *value);
        void SetAlignedPointerInInternalFields(int argc, int indices[], void *values[]);
        Maybe<bool> HasOwnProperty(Local<v8::Context> context, Local<v8::Name> key) __attribute__((warn_unused_result));
        Maybe<bool> HasOwnProperty(Local<v8::Context> context, uint32_t index) __attribute__((warn_unused_result));
        Maybe<bool> HasRealNamedProperty(Local<v8::Context> context, Local<v8::Name> key) __attribute__((warn_unused_result));
        Maybe<bool> HasRealIndexedProperty(Local<v8::Context> context, uint32_t index) __attribute__((warn_unused_result));
        Maybe<bool> HasRealNamedCallbackProperty(Local<v8::Context> context, Local<v8::Name> key) __attribute__((warn_unused_result));
        MaybeLocal<v8::Value> GetRealNamedPropertyInPrototypeChain(Local<v8::Context> context, Local<v8::Name> key) __attribute__((warn_unused_result));
        Maybe<v8::PropertyAttribute> GetRealNamedPropertyAttributesInPrototypeChain(Local<v8::Context> context, Local<v8::Name> key) __attribute__((warn_unused_result));
        MaybeLocal<v8::Value> GetRealNamedProperty(Local<v8::Context> context, Local<v8::Name> key) __attribute__((warn_unused_result));
        Maybe<v8::PropertyAttribute> GetRealNamedPropertyAttributes(Local<v8::Context> context, Local<v8::Name> key) __attribute__((warn_unused_result));
        bool HasNamedLookupInterceptor();
        bool HasIndexedLookupInterceptor();
        int GetIdentityHash();
        Local<v8::Object> Clone();
        Local<v8::Context> CreationContext();
        static inline Local<v8::Context> CreationContext(const PersistentBase<v8::Object> &object) __attribute__((always_inline))         {
            return object.val_->CreationContext();
        }
        bool IsCallable();
        bool IsConstructor();
        MaybeLocal<v8::Value> CallAsFunction(Local<v8::Context> context, Local<v8::Value> recv, int argc, Local<v8::Value> argv[]) __attribute__((warn_unused_result));
        MaybeLocal<v8::Value> CallAsConstructor(Local<v8::Context> context, int argc, Local<v8::Value> argv[]) __attribute__((warn_unused_result));
        v8::Isolate *GetIsolate();
        MaybeLocal<v8::Array> PreviewEntries(bool *is_key_value);
        static Local<v8::Object> New(v8::Isolate *isolate);
        static Local<v8::Object> New(v8::Isolate *isolate, Local<v8::Value> prototype_or_null, Local<v8::Name> *names, Local<v8::Value> *values, size_t length);
        static inline v8::Object *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Object();
        static void CheckCast(v8::Value *obj);
        Local<v8::Value> SlowGetInternalField(int index);
        void *SlowGetAlignedPointerFromInternalField(int index);
    };
    class Array : public v8::Object {
    public:
        uint32_t Length() const;
        static Local<v8::Array> New(v8::Isolate *isolate, int length = 0);
        static Local<v8::Array> New(v8::Isolate *isolate, Local<v8::Value> *elements, size_t length);
        static inline v8::Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Array();
        static void CheckCast(v8::Value *obj);
    };
    class Map : public v8::Object {
    public:
        size_t Size() const;
        void Clear();
        MaybeLocal<v8::Value> Get(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        MaybeLocal<v8::Map> Set(Local<v8::Context> context, Local<v8::Value> key, Local<v8::Value> value) __attribute__((warn_unused_result));
        Maybe<bool> Has(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        Maybe<bool> Delete(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        Local<v8::Array> AsArray() const;
        static Local<v8::Map> New(v8::Isolate *isolate);
        static inline v8::Map *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Map();
        static void CheckCast(v8::Value *obj);
    };
    class Set : public v8::Object {
    public:
        size_t Size() const;
        void Clear();
        MaybeLocal<v8::Set> Add(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        Maybe<bool> Has(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        Maybe<bool> Delete(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        Local<v8::Array> AsArray() const;
        static Local<v8::Set> New(v8::Isolate *isolate);
        static inline v8::Set *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Set();
        static void CheckCast(v8::Value *obj);
    };
    template <typename T> class ReturnValue {
    public:
        template <class S> inline ReturnValue<T>(const ReturnValue<S> &that) : value_(that.value_) __attribute__((always_inline))         {
            while (false)
                {
                    *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
                }
            ;
        }
        template <typename S> inline void Set(const Global<S> &handle) __attribute__((always_inline));
        template <typename S> inline void Set(const TracedGlobal<S> &handle) __attribute__((always_inline));
        template <typename S> inline void Set(const Local<S> handle) __attribute__((always_inline));
        inline void Set(bool value) __attribute__((always_inline));
        inline void Set(double i) __attribute__((always_inline));
        inline void Set(int32_t i) __attribute__((always_inline));
        inline void Set(uint32_t i) __attribute__((always_inline));
        inline void SetNull() __attribute__((always_inline));
        inline void SetUndefined() __attribute__((always_inline));
        inline void SetEmptyString() __attribute__((always_inline));
        inline v8::Isolate *GetIsolate() const __attribute__((always_inline));
        template <typename S> inline void Set(S *whatever) __attribute__((always_inline));
        inline Local<v8::Value> Get() const __attribute__((always_inline));
    private:
        friend template <class F> class ReturnValue;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend template <class F, class G, class H> class PersistentValueMapBase;
        inline void SetInternal(internal::Address value) __attribute__((always_inline))         {
            *this->value_ = value;
        }
        inline internal::Address GetDefaultValue() __attribute__((always_inline));
        inline explicit ReturnValue<T>(internal::Address *slot) __attribute__((always_inline));
        internal::Address *value_;
    };
    template <typename T> class FunctionCallbackInfo {
    public:
        inline int Length() const __attribute__((always_inline));
        inline Local<v8::Value> operator[](int i) const __attribute__((always_inline));
        inline Local<v8::Object> This() const __attribute__((always_inline));
        inline Local<v8::Object> Holder() const __attribute__((always_inline));
        inline Local<v8::Value> NewTarget() const __attribute__((always_inline));
        inline bool IsConstructCall() const __attribute__((always_inline));
        inline Local<v8::Value> Data() const __attribute__((always_inline));
        inline v8::Isolate *GetIsolate() const __attribute__((always_inline));
        inline ReturnValue<T> GetReturnValue() const __attribute__((always_inline));
        static const int kArgsLength = 6;
    protected:
        friend  class internal::FunctionCallbackArguments;
        friend  class internal::CustomArguments<FunctionCallbackInfo<T> >;
        friend  class debug::ConsoleCallArguments;
        static const int kHolderIndex = 0;
        static const int kIsolateIndex = 1;
        static const int kReturnValueDefaultValueIndex = 2;
        static const int kReturnValueIndex = 3;
        static const int kDataIndex = 4;
        static const int kNewTargetIndex = 5;
        inline FunctionCallbackInfo<T>(internal::Address *implicit_args, internal::Address *values, int length) __attribute__((always_inline));
        internal::Address *implicit_args_;
        internal::Address *values_;
        int length_;
    };
    template <typename T> class PropertyCallbackInfo {
    public:
        inline v8::Isolate *GetIsolate() const __attribute__((always_inline));
        inline Local<v8::Value> Data() const __attribute__((always_inline));
        inline Local<v8::Object> This() const __attribute__((always_inline));
        inline Local<v8::Object> Holder() const __attribute__((always_inline));
        inline ReturnValue<T> GetReturnValue() const __attribute__((always_inline));
        inline bool ShouldThrowOnError() const __attribute__((always_inline));
        static const int kArgsLength = 7;
    protected:
        friend  class MacroAssembler;
        friend  class internal::PropertyCallbackArguments;
        friend  class internal::CustomArguments<PropertyCallbackInfo<T> >;
        static const int kShouldThrowOnErrorIndex = 0;
        static const int kHolderIndex = 1;
        static const int kIsolateIndex = 2;
        static const int kReturnValueDefaultValueIndex = 3;
        static const int kReturnValueIndex = 4;
        static const int kDataIndex = 5;
        static const int kThisIndex = 6;
        inline PropertyCallbackInfo<T>(internal::Address *args) : args_(args) __attribute__((always_inline))         {
        }
        internal::Address *args_;
    };
    typedef void (*FunctionCallback)(const FunctionCallbackInfo<v8::Value> &);
    enum class ConstructorBehavior : int {
        kThrow,
        kAllow
    };
    class Function : public v8::Object {
    public:
        static MaybeLocal<v8::Function> New(Local<v8::Context> context, v8::FunctionCallback callback, Local<v8::Value> data = Local<v8::Value>(), int length = 0, v8::ConstructorBehavior behavior = ConstructorBehavior::kAllow, v8::SideEffectType side_effect_type = SideEffectType::kHasSideEffect);
        MaybeLocal<v8::Object> NewInstance(Local<v8::Context> context, int argc, Local<v8::Value> argv[]) const __attribute__((warn_unused_result));
        MaybeLocal<v8::Object> NewInstance(Local<v8::Context> context) const __attribute__((warn_unused_result))         {
            return this->NewInstance(context, 0, nullptr);
        }
        MaybeLocal<v8::Object> NewInstanceWithSideEffectType(Local<v8::Context> context, int argc, Local<v8::Value> argv[], v8::SideEffectType side_effect_type = SideEffectType::kHasSideEffect) const __attribute__((warn_unused_result));
        MaybeLocal<v8::Value> Call(Local<v8::Context> context, Local<v8::Value> recv, int argc, Local<v8::Value> argv[]) __attribute__((warn_unused_result));
        void SetName(Local<v8::String> name);
        Local<v8::Value> GetName() const;
        Local<v8::Value> GetInferredName() const;
        Local<v8::Value> GetDebugName() const;
        Local<v8::Value> GetDisplayName() const;
        int GetScriptLineNumber() const;
        int GetScriptColumnNumber() const;
        int ScriptId() const;
        Local<v8::Value> GetBoundFunction() const;
        v8::ScriptOrigin GetScriptOrigin() const;
        static inline v8::Function *Cast(v8::Value *obj) __attribute__((always_inline));
        static const int kLineOffsetNotFound;
    private:
        Function();
        static void CheckCast(v8::Value *obj);
    };
    class Promise : public v8::Object {
    public:
        enum PromiseState {
            kPending,
            kFulfilled,
            kRejected
        };
        class Resolver : public v8::Object {
        public:
            static MaybeLocal<v8::Promise::Resolver> New(Local<v8::Context> context) __attribute__((warn_unused_result));
            Local<v8::Promise> GetPromise();
            Maybe<bool> Resolve(Local<v8::Context> context, Local<v8::Value> value) __attribute__((warn_unused_result));
            Maybe<bool> Reject(Local<v8::Context> context, Local<v8::Value> value) __attribute__((warn_unused_result));
            static inline v8::Promise::Resolver *Cast(v8::Value *obj) __attribute__((always_inline));
        private:
            Resolver();
            static void CheckCast(v8::Value *obj);
        };
        MaybeLocal<v8::Promise> Catch(Local<v8::Context> context, Local<v8::Function> handler) __attribute__((warn_unused_result));
        MaybeLocal<v8::Promise> Then(Local<v8::Context> context, Local<v8::Function> handler) __attribute__((warn_unused_result));
        MaybeLocal<v8::Promise> Then(Local<v8::Context> context, Local<v8::Function> on_fulfilled, Local<v8::Function> on_rejected) __attribute__((warn_unused_result));
        bool HasHandler();
        Local<v8::Value> Result();
        v8::Promise::PromiseState State();
        void MarkAsHandled();
        static inline v8::Promise *Cast(v8::Value *obj) __attribute__((always_inline));
        static const int kEmbedderFieldCount = 0;
    private:
        Promise();
        static void CheckCast(v8::Value *obj);
    };
    class PropertyDescriptor {
    public:
        PropertyDescriptor();
        explicit PropertyDescriptor(Local<v8::Value> value);
        PropertyDescriptor(Local<v8::Value> value, bool writable);
        PropertyDescriptor(Local<v8::Value> get, Local<v8::Value> set);
        ~PropertyDescriptor();
        Local<v8::Value> value() const;
        bool has_value() const;
        Local<v8::Value> get() const;
        bool has_get() const;
        Local<v8::Value> set() const;
        bool has_set() const;
        void set_enumerable(bool enumerable);
        bool enumerable() const;
        bool has_enumerable() const;
        void set_configurable(bool configurable);
        bool configurable() const;
        bool has_configurable() const;
        bool writable() const;
        bool has_writable() const;
        struct PrivateData;
        v8::PropertyDescriptor::PrivateData *get_private() const         {
            return this->private_;
        }
        PropertyDescriptor(const v8::PropertyDescriptor &) = delete
        void operator=(const v8::PropertyDescriptor &) = delete
    private:
        v8::PropertyDescriptor::PrivateData *private_;
    };
    class Proxy : public v8::Object {
    public:
        Local<v8::Value> GetTarget();
        Local<v8::Value> GetHandler();
        bool IsRevoked();
        void Revoke();
        static MaybeLocal<v8::Proxy> New(Local<v8::Context> context, Local<v8::Object> local_target, Local<v8::Object> local_handler);
        static inline v8::Proxy *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Proxy();
        static void CheckCast(v8::Value *obj);
    };
    template <typename T> class MemorySpan {
    public:
        MemorySpan<T>() = default
        constexpr MemorySpan<T>(T *data, size_t size) : data_(data), size_(size)         {
        }
        constexpr T *data() const         {
            return this->data_;
        }
        constexpr size_t size() const         {
            return this->size_;
        }
    private:
        T *data_ = nullptr;
        size_t size_ = 0;
    };
template<> class MemorySpan<const unsigned char> {
    public:
        MemorySpan() = default
        constexpr MemorySpan(const unsigned char *data, size_t size) : data_(data), size_(size)         {
        }
        constexpr const unsigned char *data() const;
        constexpr size_t size() const;
    private:
        const unsigned char *data_;
        size_t size_;
    };
    struct OwnedBuffer {
        std::unique_ptr<const uint8_t []> buffer;
        size_t size = 0;
        OwnedBuffer(std::unique_ptr<const uint8_t []> buffer, size_t size) : buffer(std::move(buffer)), size(size)         {
        }
        OwnedBuffer() = default
    };
    class CompiledWasmModule {
    public:
        v8::OwnedBuffer Serialize();
        MemorySpan<const uint8_t> GetWireBytesRef();
    private:
        explicit CompiledWasmModule(std::shared_ptr<internal::wasm::NativeModule>);
        friend  class Utils;
        const std::shared_ptr<internal::wasm::NativeModule> native_module_;
    };
    class WasmModuleObject : public v8::Object {
    public:
        class final TransferrableModule {
        public:
            TransferrableModule(v8::WasmModuleObject::TransferrableModule &&src) = default
            TransferrableModule(const v8::WasmModuleObject::TransferrableModule &src) = delete
            v8::WasmModuleObject::TransferrableModule &operator=(v8::WasmModuleObject::TransferrableModule &&src) = default
            v8::WasmModuleObject::TransferrableModule &operator=(const v8::WasmModuleObject::TransferrableModule &src) = delete
        private:
            typedef std::shared_ptr<internal::wasm::NativeModule> SharedModule;
            friend  class WasmModuleObject;
            explicit TransferrableModule(v8::WasmModuleObject::TransferrableModule::SharedModule shared_module) : shared_module_(std::move(shared_module))             {
            }
            TransferrableModule(v8::OwnedBuffer serialized, v8::OwnedBuffer bytes) : shared_module_(), serialized_(std::move(serialized)), wire_bytes_(std::move(bytes))             {
            }
            v8::WasmModuleObject::TransferrableModule::SharedModule shared_module_;
            v8::OwnedBuffer serialized_ = {nullptr, 0};
            v8::OwnedBuffer wire_bytes_ = {nullptr, 0};
        };
        v8::WasmModuleObject::TransferrableModule GetTransferrableModule();
        static MaybeLocal<v8::WasmModuleObject> FromTransferrableModule(v8::Isolate *isolate, const v8::WasmModuleObject::TransferrableModule &);
        v8::CompiledWasmModule GetCompiledModule();
        static MaybeLocal<v8::WasmModuleObject> DeserializeOrCompile(v8::Isolate *isolate, MemorySpan<const uint8_t> serialized_module, MemorySpan<const uint8_t> wire_bytes);
        static inline v8::WasmModuleObject *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static MaybeLocal<v8::WasmModuleObject> Deserialize(v8::Isolate *isolate, MemorySpan<const uint8_t> serialized_module, MemorySpan<const uint8_t> wire_bytes);
        static MaybeLocal<v8::WasmModuleObject> Compile(v8::Isolate *isolate, const uint8_t *start, size_t length);
        static MemorySpan<const uint8_t> AsReference(const v8::OwnedBuffer &buff)         {
            return {buff.buffer.get(), buff.size};
        }
        WasmModuleObject();
        static void CheckCast(v8::Value *obj);
    };
    class final WasmStreaming {
    public:
        class WasmStreamingImpl;
        class Client {
        public:
            virtual ~Client() noexcept = default
            virtual void OnModuleCompiled(v8::CompiledWasmModule compiled_module) = 0;
        };
        explicit WasmStreaming(std::unique_ptr<WasmStreamingImpl> impl);
        ~WasmStreaming();
        void OnBytesReceived(const uint8_t *bytes, size_t size);
        void Finish();
        void Abort(MaybeLocal<v8::Value> exception);
        bool SetCompiledModuleBytes(const uint8_t *bytes, size_t size);
        void SetClient(std::shared_ptr<Client> client);
        static std::shared_ptr<WasmStreaming> Unpack(v8::Isolate *isolate, Local<v8::Value> value);
    private:
        std::unique_ptr<WasmStreamingImpl> impl_;
    };
    class final WasmModuleObjectBuilderStreaming {
    public:
        explicit WasmModuleObjectBuilderStreaming(v8::Isolate *isolate);
        void OnBytesReceived(const uint8_t *, size_t size);
        void Finish();
        void Abort(MaybeLocal<v8::Value> exception);
        Local<v8::Promise> GetPromise();
        ~WasmModuleObjectBuilderStreaming() noexcept = default
    private:
        WasmModuleObjectBuilderStreaming(const v8::WasmModuleObjectBuilderStreaming &) = delete
        WasmModuleObjectBuilderStreaming(v8::WasmModuleObjectBuilderStreaming &&) = default
        v8::WasmModuleObjectBuilderStreaming &operator=(const v8::WasmModuleObjectBuilderStreaming &) = delete
        v8::WasmModuleObjectBuilderStreaming &operator=(v8::WasmModuleObjectBuilderStreaming &&) = default
        v8::Isolate *isolate_ = nullptr;
        Persistent<v8::Promise, CopyablePersistentTraits<v8::Promise> > promise_;
        std::shared_ptr<internal::wasm::StreamingDecoder> streaming_decoder_;
    };
    enum class ArrayBufferCreationMode : int {
        kInternalized,
        kExternalized
    };
    class ArrayBuffer : public v8::Object {
    public:
        class Allocator {
        public:
            virtual ~Allocator() noexcept = default
            virtual void *Allocate(size_t length) = 0;
            virtual void *AllocateUninitialized(size_t length) = 0;
            virtual void Free(void *data, size_t length) = 0;
            enum class AllocationMode : int {
                kNormal,
                kReservation
            };
            static v8::ArrayBuffer::Allocator *NewDefaultAllocator();
        };
        class Contents {
        public:
            using DeleterCallback = void (*)(void *, size_t, void *);
            Contents() : data_(nullptr), byte_length_(0), allocation_base_(nullptr), allocation_length_(0), allocation_mode_(Allocator::AllocationMode::kNormal), deleter_(nullptr), deleter_data_(nullptr)             {
            }
            void *AllocationBase() const             {
                return this->allocation_base_;
            }
            size_t AllocationLength() const             {
                return this->allocation_length_;
            }
            Allocator::AllocationMode AllocationMode() const             {
                return this->allocation_mode_;
            }
            void *Data() const             {
                return this->data_;
            }
            size_t ByteLength() const             {
                return this->byte_length_;
            }
            v8::ArrayBuffer::Contents::DeleterCallback Deleter() const             {
                return this->deleter_;
            }
            void *DeleterData() const             {
                return this->deleter_data_;
            }
        private:
            Contents(void *data, size_t byte_length, void *allocation_base, size_t allocation_length, Allocator::AllocationMode allocation_mode, v8::ArrayBuffer::Contents::DeleterCallback deleter, void *deleter_data);
            void *data_;
            size_t byte_length_;
            void *allocation_base_;
            size_t allocation_length_;
            Allocator::AllocationMode allocation_mode_;
            v8::ArrayBuffer::Contents::DeleterCallback deleter_;
            void *deleter_data_;
            friend  class ArrayBuffer;
        };
        size_t ByteLength() const;
        static Local<v8::ArrayBuffer> New(v8::Isolate *isolate, size_t byte_length);
        static Local<v8::ArrayBuffer> New(v8::Isolate *isolate, void *data, size_t byte_length, v8::ArrayBufferCreationMode mode = ArrayBufferCreationMode::kExternalized);
        bool IsExternal() const;
        bool IsDetachable() const;
        inline bool IsNeuterable() const         {
            return this->IsDetachable();
        }
        void Detach();
        inline void Neuter()         {
            this->Detach();
        }
        v8::ArrayBuffer::Contents Externalize();
        v8::ArrayBuffer::Contents GetContents();
        static inline v8::ArrayBuffer *Cast(v8::Value *obj) __attribute__((always_inline));
        static const int kInternalFieldCount = 2;
        static const int kEmbedderFieldCount = 2;
    private:
        ArrayBuffer();
        static void CheckCast(v8::Value *obj);
    };
    class ArrayBufferView : public v8::Object {
    public:
        Local<v8::ArrayBuffer> Buffer();
        size_t ByteOffset();
        size_t ByteLength();
        size_t CopyContents(void *dest, size_t byte_length);
        bool HasBuffer() const;
        static inline v8::ArrayBufferView *Cast(v8::Value *obj) __attribute__((always_inline));
        static const int kInternalFieldCount = 2;
        static const int kEmbedderFieldCount = 2;
    private:
        ArrayBufferView();
        static void CheckCast(v8::Value *obj);
    };
    class TypedArray : public v8::ArrayBufferView {
    public:
        static constexpr size_t kMaxLength = internal::kSmiMaxValue;
        size_t Length();
        static inline v8::TypedArray *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        TypedArray();
        static void CheckCast(v8::Value *obj);
    };
    class Uint8Array : public v8::TypedArray {
    public:
        static Local<v8::Uint8Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Uint8Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Uint8Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Uint8Array();
        static void CheckCast(v8::Value *obj);
    };
    class Uint8ClampedArray : public v8::TypedArray {
    public:
        static Local<v8::Uint8ClampedArray> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Uint8ClampedArray> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Uint8ClampedArray *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Uint8ClampedArray();
        static void CheckCast(v8::Value *obj);
    };
    class Int8Array : public v8::TypedArray {
    public:
        static Local<v8::Int8Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Int8Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Int8Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Int8Array();
        static void CheckCast(v8::Value *obj);
    };
    class Uint16Array : public v8::TypedArray {
    public:
        static Local<v8::Uint16Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Uint16Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Uint16Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Uint16Array();
        static void CheckCast(v8::Value *obj);
    };
    class Int16Array : public v8::TypedArray {
    public:
        static Local<v8::Int16Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Int16Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Int16Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Int16Array();
        static void CheckCast(v8::Value *obj);
    };
    class Uint32Array : public v8::TypedArray {
    public:
        static Local<v8::Uint32Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Uint32Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Uint32Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Uint32Array();
        static void CheckCast(v8::Value *obj);
    };
    class Int32Array : public v8::TypedArray {
    public:
        static Local<v8::Int32Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Int32Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Int32Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Int32Array();
        static void CheckCast(v8::Value *obj);
    };
    class Float32Array : public v8::TypedArray {
    public:
        static Local<v8::Float32Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Float32Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Float32Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Float32Array();
        static void CheckCast(v8::Value *obj);
    };
    class Float64Array : public v8::TypedArray {
    public:
        static Local<v8::Float64Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Float64Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Float64Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Float64Array();
        static void CheckCast(v8::Value *obj);
    };
    class BigInt64Array : public v8::TypedArray {
    public:
        static Local<v8::BigInt64Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::BigInt64Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::BigInt64Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        BigInt64Array();
        static void CheckCast(v8::Value *obj);
    };
    class BigUint64Array : public v8::TypedArray {
    public:
        static Local<v8::BigUint64Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::BigUint64Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::BigUint64Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        BigUint64Array();
        static void CheckCast(v8::Value *obj);
    };
    class DataView : public v8::ArrayBufferView {
    public:
        static Local<v8::DataView> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::DataView> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::DataView *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        DataView();
        static void CheckCast(v8::Value *obj);
    };
    class SharedArrayBuffer : public v8::Object {
    public:
        class Contents {
        public:
            using Allocator = v8::ArrayBuffer::Allocator;
            using DeleterCallback = void (*)(void *, size_t, void *);
            Contents() : data_(nullptr), byte_length_(0), allocation_base_(nullptr), allocation_length_(0), allocation_mode_(Allocator::AllocationMode::kNormal), deleter_(nullptr), deleter_data_(nullptr)             {
            }
            void *AllocationBase() const             {
                return this->allocation_base_;
            }
            size_t AllocationLength() const             {
                return this->allocation_length_;
            }
            Allocator::AllocationMode AllocationMode() const             {
                return this->allocation_mode_;
            }
            void *Data() const             {
                return this->data_;
            }
            size_t ByteLength() const             {
                return this->byte_length_;
            }
            v8::SharedArrayBuffer::Contents::DeleterCallback Deleter() const             {
                return this->deleter_;
            }
            void *DeleterData() const             {
                return this->deleter_data_;
            }
        private:
            Contents(void *data, size_t byte_length, void *allocation_base, size_t allocation_length, Allocator::AllocationMode allocation_mode, v8::SharedArrayBuffer::Contents::DeleterCallback deleter, void *deleter_data);
            void *data_;
            size_t byte_length_;
            void *allocation_base_;
            size_t allocation_length_;
            Allocator::AllocationMode allocation_mode_;
            v8::SharedArrayBuffer::Contents::DeleterCallback deleter_;
            void *deleter_data_;
            friend  class SharedArrayBuffer;
        };
        size_t ByteLength() const;
        static Local<v8::SharedArrayBuffer> New(v8::Isolate *isolate, size_t byte_length);
        static Local<v8::SharedArrayBuffer> New(v8::Isolate *isolate, void *data, size_t byte_length, v8::ArrayBufferCreationMode mode = ArrayBufferCreationMode::kExternalized);
        static Local<v8::SharedArrayBuffer> New(v8::Isolate *isolate, const SharedArrayBuffer::Contents &, v8::ArrayBufferCreationMode mode = ArrayBufferCreationMode::kExternalized);
        bool IsExternal() const;
        v8::SharedArrayBuffer::Contents Externalize();
        v8::SharedArrayBuffer::Contents GetContents();
        static inline v8::SharedArrayBuffer *Cast(v8::Value *obj) __attribute__((always_inline));
        static const int kInternalFieldCount = 2;
    private:
        SharedArrayBuffer();
        static void CheckCast(v8::Value *obj);
    };
    class Date : public v8::Object {
    public:
        static MaybeLocal<v8::Value> New(Local<v8::Context> context, double time) __attribute__((warn_unused_result));
        double ValueOf() const;
        static inline v8::Date *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    class NumberObject : public v8::Object {
    public:
        static Local<v8::Value> New(v8::Isolate *isolate, double value);
        double ValueOf() const;
        static inline v8::NumberObject *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    class BigIntObject : public v8::Object {
    public:
        static Local<v8::Value> New(v8::Isolate *isolate, int64_t value);
        Local<v8::BigInt> ValueOf() const;
        static inline v8::BigIntObject *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    class BooleanObject : public v8::Object {
    public:
        static Local<v8::Value> New(v8::Isolate *isolate, bool value);
        bool ValueOf() const;
        static inline v8::BooleanObject *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    class StringObject : public v8::Object {
    public:
        static Local<v8::Value> New(v8::Isolate *isolate, Local<v8::String> value);
        Local<v8::String> ValueOf() const;
        static inline v8::StringObject *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    class SymbolObject : public v8::Object {
    public:
        static Local<v8::Value> New(v8::Isolate *isolate, Local<v8::Symbol> value);
        Local<v8::Symbol> ValueOf() const;
        static inline v8::SymbolObject *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    class RegExp : public v8::Object {
    public:
        enum Flags {
            kNone = 0,
            kGlobal = 1 << 0,
            kIgnoreCase = 1 << 1,
            kMultiline = 1 << 2,
            kSticky = 1 << 3,
            kUnicode = 1 << 4,
            kDotAll = 1 << 5
        };
        static MaybeLocal<v8::RegExp> New(Local<v8::Context> context, Local<v8::String> pattern, v8::RegExp::Flags flags) __attribute__((warn_unused_result));
        Local<v8::String> GetSource() const;
        v8::RegExp::Flags GetFlags() const;
        static inline v8::RegExp *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    class External : public v8::Value {
    public:
        static Local<v8::External> New(v8::Isolate *isolate, void *value);
        static inline v8::External *Cast(v8::Value *obj) __attribute__((always_inline));
        void *Value() const;
    private:
        static void CheckCast(v8::Value *obj);
    };
    enum Intrinsic {
        kArrayProto_entries,
        kArrayProto_forEach,
        kArrayProto_keys,
        kArrayProto_values,
        kErrorPrototype,
        kIteratorPrototype
    };
    class Template : public v8::Data {
    public:
        void Set(Local<v8::Name> name, Local<v8::Data> value, v8::PropertyAttribute attributes = None);
        void SetPrivate(Local<v8::Private> name, Local<v8::Data> value, v8::PropertyAttribute attributes = None);
        inline void Set(v8::Isolate *isolate, const char *name, Local<v8::Data> value) __attribute__((always_inline));
        void SetAccessorProperty(Local<v8::Name> name, Local<v8::FunctionTemplate> getter = Local<v8::FunctionTemplate>(), Local<v8::FunctionTemplate> setter = Local<v8::FunctionTemplate>(), v8::PropertyAttribute attribute = None, v8::AccessControl settings = DEFAULT);
        void SetNativeDataProperty(Local<v8::String> name, v8::AccessorGetterCallback getter, v8::AccessorSetterCallback setter = nullptr, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyAttribute attribute = None, Local<v8::AccessorSignature> signature = Local<v8::AccessorSignature>(), v8::AccessControl settings = DEFAULT, v8::SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect, v8::SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect);
        void SetNativeDataProperty(Local<v8::Name> name, v8::AccessorNameGetterCallback getter, v8::AccessorNameSetterCallback setter = nullptr, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyAttribute attribute = None, Local<v8::AccessorSignature> signature = Local<v8::AccessorSignature>(), v8::AccessControl settings = DEFAULT, v8::SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect, v8::SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect);
        void SetLazyDataProperty(Local<v8::Name> name, v8::AccessorNameGetterCallback getter, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyAttribute attribute = None, v8::SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect, v8::SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect);
        void SetIntrinsicDataProperty(Local<v8::Name> name, v8::Intrinsic intrinsic, v8::PropertyAttribute attribute = None);
    private:
        Template();
        friend  class ObjectTemplate;
        friend  class FunctionTemplate;
    };
    typedef void (*GenericNamedPropertyGetterCallback)(Local<v8::Name>, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*GenericNamedPropertySetterCallback)(Local<v8::Name>, Local<v8::Value>, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*GenericNamedPropertyQueryCallback)(Local<v8::Name>, const PropertyCallbackInfo<v8::Integer> &);
    typedef void (*GenericNamedPropertyDeleterCallback)(Local<v8::Name>, const PropertyCallbackInfo<v8::Boolean> &);
    typedef void (*GenericNamedPropertyEnumeratorCallback)(const PropertyCallbackInfo<v8::Array> &);
    typedef void (*GenericNamedPropertyDefinerCallback)(Local<v8::Name>, const v8::PropertyDescriptor &, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*GenericNamedPropertyDescriptorCallback)(Local<v8::Name>, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*IndexedPropertyGetterCallback)(uint32_t, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*IndexedPropertySetterCallback)(uint32_t, Local<v8::Value>, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*IndexedPropertyQueryCallback)(uint32_t, const PropertyCallbackInfo<v8::Integer> &);
    typedef void (*IndexedPropertyDeleterCallback)(uint32_t, const PropertyCallbackInfo<v8::Boolean> &);
    typedef void (*IndexedPropertyEnumeratorCallback)(const PropertyCallbackInfo<v8::Array> &);
    typedef void (*IndexedPropertyDefinerCallback)(uint32_t, const v8::PropertyDescriptor &, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*IndexedPropertyDescriptorCallback)(uint32_t, const PropertyCallbackInfo<v8::Value> &);
    enum AccessType {
        ACCESS_GET,
        ACCESS_SET,
        ACCESS_HAS,
        ACCESS_DELETE,
        ACCESS_KEYS
    };
    typedef bool (*AccessCheckCallback)(Local<v8::Context>, Local<v8::Object>, Local<v8::Value>);
    class FunctionTemplate : public v8::Template {
    public:
        static Local<v8::FunctionTemplate> New(v8::Isolate *isolate, v8::FunctionCallback callback = nullptr, Local<v8::Value> data = Local<v8::Value>(), Local<v8::Signature> signature = Local<v8::Signature>(), int length = 0, v8::ConstructorBehavior behavior = ConstructorBehavior::kAllow, v8::SideEffectType side_effect_type = SideEffectType::kHasSideEffect);
        static MaybeLocal<v8::FunctionTemplate> FromSnapshot(v8::Isolate *isolate, size_t index);
        static Local<v8::FunctionTemplate> NewWithCache(v8::Isolate *isolate, v8::FunctionCallback callback, Local<v8::Private> cache_property, Local<v8::Value> data = Local<v8::Value>(), Local<v8::Signature> signature = Local<v8::Signature>(), int length = 0, v8::SideEffectType side_effect_type = SideEffectType::kHasSideEffect);
        MaybeLocal<v8::Function> GetFunction(Local<v8::Context> context) __attribute__((warn_unused_result));
        MaybeLocal<v8::Object> NewRemoteInstance() __attribute__((warn_unused_result));
        void SetCallHandler(v8::FunctionCallback callback, Local<v8::Value> data = Local<v8::Value>(), v8::SideEffectType side_effect_type = SideEffectType::kHasSideEffect);
        void SetLength(int length);
        Local<v8::ObjectTemplate> InstanceTemplate();
        void Inherit(Local<v8::FunctionTemplate> parent);
        Local<v8::ObjectTemplate> PrototypeTemplate();
        void SetPrototypeProviderTemplate(Local<v8::FunctionTemplate> prototype_provider);
        void SetClassName(Local<v8::String> name);
        void SetAcceptAnyReceiver(bool value);
        void ReadOnlyPrototype();
        void RemovePrototype();
        bool HasInstance(Local<v8::Value> object);
        static inline v8::FunctionTemplate *Cast(v8::Data *data) __attribute__((always_inline));
    private:
        FunctionTemplate();
        static void CheckCast(v8::Data *that);
        friend  class Context;
        friend  class ObjectTemplate;
    };
    enum class PropertyHandlerFlags : int {
        kNone = 0,
        kAllCanRead = 1,
        kNonMasking = 1 << 1,
        kOnlyInterceptStrings = 1 << 2,
        kHasNoSideEffect = 1 << 3
    };
    struct NamedPropertyHandlerConfiguration {
        NamedPropertyHandlerConfiguration(v8::GenericNamedPropertyGetterCallback getter, v8::GenericNamedPropertySetterCallback setter, v8::GenericNamedPropertyQueryCallback query, v8::GenericNamedPropertyDeleterCallback deleter, v8::GenericNamedPropertyEnumeratorCallback enumerator, v8::GenericNamedPropertyDefinerCallback definer, v8::GenericNamedPropertyDescriptorCallback descriptor, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyHandlerFlags flags = PropertyHandlerFlags::kNone) : getter(getter), setter(setter), query(query), deleter(deleter), enumerator(enumerator), definer(definer), descriptor(descriptor), data(data), flags(flags)         {
        }
        NamedPropertyHandlerConfiguration(v8::GenericNamedPropertyGetterCallback getter = nullptr, v8::GenericNamedPropertySetterCallback setter = nullptr, v8::GenericNamedPropertyQueryCallback query = nullptr, v8::GenericNamedPropertyDeleterCallback deleter = nullptr, v8::GenericNamedPropertyEnumeratorCallback enumerator = nullptr, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyHandlerFlags flags = PropertyHandlerFlags::kNone) : getter(getter), setter(setter), query(query), deleter(deleter), enumerator(enumerator), definer(nullptr), descriptor(nullptr), data(data), flags(flags)         {
        }
        NamedPropertyHandlerConfiguration(v8::GenericNamedPropertyGetterCallback getter, v8::GenericNamedPropertySetterCallback setter, v8::GenericNamedPropertyDescriptorCallback descriptor, v8::GenericNamedPropertyDeleterCallback deleter, v8::GenericNamedPropertyEnumeratorCallback enumerator, v8::GenericNamedPropertyDefinerCallback definer, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyHandlerFlags flags = PropertyHandlerFlags::kNone) : getter(getter), setter(setter), query(nullptr), deleter(deleter), enumerator(enumerator), definer(definer), descriptor(descriptor), data(data), flags(flags)         {
        }
        v8::GenericNamedPropertyGetterCallback getter;
        v8::GenericNamedPropertySetterCallback setter;
        v8::GenericNamedPropertyQueryCallback query;
        v8::GenericNamedPropertyDeleterCallback deleter;
        v8::GenericNamedPropertyEnumeratorCallback enumerator;
        v8::GenericNamedPropertyDefinerCallback definer;
        v8::GenericNamedPropertyDescriptorCallback descriptor;
        Local<v8::Value> data;
        v8::PropertyHandlerFlags flags;
    };
    struct IndexedPropertyHandlerConfiguration {
        IndexedPropertyHandlerConfiguration(v8::IndexedPropertyGetterCallback getter, v8::IndexedPropertySetterCallback setter, v8::IndexedPropertyQueryCallback query, v8::IndexedPropertyDeleterCallback deleter, v8::IndexedPropertyEnumeratorCallback enumerator, v8::IndexedPropertyDefinerCallback definer, v8::IndexedPropertyDescriptorCallback descriptor, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyHandlerFlags flags = PropertyHandlerFlags::kNone) : getter(getter), setter(setter), query(query), deleter(deleter), enumerator(enumerator), definer(definer), descriptor(descriptor), data(data), flags(flags)         {
        }
        IndexedPropertyHandlerConfiguration(v8::IndexedPropertyGetterCallback getter = nullptr, v8::IndexedPropertySetterCallback setter = nullptr, v8::IndexedPropertyQueryCallback query = nullptr, v8::IndexedPropertyDeleterCallback deleter = nullptr, v8::IndexedPropertyEnumeratorCallback enumerator = nullptr, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyHandlerFlags flags = PropertyHandlerFlags::kNone) : getter(getter), setter(setter), query(query), deleter(deleter), enumerator(enumerator), definer(nullptr), descriptor(nullptr), data(data), flags(flags)         {
        }
        IndexedPropertyHandlerConfiguration(v8::IndexedPropertyGetterCallback getter, v8::IndexedPropertySetterCallback setter, v8::IndexedPropertyDescriptorCallback descriptor, v8::IndexedPropertyDeleterCallback deleter, v8::IndexedPropertyEnumeratorCallback enumerator, v8::IndexedPropertyDefinerCallback definer, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyHandlerFlags flags = PropertyHandlerFlags::kNone) : getter(getter), setter(setter), query(nullptr), deleter(deleter), enumerator(enumerator), definer(definer), descriptor(descriptor), data(data), flags(flags)         {
        }
        v8::IndexedPropertyGetterCallback getter;
        v8::IndexedPropertySetterCallback setter;
        v8::IndexedPropertyQueryCallback query;
        v8::IndexedPropertyDeleterCallback deleter;
        v8::IndexedPropertyEnumeratorCallback enumerator;
        v8::IndexedPropertyDefinerCallback definer;
        v8::IndexedPropertyDescriptorCallback descriptor;
        Local<v8::Value> data;
        v8::PropertyHandlerFlags flags;
    };
    class ObjectTemplate : public v8::Template {
    public:
        static Local<v8::ObjectTemplate> New(v8::Isolate *isolate, Local<v8::FunctionTemplate> constructor = Local<v8::FunctionTemplate>());
        static MaybeLocal<v8::ObjectTemplate> FromSnapshot(v8::Isolate *isolate, size_t index);
        MaybeLocal<v8::Object> NewInstance(Local<v8::Context> context) __attribute__((warn_unused_result));
        void SetAccessor(Local<v8::String> name, v8::AccessorGetterCallback getter, v8::AccessorSetterCallback setter = nullptr, Local<v8::Value> data = Local<v8::Value>(), v8::AccessControl settings = DEFAULT, v8::PropertyAttribute attribute = None, Local<v8::AccessorSignature> signature = Local<v8::AccessorSignature>(), v8::SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect, v8::SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect);
        void SetAccessor(Local<v8::Name> name, v8::AccessorNameGetterCallback getter, v8::AccessorNameSetterCallback setter = nullptr, Local<v8::Value> data = Local<v8::Value>(), v8::AccessControl settings = DEFAULT, v8::PropertyAttribute attribute = None, Local<v8::AccessorSignature> signature = Local<v8::AccessorSignature>(), v8::SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect, v8::SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect);
        void SetHandler(const v8::NamedPropertyHandlerConfiguration &configuration);
        void SetIndexedPropertyHandler(v8::IndexedPropertyGetterCallback getter, v8::IndexedPropertySetterCallback setter = nullptr, v8::IndexedPropertyQueryCallback query = nullptr, v8::IndexedPropertyDeleterCallback deleter = nullptr, v8::IndexedPropertyEnumeratorCallback enumerator = nullptr, Local<v8::Value> data = Local<v8::Value>())         {
            this->SetHandler(v8::IndexedPropertyHandlerConfiguration(getter, setter, query, deleter, enumerator, data));
        }
        void SetHandler(const v8::IndexedPropertyHandlerConfiguration &configuration);
        void SetCallAsFunctionHandler(v8::FunctionCallback callback, Local<v8::Value> data = Local<v8::Value>());
        void MarkAsUndetectable();
        void SetAccessCheckCallback(v8::AccessCheckCallback callback, Local<v8::Value> data = Local<v8::Value>());
        void SetAccessCheckCallbackAndHandler(v8::AccessCheckCallback callback, const v8::NamedPropertyHandlerConfiguration &named_handler, const v8::IndexedPropertyHandlerConfiguration &indexed_handler, Local<v8::Value> data = Local<v8::Value>());
        int InternalFieldCount();
        void SetInternalFieldCount(int value);
        bool IsImmutableProto();
        void SetImmutableProto();
        static inline v8::ObjectTemplate *Cast(v8::Data *data) __attribute__((always_inline));
    private:
        ObjectTemplate();
        static Local<v8::ObjectTemplate> New(internal::Isolate *isolate, Local<v8::FunctionTemplate> constructor);
        static void CheckCast(v8::Data *that);
        friend  class FunctionTemplate;
    };
    class Signature : public v8::Data {
    public:
        static Local<v8::Signature> New(v8::Isolate *isolate, Local<v8::FunctionTemplate> receiver = Local<v8::FunctionTemplate>());
        static inline v8::Signature *Cast(v8::Data *data) __attribute__((always_inline));
    private:
        Signature();
        static void CheckCast(v8::Data *that);
    };
    class AccessorSignature : public v8::Data {
    public:
        static Local<v8::AccessorSignature> New(v8::Isolate *isolate, Local<v8::FunctionTemplate> receiver = Local<v8::FunctionTemplate>());
        static inline v8::AccessorSignature *Cast(v8::Data *data) __attribute__((always_inline));
    private:
        AccessorSignature();
        static void CheckCast(v8::Data *that);
    };
    class Extension {
    public:
        Extension(const char *name, const char *source = nullptr, int dep_count = 0, const char **deps = nullptr, int source_length = -1);
        virtual ~Extension() noexcept         {
            delete this->source_;
        }
        virtual Local<v8::FunctionTemplate> GetNativeFunctionTemplate(v8::Isolate *isolate, Local<v8::String> name)         {
            return Local<v8::FunctionTemplate>();
        }
        const char *name() const         {
            return this->name_;
        }
        size_t source_length() const         {
            return this->source_length_;
        }
        const String::ExternalOneByteStringResource *source() const         {
            return this->source_;
        }
        int dependency_count() const         {
            return this->dep_count_;
        }
        const char **dependencies() const         {
            return this->deps_;
        }
        void set_auto_enable(bool value)         {
            this->auto_enable_ = value;
        }
        bool auto_enable()         {
            return this->auto_enable_;
        }
        Extension(const v8::Extension &) = delete
        void operator=(const v8::Extension &) = delete
    private:
        const char *name_;
        size_t source_length_;
        String::ExternalOneByteStringResource *source_;
        int dep_count_;
        const char **deps_;
        bool auto_enable_;
    };
    void RegisterExtension(std::unique_ptr<Extension>);
    inline Local<v8::Primitive> Undefined(v8::Isolate *isolate) __attribute__((always_inline));
    inline Local<v8::Primitive> Null(v8::Isolate *isolate) __attribute__((always_inline));
    inline Local<v8::Boolean> True(v8::Isolate *isolate) __attribute__((always_inline));
    inline Local<v8::Boolean> False(v8::Isolate *isolate) __attribute__((always_inline));
    class ResourceConstraints {
    public:
        void ConfigureDefaultsFromHeapSize(size_t initial_heap_size_in_bytes, size_t maximum_heap_size_in_bytes);
        void ConfigureDefaults(uint64_t physical_memory, uint64_t virtual_memory_limit);
        uint32_t *stack_limit() const         {
            return this->stack_limit_;
        }
        void set_stack_limit(uint32_t *value)         {
            this->stack_limit_ = value;
        }
        size_t code_range_size_in_bytes() const         {
            return this->code_range_size_;
        }
        void set_code_range_size_in_bytes(size_t limit)         {
            this->code_range_size_ = limit;
        }
        size_t max_old_generation_size_in_bytes() const         {
            return this->max_old_generation_size_;
        }
        void set_max_old_generation_size_in_bytes(size_t limit)         {
            this->max_old_generation_size_ = limit;
        }
        size_t max_young_generation_size_in_bytes() const         {
            return this->max_young_generation_size_;
        }
        void set_max_young_generation_size_in_bytes(size_t limit)         {
            this->max_young_generation_size_ = limit;
        }
        size_t initial_old_generation_size_in_bytes() const         {
            return this->initial_old_generation_size_;
        }
        void set_initial_old_generation_size_in_bytes(size_t initial_size)         {
            this->initial_old_generation_size_ = initial_size;
        }
        size_t initial_young_generation_size_in_bytes() const         {
            return this->initial_young_generation_size_;
        }
        void set_initial_young_generation_size_in_bytes(size_t initial_size)         {
            this->initial_young_generation_size_ = initial_size;
        }
        size_t code_range_size() const         {
            return this->code_range_size_ / kMB;
        }
        void set_code_range_size(size_t limit_in_mb)         {
            this->code_range_size_ = limit_in_mb * kMB;
        }
        size_t max_semi_space_size_in_kb() const;
        void set_max_semi_space_size_in_kb(size_t limit_in_kb);
        size_t max_old_space_size() const         {
            return this->max_old_generation_size_ / kMB;
        }
        void set_max_old_space_size(size_t limit_in_mb)         {
            this->max_old_generation_size_ = limit_in_mb * kMB;
        }
        size_t max_zone_pool_size() const         {
            return this->max_zone_pool_size_;
        }
        void set_max_zone_pool_size(size_t bytes)         {
            this->max_zone_pool_size_ = bytes;
        }
    private:
        static constexpr size_t kMB = 1048576U;
        size_t code_range_size_ = 0;
        size_t max_old_generation_size_ = 0;
        size_t max_young_generation_size_ = 0;
        size_t max_zone_pool_size_ = 0;
        size_t initial_old_generation_size_ = 0;
        size_t initial_young_generation_size_ = 0;
        uint32_t *stack_limit_ = nullptr;
    };
    typedef void (*FatalErrorCallback)(const char *, const char *);
    typedef void (*OOMErrorCallback)(const char *, bool);
    typedef void (*DcheckErrorCallback)(const char *, int, const char *);
    typedef void (*MessageCallback)(Local<v8::Message>, Local<v8::Value>);
    typedef void (*LogEventCallback)(const char *, int);
    class Exception {
    public:
        static Local<v8::Value> RangeError(Local<v8::String> message);
        static Local<v8::Value> ReferenceError(Local<v8::String> message);
        static Local<v8::Value> SyntaxError(Local<v8::String> message);
        static Local<v8::Value> TypeError(Local<v8::String> message);
        static Local<v8::Value> Error(Local<v8::String> message);
        static Local<v8::Message> CreateMessage(v8::Isolate *isolate, Local<v8::Value> exception);
        static Local<v8::StackTrace> GetStackTrace(Local<v8::Value> exception);
    };
    typedef int *(*CounterLookupCallback)(const char *);
    typedef void *(*CreateHistogramCallback)(const char *, int, int, size_t);
    typedef void (*AddHistogramSampleCallback)(void *, int);
    typedef void (*BeforeCallEnteredCallback)(v8::Isolate *);
    typedef void (*CallCompletedCallback)(v8::Isolate *);
    typedef MaybeLocal<v8::Promise> (*HostImportModuleDynamicallyCallback)(Local<v8::Context>, Local<v8::ScriptOrModule>, Local<v8::String>);
    typedef void (*HostInitializeImportMetaObjectCallback)(Local<v8::Context>, Local<v8::Module>, Local<v8::Object>);
    typedef MaybeLocal<v8::Value> (*PrepareStackTraceCallback)(Local<v8::Context>, Local<v8::Value>, Local<v8::Array>);
    enum class PromiseHookType : int {
        kInit,
        kResolve,
        kBefore,
        kAfter
    };
    typedef void (*PromiseHook)(v8::PromiseHookType, Local<v8::Promise>, Local<v8::Value>);
    enum PromiseRejectEvent {
        kPromiseRejectWithNoHandler = 0,
        kPromiseHandlerAddedAfterReject = 1,
        kPromiseRejectAfterResolved = 2,
        kPromiseResolveAfterResolved = 3
    };
    class PromiseRejectMessage {
    public:
        PromiseRejectMessage(Local<v8::Promise> promise, v8::PromiseRejectEvent event, Local<v8::Value> value) : promise_(promise), event_(event), value_(value)         {
        }
        inline Local<v8::Promise> GetPromise() const __attribute__((always_inline))         {
            return this->promise_;
        }
        inline v8::PromiseRejectEvent GetEvent() const __attribute__((always_inline))         {
            return this->event_;
        }
        inline Local<v8::Value> GetValue() const __attribute__((always_inline))         {
            return this->value_;
        }
    private:
        Local<v8::Promise> promise_;
        v8::PromiseRejectEvent event_;
        Local<v8::Value> value_;
    };
    typedef void (*PromiseRejectCallback)(v8::PromiseRejectMessage);
    typedef void (*MicrotasksCompletedCallback)(v8::Isolate *);
    typedef void (*MicrotasksCompletedCallbackWithData)(v8::Isolate *, void *);
    typedef void (*MicrotaskCallback)(void *);
    enum class MicrotasksPolicy : int {
        kExplicit,
        kScoped,
        kAuto
    };
    class MicrotaskQueue {
    public:
        static std::unique_ptr<MicrotaskQueue> New(v8::Isolate *isolate, v8::MicrotasksPolicy policy = MicrotasksPolicy::kAuto);
        virtual ~MicrotaskQueue() noexcept = default
        virtual void EnqueueMicrotask(v8::Isolate *isolate, Local<v8::Function> microtask) = 0;
        virtual void EnqueueMicrotask(v8::Isolate *isolate, v8::MicrotaskCallback callback, void *data = nullptr) = 0;
        virtual void AddMicrotasksCompletedCallback(v8::MicrotasksCompletedCallbackWithData callback, void *data = nullptr) = 0;
        virtual void RemoveMicrotasksCompletedCallback(v8::MicrotasksCompletedCallbackWithData callback, void *data = nullptr) = 0;
        virtual void PerformCheckpoint(v8::Isolate *isolate) = 0;
        virtual bool IsRunningMicrotasks() const = 0;
        virtual int GetMicrotasksScopeDepth() const = 0;
        MicrotaskQueue(const v8::MicrotaskQueue &) = delete
        v8::MicrotaskQueue &operator=(const v8::MicrotaskQueue &) = delete
    private:
        friend  class internal::MicrotaskQueue;
        MicrotaskQueue() = default
    };
    class MicrotasksScope {
    public:
        enum Type {
            kRunMicrotasks,
            kDoNotRunMicrotasks
        };
        MicrotasksScope(v8::Isolate *isolate, v8::MicrotasksScope::Type type);
        MicrotasksScope(v8::Isolate *isolate, v8::MicrotaskQueue *microtask_queue, v8::MicrotasksScope::Type type);
        ~MicrotasksScope();
        static void PerformCheckpoint(v8::Isolate *isolate);
        static int GetCurrentDepth(v8::Isolate *isolate);
        static bool IsRunningMicrotasks(v8::Isolate *isolate);
        MicrotasksScope(const v8::MicrotasksScope &) = delete
        v8::MicrotasksScope &operator=(const v8::MicrotasksScope &) = delete
    private:
        internal::Isolate *const isolate_;
        internal::MicrotaskQueue *const microtask_queue_;
        bool run_;
    };
    typedef void (*FailedAccessCheckCallback)(Local<v8::Object>, v8::AccessType, Local<v8::Value>);
    typedef bool (*AllowCodeGenerationFromStringsCallback)(Local<v8::Context>, Local<v8::String>);
    typedef bool (*ExtensionCallback)(const FunctionCallbackInfo<v8::Value> &);
    typedef bool (*AllowWasmCodeGenerationCallback)(Local<v8::Context>, Local<v8::String>);
    typedef void (*ApiImplementationCallback)(const FunctionCallbackInfo<v8::Value> &);
    typedef void (*WasmStreamingCallback)(const FunctionCallbackInfo<v8::Value> &);
    typedef bool (*WasmThreadsEnabledCallback)(Local<v8::Context>);
    enum GCType {
        kGCTypeScavenge = 1 << 0,
        kGCTypeMarkSweepCompact = 1 << 1,
        kGCTypeIncrementalMarking = 1 << 2,
        kGCTypeProcessWeakCallbacks = 1 << 3,
        kGCTypeAll = kGCTypeScavenge | kGCTypeMarkSweepCompact | kGCTypeIncrementalMarking | kGCTypeProcessWeakCallbacks
    };
    enum GCCallbackFlags {
        kNoGCCallbackFlags = 0,
        kGCCallbackFlagConstructRetainedObjectInfos = 1 << 1,
        kGCCallbackFlagForced = 1 << 2,
        kGCCallbackFlagSynchronousPhantomCallbackProcessing = 1 << 3,
        kGCCallbackFlagCollectAllAvailableGarbage = 1 << 4,
        kGCCallbackFlagCollectAllExternalMemory = 1 << 5,
        kGCCallbackScheduleIdleGarbageCollection = 1 << 6
    };
    typedef void (*GCCallback)(v8::GCType, v8::GCCallbackFlags);
    typedef void (*InterruptCallback)(v8::Isolate *, void *);
    typedef size_t (*NearHeapLimitCallback)(void *, size_t, size_t);
    class HeapStatistics {
    public:
        HeapStatistics();
        size_t total_heap_size()         {
            return this->total_heap_size_;
        }
        size_t total_heap_size_executable()         {
            return this->total_heap_size_executable_;
        }
        size_t total_physical_size()         {
            return this->total_physical_size_;
        }
        size_t total_available_size()         {
            return this->total_available_size_;
        }
        size_t used_heap_size()         {
            return this->used_heap_size_;
        }
        size_t heap_size_limit()         {
            return this->heap_size_limit_;
        }
        size_t malloced_memory()         {
            return this->malloced_memory_;
        }
        size_t external_memory()         {
            return this->external_memory_;
        }
        size_t peak_malloced_memory()         {
            return this->peak_malloced_memory_;
        }
        size_t number_of_native_contexts()         {
            return this->number_of_native_contexts_;
        }
        size_t number_of_detached_contexts()         {
            return this->number_of_detached_contexts_;
        }
        size_t does_zap_garbage()         {
            return this->does_zap_garbage_;
        }
    private:
        size_t total_heap_size_;
        size_t total_heap_size_executable_;
        size_t total_physical_size_;
        size_t total_available_size_;
        size_t used_heap_size_;
        size_t heap_size_limit_;
        size_t malloced_memory_;
        size_t external_memory_;
        size_t peak_malloced_memory_;
        bool does_zap_garbage_;
        size_t number_of_native_contexts_;
        size_t number_of_detached_contexts_;
        friend  class V8;
        friend  class Isolate;
    };
    class HeapSpaceStatistics {
    public:
        HeapSpaceStatistics();
        const char *space_name()         {
            return this->space_name_;
        }
        size_t space_size()         {
            return this->space_size_;
        }
        size_t space_used_size()         {
            return this->space_used_size_;
        }
        size_t space_available_size()         {
            return this->space_available_size_;
        }
        size_t physical_space_size()         {
            return this->physical_space_size_;
        }
    private:
        const char *space_name_;
        size_t space_size_;
        size_t space_used_size_;
        size_t space_available_size_;
        size_t physical_space_size_;
        friend  class Isolate;
    };
    class HeapObjectStatistics {
    public:
        HeapObjectStatistics();
        const char *object_type()         {
            return this->object_type_;
        }
        const char *object_sub_type()         {
            return this->object_sub_type_;
        }
        size_t object_count()         {
            return this->object_count_;
        }
        size_t object_size()         {
            return this->object_size_;
        }
    private:
        const char *object_type_;
        const char *object_sub_type_;
        size_t object_count_;
        size_t object_size_;
        friend  class Isolate;
    };
    class HeapCodeStatistics {
    public:
        HeapCodeStatistics();
        size_t code_and_metadata_size()         {
            return this->code_and_metadata_size_;
        }
        size_t bytecode_and_metadata_size()         {
            return this->bytecode_and_metadata_size_;
        }
        size_t external_script_source_size()         {
            return this->external_script_source_size_;
        }
    private:
        size_t code_and_metadata_size_;
        size_t bytecode_and_metadata_size_;
        size_t external_script_source_size_;
        friend  class Isolate;
    };
    struct JitCodeEvent {
        enum EventType {
            CODE_ADDED,
            CODE_MOVED,
            CODE_REMOVED,
            CODE_ADD_LINE_POS_INFO,
            CODE_START_LINE_INFO_RECORDING,
            CODE_END_LINE_INFO_RECORDING
        };
        enum PositionType {
            POSITION,
            STATEMENT_POSITION
        };
        enum CodeType {
            BYTE_CODE,
            JIT_CODE
        };
        v8::JitCodeEvent::EventType type;
        v8::JitCodeEvent::CodeType code_type;
        void *code_start;
        size_t code_len;
        Local<v8::UnboundScript> script;
        void *user_data;
        struct name_t {
            const char *str;
            size_t len;
        };
        struct line_info_t {
            size_t offset;
            size_t pos;
            v8::JitCodeEvent::PositionType position_type;
        };
        union {
            struct name_t name;
            struct line_info_t line_info;
            void *new_code_start;
        };
        v8::Isolate *isolate;
    };
    enum RAILMode : unsigned int {
        PERFORMANCE_RESPONSE,
        PERFORMANCE_ANIMATION,
        PERFORMANCE_IDLE,
        PERFORMANCE_LOAD
    };
    enum JitCodeEventOptions {
        kJitCodeEventDefault = 0,
        kJitCodeEventEnumExisting = 1
    };
    typedef void (*JitCodeEventHandler)(const v8::JitCodeEvent *);
    typedef int (*UnhandledExceptionCallback)(_EXCEPTION_POINTERS *);
    class ExternalResourceVisitor {
    public:
        virtual ~ExternalResourceVisitor() noexcept = default
        virtual void VisitExternalString(Local<v8::String> string)         {
        }
    };
    class PersistentHandleVisitor {
    public:
        virtual ~PersistentHandleVisitor() noexcept = default
        virtual void VisitPersistentHandle(Persistent<v8::Value> *value, uint16_t class_id)         {
        }
    };
    enum class MemoryPressureLevel : int {
        kNone,
        kModerate,
        kCritical
    };
    class EmbedderHeapTracer {
    public:
        enum TraceFlags : uint64_t {
            kNoFlags = 0,
            kReduceMemory = 1 << 0
        };
        enum EmbedderStackState {
            kUnknown,
            kNonEmpty,
            kEmpty
        };
        class TracedGlobalHandleVisitor {
        public:
            virtual ~TracedGlobalHandleVisitor() noexcept = default
            virtual void VisitTracedGlobalHandle(const TracedGlobal<v8::Value> &value) = 0;
        };
        struct TraceSummary {
            double time = 0.;
            size_t allocated_size = 0;
        };
        virtual ~EmbedderHeapTracer() noexcept = default
        void IterateTracedGlobalHandles(v8::EmbedderHeapTracer::TracedGlobalHandleVisitor *visitor);
        virtual void RegisterV8References(const std::vector<std::pair<void *, void *> > &embedder_fields) = 0;
        void RegisterEmbedderReference(const TracedGlobal<v8::Value> &ref);
        virtual void TracePrologue()         {
        }
        virtual void TracePrologue(v8::EmbedderHeapTracer::TraceFlags flags);
        virtual bool AdvanceTracing(double deadline_in_ms) = 0;
        virtual bool IsTracingDone() = 0;
        virtual void TraceEpilogue()         {
        }
        virtual void TraceEpilogue(v8::EmbedderHeapTracer::TraceSummary *trace_summary)         {
            this->TraceEpilogue();
        }
        virtual void EnterFinalPause(v8::EmbedderHeapTracer::EmbedderStackState stack_state) = 0;
        void FinalizeTracing();
        virtual bool IsRootForNonTracingGC(const v8::TracedGlobal<v8::Value> &handle)         {
            return true;
        }
        void GarbageCollectionForTesting(v8::EmbedderHeapTracer::EmbedderStackState stack_state);
        void IncreaseAllocatedSize(size_t bytes);
        void DecreaseAllocatedSize(size_t bytes);
        v8::Isolate *isolate() const         {
            return this->isolate_;
        }
    protected:
        v8::Isolate *isolate_ = nullptr;
        friend  class internal::LocalEmbedderHeapTracer;
    };
    struct SerializeInternalFieldsCallback {
        typedef v8::StartupData (*CallbackFunction)(Local<v8::Object>, int, void *);
        SerializeInternalFieldsCallback(v8::SerializeInternalFieldsCallback::CallbackFunction function = nullptr, void *data_arg = nullptr) : callback(function), data(data_arg)         {
        }
        v8::SerializeInternalFieldsCallback::CallbackFunction callback;
        void *data;
    };
    typedef v8::SerializeInternalFieldsCallback SerializeEmbedderFieldsCallback;
    struct DeserializeInternalFieldsCallback {
        typedef void (*CallbackFunction)(Local<v8::Object>, int, v8::StartupData, void *);
        DeserializeInternalFieldsCallback(v8::DeserializeInternalFieldsCallback::CallbackFunction function = nullptr, void *data_arg = nullptr) : callback(function), data(data_arg)         {
        }
        void (*callback)(Local<v8::Object>, int, v8::StartupData, void *);
        void *data;
    };
    typedef v8::DeserializeInternalFieldsCallback DeserializeEmbedderFieldsCallback;
    class Isolate {
    public:
        struct CreateParams {
            CreateParams() : code_event_handler(nullptr), constraints(), snapshot_blob(nullptr), counter_lookup_callback(nullptr), create_histogram_callback(nullptr), add_histogram_sample_callback(nullptr), array_buffer_allocator(nullptr), external_references(nullptr), allow_atomics_wait(true), only_terminate_in_safe_scope(false)             {
            }
            v8::JitCodeEventHandler code_event_handler;
            v8::ResourceConstraints constraints;
            v8::StartupData *snapshot_blob;
            v8::CounterLookupCallback counter_lookup_callback;
            v8::CreateHistogramCallback create_histogram_callback;
            v8::AddHistogramSampleCallback add_histogram_sample_callback;
            ArrayBuffer::Allocator *array_buffer_allocator;
            const intptr_t *external_references;
            bool allow_atomics_wait;
            bool only_terminate_in_safe_scope;
        };
        class Scope {
        public:
            explicit Scope(v8::Isolate *isolate) : isolate_(isolate)             {
                isolate->Enter();
            }
            ~Scope() noexcept             {
                this->isolate_->Exit();
            }
            Scope(const v8::Isolate::Scope &) = delete
            v8::Isolate::Scope &operator=(const v8::Isolate::Scope &) = delete
        private:
            v8::Isolate *const isolate_;
        };
        class DisallowJavascriptExecutionScope {
        public:
            enum OnFailure {
                CRASH_ON_FAILURE,
                THROW_ON_FAILURE,
                DUMP_ON_FAILURE
            };
            DisallowJavascriptExecutionScope(v8::Isolate *isolate, v8::Isolate::DisallowJavascriptExecutionScope::OnFailure on_failure);
            ~DisallowJavascriptExecutionScope();
            DisallowJavascriptExecutionScope(const v8::Isolate::DisallowJavascriptExecutionScope &) = delete
            v8::Isolate::DisallowJavascriptExecutionScope &operator=(const v8::Isolate::DisallowJavascriptExecutionScope &) = delete
        private:
            v8::Isolate::DisallowJavascriptExecutionScope::OnFailure on_failure_;
            void *internal_;
        };
        class AllowJavascriptExecutionScope {
        public:
            explicit AllowJavascriptExecutionScope(v8::Isolate *isolate);
            ~AllowJavascriptExecutionScope();
            AllowJavascriptExecutionScope(const v8::Isolate::AllowJavascriptExecutionScope &) = delete
            v8::Isolate::AllowJavascriptExecutionScope &operator=(const v8::Isolate::AllowJavascriptExecutionScope &) = delete
        private:
            void *internal_throws_;
            void *internal_assert_;
            void *internal_dump_;
        };
        class SuppressMicrotaskExecutionScope {
        public:
            explicit SuppressMicrotaskExecutionScope(v8::Isolate *isolate);
            explicit SuppressMicrotaskExecutionScope(v8::MicrotaskQueue *microtask_queue);
            ~SuppressMicrotaskExecutionScope();
            SuppressMicrotaskExecutionScope(const v8::Isolate::SuppressMicrotaskExecutionScope &) = delete
            v8::Isolate::SuppressMicrotaskExecutionScope &operator=(const v8::Isolate::SuppressMicrotaskExecutionScope &) = delete
        private:
            internal::Isolate *const isolate_;
            internal::MicrotaskQueue *const microtask_queue_;
        };
        class SafeForTerminationScope {
        public:
            explicit SafeForTerminationScope(v8::Isolate *isolate);
            ~SafeForTerminationScope();
            SafeForTerminationScope(const v8::Isolate::SafeForTerminationScope &) = delete
            v8::Isolate::SafeForTerminationScope &operator=(const v8::Isolate::SafeForTerminationScope &) = delete
        private:
            internal::Isolate *isolate_;
            bool prev_value_;
        };
        enum GarbageCollectionType {
            kFullGarbageCollection,
            kMinorGarbageCollection
        };
        enum UseCounterFeature {
            kUseAsm = 0,
            kBreakIterator = 1,
            kLegacyConst = 2,
            kMarkDequeOverflow = 3,
            kStoreBufferOverflow = 4,
            kSlotsBufferOverflow = 5,
            kObjectObserve = 6,
            kForcedGC = 7,
            kSloppyMode = 8,
            kStrictMode = 9,
            kStrongMode = 10,
            kRegExpPrototypeStickyGetter = 11,
            kRegExpPrototypeToString = 12,
            kRegExpPrototypeUnicodeGetter = 13,
            kIntlV8Parse = 14,
            kIntlPattern = 15,
            kIntlResolved = 16,
            kPromiseChain = 17,
            kPromiseAccept = 18,
            kPromiseDefer = 19,
            kHtmlCommentInExternalScript = 20,
            kHtmlComment = 21,
            kSloppyModeBlockScopedFunctionRedefinition = 22,
            kForInInitializer = 23,
            kArrayProtectorDirtied = 24,
            kArraySpeciesModified = 25,
            kArrayPrototypeConstructorModified = 26,
            kArrayInstanceProtoModified = 27,
            kArrayInstanceConstructorModified = 28,
            kLegacyFunctionDeclaration = 29,
            kRegExpPrototypeSourceGetter = 30,
            kRegExpPrototypeOldFlagGetter = 31,
            kDecimalWithLeadingZeroInStrictMode = 32,
            kLegacyDateParser = 33,
            kDefineGetterOrSetterWouldThrow = 34,
            kFunctionConstructorReturnedUndefined = 35,
            kAssigmentExpressionLHSIsCallInSloppy = 36,
            kAssigmentExpressionLHSIsCallInStrict = 37,
            kPromiseConstructorReturnedUndefined = 38,
            kConstructorNonUndefinedPrimitiveReturn = 39,
            kLabeledExpressionStatement = 40,
            kLineOrParagraphSeparatorAsLineTerminator = 41,
            kIndexAccessor = 42,
            kErrorCaptureStackTrace = 43,
            kErrorPrepareStackTrace = 44,
            kErrorStackTraceLimit = 45,
            kWebAssemblyInstantiation = 46,
            kDeoptimizerDisableSpeculation = 47,
            kArrayPrototypeSortJSArrayModifiedPrototype = 48,
            kFunctionTokenOffsetTooLongForToString = 49,
            kWasmSharedMemory = 50,
            kWasmThreadOpcodes = 51,
            kAtomicsNotify = 52,
            kAtomicsWake = 53,
            kCollator = 54,
            kNumberFormat = 55,
            kDateTimeFormat = 56,
            kPluralRules = 57,
            kRelativeTimeFormat = 58,
            kLocale = 59,
            kListFormat = 60,
            kSegmenter = 61,
            kStringLocaleCompare = 62,
            kStringToLocaleUpperCase = 63,
            kStringToLocaleLowerCase = 64,
            kNumberToLocaleString = 65,
            kDateToLocaleString = 66,
            kDateToLocaleDateString = 67,
            kDateToLocaleTimeString = 68,
            kAttemptOverrideReadOnlyOnPrototypeSloppy = 69,
            kAttemptOverrideReadOnlyOnPrototypeStrict = 70,
            kOptimizedFunctionWithOneShotBytecode = 71,
            kRegExpMatchIsTrueishOnNonJSRegExp = 72,
            kRegExpMatchIsFalseishOnJSRegExp = 73,
            kDateGetTimezoneOffset = 74,
            kStringNormalize = 75,
            kUseCounterFeatureCount
        };
        enum MessageErrorLevel {
            kMessageLog = (1 << 0),
            kMessageDebug = (1 << 1),
            kMessageInfo = (1 << 2),
            kMessageError = (1 << 3),
            kMessageWarning = (1 << 4),
            kMessageAll = kMessageLog | kMessageDebug | kMessageInfo | kMessageError | kMessageWarning
        };
        typedef void (*UseCounterCallback)(v8::Isolate *, v8::Isolate::UseCounterFeature);
        static v8::Isolate *Allocate();
        static void Initialize(v8::Isolate *isolate, const v8::Isolate::CreateParams &params);
        static v8::Isolate *New(const v8::Isolate::CreateParams &params);
        static v8::Isolate *GetCurrent();
        typedef bool (*AbortOnUncaughtExceptionCallback)(v8::Isolate *);
        void SetAbortOnUncaughtExceptionCallback(v8::Isolate::AbortOnUncaughtExceptionCallback callback);
        void SetHostImportModuleDynamicallyCallback(v8::HostImportModuleDynamicallyCallback callback);
        void SetHostInitializeImportMetaObjectCallback(v8::HostInitializeImportMetaObjectCallback callback);
        void SetPrepareStackTraceCallback(v8::PrepareStackTraceCallback callback);
        void MemoryPressureNotification(v8::MemoryPressureLevel level);
        void Enter();
        void Exit();
        void Dispose();
        void DumpAndResetStats();
        void DiscardThreadSpecificMetadata();
        inline void SetData(uint32_t slot, void *data) __attribute__((always_inline));
        inline void *GetData(uint32_t slot) __attribute__((always_inline));
        static inline uint32_t GetNumberOfDataSlots() __attribute__((always_inline));
        template <class T> inline MaybeLocal<T> GetDataFromSnapshotOnce(size_t index) __attribute__((always_inline));
        void GetHeapStatistics(v8::HeapStatistics *heap_statistics);
        size_t NumberOfHeapSpaces();
        bool GetHeapSpaceStatistics(v8::HeapSpaceStatistics *space_statistics, size_t index);
        size_t NumberOfTrackedHeapObjectTypes();
        bool GetHeapObjectStatisticsAtLastGC(v8::HeapObjectStatistics *object_statistics, size_t type_index);
        bool GetHeapCodeAndMetadataStatistics(v8::HeapCodeStatistics *object_statistics);
        void GetStackSample(const v8::RegisterState &state, void **frames, size_t frames_limit, v8::SampleInfo *sample_info);
        inline int64_t AdjustAmountOfExternalAllocatedMemory(int64_t change_in_bytes) __attribute__((always_inline));
        size_t NumberOfPhantomHandleResetsSinceLastCall();
        v8::HeapProfiler *GetHeapProfiler();
        void SetIdle(bool is_idle);
        ArrayBuffer::Allocator *GetArrayBufferAllocator();
        bool InContext();
        Local<v8::Context> GetCurrentContext();
        Local<v8::Context> GetEnteredContext();
        Local<v8::Context> GetEnteredOrMicrotaskContext();
        Local<v8::Context> GetIncumbentContext();
        Local<v8::Value> ThrowException(Local<v8::Value> exception);
        typedef void (*GCCallback)(v8::Isolate *, v8::GCType, v8::GCCallbackFlags);
        typedef void (*GCCallbackWithData)(v8::Isolate *, v8::GCType, v8::GCCallbackFlags, void *);
        void AddGCPrologueCallback(v8::Isolate::GCCallbackWithData callback, void *data = nullptr, v8::GCType gc_type_filter = kGCTypeAll);
        void AddGCPrologueCallback(v8::Isolate::GCCallback callback, v8::GCType gc_type_filter = kGCTypeAll);
        void RemoveGCPrologueCallback(v8::Isolate::GCCallbackWithData, void *data = nullptr);
        void RemoveGCPrologueCallback(v8::Isolate::GCCallback callback);
        void SetEmbedderHeapTracer(v8::EmbedderHeapTracer *tracer);
        v8::EmbedderHeapTracer *GetEmbedderHeapTracer();
        enum class AtomicsWaitEvent : int {
            kStartWait,
            kWokenUp,
            kTimedOut,
            kTerminatedExecution,
            kAPIStopped,
            kNotEqual
        };
        class AtomicsWaitWakeHandle {
        public:
            void Wake();
        };
        typedef void (*AtomicsWaitCallback)(v8::Isolate::AtomicsWaitEvent, Local<v8::SharedArrayBuffer>, size_t, int64_t, double, v8::Isolate::AtomicsWaitWakeHandle *, void *);
        void SetAtomicsWaitCallback(v8::Isolate::AtomicsWaitCallback callback, void *data);
        void AddGCEpilogueCallback(v8::Isolate::GCCallbackWithData callback, void *data = nullptr, v8::GCType gc_type_filter = kGCTypeAll);
        void AddGCEpilogueCallback(v8::Isolate::GCCallback callback, v8::GCType gc_type_filter = kGCTypeAll);
        void RemoveGCEpilogueCallback(v8::Isolate::GCCallbackWithData callback, void *data = nullptr);
        void RemoveGCEpilogueCallback(v8::Isolate::GCCallback callback);
        typedef size_t (*GetExternallyAllocatedMemoryInBytesCallback)();
        void SetGetExternallyAllocatedMemoryInBytesCallback(v8::Isolate::GetExternallyAllocatedMemoryInBytesCallback callback);
        void TerminateExecution();
        bool IsExecutionTerminating();
        void CancelTerminateExecution();
        void RequestInterrupt(v8::InterruptCallback callback, void *data);
        void RequestGarbageCollectionForTesting(v8::Isolate::GarbageCollectionType type);
        void SetEventLogger(v8::LogEventCallback that);
        void AddBeforeCallEnteredCallback(v8::BeforeCallEnteredCallback callback);
        void RemoveBeforeCallEnteredCallback(v8::BeforeCallEnteredCallback callback);
        void AddCallCompletedCallback(v8::CallCompletedCallback callback);
        void RemoveCallCompletedCallback(v8::CallCompletedCallback callback);
        void SetPromiseHook(v8::PromiseHook hook);
        void SetPromiseRejectCallback(v8::PromiseRejectCallback callback);
        void RunMicrotasks();
        void EnqueueMicrotask(Local<v8::Function> microtask);
        void EnqueueMicrotask(v8::MicrotaskCallback callback, void *data = nullptr);
        void SetMicrotasksPolicy(v8::MicrotasksPolicy policy);
        v8::MicrotasksPolicy GetMicrotasksPolicy() const;
        void AddMicrotasksCompletedCallback(v8::MicrotasksCompletedCallback callback);
        void AddMicrotasksCompletedCallback(v8::MicrotasksCompletedCallbackWithData callback, void *data = nullptr);
        void RemoveMicrotasksCompletedCallback(v8::MicrotasksCompletedCallback callback);
        void RemoveMicrotasksCompletedCallback(v8::MicrotasksCompletedCallbackWithData callback, void *data = nullptr);
        void SetUseCounterCallback(v8::Isolate::UseCounterCallback callback);
        void SetCounterFunction(v8::CounterLookupCallback);
        void SetCreateHistogramFunction(v8::CreateHistogramCallback);
        void SetAddHistogramSampleFunction(v8::AddHistogramSampleCallback);
        bool IdleNotificationDeadline(double deadline_in_seconds);
        void LowMemoryNotification();
        int ContextDisposedNotification(bool dependant_context = true);
        void IsolateInForegroundNotification();
        void IsolateInBackgroundNotification();
        void EnableMemorySavingsMode();
        void DisableMemorySavingsMode();
        void SetRAILMode(v8::RAILMode rail_mode);
        void IncreaseHeapLimitForDebugging();
        void RestoreOriginalHeapLimit();
        bool IsHeapLimitIncreasedForDebugging();
        void SetJitCodeEventHandler(v8::JitCodeEventOptions options, v8::JitCodeEventHandler event_handler);
        void SetStackLimit(uintptr_t stack_limit);
        void GetCodeRange(void **start, size_t *length_in_bytes);
        v8::UnwindState GetUnwindState();
        void SetFatalErrorHandler(v8::FatalErrorCallback that);
        void SetOOMErrorHandler(v8::OOMErrorCallback that);
        void AddNearHeapLimitCallback(v8::NearHeapLimitCallback callback, void *data);
        void RemoveNearHeapLimitCallback(v8::NearHeapLimitCallback callback, size_t heap_limit);
        void AutomaticallyRestoreInitialHeapLimit(double threshold_percent = 0.5);
        void SetAllowCodeGenerationFromStringsCallback(v8::AllowCodeGenerationFromStringsCallback callback);
        void SetAllowWasmCodeGenerationCallback(v8::AllowWasmCodeGenerationCallback callback);
        void SetWasmModuleCallback(v8::ExtensionCallback callback);
        void SetWasmInstanceCallback(v8::ExtensionCallback callback);
        void SetWasmStreamingCallback(v8::WasmStreamingCallback callback);
        void SetWasmThreadsEnabledCallback(v8::WasmThreadsEnabledCallback callback);
        bool IsDead();
        bool AddMessageListener(v8::MessageCallback that, Local<v8::Value> data = Local<v8::Value>());
        bool AddMessageListenerWithErrorLevel(v8::MessageCallback that, int message_levels, Local<v8::Value> data = Local<v8::Value>());
        void RemoveMessageListeners(v8::MessageCallback that);
        void SetFailedAccessCheckCallbackFunction(v8::FailedAccessCheckCallback);
        void SetCaptureStackTraceForUncaughtExceptions(bool capture, int frame_limit = 10, StackTrace::StackTraceOptions options = StackTrace::kOverview);
        void VisitExternalResources(v8::ExternalResourceVisitor *visitor);
        void VisitHandlesWithClassIds(v8::PersistentHandleVisitor *visitor);
        void VisitWeakHandles(v8::PersistentHandleVisitor *visitor);
        bool IsInUse();
        void SetAllowAtomicsWait(bool allow);
        enum class TimeZoneDetection : int {
            kSkip,
            kRedetect
        };
        void DateTimeConfigurationChangeNotification(v8::Isolate::TimeZoneDetection time_zone_detection = TimeZoneDetection::kSkip);
        void LocaleConfigurationChangeNotification();
        Isolate() = delete
        ~Isolate() = delete
        Isolate(const v8::Isolate &) = delete
        v8::Isolate &operator=(const v8::Isolate &) = delete
        void *operator new(size_t size) = delete
        void *operator new[](size_t size) = delete
        void operator delete(void *, size_t) noexcept = delete
        void operator delete[](void *, size_t) noexcept = delete
    private:
        friend template <class K, class V, class Traits> class PersistentValueMapBase;
        internal::Address *GetDataFromSnapshotOnce(size_t index);
        void ReportExternalAllocationLimitReached();
        void CheckMemoryPressure();
    };
    class StartupData {
    public:
        bool CanBeRehashed() const;
        const char *data;
        int raw_size;
    };
    typedef bool (*EntropySource)(unsigned char *, size_t);
    typedef uintptr_t (*ReturnAddressLocationResolver)(uintptr_t);
    class V8 {
    public:
        static void SetNativesDataBlob(v8::StartupData *startup_blob);
        static void SetSnapshotDataBlob(v8::StartupData *startup_blob);
        static void SetDcheckErrorHandler(v8::DcheckErrorCallback that);
        static void SetFlagsFromString(const char *str);
        static void SetFlagsFromString(const char *str, size_t length);
        static void SetFlagsFromString(const char *str, int length);
        static void SetFlagsFromCommandLine(int *argc, char **argv, bool remove_flags);
        static const char *GetVersion();
        static bool Initialize();
        static void SetEntropySource(v8::EntropySource source);
        static void SetReturnAddressLocationResolver(v8::ReturnAddressLocationResolver return_address_resolver);
        static bool Dispose();
        static bool InitializeICU(const char *icu_data_file = nullptr);
        static bool InitializeICUDefaultLocation(const char *exec_path, const char *icu_data_file = nullptr);
        static void InitializeExternalStartupData(const char *directory_path);
        static void InitializeExternalStartupData(const char *natives_blob, const char *snapshot_blob);
        static void InitializePlatform(v8::Platform *platform);
        static void ShutdownPlatform();
        static bool EnableWebAssemblyTrapHandler(bool use_v8_signal_handler);
        static void SetUnhandledExceptionCallback(v8::UnhandledExceptionCallback unhandled_exception_callback);
    private:
        V8();
        static internal::Address *GlobalizeReference(internal::Isolate *isolate, internal::Address *handle);
        static internal::Address *GlobalizeTracedReference(internal::Isolate *isolate, internal::Address *handle, internal::Address *slot);
        static void MoveGlobalReference(internal::Address **from, internal::Address **to);
        static void MoveTracedGlobalReference(internal::Address **from, internal::Address **to);
        static internal::Address *CopyGlobalReference(internal::Address *from);
        static void DisposeGlobal(internal::Address *global_handle);
        static void DisposeTracedGlobal(internal::Address *global_handle);
        static void MakeWeak(internal::Address *location, void *data, WeakCallbackInfo<void>::Callback weak_callback, v8::WeakCallbackType type);
        static void MakeWeak(internal::Address **location_addr);
        static void *ClearWeak(internal::Address *location);
        static void SetFinalizationCallbackTraced(internal::Address *location, void *parameter, WeakCallbackInfo<void>::Callback callback);
        static void AnnotateStrongRetainer(internal::Address *location, const char *label);
        static v8::Value *Eternalize(v8::Isolate *isolate, v8::Value *handle);
        friend template <class K, class V, class T> class PersistentValueMapBase;
        static void FromJustIsNothing();
        static void ToLocalEmpty();
        static void InternalFieldOutOfBounds(int index);
        friend template <class T> class Global;
        friend template <class T> class Local;
        friend template <class T> class MaybeLocal;
        friend template <class T> class Maybe;
        friend template <class T> class TracedGlobal;
        friend template <class T> class WeakCallbackInfo;
        friend template <class T> class Eternal;
        friend template <class T> class PersistentBase;
        friend template <class T, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend  class Context;
    };
    class SnapshotCreator {
    public:
        enum class FunctionCodeHandling : int {
            kClear,
            kKeep
        };
        SnapshotCreator(v8::Isolate *isolate, const intptr_t *external_references = nullptr, v8::StartupData *existing_blob = nullptr);
        SnapshotCreator(const intptr_t *external_references = nullptr, v8::StartupData *existing_blob = nullptr);
        ~SnapshotCreator();
        v8::Isolate *GetIsolate();
        void SetDefaultContext(Local<v8::Context> context, v8::SerializeInternalFieldsCallback callback = v8::SerializeInternalFieldsCallback());
        size_t AddContext(Local<v8::Context> context, v8::SerializeInternalFieldsCallback callback = v8::SerializeInternalFieldsCallback());
        size_t AddTemplate(Local<v8::Template> template_obj);
        template <class T> inline size_t AddData(Local<v8::Context> context, Local<T> object) __attribute__((always_inline));
        template <class T> inline size_t AddData(Local<T> object) __attribute__((always_inline));
        v8::StartupData CreateBlob(v8::SnapshotCreator::FunctionCodeHandling function_code_handling);
        SnapshotCreator(const v8::SnapshotCreator &) = delete
        void operator=(const v8::SnapshotCreator &) = delete
    private:
        size_t AddData(Local<v8::Context> context, internal::Address object);
        size_t AddData(internal::Address object);
        void *data_;
    };
    template <class T> class Maybe {
    public:
        inline bool IsNothing() const __attribute__((always_inline))         {
            return !this->has_value_;
        }
        inline bool IsJust() const __attribute__((always_inline))         {
            return this->has_value_;
        }
        inline T ToChecked() const __attribute__((always_inline))         {
            return this->FromJust();
        }
        inline void Check() const __attribute__((always_inline))         {
            if ((__builtin_expect(!!(!this->IsJust()), 0)))
                V8::FromJustIsNothing();
        }
        inline bool To(T *out) const __attribute__((warn_unused_result)) __attribute__((always_inline))         {
            if ((__builtin_expect(!!(this->IsJust()), 1)))
                *out = this->value_;
            return this->IsJust();
        }
        inline T FromJust() const __attribute__((always_inline))         {
            if ((__builtin_expect(!!(!this->IsJust()), 0)))
                V8::FromJustIsNothing();
            return this->value_;
        }
        inline T FromMaybe(const T &default_value) const __attribute__((always_inline))         {
            return this->has_value_ ? this->value_ : default_value;
        }
        inline bool operator==(const Maybe<T> &other) const __attribute__((always_inline))         {
            return (this->IsJust() == other.IsJust()) && (!this->IsJust() || this->FromJust() == other.FromJust());
        }
        inline bool operator!=(const Maybe<T> &other) const __attribute__((always_inline))         {
            return !this->operator==(other);
        }
    private:
        Maybe<T>() : has_value_(false)         {
        }
        explicit Maybe<T>(const T &t) : has_value_(true), value_(t)         {
        }
        bool has_value_;
        T value_;
        friend template <class U> Maybe<U> Nothing();
        friend template <class U> Maybe<U> Just(const U &u);
    };
    template <class T> inline Maybe<T> Nothing()     {
        return Maybe<T>();
    }
    template <class T> inline Maybe<T> Just(const T &t)     {
        return Maybe<T>(t);
    }
    template<> class Maybe<void> {
    public:
        inline bool IsNothing() const __attribute__((always_inline))         {
            return !this->is_valid_;
        }
        inline bool IsJust() const __attribute__((always_inline))         {
            return this->is_valid_;
        }
        inline bool operator==(const v8::Maybe<void> &other) const __attribute__((always_inline))         {
            return this->IsJust() == other.IsJust();
        }
        inline bool operator!=(const v8::Maybe<void> &other) const __attribute__((always_inline))         {
            return !this->operator==(other);
        }
    private:
        struct JustTag {
        };
        Maybe() : is_valid_(false)         {
        }
        explicit Maybe(v8::Maybe<void>::JustTag) : is_valid_(true)         {
        }
        bool is_valid_;
        friend template <class U> Maybe<U> Nothing();
        friend Maybe<void> JustVoid();
    };
    inline Maybe<void> JustVoid()     {
        return Maybe<void>(Maybe<void>::JustTag());
    }
    class TryCatch {
    public:
        explicit TryCatch(v8::Isolate *isolate);
        ~TryCatch();
        bool HasCaught() const;
        bool CanContinue() const;
        bool HasTerminated() const;
        Local<v8::Value> ReThrow();
        Local<v8::Value> Exception() const;
        MaybeLocal<v8::Value> StackTrace(Local<v8::Context> context) const __attribute__((warn_unused_result));
        Local<v8::Message> Message() const;
        void Reset();
        void SetVerbose(bool value);
        bool IsVerbose() const;
        void SetCaptureMessage(bool value);
        static void *JSStackComparableAddress(v8::TryCatch *handler)         {
            if (handler == nullptr)
                return nullptr;
            return handler->js_stack_comparable_address_;
        }
        TryCatch(const v8::TryCatch &) = delete
        void operator=(const v8::TryCatch &) = delete
    private:
        void *operator new(size_t size);
        void *operator new[](size_t size);
        void operator delete(void *, size_t) noexcept;
        void operator delete[](void *, size_t) noexcept;
        void ResetInternal();
        internal::Isolate *isolate_;
        v8::TryCatch *next_;
        void *exception_;
        void *message_obj_;
        void *js_stack_comparable_address_;
        bool is_verbose_ : 1;
        bool can_continue_ : 1;
        bool capture_message_ : 1;
        bool rethrow_ : 1;
        bool has_terminated_ : 1;
        friend  class internal::Isolate;
    };
    class ExtensionConfiguration {
    public:
        ExtensionConfiguration() : name_count_(0), names_(nullptr)         {
        }
        ExtensionConfiguration(int name_count, const char *names[]) : name_count_(name_count), names_(names)         {
        }
        const char **begin() const         {
            return &this->names_[0];
        }
        const char **end() const         {
            return &this->names_[this->name_count_];
        }
    private:
        const int name_count_;
        const char **names_;
    };
    class Context {
    public:
        Local<v8::Object> Global();
        void DetachGlobal();
        static Local<v8::Context> New(v8::Isolate *isolate, v8::ExtensionConfiguration *extensions = nullptr, MaybeLocal<v8::ObjectTemplate> global_template = MaybeLocal<v8::ObjectTemplate>(), MaybeLocal<v8::Value> global_object = MaybeLocal<v8::Value>(), v8::DeserializeInternalFieldsCallback internal_fields_deserializer = v8::DeserializeInternalFieldsCallback(), v8::MicrotaskQueue *microtask_queue = nullptr);
        static MaybeLocal<v8::Context> FromSnapshot(v8::Isolate *isolate, size_t context_snapshot_index, v8::DeserializeInternalFieldsCallback embedder_fields_deserializer = v8::DeserializeInternalFieldsCallback(), v8::ExtensionConfiguration *extensions = nullptr, MaybeLocal<v8::Value> global_object = MaybeLocal<v8::Value>(), v8::MicrotaskQueue *microtask_queue = nullptr);
        static MaybeLocal<v8::Object> NewRemoteContext(v8::Isolate *isolate, Local<v8::ObjectTemplate> global_template, MaybeLocal<v8::Value> global_object = MaybeLocal<v8::Value>());
        void SetSecurityToken(Local<v8::Value> token);
        void UseDefaultSecurityToken();
        Local<v8::Value> GetSecurityToken();
        void Enter();
        void Exit();
        v8::Isolate *GetIsolate();
        enum EmbedderDataFields {
            kDebugIdIndex = 0
        };
        uint32_t GetNumberOfEmbedderDataFields();
        inline Local<v8::Value> GetEmbedderData(int index) __attribute__((always_inline));
        Local<v8::Object> GetExtrasBindingObject();
        void SetEmbedderData(int index, Local<v8::Value> value);
        inline void *GetAlignedPointerFromEmbedderData(int index) __attribute__((always_inline));
        void SetAlignedPointerInEmbedderData(int index, void *value);
        void AllowCodeGenerationFromStrings(bool allow);
        bool IsCodeGenerationFromStringsAllowed();
        void SetErrorMessageForCodeGenerationFromStrings(Local<v8::String> message);
        template <class T> inline MaybeLocal<T> GetDataFromSnapshotOnce(size_t index) __attribute__((always_inline));
        typedef void (*AbortScriptExecutionCallback)(v8::Isolate *, Local<v8::Context>);
        void SetAbortScriptExecution(v8::Context::AbortScriptExecutionCallback callback);
        class Scope {
        public:
            inline explicit Scope(Local<v8::Context> context) : context_(context) __attribute__((always_inline))             {
                this->context_->Enter();
            }
            inline ~Scope() noexcept __attribute__((always_inline))             {
                this->context_->Exit();
            }
        private:
            Local<v8::Context> context_;
        };
        class final BackupIncumbentScope {
        public:
            explicit BackupIncumbentScope(Local<v8::Context> backup_incumbent_context);
            ~BackupIncumbentScope();
            uintptr_t JSStackComparableAddress() const             {
                return this->js_stack_comparable_address_;
            }
        private:
            friend  class internal::Isolate;
            Local<v8::Context> backup_incumbent_context_;
            uintptr_t js_stack_comparable_address_ = 0;
            const v8::Context::BackupIncumbentScope *prev_ = nullptr;
        };
    private:
        friend  class Value;
        friend  class Script;
        friend  class Object;
        friend  class Function;
        internal::Address *GetDataFromSnapshotOnce(size_t index);
        Local<v8::Value> SlowGetEmbedderData(int index);
        void *SlowGetAlignedPointerFromEmbedderData(int index);
    };
    class Unlocker {
    public:
        inline explicit Unlocker(v8::Isolate *isolate) __attribute__((always_inline))         {
            this->Initialize(isolate);
        }
        ~Unlocker();
    private:
        void Initialize(v8::Isolate *isolate);
        internal::Isolate *isolate_;
    };
    class Locker {
    public:
        inline explicit Locker(v8::Isolate *isolate) __attribute__((always_inline))         {
            this->Initialize(isolate);
        }
        ~Locker();
        static bool IsLocked(v8::Isolate *isolate);
        static bool IsActive();
        Locker(const v8::Locker &) = delete
        void operator=(const v8::Locker &) = delete
    private:
        void Initialize(v8::Isolate *isolate);
        bool has_lock_;
        bool top_level_;
        internal::Isolate *isolate_;
    };
    class Unwinder {
    public:
        static bool TryUnwindV8Frames(const v8::UnwindState &unwind_state, v8::RegisterState *register_state, const void *stack_base);
        static bool PCIsInV8(const v8::UnwindState &unwind_state, void *pc);
    };
    template <class T> Local<T> Local<T>::New(v8::Isolate *isolate, Local<T> that)     {
        return New(isolate, that.val_);
    }
    template <class T> Local<T> Local<T>::New(v8::Isolate *isolate, const PersistentBase<T> &that)     {
        return New(isolate, that.val_);
    }
    template <class T> Local<T> Local<T>::New(v8::Isolate *isolate, const TracedGlobal<T> &that)     {
        return New(isolate, that.val_);
    }
    template <class T> Local<T> Local<T>::New(v8::Isolate *isolate, T *that)     {
        if (that == nullptr)
            return Local<T>();
        T *that_ptr = that;
        internal::Address *p = reinterpret_cast<internal::Address *>(that_ptr);
        return Local<T>(reinterpret_cast<T *>(HandleScope::CreateHandle(reinterpret_cast<internal::Isolate *>(isolate), *p)));
    }
    template <class T> template <class S> void Eternal<T>::Set(v8::Isolate *isolate, Local<S> handle)     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
            }
        ;
        this->val_ = reinterpret_cast<T *>(V8::Eternalize(isolate, reinterpret_cast<v8::Value *>(*handle)));
    }
    template <class T> Local<T> Eternal<T>::Get(v8::Isolate *isolate) const     {
        return Local<T>(this->val_);
    }
    template <class T> Local<T> MaybeLocal<T>::ToLocalChecked()     {
        if ((__builtin_expect(!!(this->val_ == nullptr), 0)))
            V8::ToLocalEmpty();
        return Local<T>(this->val_);
    }
    template <class T> void *WeakCallbackInfo<T>::GetInternalField(int index) const     {
        return this->embedder_fields_[index];
    }
    template <class T> T *PersistentBase<T>::New(v8::Isolate *isolate, T *that)     {
        if (that == nullptr)
            return nullptr;
        internal::Address *p = reinterpret_cast<internal::Address *>(that);
        return reinterpret_cast<T *>(V8::GlobalizeReference(reinterpret_cast<internal::Isolate *>(isolate), p));
    }
    template <class T, class M> template <class S, class M2> void Persistent<T, M>::Copy(const Persistent<S, M2> &that)     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
            }
        ;
        this->Reset();
        if (that.IsEmpty())
            return;
        internal::Address *p = reinterpret_cast<internal::Address *>(that.val_);
        this->val_ = reinterpret_cast<T *>(V8::CopyGlobalReference(p));
        M::Copy(that, this);
    }
    template <class T> bool PersistentBase<T>::IsWeak() const     {
        typedef internal::Internals I;
        if (this->IsEmpty())
            return false;
        return I::GetNodeState(reinterpret_cast<internal::Address *>(this->val_)) == I::kNodeStateIsWeakValue;
    }
    template <class T> void PersistentBase<T>::Reset()     {
        if (this->IsEmpty())
            return;
        V8::DisposeGlobal(reinterpret_cast<internal::Address *>(this->val_));
        this->val_ = nullptr;
    }
    template <class T> template <class S> void PersistentBase<T>::Reset(v8::Isolate *isolate, const Local<S> &other)     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
            }
        ;
        Reset();
        if (other.IsEmpty())
            return;
        this->val_ = New(isolate, other.val_);
    }
    template <class T> template <class S> void PersistentBase<T>::Reset(v8::Isolate *isolate, const PersistentBase<S> &other)     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
            }
        ;
        Reset();
        if (other.IsEmpty())
            return;
        this->val_ = New(isolate, other.val_);
    }
    template <class T> template <typename P> inline void PersistentBase<T>::SetWeak(P *parameter, typename WeakCallbackInfo<P>::Callback callback, v8::WeakCallbackType type) __attribute__((always_inline))     {
        typedef typename WeakCallbackInfo<void>::Callback Callback;
        V8::MakeWeak(reinterpret_cast<internal::Address *>(this->val_), parameter, reinterpret_cast<Callback>(callback), type);
    }
    template <class T> void PersistentBase<T>::SetWeak()     {
        V8::MakeWeak(reinterpret_cast<internal::Address **>(&this->val_));
    }
    template <class T> template <typename P> P *PersistentBase<T>::ClearWeak()     {
        return reinterpret_cast<P *>(V8::ClearWeak(reinterpret_cast<internal::Address *>(this->val_)));
    }
    template <class T> void PersistentBase<T>::AnnotateStrongRetainer(const char *label)     {
        V8::AnnotateStrongRetainer(reinterpret_cast<internal::Address *>(this->val_), label);
    }
    template <class T> void PersistentBase<T>::SetWrapperClassId(uint16_t class_id)     {
        typedef internal::Internals I;
        if (this->IsEmpty())
            return;
        internal::Address *obj = reinterpret_cast<internal::Address *>(this->val_);
        uint8_t *addr = reinterpret_cast<uint8_t *>(obj) + I::kNodeClassIdOffset;
        *reinterpret_cast<uint16_t *>(addr) = class_id;
    }
    template <class T> uint16_t PersistentBase<T>::WrapperClassId() const     {
        typedef internal::Internals I;
        if (this->IsEmpty())
            return 0;
        internal::Address *obj = reinterpret_cast<internal::Address *>(this->val_);
        uint8_t *addr = reinterpret_cast<uint8_t *>(obj) + I::kNodeClassIdOffset;
        return *reinterpret_cast<uint16_t *>(addr);
    }
    template <class T> Global<T>::Global<T>(Global<T> &&other) : PersistentBase<T>(other.val_)     {
        if (other.val_ != nullptr) {
            V8::MoveGlobalReference(reinterpret_cast<internal::Address **>(&other.val_), reinterpret_cast<internal::Address **>(&this->val_));
            other.val_ = nullptr;
        }
    }
    template <class T> template <class S> Global<T> &Global<T>::operator=(Global<S> &&rhs)     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
            }
        ;
        if (this != &rhs) {
            this->Reset();
            if (rhs.val_ != nullptr) {
                this->val_ = rhs.val_;
                V8::MoveGlobalReference(reinterpret_cast<internal::Address **>(&rhs.val_), reinterpret_cast<internal::Address **>(&this->val_));
                rhs.val_ = nullptr;
            }
        }
        return *this;
    }
    template <class T> T *TracedGlobal<T>::New(v8::Isolate *isolate, T *that, T **slot)     {
        if (that == nullptr)
            return nullptr;
        internal::Address *p = reinterpret_cast<internal::Address *>(that);
        return reinterpret_cast<T *>(V8::GlobalizeTracedReference(reinterpret_cast<internal::Isolate *>(isolate), p, reinterpret_cast<internal::Address *>(slot)));
    }
    template <class T> void TracedGlobal<T>::Reset()     {
        if (this->IsEmpty())
            return;
        V8::DisposeTracedGlobal(reinterpret_cast<internal::Address *>(this->val_));
        this->val_ = nullptr;
    }
    template <class T> template <class S> void TracedGlobal<T>::Reset(v8::Isolate *isolate, const Local<S> &other)     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
            }
        ;
        Reset();
        if (other.IsEmpty())
            return;
        this->val_ = New(isolate, other.val_, &this->val_);
    }
    template <class T> TracedGlobal<T>::TracedGlobal<T>(TracedGlobal<T> &&other) : val_(other.val_)     {
        if (other.val_ != nullptr) {
            V8::MoveTracedGlobalReference(reinterpret_cast<internal::Address **>(&other.val_), reinterpret_cast<internal::Address **>(&this->val_));
            other.val_ = nullptr;
        }
    }
    template <class T> template <class S> TracedGlobal<T> &TracedGlobal<T>::operator=(TracedGlobal<S> &&rhs)     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
            }
        ;
        if (this != &rhs) {
            this->Reset();
            if (rhs.val_ != nullptr) {
                this->val_ = rhs.val_;
                V8::MoveTracedGlobalReference(reinterpret_cast<internal::Address **>(&rhs.val_), reinterpret_cast<internal::Address **>(&this->val_));
                rhs.val_ = nullptr;
            }
        }
        return *this;
    }
    template <class T> void TracedGlobal<T>::SetWrapperClassId(uint16_t class_id)     {
        typedef internal::Internals I;
        if (this->IsEmpty())
            return;
        internal::Address *obj = reinterpret_cast<internal::Address *>(this->val_);
        uint8_t *addr = reinterpret_cast<uint8_t *>(obj) + I::kNodeClassIdOffset;
        *reinterpret_cast<uint16_t *>(addr) = class_id;
    }
    template <class T> uint16_t TracedGlobal<T>::WrapperClassId() const     {
        typedef internal::Internals I;
        if (this->IsEmpty())
            return 0;
        internal::Address *obj = reinterpret_cast<internal::Address *>(this->val_);
        uint8_t *addr = reinterpret_cast<uint8_t *>(obj) + I::kNodeClassIdOffset;
        return *reinterpret_cast<uint16_t *>(addr);
    }
    template <class T> void TracedGlobal<T>::SetFinalizationCallback(void *parameter, typename WeakCallbackInfo<void>::Callback callback)     {
        V8::SetFinalizationCallbackTraced(reinterpret_cast<internal::Address *>(this->val_), parameter, callback);
    }
    template <typename T> ReturnValue<T>::ReturnValue<T>(internal::Address *slot) : value_(slot)     {
    }
    template <typename T> template <typename S> void ReturnValue<T>::Set(const Global<S> &handle)     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
            }
        ;
        if ((__builtin_expect(!!(handle.IsEmpty()), 0))) {
            *this->value_ = this->GetDefaultValue();
        } else {
            *this->value_ = *reinterpret_cast<internal::Address *>(*handle);
        }
    }
    template <typename T> template <typename S> void ReturnValue<T>::Set(const TracedGlobal<S> &handle)     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
            }
        ;
        if ((__builtin_expect(!!(handle.IsEmpty()), 0))) {
            *this->value_ = this->GetDefaultValue();
        } else {
            *this->value_ = *reinterpret_cast<internal::Address *>(*handle);
        }
    }
    template <typename T> template <typename S> void ReturnValue<T>::Set(const Local<S> handle)     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
            }
        ;
        if ((__builtin_expect(!!(handle.IsEmpty()), 0))) {
            *this->value_ = this->GetDefaultValue();
        } else {
            *this->value_ = *reinterpret_cast<internal::Address *>(*handle);
        }
    }
    template <typename T> void ReturnValue<T>::Set(double i)     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<v8::Number *>(0);
            }
        ;
        Set(Number::New(this->GetIsolate(), i));
    }
    template <typename T> void ReturnValue<T>::Set(int32_t i)     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<v8::Integer *>(0);
            }
        ;
        typedef internal::Internals I;
        if ((__builtin_expect(!!(I::IsValidSmi(i)), 1))) {
            *this->value_ = I::IntToSmi(i);
            return;
        }
        Set(Integer::New(this->GetIsolate(), i));
    }
    template <typename T> void ReturnValue<T>::Set(uint32_t i)     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<v8::Integer *>(0);
            }
        ;
        bool fits_into_int32_t = (i & (1U << 31)) == 0;
        if ((__builtin_expect(!!(fits_into_int32_t), 1))) {
            Set(static_cast<int32_t>(i));
            return;
        }
        Set(Integer::NewFromUnsigned(this->GetIsolate(), i));
    }
    template <typename T> void ReturnValue<T>::Set(bool value)     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<v8::Boolean *>(0);
            }
        ;
        typedef internal::Internals I;
        int root_index;
        if (value) {
            root_index = I::kTrueValueRootIndex;
        } else {
            root_index = I::kFalseValueRootIndex;
        }
        *this->value_ = *I::GetRoot(this->GetIsolate(), root_index);
    }
    template <typename T> void ReturnValue<T>::SetNull()     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<v8::Primitive *>(0);
            }
        ;
        typedef internal::Internals I;
        *this->value_ = *I::GetRoot(this->GetIsolate(), I::kNullValueRootIndex);
    }
    template <typename T> void ReturnValue<T>::SetUndefined()     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<v8::Primitive *>(0);
            }
        ;
        typedef internal::Internals I;
        *this->value_ = *I::GetRoot(this->GetIsolate(), I::kUndefinedValueRootIndex);
    }
    template <typename T> void ReturnValue<T>::SetEmptyString()     {
        while (false)
            {
                *(static_cast<T *volatile *>(0)) = static_cast<v8::String *>(0);
            }
        ;
        typedef internal::Internals I;
        *this->value_ = *I::GetRoot(this->GetIsolate(), I::kEmptyStringRootIndex);
    }
    template <typename T> v8::Isolate *ReturnValue<T>::GetIsolate() const     {
        return *reinterpret_cast<v8::Isolate **>(&this->value_[-2]);
    }
    template <typename T> Local<v8::Value> ReturnValue<T>::Get() const     {
        typedef internal::Internals I;
        if (*this->value_ == *I::GetRoot(this->GetIsolate(), I::kTheHoleValueRootIndex))
            return Local<v8::Value>(*Undefined(this->GetIsolate()));
        return Local<Value>::New(this->GetIsolate(), reinterpret_cast<v8::Value *>(this->value_));
    }
    template <typename T> template <typename S> void ReturnValue<T>::Set(S *whatever)     {
        while (false)
            {
                *(static_cast<S **volatile *>(0)) = static_cast<v8::Primitive *>(0);
            }
        ;
    }
    template <typename T> internal::Address ReturnValue<T>::GetDefaultValue()     {
        return this->value_[-1];
    }
    template <typename T> FunctionCallbackInfo<T>::FunctionCallbackInfo<T>(internal::Address *implicit_args, internal::Address *values, int length) : implicit_args_(implicit_args), values_(values), length_(length)     {
    }
    template <typename T> Local<v8::Value> FunctionCallbackInfo<T>::operator[](int i) const     {
        if (i < 0 || this->length_ <= i)
            return Local<v8::Value>(*Undefined(this->GetIsolate()));
        return Local<v8::Value>(reinterpret_cast<v8::Value *>(this->values_ - i));
    }
    template <typename T> Local<v8::Object> FunctionCallbackInfo<T>::This() const     {
        return Local<v8::Object>(reinterpret_cast<v8::Object *>(this->values_ + 1));
    }
    template <typename T> Local<v8::Object> FunctionCallbackInfo<T>::Holder() const     {
        return Local<v8::Object>(reinterpret_cast<v8::Object *>(&this->implicit_args_[kHolderIndex]));
    }
    template <typename T> Local<v8::Value> FunctionCallbackInfo<T>::NewTarget() const     {
        return Local<v8::Value>(reinterpret_cast<v8::Value *>(&this->implicit_args_[kNewTargetIndex]));
    }
    template <typename T> Local<v8::Value> FunctionCallbackInfo<T>::Data() const     {
        return Local<v8::Value>(reinterpret_cast<v8::Value *>(&this->implicit_args_[kDataIndex]));
    }
    template <typename T> v8::Isolate *FunctionCallbackInfo<T>::GetIsolate() const     {
        return *reinterpret_cast<v8::Isolate **>(&this->implicit_args_[kIsolateIndex]);
    }
    template <typename T> ReturnValue<T> FunctionCallbackInfo<T>::GetReturnValue() const     {
        return ReturnValue<T>(&this->implicit_args_[kReturnValueIndex]);
    }
    template <typename T> bool FunctionCallbackInfo<T>::IsConstructCall() const     {
        return !this->NewTarget()->IsUndefined();
    }
    template <typename T> int FunctionCallbackInfo<T>::Length() const     {
        return this->length_;
    }
    ScriptOrigin::ScriptOrigin(Local<v8::Value> resource_name, Local<v8::Integer> resource_line_offset = Local<v8::Integer>(), Local<v8::Integer> resource_column_offset = Local<v8::Integer>(), Local<v8::Boolean> resource_is_shared_cross_origin = Local<v8::Boolean>(), Local<v8::Integer> script_id = Local<v8::Integer>(), Local<v8::Value> source_map_url = Local<v8::Value>(), Local<v8::Boolean> resource_is_opaque = Local<v8::Boolean>(), Local<v8::Boolean> is_wasm = Local<v8::Boolean>(), Local<v8::Boolean> is_module = Local<v8::Boolean>(), Local<v8::PrimitiveArray> host_defined_options = Local<v8::PrimitiveArray>()) : resource_name_(resource_name), resource_line_offset_(resource_line_offset), resource_column_offset_(resource_column_offset), options_(!resource_is_shared_cross_origin.IsEmpty() && resource_is_shared_cross_origin->IsTrue(), !resource_is_opaque.IsEmpty() && resource_is_opaque->IsTrue(), !is_wasm.IsEmpty() && is_wasm->IsTrue(), !is_module.IsEmpty() && is_module->IsTrue()), script_id_(script_id), source_map_url_(source_map_url), host_defined_options_(host_defined_options)     {
    }
    Local<v8::Value> ScriptOrigin::ResourceName() const     {
        return this->resource_name_;
    }
    Local<v8::PrimitiveArray> ScriptOrigin::HostDefinedOptions() const     {
        return this->host_defined_options_;
    }
    Local<v8::Integer> ScriptOrigin::ResourceLineOffset() const     {
        return this->resource_line_offset_;
    }
    Local<v8::Integer> ScriptOrigin::ResourceColumnOffset() const     {
        return this->resource_column_offset_;
    }
    Local<v8::Integer> ScriptOrigin::ScriptID() const     {
        return this->script_id_;
    }
    Local<v8::Value> ScriptOrigin::SourceMapUrl() const     {
        return this->source_map_url_;
    }
    ScriptCompiler::Source::Source(Local<v8::String> string, const v8::ScriptOrigin &origin, v8::ScriptCompiler::CachedData *data = nullptr) : source_string(string), resource_name(origin.ResourceName()), resource_line_offset(origin.ResourceLineOffset()), resource_column_offset(origin.ResourceColumnOffset()), resource_options(origin.Options()), source_map_url(origin.SourceMapUrl()), host_defined_options(origin.HostDefinedOptions()), cached_data(data)     {
    }
    ScriptCompiler::Source::Source(Local<v8::String> string, v8::ScriptCompiler::CachedData *data = nullptr) : source_string(string), resource_name(), resource_line_offset(), resource_column_offset(), resource_options(), source_map_url(), host_defined_options(), cached_data(data)     {
    }
    ScriptCompiler::Source::~Source() noexcept     {
        delete this->cached_data;
    }
    const ScriptCompiler::CachedData *ScriptCompiler::Source::GetCachedData() const     {
        return this->cached_data;
    }
    const v8::ScriptOriginOptions &ScriptCompiler::Source::GetResourceOptions() const     {
        return this->resource_options;
    }
    Local<v8::Boolean> Boolean::New(v8::Isolate *isolate, bool value)     {
        return value ? True(isolate) : False(isolate);
    }
    void Template::Set(v8::Isolate *isolate, const char *name, Local<v8::Data> value)     {
        this->Set(String::NewFromUtf8(isolate, name, NewStringType::kInternalized).ToLocalChecked(), value);
    }
    v8::FunctionTemplate *FunctionTemplate::Cast(v8::Data *data)     {
        return reinterpret_cast<v8::FunctionTemplate *>(data);
    }
    v8::ObjectTemplate *ObjectTemplate::Cast(v8::Data *data)     {
        return reinterpret_cast<v8::ObjectTemplate *>(data);
    }
    v8::Signature *Signature::Cast(v8::Data *data)     {
        return reinterpret_cast<v8::Signature *>(data);
    }
    v8::AccessorSignature *AccessorSignature::Cast(v8::Data *data)     {
        return reinterpret_cast<v8::AccessorSignature *>(data);
    }
    Local<v8::Value> Object::GetInternalField(int index)     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A obj = *reinterpret_cast<A *>(this);
        auto instance_type = I::GetInstanceType(obj);
        if (instance_type == I::kJSObjectType || instance_type == I::kJSApiObjectType || instance_type == I::kJSSpecialApiObjectType) {
            int offset = I::kJSObjectHeaderSize + (I::kEmbedderDataSlotSize * index);
            A value = I::ReadRawField<A>(obj, offset);
            internal::Isolate *isolate = internal::IsolateFromNeverReadOnlySpaceObject(obj);
            A *result = HandleScope::CreateHandle(isolate, value);
            return Local<v8::Value>(reinterpret_cast<v8::Value *>(result));
        }
        return this->SlowGetInternalField(index);
    }
    void *Object::GetAlignedPointerFromInternalField(int index)     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A obj = *reinterpret_cast<A *>(this);
        auto instance_type = I::GetInstanceType(obj);
        if ((__builtin_expect(!!(instance_type == I::kJSObjectType || instance_type == I::kJSApiObjectType || instance_type == I::kJSSpecialApiObjectType), 1))) {
            int offset = I::kJSObjectHeaderSize + (I::kEmbedderDataSlotSize * index);
            return I::ReadRawField<void *>(obj, offset);
        }
        return this->SlowGetAlignedPointerFromInternalField(index);
    }
    v8::String *String::Cast(v8::Value *value)     {
        return static_cast<v8::String *>(value);
    }
    Local<v8::String> String::Empty(v8::Isolate *isolate)     {
        typedef internal::Address S;
        typedef internal::Internals I;
        I::CheckInitialized(isolate);
        S *slot = I::GetRoot(isolate, I::kEmptyStringRootIndex);
        return Local<v8::String>(reinterpret_cast<v8::String *>(slot));
    }
    String::ExternalStringResource *String::GetExternalStringResource() const     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A obj = *reinterpret_cast<const A *>(this);
        v8::String::ExternalStringResource *result;
        if (I::IsExternalTwoByteString(I::GetInstanceType(obj))) {
            void *value = I::ReadRawField<void *>(obj, I::kStringResourceOffset);
            result = reinterpret_cast<String::ExternalStringResource *>(value);
        } else {
            result = this->GetExternalStringResourceSlow();
        }
        return result;
    }
    String::ExternalStringResourceBase *String::GetExternalStringResourceBase(String::Encoding *encoding_out) const     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A obj = *reinterpret_cast<const A *>(this);
        int type = I::GetInstanceType(obj) & I::kFullStringRepresentationMask;
        *encoding_out = static_cast<v8::String::Encoding>(type & I::kStringEncodingMask);
        v8::String::ExternalStringResourceBase *resource;
        if (type == I::kExternalOneByteRepresentationTag || type == I::kExternalTwoByteRepresentationTag) {
            void *value = I::ReadRawField<void *>(obj, I::kStringResourceOffset);
            resource = static_cast<v8::String::ExternalStringResourceBase *>(value);
        } else {
            resource = this->GetExternalStringResourceBaseSlow(encoding_out);
        }
        return resource;
    }
    bool Value::IsUndefined() const     {
        return this->QuickIsUndefined();
    }
    bool Value::QuickIsUndefined() const     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A obj = *reinterpret_cast<const A *>(this);
        if (!I::HasHeapObjectTag(obj))
            return false;
        if (I::GetInstanceType(obj) != I::kOddballType)
            return false;
        return (I::GetOddballKind(obj) == I::kUndefinedOddballKind);
    }
    bool Value::IsNull() const     {
        return this->QuickIsNull();
    }
    bool Value::QuickIsNull() const     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A obj = *reinterpret_cast<const A *>(this);
        if (!I::HasHeapObjectTag(obj))
            return false;
        if (I::GetInstanceType(obj) != I::kOddballType)
            return false;
        return (I::GetOddballKind(obj) == I::kNullOddballKind);
    }
    bool Value::IsNullOrUndefined() const     {
        return this->QuickIsNullOrUndefined();
    }
    bool Value::QuickIsNullOrUndefined() const     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A obj = *reinterpret_cast<const A *>(this);
        if (!I::HasHeapObjectTag(obj))
            return false;
        if (I::GetInstanceType(obj) != I::kOddballType)
            return false;
        int kind = I::GetOddballKind(obj);
        return kind == I::kNullOddballKind || kind == I::kUndefinedOddballKind;
    }
    bool Value::IsString() const     {
        return this->QuickIsString();
    }
    bool Value::QuickIsString() const     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A obj = *reinterpret_cast<const A *>(this);
        if (!I::HasHeapObjectTag(obj))
            return false;
        return (I::GetInstanceType(obj) < I::kFirstNonstringType);
    }
    template <class T> v8::Value *Value::Cast(T *value)     {
        return static_cast<v8::Value *>(value);
    }
    v8::Boolean *Boolean::Cast(v8::Value *value)     {
        return static_cast<v8::Boolean *>(value);
    }
    v8::Name *Name::Cast(v8::Value *value)     {
        return static_cast<v8::Name *>(value);
    }
    v8::Symbol *Symbol::Cast(v8::Value *value)     {
        return static_cast<v8::Symbol *>(value);
    }
    v8::Private *Private::Cast(v8::Data *data)     {
        return reinterpret_cast<v8::Private *>(data);
    }
    v8::Number *Number::Cast(v8::Value *value)     {
        return static_cast<v8::Number *>(value);
    }
    v8::Integer *Integer::Cast(v8::Value *value)     {
        return static_cast<v8::Integer *>(value);
    }
    v8::Int32 *Int32::Cast(v8::Value *value)     {
        return static_cast<v8::Int32 *>(value);
    }
    v8::Uint32 *Uint32::Cast(v8::Value *value)     {
        return static_cast<v8::Uint32 *>(value);
    }
    v8::BigInt *BigInt::Cast(v8::Value *value)     {
        return static_cast<v8::BigInt *>(value);
    }
    v8::Date *Date::Cast(v8::Value *value)     {
        return static_cast<v8::Date *>(value);
    }
    v8::StringObject *StringObject::Cast(v8::Value *value)     {
        return static_cast<v8::StringObject *>(value);
    }
    v8::SymbolObject *SymbolObject::Cast(v8::Value *value)     {
        return static_cast<v8::SymbolObject *>(value);
    }
    v8::NumberObject *NumberObject::Cast(v8::Value *value)     {
        return static_cast<v8::NumberObject *>(value);
    }
    v8::BigIntObject *BigIntObject::Cast(v8::Value *value)     {
        return static_cast<v8::BigIntObject *>(value);
    }
    v8::BooleanObject *BooleanObject::Cast(v8::Value *value)     {
        return static_cast<v8::BooleanObject *>(value);
    }
    v8::RegExp *RegExp::Cast(v8::Value *value)     {
        return static_cast<v8::RegExp *>(value);
    }
    v8::Object *Object::Cast(v8::Value *value)     {
        return static_cast<v8::Object *>(value);
    }
    v8::Array *Array::Cast(v8::Value *value)     {
        return static_cast<v8::Array *>(value);
    }
    v8::Map *Map::Cast(v8::Value *value)     {
        return static_cast<v8::Map *>(value);
    }
    v8::Set *Set::Cast(v8::Value *value)     {
        return static_cast<v8::Set *>(value);
    }
    v8::Promise *Promise::Cast(v8::Value *value)     {
        return static_cast<v8::Promise *>(value);
    }
    v8::Proxy *Proxy::Cast(v8::Value *value)     {
        return static_cast<v8::Proxy *>(value);
    }
    v8::WasmModuleObject *WasmModuleObject::Cast(v8::Value *value)     {
        return static_cast<v8::WasmModuleObject *>(value);
    }
    Promise::Resolver *Promise::Resolver::Cast(v8::Value *value)     {
        return static_cast<Promise::Resolver *>(value);
    }
    v8::ArrayBuffer *ArrayBuffer::Cast(v8::Value *value)     {
        return static_cast<v8::ArrayBuffer *>(value);
    }
    v8::ArrayBufferView *ArrayBufferView::Cast(v8::Value *value)     {
        return static_cast<v8::ArrayBufferView *>(value);
    }
    v8::TypedArray *TypedArray::Cast(v8::Value *value)     {
        return static_cast<v8::TypedArray *>(value);
    }
    v8::Uint8Array *Uint8Array::Cast(v8::Value *value)     {
        return static_cast<v8::Uint8Array *>(value);
    }
    v8::Int8Array *Int8Array::Cast(v8::Value *value)     {
        return static_cast<v8::Int8Array *>(value);
    }
    v8::Uint16Array *Uint16Array::Cast(v8::Value *value)     {
        return static_cast<v8::Uint16Array *>(value);
    }
    v8::Int16Array *Int16Array::Cast(v8::Value *value)     {
        return static_cast<v8::Int16Array *>(value);
    }
    v8::Uint32Array *Uint32Array::Cast(v8::Value *value)     {
        return static_cast<v8::Uint32Array *>(value);
    }
    v8::Int32Array *Int32Array::Cast(v8::Value *value)     {
        return static_cast<v8::Int32Array *>(value);
    }
    v8::Float32Array *Float32Array::Cast(v8::Value *value)     {
        return static_cast<v8::Float32Array *>(value);
    }
    v8::Float64Array *Float64Array::Cast(v8::Value *value)     {
        return static_cast<v8::Float64Array *>(value);
    }
    v8::BigInt64Array *BigInt64Array::Cast(v8::Value *value)     {
        return static_cast<v8::BigInt64Array *>(value);
    }
    v8::BigUint64Array *BigUint64Array::Cast(v8::Value *value)     {
        return static_cast<v8::BigUint64Array *>(value);
    }
    v8::Uint8ClampedArray *Uint8ClampedArray::Cast(v8::Value *value)     {
        return static_cast<v8::Uint8ClampedArray *>(value);
    }
    v8::DataView *DataView::Cast(v8::Value *value)     {
        return static_cast<v8::DataView *>(value);
    }
    v8::SharedArrayBuffer *SharedArrayBuffer::Cast(v8::Value *value)     {
        return static_cast<v8::SharedArrayBuffer *>(value);
    }
    v8::Function *Function::Cast(v8::Value *value)     {
        return static_cast<v8::Function *>(value);
    }
    v8::External *External::Cast(v8::Value *value)     {
        return static_cast<v8::External *>(value);
    }
    template <typename T> v8::Isolate *PropertyCallbackInfo<T>::GetIsolate() const     {
        return *reinterpret_cast<v8::Isolate **>(&this->args_[kIsolateIndex]);
    }
    template <typename T> Local<v8::Value> PropertyCallbackInfo<T>::Data() const     {
        return Local<v8::Value>(reinterpret_cast<v8::Value *>(&this->args_[kDataIndex]));
    }
    template <typename T> Local<v8::Object> PropertyCallbackInfo<T>::This() const     {
        return Local<v8::Object>(reinterpret_cast<v8::Object *>(&this->args_[kThisIndex]));
    }
    template <typename T> Local<v8::Object> PropertyCallbackInfo<T>::Holder() const     {
        return Local<v8::Object>(reinterpret_cast<v8::Object *>(&this->args_[kHolderIndex]));
    }
    template <typename T> ReturnValue<T> PropertyCallbackInfo<T>::GetReturnValue() const     {
        return ReturnValue<T>(&this->args_[kReturnValueIndex]);
    }
    template <typename T> bool PropertyCallbackInfo<T>::ShouldThrowOnError() const     {
        typedef internal::Internals I;
        if (this->args_[kShouldThrowOnErrorIndex] != I::IntToSmi(I::kInferShouldThrowMode)) {
            return this->args_[kShouldThrowOnErrorIndex] != I::IntToSmi(I::kDontThrow);
        }
        return v8::internal::ShouldThrowOnError(reinterpret_cast<v8::internal::Isolate *>(this->GetIsolate()));
    }
    Local<v8::Primitive> Undefined(v8::Isolate *isolate)     {
        typedef internal::Address S;
        typedef internal::Internals I;
        I::CheckInitialized(isolate);
        S *slot = I::GetRoot(isolate, I::kUndefinedValueRootIndex);
        return Local<v8::Primitive>(reinterpret_cast<v8::Primitive *>(slot));
    }
    Local<v8::Primitive> Null(v8::Isolate *isolate)     {
        typedef internal::Address S;
        typedef internal::Internals I;
        I::CheckInitialized(isolate);
        S *slot = I::GetRoot(isolate, I::kNullValueRootIndex);
        return Local<v8::Primitive>(reinterpret_cast<v8::Primitive *>(slot));
    }
    Local<v8::Boolean> True(v8::Isolate *isolate)     {
        typedef internal::Address S;
        typedef internal::Internals I;
        I::CheckInitialized(isolate);
        S *slot = I::GetRoot(isolate, I::kTrueValueRootIndex);
        return Local<v8::Boolean>(reinterpret_cast<v8::Boolean *>(slot));
    }
    Local<v8::Boolean> False(v8::Isolate *isolate)     {
        typedef internal::Address S;
        typedef internal::Internals I;
        I::CheckInitialized(isolate);
        S *slot = I::GetRoot(isolate, I::kFalseValueRootIndex);
        return Local<v8::Boolean>(reinterpret_cast<v8::Boolean *>(slot));
    }
    void Isolate::SetData(uint32_t slot, void *data)     {
        typedef internal::Internals I;
        I::SetEmbedderData(this, slot, data);
    }
    void *Isolate::GetData(uint32_t slot)     {
        typedef internal::Internals I;
        return I::GetEmbedderData(this, slot);
    }
    uint32_t Isolate::GetNumberOfDataSlots()     {
        typedef internal::Internals I;
        return I::kNumIsolateDataSlots;
    }
    template <class T> MaybeLocal<T> Isolate::GetDataFromSnapshotOnce(size_t index)     {
        T *data = reinterpret_cast<T *>(this->GetDataFromSnapshotOnce(index));
        if (data)
            internal::PerformCastCheck(data);
        return Local<T>(data);
    }
    int64_t Isolate::AdjustAmountOfExternalAllocatedMemory(int64_t change_in_bytes)     {
        typedef internal::Internals I;
        constexpr int64_t kMemoryReducerActivationLimit = 32 * 1024 * 1024;
        int64_t *external_memory = reinterpret_cast<int64_t *>(reinterpret_cast<uint8_t *>(this) + I::kExternalMemoryOffset);
        int64_t *external_memory_limit = reinterpret_cast<int64_t *>(reinterpret_cast<uint8_t *>(this) + I::kExternalMemoryLimitOffset);
        int64_t *external_memory_at_last_mc = reinterpret_cast<int64_t *>(reinterpret_cast<uint8_t *>(this) + I::kExternalMemoryAtLastMarkCompactOffset);
        const int64_t amount = static_cast<int64_t>(static_cast<uint64_t>(change_in_bytes) + static_cast<uint64_t>(*external_memory));
        *external_memory = amount;
        int64_t allocation_diff_since_last_mc = static_cast<int64_t>(static_cast<uint64_t>(*external_memory) - static_cast<uint64_t>(*external_memory_at_last_mc));
        if (allocation_diff_since_last_mc > kMemoryReducerActivationLimit) {
            this->CheckMemoryPressure();
        }
        if (change_in_bytes < 0) {
            const int64_t lower_limit = *external_memory_limit + change_in_bytes;
            if (lower_limit > I::kExternalAllocationSoftLimit)
                *external_memory_limit = lower_limit;
        } else if (change_in_bytes > 0 && amount > *external_memory_limit) {
            this->ReportExternalAllocationLimitReached();
        }
        return *external_memory;
    }
    Local<v8::Value> Context::GetEmbedderData(int index)     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A ctx = *reinterpret_cast<const A *>(this);
        A embedder_data = I::ReadTaggedPointerField(ctx, I::kNativeContextEmbedderDataOffset);
        int value_offset = I::kEmbedderDataArrayHeaderSize + (I::kEmbedderDataSlotSize * index);
        A value = I::ReadRawField<A>(embedder_data, value_offset);
        internal::Isolate *isolate = internal::IsolateFromNeverReadOnlySpaceObject(*reinterpret_cast<A *>(this));
        A *result = HandleScope::CreateHandle(isolate, value);
        return Local<v8::Value>(reinterpret_cast<v8::Value *>(result));
    }
    void *Context::GetAlignedPointerFromEmbedderData(int index)     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A ctx = *reinterpret_cast<const A *>(this);
        A embedder_data = I::ReadTaggedPointerField(ctx, I::kNativeContextEmbedderDataOffset);
        int value_offset = I::kEmbedderDataArrayHeaderSize + (I::kEmbedderDataSlotSize * index);
        return I::ReadRawField<void *>(embedder_data, value_offset);
    }
    template <class T> MaybeLocal<T> Context::GetDataFromSnapshotOnce(size_t index)     {
        T *data = reinterpret_cast<T *>(this->GetDataFromSnapshotOnce(index));
        if (data)
            internal::PerformCastCheck(data);
        return Local<T>(data);
    }
    template <class T> size_t SnapshotCreator::AddData(Local<v8::Context> context, Local<T> object)     {
        T *object_ptr = *object;
        internal::Address *p = reinterpret_cast<internal::Address *>(object_ptr);
        return this->AddData(context, *p);
    }
    template <class T> size_t SnapshotCreator::AddData(Local<T> object)     {
        T *object_ptr = *object;
        internal::Address *p = reinterpret_cast<internal::Address *>(object_ptr);
        return this->AddData(*p);
    }
}
