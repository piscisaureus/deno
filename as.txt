typedef long long ptrdiff_t;
typedef unsigned long long size_t;
namespace std {
    typedef decltype(nullptr) nullptr_t;
}
using ::std::nullptr_t;
typedef double max_align_t;
extern "C" {
}
extern "C" {
}
extern "C" {
    typedef unsigned long long uintptr_t;
    typedef char *va_list;
    void __va_start(va_list *, ...) throw();
}
extern "C++" {
    template <typename _Ty> struct __vcrt_va_list_is_reference {
        enum  : bool {
            __the_value = false
        };
    };
    template <typename _Ty> struct __vcrt_va_list_is_reference<type-parameter-0-0 &> {
        enum  : bool {
            __the_value = true
        };
    };
    template <typename _Ty> struct __vcrt_va_list_is_reference<type-parameter-0-0 &&> {
        enum  : bool {
            __the_value = true
        };
    };
    template <typename _Ty> struct __vcrt_assert_va_start_is_not_reference {
        static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
    };
}
extern "C" {
    typedef unsigned long long size_t;
    typedef long long ptrdiff_t;
    typedef long long intptr_t;
    typedef bool __vcrt_bool;
    extern "C++" {
        template <typename _CountofType, size_t _SizeOfArray> char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
    }
    void __security_init_cookie();
    void __security_check_cookie(uintptr_t _StackCookie);
    void __report_gsfailure(uintptr_t _StackCookie);
    extern uintptr_t __security_cookie;
}
typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef int int_least32_t;
typedef long long int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long long uint_least64_t;
typedef signed char int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long uint_fast64_t;
typedef long long intmax_t;
typedef unsigned long long uintmax_t;
extern "C" {
    extern "C++" {
        template <bool _Enable, typename _Ty> struct _CrtEnableIf;
        template <typename _Ty> struct _CrtEnableIf<true, _Ty> {
            typedef _Ty _Type;
        };
    }
    typedef bool __crt_bool;
    void _invalid_parameter_noinfo();
    void _invalid_parameter_noinfo_noreturn();
    void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved);
    typedef int errno_t;
    typedef unsigned short wint_t;
    typedef unsigned short wctype_t;
    typedef long __time32_t;
    typedef long long __time64_t;
    typedef struct __crt_locale_data_public {
        const unsigned short *_locale_pctype;
        int _locale_mb_cur_max;
        unsigned int _locale_lc_codepage;
    } __crt_locale_data_public;
    typedef struct __crt_locale_pointers {
        struct __crt_locale_data *locinfo;
        struct __crt_multibyte_data *mbcinfo;
    } __crt_locale_pointers;
    typedef __crt_locale_pointers *_locale_t;
    typedef struct _Mbstatet {
        unsigned long _Wchar;
        unsigned short _Byte;
        unsigned short _State;
    } _Mbstatet;
    typedef _Mbstatet mbstate_t;
    typedef __time64_t time_t;
    typedef size_t rsize_t;
}
extern "C" {
    inline unsigned long long *__local_stdio_printf_options() __declspec(noinline)     {
        static unsigned long long _OptionsStorage;
        return &_OptionsStorage;
    }
    inline unsigned long long *__local_stdio_scanf_options() __declspec(noinline)     {
        static unsigned long long _OptionsStorage;
        return &_OptionsStorage;
    }
}
;
extern "C" {
    typedef struct _iobuf {
        void *_Placeholder;
    } FILE;
    FILE *__acrt_iob_func(unsigned int _Ix);
    wint_t fgetwc(FILE *_Stream);
    wint_t _fgetwchar();
    wint_t fputwc(wchar_t _Character, FILE *_Stream);
    wint_t _fputwchar(wchar_t _Character);
    wint_t getwc(FILE *_Stream);
    wint_t getwchar();
    wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream);
    int fputws(const wchar_t *_Buffer, FILE *_Stream);
    wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount);
    extern "C++" {
        template <size_t _Size> inline wchar_t *_getws_s(wchar_t (&_Buffer)[_Size]) throw()     }
    wint_t putwc(wchar_t _Character, FILE *_Stream);
    wint_t putwchar(wchar_t _Character);
    int _putws(const wchar_t *_Buffer);
    wint_t ungetwc(wint_t _Character, FILE *_Stream);
    FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode);
    FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode) __declspec(deprecated("This function or variable may be unsafe. Consider using _wfopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode);
    FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream) __declspec(deprecated("This function or variable may be unsafe. Consider using _wfreopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream);
    FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag);
    void _wperror(const wchar_t *_ErrorMessage);
    FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode);
    int _wremove(const wchar_t *_FileName);
    wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix);
    errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount);
    extern "C++" {
        template <size_t _Size> inline errno_t _wtmpnam_s(wchar_t (&_Buffer)[_Size]) throw()     }
    wchar_t *_wtmpnam(wchar_t *_Buffer) __declspec(deprecated("This function or variable may be unsafe. Consider using _wtmpnam_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    wint_t _fgetwc_nolock(FILE *_Stream);
    wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream);
    wint_t _getwc_nolock(FILE *_Stream);
    wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream);
    wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream);
    int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vfwprintf_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    inline int vfwprintf(FILE *const _Stream, const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vfwprintf_s_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    inline int vfwprintf_s(FILE *const _Stream, const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vfwprintf_p_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    inline int _vfwprintf_p(FILE *const _Stream, const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vwprintf_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    inline int vwprintf(const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    inline int _vwprintf_s_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    inline int vwprintf_s(const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    inline int _vwprintf_p_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    inline int _vwprintf_p(const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    inline int _fwprintf_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int fwprintf(FILE *const _Stream, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _fwprintf_s_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int fwprintf_s(FILE *const _Stream, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _fwprintf_p_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _fwprintf_p(FILE *const _Stream, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _wprintf_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int wprintf(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _wprintf_s_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int wprintf_s(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _wprintf_p_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _wprintf_p(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vfwscanf_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfwscanf((*__local_stdio_scanf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    inline int vfwscanf(FILE *const _Stream, const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vfwscanf_s_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfwscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Stream, _Format, _Locale, _ArgList);
    }
    inline int vfwscanf_s(FILE *const _Stream, const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vwscanf_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    inline int vwscanf(const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    inline int _vwscanf_s_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    inline int vwscanf_s(const wchar_t *const _Format, va_list _ArgList)     {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    inline int _fwscanf_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _fwscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int fwscanf(FILE *const _Stream, const wchar_t *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using fwscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _fwscanf_s_l(FILE *const _Stream, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int fwscanf_s(FILE *const _Stream, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _wscanf_l(const wchar_t *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _wscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int wscanf(const wchar_t *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using wscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _wscanf_s_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int wscanf_s(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vsnwprintf_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnwprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        const int _Result = __stdio_common_vswprintf((*__local_stdio_printf_options()) | (1ULL << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vsnwprintf_s_l(wchar_t *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vsnwprintf_s((*__local_stdio_printf_options()), _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vsnwprintf_s(wchar_t *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const wchar_t *const _Format, va_list _ArgList)     {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    inline int _snwprintf(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _snwprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    inline int _vsnwprintf(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, va_list _Args) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnwprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    inline int _vsnwprintf(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, va_list _ArgList) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnwprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    extern "C++" {
        template <size_t _Size> inline int _vsnwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, const wchar_t *_Format, va_list _ArgList) throw()     }
    inline int _vswprintf_c_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vswprintf((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vswprintf_c(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, va_list _ArgList)     {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    inline int _vswprintf_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    inline int __vswprintf_l(wchar_t *const _Buffer, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    inline int _vswprintf(wchar_t *const _Buffer, const wchar_t *const _Format, va_list _ArgList)     {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    inline int vswprintf(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, va_list _ArgList)     {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    inline int _vswprintf_s_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vswprintf_s((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int vswprintf_s(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, va_list _ArgList)     {
        return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    extern "C++" {
        template <size_t _Size> inline int vswprintf_s(wchar_t (&_Buffer)[_Size], const wchar_t *_Format, va_list _ArgList) throw()     }
    inline int _vswprintf_p_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vswprintf_p((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vswprintf_p(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, va_list _ArgList)     {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    inline int _vscwprintf_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vswprintf((*__local_stdio_printf_options()) | (1ULL << 1), 0, 0, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vscwprintf(const wchar_t *const _Format, va_list _ArgList)     {
        return _vscwprintf_l(_Format, 0, _ArgList);
    }
    inline int _vscwprintf_p_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vswprintf_p((*__local_stdio_printf_options()) | (1ULL << 1), 0, 0, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vscwprintf_p(const wchar_t *const _Format, va_list _ArgList)     {
        return _vscwprintf_p_l(_Format, 0, _ArgList);
    }
    inline int __swprintf_l(wchar_t *const _Buffer, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _swprintf_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _swprintf(wchar_t *const _Buffer, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int swprintf(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int __swprintf_l(wchar_t *_Buffer, const wchar_t *_Format, _locale_t _Locale, ...);
    inline int __vswprintf_l(wchar_t *_Buffer, const wchar_t *_Format, _locale_t _Locale, va_list _Args);
    inline int _swprintf(wchar_t *_Buffer, const wchar_t *_Format, ...);
    inline int _vswprintf(wchar_t *_Buffer, const wchar_t *_Format, va_list _Args);
    inline int _swprintf_s_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int swprintf_s(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    extern "C++" {
        ;
        template <size_t _Size> inline int swprintf_s(wchar_t (&_Buffer)[_Size], const wchar_t *_Format, ...) throw()         ;
    }
    inline int _swprintf_p_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _swprintf_p(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _swprintf_c_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _swprintf_c(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snwprintf_l(wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _snwprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snwprintf(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snwprintf_s_l(wchar_t *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snwprintf_s(wchar_t *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    extern "C++" {
        ;
        template <size_t _Size> inline int _snwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, const wchar_t *_Format, ...) throw()         ;
    }
    inline int _scwprintf_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _scwprintf(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vscwprintf_l(_Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _scwprintf_p_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _scwprintf_p(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    extern "C++" inline int swprintf(wchar_t *const _Buffer, const wchar_t *const _Format, ...) throw() __declspec(deprecated("This function or variable may be unsafe. Consider using swprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }

    extern "C++" inline int vswprintf(wchar_t *const _Buffer, const wchar_t *const _Format, va_list _ArgList) throw() __declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using vswprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
    }

    extern "C++" inline int _swprintf_l(wchar_t *const _Buffer, const wchar_t *const _Format, const _locale_t _Locale, ...) throw() __declspec(deprecated("This function or variable may be unsafe. Consider using _swprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }

    extern "C++" inline int _vswprintf_l(wchar_t *const _Buffer, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList) throw() __declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using _vswprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }

    int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vswscanf_l(const wchar_t *const _Buffer, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vswscanf((*__local_stdio_scanf_options()), _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    inline int vswscanf(const wchar_t *_Buffer, const wchar_t *_Format, va_list _ArgList)     {
        return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    inline int _vswscanf_s_l(const wchar_t *const _Buffer, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vswscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    inline int vswscanf_s(const wchar_t *const _Buffer, const wchar_t *const _Format, va_list _ArgList)     {
        return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
    }
    extern "C++" {
        template <size_t _Size> inline int vswscanf_s(wchar_t (&_Buffer)[_Size], const wchar_t *_Format, va_list _ArgList) throw()     }
    inline int _vsnwscanf_l(const wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnwscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return __stdio_common_vswscanf((*__local_stdio_scanf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    inline int _vsnwscanf_s_l(const wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vswscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    inline int _swscanf_l(const wchar_t *const _Buffer, const wchar_t *const _Format, _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _swscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int swscanf(const wchar_t *const _Buffer, const wchar_t *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using swscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _swscanf_s_l(const wchar_t *const _Buffer, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int swscanf_s(const wchar_t *const _Buffer, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snwscanf_l(const wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _snwscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snwscanf(const wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _snwscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snwscanf_s_l(const wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snwscanf_s(const wchar_t *const _Buffer, const size_t _BufferCount, const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
}
extern "C" {
    typedef long long fpos_t;
    errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count);
    errno_t clearerr_s(FILE *_Stream);
    errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode);
    size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream);
    errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream);
    char *gets_s(char *_Buffer, rsize_t _Size);
    errno_t tmpfile_s(FILE **_Stream);
    errno_t tmpnam_s(char *_Buffer, rsize_t _Size);
    void clearerr(FILE *_Stream);
    int fclose(FILE *_Stream);
    int _fcloseall();
    FILE *_fdopen(int _FileHandle, const char *_Mode);
    int feof(FILE *_Stream);
    int ferror(FILE *_Stream);
    int fflush(FILE *_Stream);
    int fgetc(FILE *_Stream);
    int _fgetchar();
    int fgetpos(FILE *_Stream, fpos_t *_Position);
    char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream);
    int _fileno(FILE *_Stream);
    int _flushall();
    FILE *fopen(const char *_FileName, const char *_Mode) __declspec(deprecated("This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int fputc(int _Character, FILE *_Stream);
    int _fputchar(int _Character);
    int fputs(const char *_Buffer, FILE *_Stream);
    size_t fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream);
    FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream) __declspec(deprecated("This function or variable may be unsafe. Consider using freopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag);
    int fsetpos(FILE *_Stream, const fpos_t *_Position);
    int fseek(FILE *_Stream, long _Offset, int _Origin);
    int _fseeki64(FILE *_Stream, long long _Offset, int _Origin);
    long ftell(FILE *_Stream);
    long long _ftelli64(FILE *_Stream);
    size_t fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream);
    int getc(FILE *_Stream);
    int getchar();
    int _getmaxstdio();
    extern "C++" {
        template <size_t _Size> inline char *gets_s(char (&_Buffer)[_Size]) throw()     }
    int _getw(FILE *_Stream);
    void perror(const char *_ErrorMessage);
    int _pclose(FILE *_Stream);
    FILE *_popen(const char *_Command, const char *_Mode);
    int putc(int _Character, FILE *_Stream);
    int putchar(int _Character);
    int puts(const char *_Buffer);
    int _putw(int _Word, FILE *_Stream);
    int remove(const char *_FileName);
    int rename(const char *_OldFileName, const char *_NewFileName);
    int _unlink(const char *_FileName);
    int unlink(const char *_FileName) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _unlink. See online help for details."));
    void rewind(FILE *_Stream);
    int _rmtmp();
    void setbuf(FILE *_Stream, char *_Buffer) __declspec(deprecated("This function or variable may be unsafe. Consider using setvbuf instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int _setmaxstdio(int _Maximum);
    int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size);
    char *_tempnam(const char *_DirectoryName, const char *_FilePrefix);
    FILE *tmpfile() __declspec(deprecated("This function or variable may be unsafe. Consider using tmpfile_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    extern "C++" {
        template <size_t _Size> inline errno_t tmpnam_s(char (&_Buffer)[_Size]) throw()     }
    char *tmpnam(char *_Buffer) __declspec(deprecated("This function or variable may be unsafe. Consider using tmpnam_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int ungetc(int _Character, FILE *_Stream);
    void _lock_file(FILE *_Stream);
    void _unlock_file(FILE *_Stream);
    int _fclose_nolock(FILE *_Stream);
    int _fflush_nolock(FILE *_Stream);
    int _fgetc_nolock(FILE *_Stream);
    int _fputc_nolock(int _Character, FILE *_Stream);
    size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream);
    size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream);
    int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin);
    int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin);
    long _ftell_nolock(FILE *_Stream);
    long long _ftelli64_nolock(FILE *_Stream);
    size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream);
    int _getc_nolock(FILE *_Stream);
    int _putc_nolock(int _Character, FILE *_Stream);
    int _ungetc_nolock(int _Character, FILE *_Stream);
    int *__p__commode();
    int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vfprintf_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    inline int vfprintf(FILE *const _Stream, const char *const _Format, va_list _ArgList)     {
        return _vfprintf_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vfprintf_s_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    inline int vfprintf_s(FILE *const _Stream, const char *const _Format, va_list _ArgList)     {
        return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vfprintf_p_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    inline int _vfprintf_p(FILE *const _Stream, const char *const _Format, va_list _ArgList)     {
        return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vprintf_l(const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    inline int vprintf(const char *const _Format, va_list _ArgList)     {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    inline int _vprintf_s_l(const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    inline int vprintf_s(const char *const _Format, va_list _ArgList)     {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    inline int _vprintf_p_l(const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    inline int _vprintf_p(const char *const _Format, va_list _ArgList)     {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    inline int _fprintf_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int fprintf(FILE *const _Stream, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int _set_printf_count_output(int _Value);
    int _get_printf_count_output();
    inline int _fprintf_s_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int fprintf_s(FILE *const _Stream, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _fprintf_p_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _fprintf_p(FILE *const _Stream, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _printf_l(const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int printf(const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _printf_s_l(const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int printf_s(const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _printf_p_l(const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _printf_p(const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist);
    inline int _vfscanf_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfscanf((*__local_stdio_scanf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    inline int vfscanf(FILE *const _Stream, const char *const _Format, va_list _ArgList)     {
        return _vfscanf_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vfscanf_s_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vfscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Stream, _Format, _Locale, _ArgList);
    }
    inline int vfscanf_s(FILE *const _Stream, const char *const _Format, va_list _ArgList)     {
        return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
    }
    inline int _vscanf_l(const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    inline int vscanf(const char *const _Format, va_list _ArgList)     {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    inline int _vscanf_s_l(const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    inline int vscanf_s(const char *const _Format, va_list _ArgList)     {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    inline int _fscanf_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _fscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int fscanf(FILE *const _Stream, const char *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using fscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _fscanf_s_l(FILE *const _Stream, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int fscanf_s(FILE *const _Stream, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _scanf_l(const char *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _scanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int scanf(const char *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using scanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _scanf_s_l(const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int scanf_s(const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList);
    int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vsnprintf_l(char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, va_list _ArgList) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1ULL << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vsnprintf(char *const _Buffer, const size_t _BufferCount, const char *const _Format, va_list _ArgList)     {
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    inline int vsnprintf(char *const _Buffer, const size_t _BufferCount, const char *const _Format, va_list _ArgList)     {
        const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1ULL << 1), _Buffer, _BufferCount, _Format, 0, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vsprintf_l(char *const _Buffer, const char *const _Format, const _locale_t _Locale, va_list _ArgList) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    inline int vsprintf(char *const _Buffer, const char *const _Format, va_list _ArgList) __declspec(deprecated("This function or variable may be unsafe. Consider using vsprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    inline int _vsprintf_s_l(char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vsprintf_s((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int vsprintf_s(char *const _Buffer, const size_t _BufferCount, const char *const _Format, va_list _ArgList)     {
        return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    extern "C++" {
        template <size_t _Size> inline int vsprintf_s(char (&_Buffer)[_Size], const char *_Format, va_list _ArgList) throw()     }
    inline int _vsprintf_p_l(char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vsprintf_p((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vsprintf_p(char *const _Buffer, const size_t _BufferCount, const char *const _Format, va_list _ArgList)     {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    inline int _vsnprintf_s_l(char *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vsnprintf_s((*__local_stdio_printf_options()), _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vsnprintf_s(char *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char *const _Format, va_list _ArgList)     {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    extern "C++" {
        template <size_t _Size> inline int _vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, const char *_Format, va_list _ArgList) throw()     }
    inline int vsnprintf_s(char *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char *const _Format, va_list _ArgList)     {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    extern "C++" {
        template <size_t _Size> inline int vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, const char *_Format, va_list _ArgList) throw()     }
    inline int _vscprintf_l(const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1ULL << 1), 0, 0, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vscprintf(const char *const _Format, va_list _ArgList)     {
        return _vscprintf_l(_Format, 0, _ArgList);
    }
    inline int _vscprintf_p_l(const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vsprintf_p((*__local_stdio_printf_options()) | (1ULL << 1), 0, 0, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vscprintf_p(const char *const _Format, va_list _ArgList)     {
        return _vscprintf_p_l(_Format, 0, _ArgList);
    }
    inline int _vsnprintf_c_l(char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    inline int _vsnprintf_c(char *const _Buffer, const size_t _BufferCount, const char *const _Format, va_list _ArgList)     {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    inline int _sprintf_l(char *const _Buffer, const char *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _sprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int sprintf(char *const _Buffer, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int sprintf(char *_Buffer, const char *_Format, ...);
    int vsprintf(char *_Buffer, const char *_Format, va_list _Args) __declspec(deprecated("This function or variable may be unsafe. Consider using vsprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    inline int _sprintf_s_l(char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int sprintf_s(char *const _Buffer, const size_t _BufferCount, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    extern "C++" {
        ;
        template <size_t _Size> inline int sprintf_s(char (&_Buffer)[_Size], const char *_Format, ...) throw()         ;
    }
    inline int _sprintf_p_l(char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _sprintf_p(char *const _Buffer, const size_t _BufferCount, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snprintf_l(char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _snprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int snprintf(char *const _Buffer, const size_t _BufferCount, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snprintf(char *const _Buffer, const size_t _BufferCount, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int _snprintf(char *_Buffer, size_t _BufferCount, const char *_Format, ...);
    int _vsnprintf(char *_Buffer, size_t _BufferCount, const char *_Format, va_list _Args);
    inline int _snprintf_c_l(char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snprintf_c(char *const _Buffer, const size_t _BufferCount, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snprintf_s_l(char *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snprintf_s(char *const _Buffer, const size_t _BufferCount, const size_t _MaxCount, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    extern "C++" {
        ;
        template <size_t _Size> inline int _snprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, const char *_Format, ...) throw()         ;
    }
    inline int _scprintf_l(const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _scprintf(const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vscprintf_l(_Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _scprintf_p_l(const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _scprintf_p(const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vscprintf_p(_Format, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vsscanf_l(const char *const _Buffer, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vsscanf((*__local_stdio_scanf_options()), _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    inline int vsscanf(const char *const _Buffer, const char *const _Format, va_list _ArgList)     {
        return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    inline int _vsscanf_s_l(const char *const _Buffer, const char *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    inline int vsscanf_s(const char *const _Buffer, const char *const _Format, va_list _ArgList)     {
        return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
    }
    extern "C++" {
        template <size_t _Size> inline int vsscanf_s(const char (&_Buffer)[_Size], const char *_Format, va_list _ArgList) throw()     }
    inline int _sscanf_l(const char *const _Buffer, const char *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _sscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int sscanf(const char *const _Buffer, const char *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using sscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _sscanf_s_l(const char *const _Buffer, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int sscanf_s(const char *const _Buffer, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = vsscanf_s(_Buffer, _Format, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snscanf_l(const char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _snscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snscanf(const char *const _Buffer, const size_t _BufferCount, const char *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _snscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()), _Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snscanf_s_l(const char *const _Buffer, const size_t _BufferCount, const char *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _snscanf_s(const char *const _Buffer, const size_t _BufferCount, const char *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Buffer, _BufferCount, _Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    char *tempnam(const char *_Directory, const char *_FilePrefix) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _tempnam. See online help for details."));
    int fcloseall() __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _fcloseall. See online help for details."));
    FILE *fdopen(int _FileHandle, const char *_Format) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _fdopen. See online help for details."));
    int fgetchar() __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _fgetchar. See online help for details."));
    int fileno(FILE *_Stream) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _fileno. See online help for details."));
    int flushall() __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _flushall. See online help for details."));
    int fputchar(int _Ch) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _fputchar. See online help for details."));
    int getw(FILE *_Stream) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _getw. See online help for details."));
    int putw(int _Ch, FILE *_Stream) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _putw. See online help for details."));
    int rmtmp() __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _rmtmp. See online help for details."));
}
;
;
;
;
namespace std {
    enum _Uninitialized {
        _Noinit
    };
    class _Lockit {
    public:
        _Lockit();
        explicit _Lockit(int);
        ~_Lockit() noexcept;
        static void _Lockit_ctor(int);
        static void _Lockit_dtor(int);
    private:
        static void _Lockit_ctor(std::_Lockit *);
        static void _Lockit_ctor(std::_Lockit *, int);
        static void _Lockit_dtor(std::_Lockit *);
    public:
        _Lockit(const std::_Lockit &) = delete
        std::_Lockit &operator=(const std::_Lockit &) = delete
    private:
        int _Locktype;
    };
    class _Init_locks {
    public:
        _Init_locks();
        ~_Init_locks() noexcept;
    private:
        static void _Init_locks_ctor(std::_Init_locks *);
        static void _Init_locks_dtor(std::_Init_locks *);
    };
}
void _Atexit(void (*)() __attribute__((cdecl)));
typedef unsigned long _Uint32t;
namespace std {
    using ::int8_t;
    using ::int16_t;
    using ::int32_t;
    using ::int64_t;
    using ::uint8_t;
    using ::uint16_t;
    using ::uint32_t;
    using ::uint64_t;
    using ::int_least8_t;
    using ::int_least16_t;
    using ::int_least32_t;
    using ::int_least64_t;
    using ::uint_least8_t;
    using ::uint_least16_t;
    using ::uint_least32_t;
    using ::uint_least64_t;
    using ::int_fast8_t;
    using ::int_fast16_t;
    using ::int_fast32_t;
    using ::int_fast64_t;
    using ::uint_fast8_t;
    using ::uint_fast16_t;
    using ::uint_fast32_t;
    using ::uint_fast64_t;
    using ::intmax_t;
    using ::intptr_t;
    using ::uintmax_t;
    using ::uintptr_t;
    namespace tr1 {
        using ::int8_t;
        using ::int16_t;
        using ::int32_t;
        using ::int64_t;
        using ::uint8_t;
        using ::uint16_t;
        using ::uint32_t;
        using ::uint64_t;
        using ::int_least8_t;
        using ::int_least16_t;
        using ::int_least32_t;
        using ::int_least64_t;
        using ::uint_least8_t;
        using ::uint_least16_t;
        using ::uint_least32_t;
        using ::uint_least64_t;
        using ::int_fast8_t;
        using ::int_fast16_t;
        using ::int_fast32_t;
        using ::int_fast64_t;
        using ::uint_fast8_t;
        using ::uint_fast16_t;
        using ::uint_fast32_t;
        using ::uint_fast64_t;
        using ::intmax_t;
        using ::intptr_t;
        using ::uintmax_t;
        using ::uintptr_t;
    }
}
extern "C" {
    void *_calloc_base(size_t _Count, size_t _Size) __declspec(restrict);
    void *calloc(size_t _Count, size_t _Size) __declspec(restrict);
    int _callnewh(size_t _Size);
    void *_expand(void *_Block, size_t _Size);
    void _free_base(void *_Block);
    void free(void *_Block);
    void *_malloc_base(size_t _Size) __declspec(restrict);
    void *malloc(size_t _Size) __declspec(restrict);
    size_t _msize_base(void *_Block);
    size_t _msize(void *_Block);
    void *_realloc_base(void *_Block, size_t _Size) __declspec(restrict);
    void *realloc(void *_Block, size_t _Size) __declspec(restrict);
    void *_recalloc_base(void *_Block, size_t _Count, size_t _Size) __declspec(restrict);
    void *_recalloc(void *_Block, size_t _Count, size_t _Size) __declspec(restrict);
    void _aligned_free(void *_Block);
    void *_aligned_malloc(size_t _Size, size_t _Alignment) __declspec(restrict);
    void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset) __declspec(restrict);
    size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset);
    void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset) __declspec(restrict);
    void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset) __declspec(restrict);
    void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment) __declspec(restrict);
    void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment) __declspec(restrict);
}
extern "C" {
    typedef int (*_CoreCrtSecureSearchSortCompareFunction)(void *, const void *, const void *) __attribute__((cdecl));
    typedef int (*_CoreCrtNonSecureSearchSortCompareFunction)(const void *, const void *) __attribute__((cdecl));
    void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context);
    void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context);
    void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);
    void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);
    void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context);
    void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);
    void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context);
    void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);
    void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _lfind. See online help for details."));
    void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _lsearch. See online help for details."));
}
extern "C" {
    errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix);
    extern "C++" {
        template <size_t _Size> inline errno_t _itow_s(int _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw()     }
    wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _itow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix);
    extern "C++" {
        template <size_t _Size> inline errno_t _ltow_s(long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw()     }
    wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _ltow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix);
    extern "C++" {
        template <size_t _Size> inline errno_t _ultow_s(unsigned long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw()     }
    wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _ultow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    double wcstod(const wchar_t *_String, wchar_t **_EndPtr);
    double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale);
    long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix);
    long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale);
    long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix);
    long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale);
    unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix);
    unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale);
    unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix);
    unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale);
    long double wcstold(const wchar_t *_String, wchar_t **_EndPtr);
    long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale);
    float wcstof(const wchar_t *_String, wchar_t **_EndPtr);
    float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale);
    double _wtof(const wchar_t *_String);
    double _wtof_l(const wchar_t *_String, _locale_t _Locale);
    int _wtoi(const wchar_t *_String);
    int _wtoi_l(const wchar_t *_String, _locale_t _Locale);
    long _wtol(const wchar_t *_String);
    long _wtol_l(const wchar_t *_String, _locale_t _Locale);
    long long _wtoll(const wchar_t *_String);
    long long _wtoll_l(const wchar_t *_String, _locale_t _Locale);
    errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix);
    wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _i64tow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix);
    wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _ui64tow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    long long _wtoi64(const wchar_t *_String);
    long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale);
    long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix);
    long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale);
    unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix);
    unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale);
    wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount);
    errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext);
    extern "C++" {
        template <size_t _Size> inline errno_t _wmakepath_s(wchar_t (&_Buffer)[_Size], const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext) throw()     }
    void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext) __declspec(deprecated("This function or variable may be unsafe. Consider using _wmakepath_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    void _wperror(const wchar_t *_ErrorMessage);
    void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext) __declspec(deprecated("This function or variable may be unsafe. Consider using _wsplitpath_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount);
    extern "C++" {
        template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t _wsplitpath_s(const wchar_t *_Path, wchar_t (&_Drive)[_DriveSize], wchar_t (&_Dir)[_DirSize], wchar_t (&_Name)[_NameSize], wchar_t (&_Ext)[_ExtSize]) throw()     }
    errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName);
    wchar_t *_wgetenv(const wchar_t *_VarName) __declspec(deprecated("This function or variable may be unsafe. Consider using _wdupenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName);
    extern "C++" {
        template <size_t _Size> inline errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t (&_Buffer)[_Size], const wchar_t *_VarName) throw()     }
    int _wputenv(const wchar_t *_EnvString);
    errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value);
    errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount);
    extern "C++" {
        template <size_t _Size> inline errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t (&_ResultPath)[_Size]) throw()     }
    void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath) __declspec(deprecated("This function or variable may be unsafe. Consider using _wsearchenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int _wsystem(const wchar_t *_Command);
}
extern "C" {
}
extern "C" {
    void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes);
    void exit(int _Code);
    void _exit(int _Code);
    void _Exit(int _Code);
    void quick_exit(int _Code);
    void abort();
    unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask);
    typedef int (*_onexit_t)() __attribute__((cdecl));
    int atexit(void (*)() __attribute__((cdecl)));
    _onexit_t _onexit(_onexit_t _Func);
    int at_quick_exit(void (*)() __attribute__((cdecl)));
    typedef void (*_purecall_handler)() __attribute__((cdecl));
    typedef void (*_invalid_parameter_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t) __attribute__((cdecl));
    _purecall_handler _set_purecall_handler(_purecall_handler _Handler);
    _purecall_handler _get_purecall_handler();
    _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler);
    _invalid_parameter_handler _get_invalid_parameter_handler();
    _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler);
    _invalid_parameter_handler _get_thread_local_invalid_parameter_handler();
    int _set_error_mode(int _Mode);
    int *_errno();
    errno_t _set_errno(int _Value);
    errno_t _get_errno(int *_Value);
    unsigned long *__doserrno();
    errno_t _set_doserrno(unsigned long _Value);
    errno_t _get_doserrno(unsigned long *_Value);
    char **__sys_errlist() __declspec(deprecated("This function or variable may be unsafe. Consider using strerror instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int *__sys_nerr() __declspec(deprecated("This function or variable may be unsafe. Consider using strerror instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    void perror(const char *_ErrMsg);
    char **__p__pgmptr() __declspec(deprecated("This function or variable may be unsafe. Consider using _get_pgmptr instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    wchar_t **__p__wpgmptr() __declspec(deprecated("This function or variable may be unsafe. Consider using _get_wpgmptr instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int *__p__fmode() __declspec(deprecated("This function or variable may be unsafe. Consider using _get_fmode instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _get_pgmptr(char **_Value);
    errno_t _get_wpgmptr(wchar_t **_Value);
    errno_t _set_fmode(int _Mode);
    errno_t _get_fmode(int *_PMode);
    typedef struct _div_t {
        int quot;
        int rem;
    } div_t;
    typedef struct _ldiv_t {
        long quot;
        long rem;
    } ldiv_t;
    typedef struct _lldiv_t {
        long long quot;
        long long rem;
    } lldiv_t;
    int abs(int _Number);
    long labs(long _Number);
    long long llabs(long long _Number);
    long long _abs64(long long _Number);
    unsigned short _byteswap_ushort(unsigned short _Number);
    unsigned long _byteswap_ulong(unsigned long _Number);
    unsigned long long _byteswap_uint64(unsigned long long _Number);
    div_t div(int _Numerator, int _Denominator);
    ldiv_t ldiv(long _Numerator, long _Denominator);
    lldiv_t lldiv(long long _Numerator, long long _Denominator);
    unsigned int _rotl(unsigned int _Value, int _Shift) throw();
    unsigned long _lrotl(unsigned long _Value, int _Shift) throw();
    unsigned long long _rotl64(unsigned long long _Value, int _Shift) throw();
    unsigned int _rotr(unsigned int _Value, int _Shift) throw();
    unsigned long _lrotr(unsigned long _Value, int _Shift) throw();
    unsigned long long _rotr64(unsigned long long _Value, int _Shift) throw();
    void srand(unsigned int _Seed);
    int rand();
    extern "C++" {
        inline long abs(const long _X) throw()         {
            return labs(_X);
        }
        inline long long abs(const long long _X) throw()         {
            return llabs(_X);
        }
        inline ldiv_t div(const long _A1, const long _A2) throw()         {
            return ldiv(_A1, _A2);
        }
        inline lldiv_t div(const long long _A1, const long long _A2) throw()         {
            return lldiv(_A1, _A2);
        }
    }
    typedef struct {
        unsigned char ld[10];
    } _LDOUBLE;
    typedef struct {
        double x;
    } _CRT_DOUBLE;
    typedef struct {
        float f;
    } _CRT_FLOAT;
    typedef struct {
        long double x;
    } _LONGDOUBLE;
    typedef struct {
        unsigned char ld12[12];
    } _LDBL12;
    double atof(const char *_String);
    int atoi(const char *_String);
    long atol(const char *_String);
    long long atoll(const char *_String);
    long long _atoi64(const char *_String);
    double _atof_l(const char *_String, _locale_t _Locale);
    int _atoi_l(const char *_String, _locale_t _Locale);
    long _atol_l(const char *_String, _locale_t _Locale);
    long long _atoll_l(const char *_String, _locale_t _Locale);
    long long _atoi64_l(const char *_String, _locale_t _Locale);
    int _atoflt(_CRT_FLOAT *_Result, const char *_String);
    int _atodbl(_CRT_DOUBLE *_Result, char *_String);
    int _atoldbl(_LDOUBLE *_Result, char *_String);
    int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale);
    int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale);
    int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale);
    float strtof(const char *_String, char **_EndPtr);
    float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale);
    double strtod(const char *_String, char **_EndPtr);
    double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale);
    long double strtold(const char *_String, char **_EndPtr);
    long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale);
    long strtol(const char *_String, char **_EndPtr, int _Radix);
    long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale);
    long long strtoll(const char *_String, char **_EndPtr, int _Radix);
    long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale);
    unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix);
    unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale);
    unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix);
    unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale);
    long long _strtoi64(const char *_String, char **_EndPtr, int _Radix);
    long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale);
    unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix);
    unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale);
    errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix);
    extern "C++" {
        template <size_t _Size> inline errno_t _itoa_s(int _Value, char (&_Buffer)[_Size], int _Radix) throw()     }
    char *_itoa(int _Value, char *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _itoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix);
    extern "C++" {
        template <size_t _Size> inline errno_t _ltoa_s(long _Value, char (&_Buffer)[_Size], int _Radix) throw()     }
    char *_ltoa(long _Value, char *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _ltoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix);
    extern "C++" {
        template <size_t _Size> inline errno_t _ultoa_s(unsigned long _Value, char (&_Buffer)[_Size], int _Radix) throw()     }
    char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _ultoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix);
    char *_i64toa(long long _Value, char *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _i64toa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix);
    char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _ui64toa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign);
    extern "C++" {
        template <size_t _Size> inline errno_t _ecvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount, int *_PtDec, int *_PtSign) throw()     }
    char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign) __declspec(deprecated("This function or variable may be unsafe. Consider using _ecvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign);
    extern "C++" {
        template <size_t _Size> inline errno_t _fcvt_s(char (&_Buffer)[_Size], double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign) throw()     }
    char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign) __declspec(deprecated("This function or variable may be unsafe. Consider using _fcvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount);
    extern "C++" {
        template <size_t _Size> inline errno_t _gcvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount) throw()     }
    char *_gcvt(double _Value, int _DigitCount, char *_Buffer) __declspec(deprecated("This function or variable may be unsafe. Consider using _gcvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int ___mb_cur_max_func();
    int ___mb_cur_max_l_func(_locale_t _Locale);
    int mblen(const char *_Ch, size_t _MaxCount);
    int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale);
    size_t _mbstrlen(const char *_String);
    size_t _mbstrlen_l(const char *_String, _locale_t _Locale);
    size_t _mbstrnlen(const char *_String, size_t _MaxCount);
    size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale);
    int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes);
    int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale);
    errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount);
    extern "C++" {
        template <size_t _Size> inline errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t (&_Dest)[_Size], const char *_Source, size_t _MaxCount) throw()     }
    size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount) __declspec(deprecated("This function or variable may be unsafe. Consider using mbstowcs_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale);
    extern "C++" {
        template <size_t _Size> inline errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t (&_Dest)[_Size], const char *_Source, size_t _MaxCount, _locale_t _Locale) throw()     }
    size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale) __declspec(deprecated("This function or variable may be unsafe. Consider using _mbstowcs_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int wctomb(char *_MbCh, wchar_t _WCh) __declspec(deprecated("This function or variable may be unsafe. Consider using wctomb_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale) __declspec(deprecated("This function or variable may be unsafe. Consider using _wctomb_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh);
    errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale);
    errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes);
    extern "C++" {
        template <size_t _Size> inline errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char (&_Dest)[_Size], const wchar_t *_Source, size_t _MaxCount) throw()     }
    size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount) __declspec(deprecated("This function or variable may be unsafe. Consider using wcstombs_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale);
    extern "C++" {
        template <size_t _Size> inline errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char (&_Dest)[_Size], const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale) throw()     }
    size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcstombs_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount);
    errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext);
    extern "C++" {
        template <size_t _Size> inline errno_t _makepath_s(char (&_Buffer)[_Size], const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext) throw()     }
    void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext) __declspec(deprecated("This function or variable may be unsafe. Consider using _makepath_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext) __declspec(deprecated("This function or variable may be unsafe. Consider using _splitpath_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount);
    extern "C++" {
        template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t _splitpath_s(const char *_Dest, char (&_Drive)[_DriveSize], char (&_Dir)[_DirSize], char (&_Name)[_NameSize], char (&_Ext)[_ExtSize]) throw()     }
    errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName);
    int *__p___argc();
    char ***__p___argv();
    wchar_t ***__p___wargv();
    char ***__p__environ();
    wchar_t ***__p__wenviron();
    char *getenv(const char *_VarName) __declspec(deprecated("This function or variable may be unsafe. Consider using _dupenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    extern "C++" {
        template <size_t _Size> inline errno_t getenv_s(size_t *_RequiredCount, char (&_Buffer)[_Size], const char *_VarName) throw()     }
    errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName);
    int system(const char *_Command);
    int _putenv(const char *_EnvString);
    errno_t _putenv_s(const char *_Name, const char *_Value);
    errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount);
    extern "C++" {
        template <size_t _Size> inline errno_t _searchenv_s(const char *_Filename, const char *_VarName, char (&_Buffer)[_Size]) throw()     }
    void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer) __declspec(deprecated("This function or variable may be unsafe. Consider using _searchenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    void _seterrormode(int _Mode) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetErrorMode instead. See online help for details."));
    void _beep(unsigned int _Frequency, unsigned int _Duration) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Beep instead. See online help for details."));
    void _sleep(unsigned long _Duration) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Sleep instead. See online help for details."));
    char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign) __declspec(deprecated("This function or variable may be unsafe. Consider using _ecvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _ecvt. See online help for details."));
    char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign) __declspec(deprecated("This function or variable may be unsafe. Consider using _fcvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _fcvt. See online help for details."));
    char *gcvt(double _Value, int _DigitCount, char *_DstBuf) __declspec(deprecated("This function or variable may be unsafe. Consider using _fcvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _gcvt. See online help for details."));
    char *itoa(int _Value, char *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _itoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _itoa. See online help for details."));
    char *ltoa(long _Value, char *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _ltoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _ltoa. See online help for details."));
    void swab(char *_Buf1, char *_Buf2, int _SizeInBytes) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _swab. See online help for details."));
    char *ultoa(unsigned long _Value, char *_Buffer, int _Radix) __declspec(deprecated("This function or variable may be unsafe. Consider using _ultoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _ultoa. See online help for details."));
    int putenv(const char *_EnvString) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _putenv. See online help for details."));
    _onexit_t onexit(_onexit_t _Func);
}
extern "C" {
    struct _exception {
        int type;
        char *name;
        double arg1;
        double arg2;
        double retval;
    };
    struct _complex {
        double x;
        double y;
    };
    typedef float float_t;
    typedef double double_t;
    extern const double _HUGE;
    void _fperrraise(int _Except);
    short _dclass(double _X);
    short _ldclass(long double _X);
    short _fdclass(float _X);
    int _dsign(double _X);
    int _ldsign(long double _X);
    int _fdsign(float _X);
    int _dpcomp(double _X, double _Y);
    int _ldpcomp(long double _X, long double _Y);
    int _fdpcomp(float _X, float _Y);
    short _dtest(double *_Px);
    short _ldtest(long double *_Px);
    short _fdtest(float *_Px);
    short _d_int(double *_Px, short _Xexp);
    short _ld_int(long double *_Px, short _Xexp);
    short _fd_int(float *_Px, short _Xexp);
    short _dscale(double *_Px, long _Lexp);
    short _ldscale(long double *_Px, long _Lexp);
    short _fdscale(float *_Px, long _Lexp);
    short _dunscale(short *_Pex, double *_Px);
    short _ldunscale(short *_Pex, long double *_Px);
    short _fdunscale(short *_Pex, float *_Px);
    short _dexp(double *_Px, double _Y, long _Eoff);
    short _ldexp(long double *_Px, long double _Y, long _Eoff);
    short _fdexp(float *_Px, float _Y, long _Eoff);
    short _dnorm(unsigned short *_Ps);
    short _fdnorm(unsigned short *_Ps);
    double _dpoly(double _X, const double *_Tab, int _N);
    long double _ldpoly(long double _X, const long double *_Tab, int _N);
    float _fdpoly(float _X, const float *_Tab, int _N);
    double _dlog(double _X, int _Baseflag);
    long double _ldlog(long double _X, int _Baseflag);
    float _fdlog(float _X, int _Baseflag);
    double _dsin(double _X, unsigned int _Qoff);
    long double _ldsin(long double _X, unsigned int _Qoff);
    float _fdsin(float _X, unsigned int _Qoff);
    typedef union {
        unsigned short _Sh[4];
        double _Val;
    } _double_val;
    typedef union {
        unsigned short _Sh[2];
        float _Val;
    } _float_val;
    typedef union {
        unsigned short _Sh[4];
        long double _Val;
    } _ldouble_val;
    typedef union {
        unsigned short _Word[4];
        float _Float;
        double _Double;
        long double _Long_double;
    } _float_const;
    extern const _float_const _Denorm_C;
    extern const _float_const _Inf_C;
    extern const _float_const _Nan_C;
    extern const _float_const _Snan_C;
    extern const _float_const _Hugeval_C;
    extern const _float_const _FDenorm_C;
    extern const _float_const _FInf_C;
    extern const _float_const _FNan_C;
    extern const _float_const _FSnan_C;
    extern const _float_const _LDenorm_C;
    extern const _float_const _LInf_C;
    extern const _float_const _LNan_C;
    extern const _float_const _LSnan_C;
    extern const _float_const _Eps_C;
    extern const _float_const _Rteps_C;
    extern const _float_const _FEps_C;
    extern const _float_const _FRteps_C;
    extern const _float_const _LEps_C;
    extern const _float_const _LRteps_C;
    extern const double _Zero_C;
    extern const double _Xbig_C;
    extern const float _FZero_C;
    extern const float _FXbig_C;
    extern const long double _LZero_C;
    extern const long double _LXbig_C;
    extern "C++" {
        inline int fpclassify(float _X) throw()         {
            return _fdtest(&_X);
        }
        inline int fpclassify(double _X) throw()         {
            return _dtest(&_X);
        }
        inline int fpclassify(long double _X) throw()         {
            return _ldtest(&_X);
        }
        inline bool signbit(float _X) throw()         {
            return _fdsign(_X) != 0;
        }
        inline bool signbit(double _X) throw()         {
            return _dsign(_X) != 0;
        }
        inline bool signbit(long double _X) throw()         {
            return _ldsign(_X) != 0;
        }
        inline int _fpcomp(float _X, float _Y) throw()         {
            return _fdpcomp(_X, _Y);
        }
        inline int _fpcomp(double _X, double _Y) throw()         {
            return _dpcomp(_X, _Y);
        }
        inline int _fpcomp(long double _X, long double _Y) throw()         {
            return _ldpcomp(_X, _Y);
        }
        template <class _Trc, class _Tre> struct _Combined_type {
            typedef float _Type;
        };
        template<> struct _Combined_type<float, double> {
            typedef double _Type;
        };
        template<> struct _Combined_type<float, long double> {
            typedef long double _Type;
        };
        template <class _Ty, class _T2> struct _Real_widened {
            typedef long double _Type;
        };
        template<> struct _Real_widened<float, float> {
            typedef float _Type;
        };
        template<> struct _Real_widened<float, double> {
            typedef double _Type;
        };
        template<> struct _Real_widened<double, float> {
            typedef double _Type;
        };
        template<> struct _Real_widened<double, double> {
            typedef double _Type;
        };
        template <class _Ty> struct _Real_type {
            typedef double _Type;
        };
        template<> struct _Real_type<float> {
            typedef float _Type;
        };
        template<> struct _Real_type<long double> {
            typedef long double _Type;
        };
        template <class _T1, class _T2> inline int _fpcomp(_T1 _X, _T2 _Y) throw()         template <class _Ty> inline bool isfinite(_Ty _X) throw()         template <class _Ty> inline bool isinf(_Ty _X) throw()         template <class _Ty> inline bool isnan(_Ty _X) throw()         template <class _Ty> inline bool isnormal(_Ty _X) throw()         template <class _Ty1, class _Ty2> inline bool isgreater(_Ty1 _X, _Ty2 _Y) throw()         template <class _Ty1, class _Ty2> inline bool isgreaterequal(_Ty1 _X, _Ty2 _Y) throw()         template <class _Ty1, class _Ty2> inline bool isless(_Ty1 _X, _Ty2 _Y) throw()         template <class _Ty1, class _Ty2> inline bool islessequal(_Ty1 _X, _Ty2 _Y) throw()         template <class _Ty1, class _Ty2> inline bool islessgreater(_Ty1 _X, _Ty2 _Y) throw()         template <class _Ty1, class _Ty2> inline bool isunordered(_Ty1 _X, _Ty2 _Y) throw()     }
    int abs(int _X);
    long labs(long _X);
    long long llabs(long long _X);
    double acos(double _X);
    double asin(double _X);
    double atan(double _X);
    double atan2(double _Y, double _X);
    double cos(double _X);
    double cosh(double _X);
    double exp(double _X);
    double fabs(double _X);
    double fmod(double _X, double _Y);
    double log(double _X);
    double log10(double _X);
    double pow(double _X, double _Y);
    double sin(double _X);
    double sinh(double _X);
    double sqrt(double _X);
    double tan(double _X);
    double tanh(double _X);
    double acosh(double _X);
    double asinh(double _X);
    double atanh(double _X);
    double atof(const char *_String);
    double _atof_l(const char *_String, _locale_t _Locale);
    double _cabs(struct _complex _Complex_value);
    double cbrt(double _X);
    double ceil(double _X);
    double _chgsign(double _X);
    double copysign(double _Number, double _Sign);
    double _copysign(double _Number, double _Sign);
    double erf(double _X);
    double erfc(double _X);
    double exp2(double _X);
    double expm1(double _X);
    double fdim(double _X, double _Y);
    double floor(double _X);
    double fma(double _X, double _Y, double _Z);
    double fmax(double _X, double _Y);
    double fmin(double _X, double _Y);
    double frexp(double _X, int *_Y);
    double hypot(double _X, double _Y);
    double _hypot(double _X, double _Y);
    int ilogb(double _X);
    double ldexp(double _X, int _Y);
    double lgamma(double _X);
    long long llrint(double _X);
    long long llround(double _X);
    double log1p(double _X);
    double log2(double _X);
    double logb(double _X);
    long lrint(double _X);
    long lround(double _X);
    int _matherr(struct _exception *_Except);
    double modf(double _X, double *_Y);
    double nan(const char *_X);
    double nearbyint(double _X);
    double nextafter(double _X, double _Y);
    double nexttoward(double _X, long double _Y);
    double remainder(double _X, double _Y);
    double remquo(double _X, double _Y, int *_Z);
    double rint(double _X);
    double round(double _X);
    double scalbln(double _X, long _Y);
    double scalbn(double _X, int _Y);
    double tgamma(double _X);
    double trunc(double _X);
    double _j0(double _X);
    double _j1(double _X);
    double _jn(int _X, double _Y);
    double _y0(double _X);
    double _y1(double _X);
    double _yn(int _X, double _Y);
    float acoshf(float _X);
    float asinhf(float _X);
    float atanhf(float _X);
    float cbrtf(float _X);
    float _chgsignf(float _X);
    float copysignf(float _Number, float _Sign);
    float _copysignf(float _Number, float _Sign);
    float erff(float _X);
    float erfcf(float _X);
    float expm1f(float _X);
    float exp2f(float _X);
    float fdimf(float _X, float _Y);
    float fmaf(float _X, float _Y, float _Z);
    float fmaxf(float _X, float _Y);
    float fminf(float _X, float _Y);
    float _hypotf(float _X, float _Y);
    int ilogbf(float _X);
    float lgammaf(float _X);
    long long llrintf(float _X);
    long long llroundf(float _X);
    float log1pf(float _X);
    float log2f(float _X);
    float logbf(float _X);
    long lrintf(float _X);
    long lroundf(float _X);
    float nanf(const char *_X);
    float nearbyintf(float _X);
    float nextafterf(float _X, float _Y);
    float nexttowardf(float _X, long double _Y);
    float remainderf(float _X, float _Y);
    float remquof(float _X, float _Y, int *_Z);
    float rintf(float _X);
    float roundf(float _X);
    float scalblnf(float _X, long _Y);
    float scalbnf(float _X, int _Y);
    float tgammaf(float _X);
    float truncf(float _X);
    float _logbf(float _X);
    float _nextafterf(float _X, float _Y);
    int _finitef(float _X);
    int _isnanf(float _X);
    int _fpclassf(float _X);
    int _set_FMA3_enable(int _Flag);
    int _get_FMA3_enable();
    float acosf(float _X);
    float asinf(float _X);
    float atan2f(float _Y, float _X);
    float atanf(float _X);
    float ceilf(float _X);
    float cosf(float _X);
    float coshf(float _X);
    float expf(float _X);
    inline float fabsf(float _X)     {
        return (float)fabs(_X);
    }
    float floorf(float _X);
    float fmodf(float _X, float _Y);
    inline float frexpf(float _X, int *_Y)     {
        return (float)frexp(_X, _Y);
    }
    inline float hypotf(float _X, float _Y)     {
        return _hypotf(_X, _Y);
    }
    inline float ldexpf(float _X, int _Y)     {
        return (float)ldexp(_X, _Y);
    }
    float log10f(float _X);
    float logf(float _X);
    float modff(float _X, float *_Y);
    float powf(float _X, float _Y);
    float sinf(float _X);
    float sinhf(float _X);
    float sqrtf(float _X);
    float tanf(float _X);
    float tanhf(float _X);
    long double acoshl(long double _X);
    inline long double acosl(long double _X)     {
        return acos((double)_X);
    }
    long double asinhl(long double _X);
    inline long double asinl(long double _X)     {
        return asin((double)_X);
    }
    inline long double atan2l(long double _Y, long double _X)     {
        return atan2((double)_Y, (double)_X);
    }
    long double atanhl(long double _X);
    inline long double atanl(long double _X)     {
        return atan((double)_X);
    }
    long double cbrtl(long double _X);
    inline long double ceill(long double _X)     {
        return ceil((double)_X);
    }
    inline long double _chgsignl(long double _X)     {
        return _chgsign((double)_X);
    }
    long double copysignl(long double _Number, long double _Sign);
    inline long double _copysignl(long double _Number, long double _Sign)     {
        return _copysign((double)_Number, (double)_Sign);
    }
    inline long double coshl(long double _X)     {
        return cosh((double)_X);
    }
    inline long double cosl(long double _X)     {
        return cos((double)_X);
    }
    long double erfl(long double _X);
    long double erfcl(long double _X);
    inline long double expl(long double _X)     {
        return exp((double)_X);
    }
    long double exp2l(long double _X);
    long double expm1l(long double _X);
    inline long double fabsl(long double _X)     {
        return fabs((double)_X);
    }
    long double fdiml(long double _X, long double _Y);
    inline long double floorl(long double _X)     {
        return floor((double)_X);
    }
    long double fmal(long double _X, long double _Y, long double _Z);
    long double fmaxl(long double _X, long double _Y);
    long double fminl(long double _X, long double _Y);
    inline long double fmodl(long double _X, long double _Y)     {
        return fmod((double)_X, (double)_Y);
    }
    inline long double frexpl(long double _X, int *_Y)     {
        return frexp((double)_X, _Y);
    }
    int ilogbl(long double _X);
    inline long double _hypotl(long double _X, long double _Y)     {
        return _hypot((double)_X, (double)_Y);
    }
    inline long double hypotl(long double _X, long double _Y)     {
        return _hypot((double)_X, (double)_Y);
    }
    inline long double ldexpl(long double _X, int _Y)     {
        return ldexp((double)_X, _Y);
    }
    long double lgammal(long double _X);
    long long llrintl(long double _X);
    long long llroundl(long double _X);
    inline long double logl(long double _X)     {
        return log((double)_X);
    }
    inline long double log10l(long double _X)     {
        return log10((double)_X);
    }
    long double log1pl(long double _X);
    long double log2l(long double _X);
    long double logbl(long double _X);
    long lrintl(long double _X);
    long lroundl(long double _X);
    inline long double modfl(long double _X, long double *_Y)     {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }
    long double nanl(const char *_X);
    long double nearbyintl(long double _X);
    long double nextafterl(long double _X, long double _Y);
    long double nexttowardl(long double _X, long double _Y);
    inline long double powl(long double _X, long double _Y)     {
        return pow((double)_X, (double)_Y);
    }
    long double remainderl(long double _X, long double _Y);
    long double remquol(long double _X, long double _Y, int *_Z);
    long double rintl(long double _X);
    long double roundl(long double _X);
    long double scalblnl(long double _X, long _Y);
    long double scalbnl(long double _X, int _Y);
    inline long double sinhl(long double _X)     {
        return sinh((double)_X);
    }
    inline long double sinl(long double _X)     {
        return sin((double)_X);
    }
    inline long double sqrtl(long double _X)     {
        return sqrt((double)_X);
    }
    inline long double tanhl(long double _X)     {
        return tanh((double)_X);
    }
    inline long double tanl(long double _X)     {
        return tan((double)_X);
    }
    long double tgammal(long double _X);
    long double truncl(long double _X);
    extern double HUGE;
    double j0(double _X) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _j0. See online help for details."));
    double j1(double _X) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _j1. See online help for details."));
    double jn(int _X, double _Y) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _jn. See online help for details."));
    double y0(double _X) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _y0. See online help for details."));
    double y1(double _X) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _y1. See online help for details."));
    double yn(int _X, double _Y) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _yn. See online help for details."));
}
inline double abs(double _Xx) noexcept {
    return (::fabs(_Xx));
}
inline float abs(float _Xx) noexcept {
    return (::fabsf(_Xx));
}
inline long double abs(long double _Xx) noexcept {
    return (::fabsl(_Xx));
}
namespace std {
    using ::size_t;
    using ::div_t;
    using ::ldiv_t;
    using ::abort;
    using ::abs;
    using ::atexit;
    using ::atof;
    using ::atoi;
    using ::atol;
    using ::bsearch;
    using ::calloc;
    using ::div;
    using ::exit;
    using ::free;
    using ::labs;
    using ::ldiv;
    using ::malloc;
    using ::mblen;
    using ::mbstowcs;
    using ::mbtowc;
    using ::qsort;
    using ::rand;
    using ::realloc;
    using ::srand;
    using ::strtod;
    using ::strtol;
    using ::strtoul;
    using ::wcstombs;
    using ::wctomb;
    using ::lldiv_t;
    using ::getenv;
    using ::system;
    using ::atoll;
    using ::llabs;
    using ::lldiv;
    using ::strtof;
    using ::strtold;
    using ::strtoll;
    using ::strtoull;
    using ::_Exit;
    using ::at_quick_exit;
    using ::quick_exit;
}
extern "C" {
    void _Feraise(int);
    typedef union {
        unsigned short _Word[8];
        float _Float;
        double _Double;
        long double _Long_double;
    } _Dconst;
    double _Cosh(double, double);
    short _Dtest(double *);
    double _Sinh(double, double);
    short _Exp(double *, double, short);
    extern _Dconst _Denorm;
    extern _Dconst _Hugeval;
    extern _Dconst _Inf;
    extern _Dconst _Nan;
    extern _Dconst _Snan;
    float _FCosh(float, float);
    short _FDtest(float *);
    float _FSinh(float, float);
    short _FExp(float *, float, short);
    extern _Dconst _FDenorm;
    extern _Dconst _FInf;
    extern _Dconst _FNan;
    extern _Dconst _FSnan;
    long double _LCosh(long double, long double);
    short _LDtest(long double *);
    long double _LSinh(long double, long double);
    short _LExp(long double *, long double, short);
    extern _Dconst _LDenorm;
    extern _Dconst _LInf;
    extern _Dconst _LNan;
    extern _Dconst _LSnan;
}
extern "C" {
    unsigned int _clearfp();
    unsigned int _controlfp(unsigned int _NewValue, unsigned int _Mask) __declspec(deprecated("This function or variable may be unsafe. Consider using _controlfp_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    void _set_controlfp(unsigned int _NewValue, unsigned int _Mask);
    errno_t _controlfp_s(unsigned int *_CurrentState, unsigned int _NewValue, unsigned int _Mask);
    unsigned int _statusfp();
    void _fpreset();
    unsigned int _control87(unsigned int _NewValue, unsigned int _Mask);
    int *__fpecode();
    int __fpe_flt_rounds();
    double _copysign(double _Number, double _Sign);
    double _chgsign(double _X);
    double _scalb(double _X, long _Y);
    double _logb(double _X);
    double _nextafter(double _X, double _Y);
    int _finite(double _X);
    int _isnan(double _X);
    int _fpclass(double _X);
    float _scalbf(float _X, long _Y);
    void fpreset();
}
inline double pow(double _Xx, int _Yx) noexcept {
    if (_Yx == 2)
        return (_Xx * _Xx);
    return (::pow(_Xx, static_cast<double>(_Yx)));
}
inline float acos(float _Xx) noexcept {
    return (::acosf(_Xx));
}
inline float acosh(float _Xx) noexcept {
    return (::acoshf(_Xx));
}
inline float asin(float _Xx) noexcept {
    return (::asinf(_Xx));
}
inline float asinh(float _Xx) noexcept {
    return (::asinhf(_Xx));
}
inline float atan(float _Xx) noexcept {
    return (::atanf(_Xx));
}
inline float atanh(float _Xx) noexcept {
    return (::atanhf(_Xx));
}
inline float atan2(float _Yx, float _Xx) noexcept {
    return (::atan2f(_Yx, _Xx));
}
inline float cbrt(float _Xx) noexcept {
    return (::cbrtf(_Xx));
}
inline float ceil(float _Xx) noexcept {
    return (::ceilf(_Xx));
}
inline float copysign(float _Number, float _Sign) noexcept {
    return (::copysignf(_Number, _Sign));
}
inline float cos(float _Xx) noexcept {
    return (::cosf(_Xx));
}
inline float cosh(float _Xx) noexcept {
    return (::coshf(_Xx));
}
inline float erf(float _Xx) noexcept {
    return (::erff(_Xx));
}
inline float erfc(float _Xx) noexcept {
    return (::erfcf(_Xx));
}
inline float exp(float _Xx) noexcept {
    return (::expf(_Xx));
}
inline float exp2(float _Xx) noexcept {
    return (::exp2f(_Xx));
}
inline float expm1(float _Xx) noexcept {
    return (::expm1f(_Xx));
}
inline float fabs(float _Xx) noexcept {
    return (::fabsf(_Xx));
}
inline float fdim(float _Xx, float _Yx) noexcept {
    return (::fdimf(_Xx, _Yx));
}
inline float floor(float _Xx) noexcept {
    return (::floorf(_Xx));
}
inline float fma(float _Xx, float _Yx, float _Zx) noexcept {
    return (::fmaf(_Xx, _Yx, _Zx));
}
inline float fmax(float _Xx, float _Yx) noexcept {
    return (::fmaxf(_Xx, _Yx));
}
inline float fmin(float _Xx, float _Yx) noexcept {
    return (::fminf(_Xx, _Yx));
}
inline float fmod(float _Xx, float _Yx) noexcept {
    return (::fmodf(_Xx, _Yx));
}
inline float frexp(float _Xx, int *_Yx) noexcept {
    return (::frexpf(_Xx, _Yx));
}
inline float hypot(float _Xx, float _Yx) noexcept {
    return (::hypotf(_Xx, _Yx));
}
inline int ilogb(float _Xx) noexcept {
    return (::ilogbf(_Xx));
}
inline float ldexp(float _Xx, int _Yx) noexcept {
    return (::ldexpf(_Xx, _Yx));
}
inline float lgamma(float _Xx) noexcept {
    return (::lgammaf(_Xx));
}
inline long long llrint(float _Xx) noexcept {
    return (::llrintf(_Xx));
}
inline long long llround(float _Xx) noexcept {
    return (::llroundf(_Xx));
}
inline float log(float _Xx) noexcept {
    return (::logf(_Xx));
}
inline float log10(float _Xx) noexcept {
    return (::log10f(_Xx));
}
inline float log1p(float _Xx) noexcept {
    return (::log1pf(_Xx));
}
inline float log2(float _Xx) noexcept {
    return (::log2f(_Xx));
}
inline float logb(float _Xx) noexcept {
    return (::logbf(_Xx));
}
inline long lrint(float _Xx) noexcept {
    return (::lrintf(_Xx));
}
inline long lround(float _Xx) noexcept {
    return (::lroundf(_Xx));
}
inline float modf(float _Xx, float *_Yx) noexcept {
    return (::modff(_Xx, _Yx));
}
inline float nearbyint(float _Xx) noexcept {
    return (::nearbyintf(_Xx));
}
inline float nextafter(float _Xx, float _Yx) noexcept {
    return (::nextafterf(_Xx, _Yx));
}
inline float nexttoward(float _Xx, long double _Yx) noexcept {
    return (::nexttowardf(_Xx, _Yx));
}
inline float pow(float _Xx, float _Yx) noexcept {
    return (::powf(_Xx, _Yx));
}
inline float pow(float _Xx, int _Yx) noexcept {
    if (_Yx == 2)
        return (_Xx * _Xx);
    return (::powf(_Xx, static_cast<float>(_Yx)));
}
inline float remainder(float _Xx, float _Yx) noexcept {
    return (::remainderf(_Xx, _Yx));
}
inline float remquo(float _Xx, float _Yx, int *_Zx) noexcept {
    return (::remquof(_Xx, _Yx, _Zx));
}
inline float rint(float _Xx) noexcept {
    return (::rintf(_Xx));
}
inline float round(float _Xx) noexcept {
    return (::roundf(_Xx));
}
inline float scalbln(float _Xx, long _Yx) noexcept {
    return (::scalblnf(_Xx, _Yx));
}
inline float scalbn(float _Xx, int _Yx) noexcept {
    return (::scalbnf(_Xx, _Yx));
}
inline float sin(float _Xx) noexcept {
    return (::sinf(_Xx));
}
inline float sinh(float _Xx) noexcept {
    return (::sinhf(_Xx));
}
inline float sqrt(float _Xx) noexcept {
    return (::sqrtf(_Xx));
}
inline float tan(float _Xx) noexcept {
    return (::tanf(_Xx));
}
inline float tanh(float _Xx) noexcept {
    return (::tanhf(_Xx));
}
inline float tgamma(float _Xx) noexcept {
    return (::tgammaf(_Xx));
}
inline float trunc(float _Xx) noexcept {
    return (::truncf(_Xx));
}
inline long double acos(long double _Xx) noexcept {
    return (::acosl(_Xx));
}
inline long double acosh(long double _Xx) noexcept {
    return (::acoshl(_Xx));
}
inline long double asin(long double _Xx) noexcept {
    return (::asinl(_Xx));
}
inline long double asinh(long double _Xx) noexcept {
    return (::asinhl(_Xx));
}
inline long double atan(long double _Xx) noexcept {
    return (::atanl(_Xx));
}
inline long double atanh(long double _Xx) noexcept {
    return (::atanhl(_Xx));
}
inline long double atan2(long double _Yx, long double _Xx) noexcept {
    return (::atan2l(_Yx, _Xx));
}
inline long double cbrt(long double _Xx) noexcept {
    return (::cbrtl(_Xx));
}
inline long double ceil(long double _Xx) noexcept {
    return (::ceill(_Xx));
}
inline long double copysign(long double _Number, long double _Sign) noexcept {
    return (::copysignl(_Number, _Sign));
}
inline long double cos(long double _Xx) noexcept {
    return (::cosl(_Xx));
}
inline long double cosh(long double _Xx) noexcept {
    return (::coshl(_Xx));
}
inline long double erf(long double _Xx) noexcept {
    return (::erfl(_Xx));
}
inline long double erfc(long double _Xx) noexcept {
    return (::erfcl(_Xx));
}
inline long double exp(long double _Xx) noexcept {
    return (::expl(_Xx));
}
inline long double exp2(long double _Xx) noexcept {
    return (::exp2l(_Xx));
}
inline long double expm1(long double _Xx) noexcept {
    return (::expm1l(_Xx));
}
inline long double fabs(long double _Xx) noexcept {
    return (::fabsl(_Xx));
}
inline long double fdim(long double _Xx, long double _Yx) noexcept {
    return (::fdiml(_Xx, _Yx));
}
inline long double floor(long double _Xx) noexcept {
    return (::floorl(_Xx));
}
inline long double fma(long double _Xx, long double _Yx, long double _Zx) noexcept {
    return (::fmal(_Xx, _Yx, _Zx));
}
inline long double fmax(long double _Xx, long double _Yx) noexcept {
    return (::fmaxl(_Xx, _Yx));
}
inline long double fmin(long double _Xx, long double _Yx) noexcept {
    return (::fminl(_Xx, _Yx));
}
inline long double fmod(long double _Xx, long double _Yx) noexcept {
    return (::fmodl(_Xx, _Yx));
}
inline long double frexp(long double _Xx, int *_Yx) noexcept {
    return (::frexpl(_Xx, _Yx));
}
inline long double hypot(long double _Xx, long double _Yx) noexcept {
    return (::hypotl(_Xx, _Yx));
}
inline int ilogb(long double _Xx) noexcept {
    return (::ilogbl(_Xx));
}
inline long double ldexp(long double _Xx, int _Yx) noexcept {
    return (::ldexpl(_Xx, _Yx));
}
inline long double lgamma(long double _Xx) noexcept {
    return (::lgammal(_Xx));
}
inline long long llrint(long double _Xx) noexcept {
    return (::llrintl(_Xx));
}
inline long long llround(long double _Xx) noexcept {
    return (::llroundl(_Xx));
}
inline long double log(long double _Xx) noexcept {
    return (::logl(_Xx));
}
inline long double log10(long double _Xx) noexcept {
    return (::log10l(_Xx));
}
inline long double log1p(long double _Xx) noexcept {
    return (::log1pl(_Xx));
}
inline long double log2(long double _Xx) noexcept {
    return (::log2l(_Xx));
}
inline long double logb(long double _Xx) noexcept {
    return (::logbl(_Xx));
}
inline long lrint(long double _Xx) noexcept {
    return (::lrintl(_Xx));
}
inline long lround(long double _Xx) noexcept {
    return (::lroundl(_Xx));
}
inline long double modf(long double _Xx, long double *_Yx) noexcept {
    return (::modfl(_Xx, _Yx));
}
inline long double nearbyint(long double _Xx) noexcept {
    return (::nearbyintl(_Xx));
}
inline long double nextafter(long double _Xx, long double _Yx) noexcept {
    return (::nextafterl(_Xx, _Yx));
}
inline long double nexttoward(long double _Xx, long double _Yx) noexcept {
    return (::nexttowardl(_Xx, _Yx));
}
inline long double pow(long double _Xx, long double _Yx) noexcept {
    return (::powl(_Xx, _Yx));
}
inline long double pow(long double _Xx, int _Yx) noexcept {
    if (_Yx == 2)
        return (_Xx * _Xx);
    return (::powl(_Xx, static_cast<long double>(_Yx)));
}
inline long double remainder(long double _Xx, long double _Yx) noexcept {
    return (::remainderl(_Xx, _Yx));
}
inline long double remquo(long double _Xx, long double _Yx, int *_Zx) noexcept {
    return (::remquol(_Xx, _Yx, _Zx));
}
inline long double rint(long double _Xx) noexcept {
    return (::rintl(_Xx));
}
inline long double round(long double _Xx) noexcept {
    return (::roundl(_Xx));
}
inline long double scalbln(long double _Xx, long _Yx) noexcept {
    return (::scalblnl(_Xx, _Yx));
}
inline long double scalbn(long double _Xx, int _Yx) noexcept {
    return (::scalbnl(_Xx, _Yx));
}
inline long double sin(long double _Xx) noexcept {
    return (::sinl(_Xx));
}
inline long double sinh(long double _Xx) noexcept {
    return (::sinhl(_Xx));
}
inline long double sqrt(long double _Xx) noexcept {
    return (::sqrtl(_Xx));
}
inline long double tan(long double _Xx) noexcept {
    return (::tanl(_Xx));
}
inline long double tanh(long double _Xx) noexcept {
    return (::tanhl(_Xx));
}
inline long double tgamma(long double _Xx) noexcept {
    return (::tgammal(_Xx));
}
inline long double trunc(long double _Xx) noexcept {
    return (::truncl(_Xx));
}
namespace std {
    template <class _Ty, _Ty _Val> struct integral_constant {
        static constexpr _Ty value = _Val;
        using value_type = _Ty;
        using type = integral_constant<_Ty, _Val>;
        constexpr operator value_type() const noexcept         {
            return (value);
        }
        constexpr std::integral_constant::value_type operator()() const noexcept         {
            return (value);
        }
    };
template<> struct integral_constant<bool, true> {
        static constexpr bool value = true;
        using value_type = bool;
        using type = std::integral_constant<bool, true>;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<bool, true>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<bool, false> {
        static constexpr bool value = false;
        using value_type = bool;
        using type = std::integral_constant<bool, false>;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<bool, false>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<unsigned long long, 0> {
        static constexpr unsigned long long value = 0ULL;
        using value_type = unsigned long long;
        using type = std::integral_constant<unsigned long long, 0>;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<unsigned long long, 0>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<unsigned long long, 2> {
        static constexpr unsigned long long value = 2ULL;
        using value_type = unsigned long long;
        using type = std::integral_constant<unsigned long long, 2>;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<unsigned long long, 2>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<unsigned long long, 1> {
        static constexpr unsigned long long value = 1ULL;
        using value_type = unsigned long long;
        using type = std::integral_constant<unsigned long long, 1>;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<unsigned long long, 1>::value_type operator()() const noexcept;
    };
    template <bool _Val> using bool_constant = integral_constant<bool, _Val>;
    using true_type = bool_constant<true>;
    using false_type = bool_constant<false>;
    template <bool _Test, class _Ty = void> struct enable_if {
    };
template<> struct enable_if<false, void> {
    };
template<> struct enable_if<true, int> {
        using type = int;
    };
template<> struct enable_if<true, void> {
        using type = void;
    };
    template <class _Ty> struct enable_if<true, _Ty> {
        using type = _Ty;
    };
    template <bool _Test, class _Ty = void> using enable_if_t = typename enable_if<_Test, _Ty>::type;
    template <bool _Test, class _Ty1, class _Ty2> struct conditional {
        using type = _Ty2;
    };
template<> struct conditional<true, std::_Default_allocator_traits<std::allocator<char> >, std::_Normal_allocator_traits<std::allocator<char> >> {
        using type = std::_Default_allocator_traits<std::allocator<char> >;
    };
template<> struct conditional<true, std::_Simple_types<char>, std::_String_iter_types<char, unsigned long long, long long, char *, const char *, char &, const char &>> {
        using type = std::_Simple_types<char>;
    };
template<> struct conditional<false, std::is_same<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData> >, std::is_convertible<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData> >> {
        using type = std::is_convertible<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData> >;
    };
template<> struct conditional<false, std::is_same<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >, std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >> {
        using type = std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >;
    };
template<> struct conditional<false, std::is_same<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >, std::is_convertible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >> {
        using type = std::is_convertible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >;
    };
    template <class _Ty1, class _Ty2> struct conditional<true, _Ty1, _Ty2> {
        using type = _Ty1;
    };
    template <bool _Test, class _Ty1, class _Ty2> using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;
    template <class _Ty1, class _Ty2> struct is_same : std::false_type {
    };
template<> struct is_same<int, int &&> : std::false_type {
    };
template<> struct is_same<int &, int &&> : std::false_type {
    };
template<> struct is_same<int &&, int &&> : std::true_type {
    };
template<> struct is_same<unsigned long long, unsigned long long> : std::true_type {
    };
template<> struct is_same<long long, long long> : std::true_type {
    };
template<> struct is_same<char *, char *> : std::true_type {
    };
template<> struct is_same<const char *, const char *> : std::true_type {
    };
template<> struct is_same<char, char> : std::true_type {
    };
template<> struct is_same<const unsigned char *, const unsigned char *> : std::true_type {
    };
template<> struct is_same<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >, nullptr_t> : std::false_type {
    };
template<> struct is_same<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >, const unsigned char *> : std::false_type {
    };
    template <class _Ty1> struct is_same<_Ty1, _Ty1> : std::true_type {
    };
    template <class _Ty, class _Uty> constexpr bool is_same_v = is_same<_Ty, _Uty>::value;
    template <class _Ty> struct remove_const {
        using type = _Ty;
    };
    template <class _Ty> struct remove_const<_Ty> {
        using type = _Ty;
    };
    template <class _Ty> using remove_const_t = typename remove_const<_Ty>::type;
    template <class _Ty> struct remove_volatile {
        using type = _Ty;
    };
    template <class _Ty> struct remove_volatile<_Ty> {
        using type = _Ty;
    };
    template <class _Ty> using remove_volatile_t = typename remove_volatile<_Ty>::type;
    template <class _Ty> struct remove_cv {
        using type = _Ty;
    };
template<> struct remove_cv<std::default_delete<v8::internal::ScriptStreamingData>> {
        using type = std::default_delete<v8::internal::ScriptStreamingData>;
    };
template<> struct remove_cv<std::default_delete<unsigned char const[]>> {
        using type = std::default_delete<unsigned char const[]>;
    };
template<> struct remove_cv<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >> {
        using type = std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >;
    };
template<> struct remove_cv<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> {
        using type = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>;
    };
    template <class _Ty> struct remove_cv<_Ty> {
        using type = _Ty;
    };
    template <class _Ty> struct remove_cv<_Ty> {
        using type = _Ty;
    };
    template <class _Ty> struct remove_cv<_Ty> {
        using type = _Ty;
    };
    template <class _Ty> using remove_cv_t = typename remove_cv<_Ty>::type;
    template <class _Ty> struct _Is_integral : std::false_type {
    };
    template<> struct _Is_integral<bool> : std::true_type {
    };
    template<> struct _Is_integral<char> : std::true_type {
    };
    template<> struct _Is_integral<unsigned char> : std::true_type {
    };
    template<> struct _Is_integral<signed char> : std::true_type {
    };
    template<> struct _Is_integral<wchar_t> : std::true_type {
    };
    template<> struct _Is_integral<char16_t> : std::true_type {
    };
    template<> struct _Is_integral<char32_t> : std::true_type {
    };
    template<> struct _Is_integral<unsigned short> : std::true_type {
    };
    template<> struct _Is_integral<short> : std::true_type {
    };
    template<> struct _Is_integral<unsigned int> : std::true_type {
    };
    template<> struct _Is_integral<int> : std::true_type {
    };
    template<> struct _Is_integral<unsigned long> : std::true_type {
    };
    template<> struct _Is_integral<long> : std::true_type {
    };
    template<> struct _Is_integral<unsigned long long> : std::true_type {
    };
    template<> struct _Is_integral<long long> : std::true_type {
    };
    template <class _Ty> struct is_integral : _Is_integral<remove_cv_t<_Ty> >::type {
    };
    template <class _Ty> constexpr bool is_integral_v = is_integral<_Ty>::value;
    template <class _Ty> struct _Is_floating_point : std::false_type {
    };
    template<> struct _Is_floating_point<float> : std::true_type {
    };
    template<> struct _Is_floating_point<double> : std::true_type {
    };
    template<> struct _Is_floating_point<long double> : std::true_type {
    };
    template <class _Ty> struct is_floating_point : _Is_floating_point<remove_cv_t<_Ty> >::type {
    };
    template <class _Ty> constexpr bool is_floating_point_v = is_floating_point<_Ty>::value;
    template <class _Ty> struct is_arithmetic : bool_constant<is_integral_v<_Ty> || is_floating_point_v<_Ty> > {
    };
    template <class _Ty> constexpr bool is_arithmetic_v = is_arithmetic<_Ty>::value;
    template <class _Ty> struct remove_reference {
        using type = _Ty;
    };
template<> struct remove_reference<std::default_delete<v8::internal::ScriptStreamingData>> {
        using type = std::default_delete<v8::internal::ScriptStreamingData>;
    };
template<> struct remove_reference<std::default_delete<unsigned char const[]>> {
        using type = std::default_delete<unsigned char const[]>;
    };
template<> struct remove_reference<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &> {
        using type = std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >;
    };
template<> struct remove_reference<const unsigned char *&> {
        using type = const unsigned char *;
    };
template<> struct remove_reference<std::shared_ptr<v8::internal::wasm::NativeModule> &> {
        using type = std::shared_ptr<v8::internal::wasm::NativeModule>;
    };
template<> struct remove_reference<v8::OwnedBuffer &> {
        using type = v8::OwnedBuffer;
    };
template<> struct remove_reference<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> {
        using type = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>;
    };
    template <class _Ty> struct remove_reference<type-parameter-0-0 &> {
        using type = _Ty;
    };
    template <class _Ty> struct remove_reference<type-parameter-0-0 &&> {
        using type = _Ty;
    };
    template <class _Ty> using remove_reference_t = typename remove_reference<_Ty>::type;
    constexpr bool is_same_v = is_same<int, int &&>::value;
    constexpr bool is_same_v = is_same<int &, int &&>::value;
    constexpr bool is_same_v = is_same<int &&, int &&>::value;
    constexpr bool is_same_v = is_same<unsigned long long, unsigned long long>::value;
    constexpr bool is_same_v = is_same<long long, long long>::value;
    constexpr bool is_same_v = is_same<char *, char *>::value;
    constexpr bool is_same_v = is_same<const char *, const char *>::value;
    constexpr bool is_same_v = is_same<char, char>::value;
    constexpr bool is_same_v = is_same<const unsigned char *, const unsigned char *>::value;
    constexpr bool is_same_v = is_same<unique_ptr<unsigned char const[], default_delete<unsigned char const[]> >, const unsigned char *>::value;
}
namespace std {
    template <class _Ty1, class _Ty2> using _Common_float_type_t = conditional_t<is_same_v<_Ty1, long double> || is_same_v<_Ty2, long double>, long double, conditional_t<is_same_v<_Ty1, float> && is_same_v<_Ty2, float>, float, double> >;
}
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> pow(const _Ty1 _Left, const _Ty2 _Right) extern "C" double acos(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double acos(_Ty _Left) extern "C" double asin(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double asin(_Ty _Left) extern "C" double atan(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double atan(_Ty _Left) extern "C" double atan2(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> atan2(_Ty1 _Left, _Ty2 _Right) extern "C" double ceil(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double ceil(_Ty _Left) extern "C" double cos(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double cos(_Ty _Left) extern "C" double cosh(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double cosh(_Ty _Left) extern "C" double exp(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double exp(_Ty _Left) extern "C" double fabs(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double fabs(_Ty _Left) extern "C" double floor(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double floor(_Ty _Left) extern "C" double fmod(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> fmod(_Ty1 _Left, _Ty2 _Right) extern "C" double frexp(double, int *)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double frexp(_Ty _Left, int *_Arg2) extern "C" double ldexp(double, int)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double ldexp(_Ty _Left, int _Arg2) extern "C" double log(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double log(_Ty _Left) extern "C" double log10(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double log10(_Ty _Left) extern "C" double sin(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double sin(_Ty _Left) extern "C" double sinh(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double sinh(_Ty _Left) extern "C" double sqrt(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double sqrt(_Ty _Left) extern "C" double tan(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double tan(_Ty _Left) extern "C" double tanh(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double tanh(_Ty _Left) inline float _Fma(float _Left, float _Middle, float _Right) {
    return (::fmaf(_Left, _Middle, _Right));
}
inline double _Fma(double _Left, double _Middle, double _Right) {
    return (::fma(_Left, _Middle, _Right));
}
inline long double _Fma(long double _Left, long double _Middle, long double _Right) {
    return (::fmal(_Left, _Middle, _Right));
}
template <class _Ty1, class _Ty2, class _Ty3, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> && ::std::is_arithmetic_v<_Ty3> >> inline ::std::_Common_float_type_t<_Ty1, ::std::_Common_float_type_t<_Ty2, _Ty3> > fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right) inline float _Remquo(float _Left, float _Right, int *_Pquo) {
    return (::remquof(_Left, _Right, _Pquo));
}
inline double _Remquo(double _Left, double _Right, int *_Pquo) {
    return (::remquo(_Left, _Right, _Pquo));
}
inline long double _Remquo(long double _Left, long double _Right, int *_Pquo) {
    return (::remquol(_Left, _Right, _Pquo));
}
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> remquo(_Ty1 _Left, _Ty2 _Right, int *_Pquo) extern "C" double acosh(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double acosh(_Ty _Left) extern "C" double asinh(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double asinh(_Ty _Left) extern "C" double atanh(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double atanh(_Ty _Left) extern "C" double cbrt(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double cbrt(_Ty _Left) extern "C" double copysign(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> copysign(_Ty1 _Left, _Ty2 _Right) extern "C" double erf(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double erf(_Ty _Left) extern "C" double erfc(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double erfc(_Ty _Left) extern "C" double expm1(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double expm1(_Ty _Left) extern "C" double exp2(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double exp2(_Ty _Left) extern "C" double fdim(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> fdim(_Ty1 _Left, _Ty2 _Right) extern "C" double fmax(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> fmax(_Ty1 _Left, _Ty2 _Right) extern "C" double fmin(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> fmin(_Ty1 _Left, _Ty2 _Right) extern "C" double hypot(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> hypot(_Ty1 _Left, _Ty2 _Right) extern "C" int ilogb(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline int ilogb(_Ty _Left) extern "C" double lgamma(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double lgamma(_Ty _Left) extern "C" long long llrint(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline long long llrint(_Ty _Left) extern "C" long long llround(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline long long llround(_Ty _Left) extern "C" double log1p(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double log1p(_Ty _Left) extern "C" double log2(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double log2(_Ty _Left) extern "C" double logb(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double logb(_Ty _Left) extern "C" long lrint(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline long lrint(_Ty _Left) extern "C" long lround(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline long lround(_Ty _Left) extern "C" double nearbyint(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double nearbyint(_Ty _Left) extern "C" double nextafter(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> nextafter(_Ty1 _Left, _Ty2 _Right) extern "C" double nexttoward(double, long double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double nexttoward(_Ty _Left, long double _Arg2) extern "C" double remainder(double, double)
template <class _Ty1, class _Ty2, class  = ::std::enable_if_t< ::std::is_arithmetic_v<_Ty1> && ::std::is_arithmetic_v<_Ty2> >> inline ::std::_Common_float_type_t<_Ty1, _Ty2> remainder(_Ty1 _Left, _Ty2 _Right) extern "C" double rint(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double rint(_Ty _Left) extern "C" double round(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double round(_Ty _Left) extern "C" double scalbln(double, long)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double scalbln(_Ty _Left, long _Arg2) extern "C" double scalbn(double, int)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double scalbn(_Ty _Left, int _Arg2) extern "C" double tgamma(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double tgamma(_Ty _Left) extern "C" double trunc(double)
template <class _Ty, class  = ::std::enable_if_t< ::std::is_integral_v<_Ty> >> inline double trunc(_Ty _Left) namespace std {
    using ::abs;
    using ::acos;
    using ::asin;
    using ::atan;
    using ::atan2;
    using ::ceil;
    using ::cos;
    using ::cosh;
    using ::exp;
    using ::fabs;
    using ::floor;
    using ::fmod;
    using ::frexp;
    using ::ldexp;
    using ::log;
    using ::log10;
    using ::modf;
    using ::pow;
    using ::sin;
    using ::sinh;
    using ::sqrt;
    using ::tan;
    using ::tanh;
    using ::acosf;
    using ::asinf;
    using ::atanf;
    using ::atan2f;
    using ::ceilf;
    using ::cosf;
    using ::coshf;
    using ::expf;
    using ::fabsf;
    using ::floorf;
    using ::fmodf;
    using ::frexpf;
    using ::ldexpf;
    using ::logf;
    using ::log10f;
    using ::modff;
    using ::powf;
    using ::sinf;
    using ::sinhf;
    using ::sqrtf;
    using ::tanf;
    using ::tanhf;
    using ::acosl;
    using ::asinl;
    using ::atanl;
    using ::atan2l;
    using ::ceill;
    using ::cosl;
    using ::coshl;
    using ::expl;
    using ::fabsl;
    using ::floorl;
    using ::fmodl;
    using ::frexpl;
    using ::ldexpl;
    using ::logl;
    using ::log10l;
    using ::modfl;
    using ::powl;
    using ::sinl;
    using ::sinhl;
    using ::sqrtl;
    using ::tanl;
    using ::tanhl;
    using ::float_t;
    using ::double_t;
    using ::acosh;
    using ::asinh;
    using ::atanh;
    using ::cbrt;
    using ::erf;
    using ::erfc;
    using ::expm1;
    using ::exp2;
    using ::hypot;
    using ::ilogb;
    using ::lgamma;
    using ::log1p;
    using ::log2;
    using ::logb;
    using ::llrint;
    using ::lrint;
    using ::nearbyint;
    using ::rint;
    using ::llround;
    using ::lround;
    using ::fdim;
    using ::fma;
    using ::fmax;
    using ::fmin;
    using ::round;
    using ::trunc;
    using ::remainder;
    using ::remquo;
    using ::copysign;
    using ::nan;
    using ::nextafter;
    using ::scalbn;
    using ::scalbln;
    using ::nexttoward;
    using ::tgamma;
    using ::acoshf;
    using ::asinhf;
    using ::atanhf;
    using ::cbrtf;
    using ::erff;
    using ::erfcf;
    using ::expm1f;
    using ::exp2f;
    using ::hypotf;
    using ::ilogbf;
    using ::lgammaf;
    using ::log1pf;
    using ::log2f;
    using ::logbf;
    using ::llrintf;
    using ::lrintf;
    using ::nearbyintf;
    using ::rintf;
    using ::llroundf;
    using ::lroundf;
    using ::fdimf;
    using ::fmaf;
    using ::fmaxf;
    using ::fminf;
    using ::roundf;
    using ::truncf;
    using ::remainderf;
    using ::remquof;
    using ::copysignf;
    using ::nanf;
    using ::nextafterf;
    using ::scalbnf;
    using ::scalblnf;
    using ::nexttowardf;
    using ::tgammaf;
    using ::acoshl;
    using ::asinhl;
    using ::atanhl;
    using ::cbrtl;
    using ::erfl;
    using ::erfcl;
    using ::expm1l;
    using ::exp2l;
    using ::hypotl;
    using ::ilogbl;
    using ::lgammal;
    using ::log1pl;
    using ::log2l;
    using ::logbl;
    using ::llrintl;
    using ::lrintl;
    using ::nearbyintl;
    using ::rintl;
    using ::llroundl;
    using ::lroundl;
    using ::fdiml;
    using ::fmal;
    using ::fmaxl;
    using ::fminl;
    using ::roundl;
    using ::truncl;
    using ::remainderl;
    using ::remquol;
    using ::copysignl;
    using ::nanl;
    using ::nextafterl;
    using ::scalbnl;
    using ::scalblnl;
    using ::nexttowardl;
    using ::tgammal;
    using ::fpclassify;
    using ::signbit;
    using ::isfinite;
    using ::isinf;
    using ::isnan;
    using ::isnormal;
    using ::isgreater;
    using ::isgreaterequal;
    using ::isless;
    using ::islessequal;
    using ::islessgreater;
    using ::isunordered;
}
extern "C" {
    int *_errno();
    errno_t _set_errno(int _Value);
    errno_t _get_errno(int *_Value);
    unsigned long *__doserrno();
    errno_t _set_doserrno(unsigned long _Value);
    errno_t _get_doserrno(unsigned long *_Value);
}
extern "C" {
    const void *memchr(const void *_Buf, int _Val, size_t _MaxCount);
    int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size);
    void *memcpy(void *_Dst, const void *_Src, size_t _Size);
    void *memmove(void *_Dst, const void *_Src, size_t _Size);
    void *memset(void *_Dst, int _Val, size_t _Size);
    const char *strchr(const char *_Str, int _Val);
    const char *strrchr(const char *_Str, int _Ch);
    const char *strstr(const char *_Str, const char *_SubStr);
    const wchar_t *wcschr(const wchar_t *_Str, wchar_t _Ch);
    const wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch);
    const wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr);
}
extern "C" {
    static inline errno_t memcpy_s(void *const _Destination, const rsize_t _DestinationSize, const void *const _Source, const rsize_t _SourceSize)     {
        if (_SourceSize == 0) {
            return 0;
        }
        {
            int _Expr_val = !!(_Destination != 0);
            if (!(_Expr_val)) {
                (*_errno()) = 22;
                _invalid_parameter_noinfo();
                return 22;
            }
        }
        ;
        if (_Source == 0 || _DestinationSize < _SourceSize) {
            memset(_Destination, 0, _DestinationSize);
            {
                int _Expr_val = !!(_Source != 0);
                if (!(_Expr_val)) {
                    (*_errno()) = 22;
                    _invalid_parameter_noinfo();
                    return 22;
                }
            }
            ;
            {
                int _Expr_val = !!(_DestinationSize >= _SourceSize);
                if (!(_Expr_val)) {
                    (*_errno()) = 34;
                    _invalid_parameter_noinfo();
                    return 34;
                }
            }
            ;
            return 22;
        }
        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }
    static inline errno_t memmove_s(void *const _Destination, const rsize_t _DestinationSize, const void *const _Source, const rsize_t _SourceSize)     {
        if (_SourceSize == 0) {
            return 0;
        }
        {
            int _Expr_val = !!(_Destination != 0);
            if (!(_Expr_val)) {
                (*_errno()) = 22;
                _invalid_parameter_noinfo();
                return 22;
            }
        }
        ;
        {
            int _Expr_val = !!(_Source != 0);
            if (!(_Expr_val)) {
                (*_errno()) = 22;
                _invalid_parameter_noinfo();
                return 22;
            }
        }
        ;
        {
            int _Expr_val = !!(_DestinationSize >= _SourceSize);
            if (!(_Expr_val)) {
                (*_errno()) = 34;
                _invalid_parameter_noinfo();
                return 34;
            }
        }
        ;
        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }
}
extern "C" {
    errno_t _cgetws_s(wchar_t *_Buffer, size_t _BufferCount, size_t *_SizeRead);
    extern "C++" {
        template <size_t _Size> inline errno_t _cgetws_s(wchar_t (&_Buffer)[_Size], size_t *_SizeRead) throw()     }
    int _cputws(const wchar_t *_Buffer);
    wint_t _getwch();
    wint_t _getwche();
    wint_t _putwch(wchar_t _Character);
    wint_t _ungetwch(wint_t _Character);
    wint_t _getwch_nolock();
    wint_t _getwche_nolock();
    wint_t _putwch_nolock(wchar_t _Character);
    wint_t _ungetwch_nolock(wint_t _Character);
    int __conio_common_vcwprintf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    int __conio_common_vcwprintf_s(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    int __conio_common_vcwprintf_p(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vcwprintf_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
    inline int _vcwprintf(const wchar_t *const _Format, va_list _ArgList)     {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }
    inline int _vcwprintf_s_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
    inline int _vcwprintf_s(const wchar_t *const _Format, va_list _ArgList)     {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }
    inline int _vcwprintf_p_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
    inline int _vcwprintf_p(const wchar_t *const _Format, va_list _ArgList)     {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }
    inline int _cwprintf_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _cwprintf(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _cwprintf_s_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _cwprintf_s(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _cwprintf_p_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _cwprintf_p(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    int __conio_common_vcwscanf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
    inline int _vcwscanf_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList) __declspec(deprecated("This function or variable may be unsafe. Consider using _vcwscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return __conio_common_vcwscanf((*__local_stdio_scanf_options()), _Format, _Locale, _ArgList);
    }
    inline int _vcwscanf(const wchar_t *const _Format, va_list _ArgList) __declspec(deprecated("This function or variable may be unsafe. Consider using _vcwscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return _vcwscanf_l(_Format, 0, _ArgList);
    }
    inline int _vcwscanf_s_l(const wchar_t *const _Format, const _locale_t _Locale, va_list _ArgList)     {
        return __conio_common_vcwscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Format, _Locale, _ArgList);
    }
    inline int _vcwscanf_s(const wchar_t *const _Format, va_list _ArgList)     {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }
    inline int _cwscanf_l(const wchar_t *const _Format, const _locale_t _Locale, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _cwscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _cwscanf(const wchar_t *const _Format, ...) __declspec(deprecated("This function or variable may be unsafe. Consider using _cwscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vcwscanf_l(_Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _cwscanf_s_l(const wchar_t *const _Format, const _locale_t _Locale, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
    inline int _cwscanf_s(const wchar_t *const _Format, ...)     {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
}
extern "C" {
    const unsigned short *__pctype_func();
    const wctype_t *__pwctype_func();
    int iswalnum(wint_t _C);
    int iswalpha(wint_t _C);
    int iswascii(wint_t _C);
    int iswblank(wint_t _C);
    int iswcntrl(wint_t _C);
    int iswdigit(wint_t _C);
    int iswgraph(wint_t _C);
    int iswlower(wint_t _C);
    int iswprint(wint_t _C);
    int iswpunct(wint_t _C);
    int iswspace(wint_t _C);
    int iswupper(wint_t _C);
    int iswxdigit(wint_t _C);
    int __iswcsymf(wint_t _C);
    int __iswcsym(wint_t _C);
    int _iswalnum_l(wint_t _C, _locale_t _Locale);
    int _iswalpha_l(wint_t _C, _locale_t _Locale);
    int _iswblank_l(wint_t _C, _locale_t _Locale);
    int _iswcntrl_l(wint_t _C, _locale_t _Locale);
    int _iswdigit_l(wint_t _C, _locale_t _Locale);
    int _iswgraph_l(wint_t _C, _locale_t _Locale);
    int _iswlower_l(wint_t _C, _locale_t _Locale);
    int _iswprint_l(wint_t _C, _locale_t _Locale);
    int _iswpunct_l(wint_t _C, _locale_t _Locale);
    int _iswspace_l(wint_t _C, _locale_t _Locale);
    int _iswupper_l(wint_t _C, _locale_t _Locale);
    int _iswxdigit_l(wint_t _C, _locale_t _Locale);
    int _iswcsymf_l(wint_t _C, _locale_t _Locale);
    int _iswcsym_l(wint_t _C, _locale_t _Locale);
    wint_t towupper(wint_t _C);
    wint_t towlower(wint_t _C);
    int iswctype(wint_t _C, wctype_t _Type);
    wint_t _towupper_l(wint_t _C, _locale_t _Locale);
    wint_t _towlower_l(wint_t _C, _locale_t _Locale);
    int _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale);
    int isleadbyte(int _C);
    int _isleadbyte_l(int _C, _locale_t _Locale);
    int is_wctype(wint_t _C, wctype_t _Type) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using iswctype instead. See online help for details."));
}
extern "C" {
    wchar_t *_wgetcwd(wchar_t *_DstBuf, int _SizeInWords);
    wchar_t *_wgetdcwd(int _Drive, wchar_t *_DstBuf, int _SizeInWords);
    int _wchdir(const wchar_t *_Path);
    int _wmkdir(const wchar_t *_Path);
    int _wrmdir(const wchar_t *_Path);
}
extern "C" {
    typedef unsigned long _fsize_t;
    struct _wfinddata32_t {
        unsigned int attrib;
        __time32_t time_create;
        __time32_t time_access;
        __time32_t time_write;
        _fsize_t size;
        wchar_t name[260];
    };
    struct _wfinddata32i64_t {
        unsigned int attrib;
        __time32_t time_create;
        __time32_t time_access;
        __time32_t time_write;
        long long size;
        wchar_t name[260];
    };
    struct _wfinddata64i32_t {
        unsigned int attrib;
        __time64_t time_create;
        __time64_t time_access;
        __time64_t time_write;
        _fsize_t size;
        wchar_t name[260];
    };
    struct _wfinddata64_t {
        unsigned int attrib;
        __time64_t time_create;
        __time64_t time_access;
        __time64_t time_write;
        long long size;
        wchar_t name[260];
    };
    int _waccess(const wchar_t *_FileName, int _AccessMode);
    errno_t _waccess_s(const wchar_t *_FileName, int _AccessMode);
    int _wchmod(const wchar_t *_FileName, int _Mode);
    int _wcreat(const wchar_t *_FileName, int _PermissionMode) __declspec(deprecated("This function or variable may be unsafe. Consider using _wsopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    intptr_t _wfindfirst32(const wchar_t *_FileName, struct _wfinddata32_t *_FindData);
    int _wfindnext32(intptr_t _FindHandle, struct _wfinddata32_t *_FindData);
    int _wunlink(const wchar_t *_FileName);
    int _wrename(const wchar_t *_OldFileName, const wchar_t *_NewFileName);
    errno_t _wmktemp_s(wchar_t *_TemplateName, size_t _SizeInWords);
    extern "C++" {
        template <size_t _Size> inline errno_t _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw()     }
    wchar_t *_wmktemp(wchar_t *_TemplateName) __declspec(deprecated("This function or variable may be unsafe. Consider using _wmktemp_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    intptr_t _wfindfirst32i64(const wchar_t *_FileName, struct _wfinddata32i64_t *_FindData);
    intptr_t _wfindfirst64i32(const wchar_t *_FileName, struct _wfinddata64i32_t *_FindData);
    intptr_t _wfindfirst64(const wchar_t *_FileName, struct _wfinddata64_t *_FindData);
    int _wfindnext32i64(intptr_t _FindHandle, struct _wfinddata32i64_t *_FindData);
    int _wfindnext64i32(intptr_t _FindHandle, struct _wfinddata64i32_t *_FindData);
    int _wfindnext64(intptr_t _FindHandle, struct _wfinddata64_t *_FindData);
    errno_t _wsopen_s(int *_FileHandle, const wchar_t *_FileName, int _OpenFlag, int _ShareFlag, int _PermissionFlag);
    errno_t _wsopen_dispatch(const wchar_t *_FileName, int _OFlag, int _ShFlag, int _PMode, int *_PFileHandle, int _BSecure);
    extern "C++" inline int _wopen(const wchar_t *_FileName, int _OFlag, int _PMode = 0) __declspec(deprecated("This function or variable may be unsafe. Consider using _wsopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _FileHandle;
        const errno_t _Result = _wsopen_dispatch(_FileName, _OFlag, 64, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++" inline int _wsopen(const wchar_t *_FileName, int _OFlag, int _ShFlag, int _PMode = 0) __declspec(deprecated("This function or variable may be unsafe. Consider using _wsopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        int _FileHandle;
        const errno_t _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

}
extern "C" {
    intptr_t _wexecl(const wchar_t *_FileName, const wchar_t *_ArgList, ...);
    intptr_t _wexecle(const wchar_t *_FileName, const wchar_t *_ArgList, ...);
    intptr_t _wexeclp(const wchar_t *_FileName, const wchar_t *_ArgList, ...);
    intptr_t _wexeclpe(const wchar_t *_FileName, const wchar_t *_ArgList, ...);
    intptr_t _wexecv(const wchar_t *_FileName, const wchar_t *const *_ArgList);
    intptr_t _wexecve(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env);
    intptr_t _wexecvp(const wchar_t *_FileName, const wchar_t *const *_ArgList);
    intptr_t _wexecvpe(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env);
    intptr_t _wspawnl(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...);
    intptr_t _wspawnle(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...);
    intptr_t _wspawnlp(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...);
    intptr_t _wspawnlpe(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...);
    intptr_t _wspawnv(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList);
    intptr_t _wspawnve(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env);
    intptr_t _wspawnvp(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList);
    intptr_t _wspawnvpe(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env);
    int _wsystem(const wchar_t *_Command);
}
extern "C" {
    errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source);
    errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source);
    errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount);
    errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount);
    wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context);
    wchar_t *_wcsdup(const wchar_t *_String);
    extern "C++" {
        template <size_t _Size> inline errno_t wcscat_s(wchar_t (&_Destination)[_Size], const wchar_t *_Source) throw()     }
    wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source) __declspec(deprecated("This function or variable may be unsafe. Consider using wcscat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int wcscmp(const wchar_t *_String1, const wchar_t *_String2);
    extern "C++" {
        template <size_t _Size> inline errno_t wcscpy_s(wchar_t (&_Destination)[_Size], const wchar_t *_Source) throw()     }
    wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source) __declspec(deprecated("This function or variable may be unsafe. Consider using wcscpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    size_t wcscspn(const wchar_t *_String, const wchar_t *_Control);
    size_t wcslen(const wchar_t *_String);
    size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount);
    static inline size_t wcsnlen_s(const wchar_t *_Source, size_t _MaxCount)     {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }
    extern "C++" {
        template <size_t _Size> inline errno_t wcsncat_s(wchar_t (&_Destination)[_Size], const wchar_t *_Source, size_t _Count) throw()     }
    wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count) __declspec(deprecated("This function or variable may be unsafe. Consider using wcsncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount);
    extern "C++" {
        template <size_t _Size> inline errno_t wcsncpy_s(wchar_t (&_Destination)[_Size], const wchar_t *_Source, size_t _Count) throw()     }
    wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count) __declspec(deprecated("This function or variable may be unsafe. Consider using wcsncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    const wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control);
    size_t wcsspn(const wchar_t *_String, const wchar_t *_Control);
    wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context) __declspec(deprecated("This function or variable may be unsafe. Consider using wcstok_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    static inline wchar_t *_wcstok(wchar_t *const _String, const wchar_t *const _Delimiter) __declspec(deprecated("This function or variable may be unsafe. Consider using wcstok_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))     {
        return wcstok(_String, _Delimiter, 0);
    }
    extern "C++" inline wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter) throw() __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, adding an extra context parameter. To use the legacy Microsoft wcstok, define _CRT_NON_CONFORMING_WCSTOK."))     {
        return wcstok(_String, _Delimiter, 0);
    }

    wchar_t *_wcserror(int _ErrorNumber) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcserror_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber);
    extern "C++" {
        template <size_t _Size> inline errno_t _wcserror_s(wchar_t (&_Buffer)[_Size], int _Error) throw()     }
    wchar_t *__wcserror(const wchar_t *_String) __declspec(deprecated("This function or variable may be unsafe. Consider using __wcserror_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage);
    extern "C++" {
        template <size_t _Size> inline errno_t __wcserror_s(wchar_t (&_Buffer)[_Size], const wchar_t *_ErrorMessage) throw()     }
    int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2);
    int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale);
    int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount);
    int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale);
    errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount);
    extern "C++" {
        template <size_t _Size> inline errno_t _wcsnset_s(wchar_t (&_Destination)[_Size], wchar_t _Value, size_t _MaxCount) throw()     }
    wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcsnset_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    wchar_t *_wcsrev(wchar_t *_String);
    errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value);
    extern "C++" {
        template <size_t _Size> inline errno_t _wcsset_s(wchar_t (&_String)[_Size], wchar_t _Value) throw()     }
    wchar_t *_wcsset(wchar_t *_String, wchar_t _Value) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcsset_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords);
    extern "C++" {
        template <size_t _Size> inline errno_t _wcslwr_s(wchar_t (&_String)[_Size]) throw()     }
    wchar_t *_wcslwr(wchar_t *_String) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcslwr_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale);
    extern "C++" {
        template <size_t _Size> inline errno_t _wcslwr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw()     }
    wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcslwr_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wcsupr_s(wchar_t *_String, size_t _Size);
    extern "C++" {
        template <size_t _Size> inline errno_t _wcsupr_s(wchar_t (&_String)[_Size]) throw()     }
    wchar_t *_wcsupr(wchar_t *_String) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcsupr_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale);
    extern "C++" {
        template <size_t _Size> inline errno_t _wcsupr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw()     }
    wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcsupr_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount);
    size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale);
    int wcscoll(const wchar_t *_String1, const wchar_t *_String2);
    int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale);
    int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2);
    int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale);
    int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount);
    int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale);
    int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount);
    int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale);
    extern "C++" {
        inline wchar_t *wcschr(wchar_t *_String, wchar_t _C)         {
            return const_cast<wchar_t *>(wcschr(static_cast<const wchar_t *>(_String), _C));
        }
        inline wchar_t *wcspbrk(wchar_t *_String, const wchar_t *_Control)         {
            return const_cast<wchar_t *>(wcspbrk(static_cast<const wchar_t *>(_String), _Control));
        }
        inline wchar_t *wcsrchr(wchar_t *_String, wchar_t _C)         {
            return const_cast<wchar_t *>(wcsrchr(static_cast<const wchar_t *>(_String), _C));
        }
        inline wchar_t *wcsstr(wchar_t *_String, const wchar_t *_SubStr)         {
            return const_cast<wchar_t *>(wcsstr(static_cast<const wchar_t *>(_String), _SubStr));
        }
    }
    wchar_t *wcsdup(const wchar_t *_String) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcsdup. See online help for details."));
    int wcsicmp(const wchar_t *_String1, const wchar_t *_String2) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcsicmp. See online help for details."));
    int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcsnicmp. See online help for details."));
    wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcsnset. See online help for details."));
    wchar_t *wcsrev(wchar_t *_String) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcsrev. See online help for details."));
    wchar_t *wcsset(wchar_t *_String, wchar_t _Value) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcsset. See online help for details."));
    wchar_t *wcslwr(wchar_t *_String) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcslwr. See online help for details."));
    wchar_t *wcsupr(wchar_t *_String) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcsupr. See online help for details."));
    int wcsicoll(const wchar_t *_String1, const wchar_t *_String2) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _wcsicoll. See online help for details."));
}
extern "C" {
    struct tm {
        int tm_sec;
        int tm_min;
        int tm_hour;
        int tm_mday;
        int tm_mon;
        int tm_year;
        int tm_wday;
        int tm_yday;
        int tm_isdst;
    };
    wchar_t *_wasctime(const struct tm *_Tm) __declspec(deprecated("This function or variable may be unsafe. Consider using _wasctime_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wasctime_s(wchar_t *_Buffer, size_t _SizeInWords, const struct tm *_Tm);
    extern "C++" {
        template <size_t _Size> inline errno_t _wasctime_s(wchar_t (&_Buffer)[_Size], const struct tm *_Time) throw()     }
    size_t wcsftime(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm);
    size_t _wcsftime_l(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm, _locale_t _Locale);
    wchar_t *_wctime32(const __time32_t *_Time) __declspec(deprecated("This function or variable may be unsafe. Consider using _wctime32_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wctime32_s(wchar_t *_Buffer, size_t _SizeInWords, const __time32_t *_Time);
    extern "C++" {
        template <size_t _Size> inline errno_t _wctime32_s(wchar_t (&_Buffer)[_Size], const __time32_t *_Time) throw()     }
    wchar_t *_wctime64(const __time64_t *_Time) __declspec(deprecated("This function or variable may be unsafe. Consider using _wctime64_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wctime64_s(wchar_t *_Buffer, size_t _SizeInWords, const __time64_t *_Time);
    extern "C++" {
        template <size_t _Size> inline errno_t _wctime64_s(wchar_t (&_Buffer)[_Size], const __time64_t *_Time) throw()     }
    errno_t _wstrdate_s(wchar_t *_Buffer, size_t _SizeInWords);
    extern "C++" {
        template <size_t _Size> inline errno_t _wstrdate_s(wchar_t (&_Buffer)[_Size]) throw()     }
    wchar_t *_wstrdate(wchar_t *_Buffer) __declspec(deprecated("This function or variable may be unsafe. Consider using _wstrdate_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _wstrtime_s(wchar_t *_Buffer, size_t _SizeInWords);
    extern "C++" {
        template <size_t _Size> inline errno_t _wstrtime_s(wchar_t (&_Buffer)[_Size]) throw()     }
    wchar_t *_wstrtime(wchar_t *_Buffer) __declspec(deprecated("This function or variable may be unsafe. Consider using _wstrtime_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    static inline wchar_t *_wctime(const time_t *const _Time)     {
        return _wctime64(_Time);
    }
    static inline errno_t _wctime_s(wchar_t *const _Buffer, const size_t _SizeInWords, const time_t *const _Time)     {
        return _wctime64_s(_Buffer, _SizeInWords, _Time);
    }
}
typedef unsigned short _ino_t;
typedef _ino_t ino_t;
typedef unsigned int _dev_t;
typedef _dev_t dev_t;
typedef long _off_t;
typedef _off_t off_t;
extern "C" {
    struct _stat32 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
    };
    struct _stat32i64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        long long st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
    };
    struct _stat64i32 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
    };
    struct _stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        long long st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
    };
    struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
    };
    int _fstat32(int _FileHandle, struct _stat32 *_Stat);
    int _fstat32i64(int _FileHandle, struct _stat32i64 *_Stat);
    int _fstat64i32(int _FileHandle, struct _stat64i32 *_Stat);
    int _fstat64(int _FileHandle, struct _stat64 *_Stat);
    int _stat32(const char *_FileName, struct _stat32 *_Stat);
    int _stat32i64(const char *_FileName, struct _stat32i64 *_Stat);
    int _stat64i32(const char *_FileName, struct _stat64i32 *_Stat);
    int _stat64(const char *_FileName, struct _stat64 *_Stat);
    int _wstat32(const wchar_t *_FileName, struct _stat32 *_Stat);
    int _wstat32i64(const wchar_t *_FileName, struct _stat32i64 *_Stat);
    int _wstat64i32(const wchar_t *_FileName, struct _stat64i32 *_Stat);
    int _wstat64(const wchar_t *_FileName, struct _stat64 *_Stat);
    static inline int fstat(const int _FileHandle, struct stat *const _Stat)     {
        typedef char __static_assert_t[1];
        return _fstat64i32(_FileHandle, (struct _stat64i32 *)_Stat);
    }
    static inline int stat(const char *const _FileName, struct stat *const _Stat)     {
        typedef char __static_assert_t[1];
        return _stat64i32(_FileName, (struct _stat64i32 *)_Stat);
    }
}
extern "C" {
    typedef wchar_t _Wint_t;
    wchar_t *_wsetlocale(int _Category, const wchar_t *_Locale);
    _locale_t _wcreate_locale(int _Category, const wchar_t *_Locale);
    wint_t btowc(int _Ch);
    size_t mbrlen(const char *_Ch, size_t _SizeInBytes, mbstate_t *_State);
    size_t mbrtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SizeInBytes, mbstate_t *_State);
    errno_t mbsrtowcs_s(size_t *_Retval, wchar_t *_Dst, size_t _Size, const char **_PSrc, size_t _N, mbstate_t *_State);
    extern "C++" {
        template <size_t _Size> inline errno_t mbsrtowcs_s(size_t *_Retval, wchar_t (&_Dest)[_Size], const char **_PSource, size_t _Count, mbstate_t *_State) throw()     }
    size_t mbsrtowcs(wchar_t *_Dest, const char **_PSrc, size_t _Count, mbstate_t *_State) __declspec(deprecated("This function or variable may be unsafe. Consider using mbsrtowcs_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t wcrtomb_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, wchar_t _Ch, mbstate_t *_State);
    extern "C++" {
        template <size_t _Size> inline errno_t wcrtomb_s(size_t *_Retval, char (&_Dest)[_Size], wchar_t _Source, mbstate_t *_State) throw()     }
    size_t wcrtomb(char *_Dest, wchar_t _Source, mbstate_t *_State) __declspec(deprecated("This function or variable may be unsafe. Consider using wcrtomb_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t wcsrtombs_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, const wchar_t **_Src, size_t _Size, mbstate_t *_State);
    extern "C++" {
        template <size_t _Size> inline errno_t wcsrtombs_s(size_t *_Retval, char (&_Dest)[_Size], const wchar_t **_PSrc, size_t _Count, mbstate_t *_State) throw()     }
    size_t wcsrtombs(char *_Dest, const wchar_t **_PSource, size_t _Count, mbstate_t *_State) __declspec(deprecated("This function or variable may be unsafe. Consider using wcsrtombs_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int wctob(wint_t _WCh);
    errno_t wmemcpy_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N);
    errno_t wmemmove_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N);
    inline int fwide(FILE *_F, int _M)     {
        (void)_F;
        return (_M);
    }
    inline int mbsinit(const mbstate_t *_P)     {
        return _P == 0 || _P->_Wchar == 0;
    }
    inline const wchar_t *wmemchr(const wchar_t *_S, wchar_t _C, size_t _N)     {
        for (; 0 < _N; ++_S , --_N) 
            if (*_S == _C)
                return (const wchar_t *)_S;
        return 0;
    }
    inline int wmemcmp(const wchar_t *_S1, const wchar_t *_S2, size_t _N)     {
        for (; 0 < _N; ++_S1 , ++_S2 , --_N) 
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;
        return 0;
    }
    inline wchar_t *wmemcpy(wchar_t *_S1, const wchar_t *_S2, size_t _N)     {
        return (wchar_t *)memcpy(_S1, _S2, _N * sizeof(wchar_t));
    }
    inline wchar_t *wmemmove(wchar_t *_S1, const wchar_t *_S2, size_t _N)     {
        return (wchar_t *)memmove(_S1, _S2, _N * sizeof(wchar_t));
    }
    inline wchar_t *wmemset(wchar_t *_S, wchar_t _C, size_t _N)     {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su , --_N) {
            *_Su = _C;
        }
        return _S;
    }
    extern "C++" inline wchar_t *wmemchr(wchar_t *_S, wchar_t _C, size_t _N)     {
        const wchar_t *const _SC = _S;
        return const_cast<wchar_t *>(wmemchr(_SC, _C, _N));
    }

}
typedef mbstate_t _Mbstatet;
namespace std {
    using ::_Mbstatet;
    using ::mbstate_t;
    using ::size_t;
    using ::tm;
    using ::wint_t;
    using ::btowc;
    using ::fgetwc;
    using ::fgetws;
    using ::fputwc;
    using ::fputws;
    using ::fwide;
    using ::fwprintf;
    using ::fwscanf;
    using ::getwc;
    using ::getwchar;
    using ::mbrlen;
    using ::mbrtowc;
    using ::mbsrtowcs;
    using ::mbsinit;
    using ::putwc;
    using ::putwchar;
    using ::swprintf;
    using ::swscanf;
    using ::ungetwc;
    using ::vfwprintf;
    using ::vswprintf;
    using ::vwprintf;
    using ::wcrtomb;
    using ::wprintf;
    using ::wscanf;
    using ::wcsrtombs;
    using ::wcstol;
    using ::wcscat;
    using ::wcschr;
    using ::wcscmp;
    using ::wcscoll;
    using ::wcscpy;
    using ::wcscspn;
    using ::wcslen;
    using ::wcsncat;
    using ::wcsncmp;
    using ::wcsncpy;
    using ::wcspbrk;
    using ::wcsrchr;
    using ::wcsspn;
    using ::wcstod;
    using ::wcstoul;
    using ::wcsstr;
    using ::wcstok;
    using ::wcsxfrm;
    using ::wctob;
    using ::wmemchr;
    using ::wmemcmp;
    using ::wmemcpy;
    using ::wmemmove;
    using ::wmemset;
    using ::wcsftime;
    using ::vfwscanf;
    using ::vswscanf;
    using ::vwscanf;
    using ::wcstof;
    using ::wcstold;
    using ::wcstoll;
    using ::wcstoull;
}
namespace std {
    using ::ptrdiff_t;
    using ::size_t;
    typedef double max_align_t;
}
using ::std::max_align_t;
namespace std {
    template <class _Elem> class initializer_list {
    public:
        typedef _Elem value_type;
        typedef const _Elem &reference;
        typedef const _Elem &const_reference;
        typedef size_t size_type;
        typedef const _Elem *iterator;
        typedef const _Elem *const_iterator;
        constexpr initializer_list<_Elem>() noexcept : _First(nullptr), _Last(nullptr)         {
        }
        constexpr initializer_list<_Elem>(const _Elem *_First_arg, const _Elem *_Last_arg) noexcept : _First(_First_arg), _Last(_Last_arg)         {
        }
        constexpr const _Elem *begin() const noexcept         {
            return (this->_First);
        }
        constexpr const _Elem *end() const noexcept         {
            return (this->_Last);
        }
        constexpr size_t size() const noexcept         {
            return (static_cast<size_t>(this->_Last - this->_First));
        }
    private:
        const _Elem *_First;
        const _Elem *_Last;
    };
    template <class _Elem> constexpr const _Elem *begin(initializer_list<_Elem> _Ilist) noexcept     {
        return (_Ilist.begin());
    }
    template <class _Elem> constexpr const _Elem *end(initializer_list<_Elem> _Ilist) noexcept     {
        return (_Ilist.end());
    }
}
namespace std {
    template <class _Ty> struct _Always_false : std::false_type {
    };
    template <class _Arg, class _Result> struct unary_function {
        typedef _Arg argument_type;
        typedef _Result result_type;
    };
    template <class _Arg1, class _Arg2, class _Result> struct binary_function {
        typedef _Arg1 first_argument_type;
        typedef _Arg2 second_argument_type;
        typedef _Result result_type;
    };
    template <class _Ty = void> struct plus {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef _Ty result_type;
        constexpr _Ty operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left + _Right);
        }
    };
    template <class _Ty = void> struct minus {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef _Ty result_type;
        constexpr _Ty operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left - _Right);
        }
    };
    template <class _Ty = void> struct multiplies {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef _Ty result_type;
        constexpr _Ty operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left * _Right);
        }
    };
    template <class _Ty = void> struct equal_to {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;
        constexpr bool operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left == _Right);
        }
    };
    template <class _Ty = void> struct not_equal_to {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;
        constexpr bool operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left != _Right);
        }
    };
    template <class _Ty = void> struct greater {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;
        constexpr bool operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left > _Right);
        }
    };
    template <class _Ty = void> struct less {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;
        constexpr bool operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left < _Right);
        }
    };
    template <class _Ty = void> struct greater_equal {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;
        constexpr bool operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left >= _Right);
        }
    };
    template <class _Ty = void> struct less_equal {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;
        constexpr bool operator()(const _Ty &_Left, const _Ty &_Right) const         {
            return (_Left <= _Right);
        }
    };
    template<> struct plus<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) + static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) + static_cast<_Ty2 &&>(_Right));
        }
    };
    template<> struct minus<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) - static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) - static_cast<_Ty2 &&>(_Right));
        }
    };
    template<> struct multiplies<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) * static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) * static_cast<_Ty2 &&>(_Right));
        }
    };
    template<> struct equal_to<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) == static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) == static_cast<_Ty2 &&>(_Right));
        }
    };
    template<> struct not_equal_to<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) != static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) != static_cast<_Ty2 &&>(_Right));
        }
    };
    template<> struct greater<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) > static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) > static_cast<_Ty2 &&>(_Right));
        }
    };
    template<> struct less<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) < static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) < static_cast<_Ty2 &&>(_Right));
        }
    };
    template<> struct greater_equal<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) >= static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) >= static_cast<_Ty2 &&>(_Right));
        }
    };
    template<> struct less_equal<void> {
        typedef int is_transparent;
        template <class _Ty1, class _Ty2> constexpr auto operator()(_Ty1 &&_Left, _Ty2 &&_Right) const -> decltype(static_cast<_Ty1 &&>(_Left) <= static_cast<_Ty2 &&>(_Right))         {
            return (static_cast<_Ty1 &&>(_Left) <= static_cast<_Ty2 &&>(_Right));
        }
    };
    template <class _Ty> constexpr _Ty *addressof(_Ty &_Val) noexcept     {
        return (__builtin_addressof(_Val));
    }
    template <class _Ty> const _Ty *addressof(const _Ty &&) = delete
    template <class _Ptrty> inline auto _Unfancy(_Ptrty _Ptr)     {
        return (::std::addressof(*_Ptr));
    }
    template<> inline auto _Unfancy<char *>(char *_Ptr)    template <class _Ty> inline _Ty *_Unfancy(_Ty *_Ptr)     {
        return (_Ptr);
    }
    template<> inline char *_Unfancy<char>(char *_Ptr)     {
        return (_Ptr);
    }
}
namespace std {
    typedef enum  {
        denorm_indeterminate = -1,
        denorm_absent = 0,
        denorm_present = 1
    } float_denorm_style;
    typedef enum  {
        round_indeterminate = -1,
        round_toward_zero = 0,
        round_to_nearest = 1,
        round_toward_infinity = 2,
        round_toward_neg_infinity = 3
    } float_round_style;
    struct _Num_base {
        static constexpr std::float_denorm_style has_denorm = (std::float_denorm_style)(denorm_absent);
        static constexpr bool has_denorm_loss = (bool)(false);
        static constexpr bool has_infinity = (bool)(false);
        static constexpr bool has_quiet_NaN = (bool)(false);
        static constexpr bool has_signaling_NaN = (bool)(false);
        static constexpr bool is_bounded = (bool)(false);
        static constexpr bool is_exact = (bool)(false);
        static constexpr bool is_iec559 = (bool)(false);
        static constexpr bool is_integer = (bool)(false);
        static constexpr bool is_modulo = (bool)(false);
        static constexpr bool is_signed = (bool)(false);
        static constexpr bool is_specialized = (bool)(false);
        static constexpr bool tinyness_before = (bool)(false);
        static constexpr bool traps = (bool)(false);
        static constexpr std::float_round_style round_style = (std::float_round_style)(round_toward_zero);
        static constexpr int digits = (int)(0);
        static constexpr int digits10 = (int)(0);
        static constexpr int max_digits10 = (int)(0);
        static constexpr int max_exponent = (int)(0);
        static constexpr int max_exponent10 = (int)(0);
        static constexpr int min_exponent = (int)(0);
        static constexpr int min_exponent10 = (int)(0);
        static constexpr int radix = (int)(0);
    };
    template <class _Ty> class numeric_limits : public std::_Num_base {
    public:
        static constexpr _Ty (min)() noexcept         {
            return (_Ty());
        }
        static constexpr _Ty (max)() noexcept         {
            return (_Ty());
        }
        static constexpr _Ty lowest() noexcept         {
            return (_Ty());
        }
        static constexpr _Ty epsilon() noexcept         {
            return (_Ty());
        }
        static constexpr _Ty round_error() noexcept         {
            return (_Ty());
        }
        static constexpr _Ty denorm_min() noexcept         {
            return (_Ty());
        }
        static constexpr _Ty infinity() noexcept         {
            return (_Ty());
        }
        static constexpr _Ty quiet_NaN() noexcept         {
            return (_Ty());
        }
        static constexpr _Ty signaling_NaN() noexcept         {
            return (_Ty());
        }
    };
    template <class _Ty> class numeric_limits<_Ty> : public numeric_limits<_Ty> {
    };
    template <class _Ty> class numeric_limits<_Ty> : public numeric_limits<_Ty> {
    };
    template <class _Ty> class numeric_limits<_Ty> : public numeric_limits<_Ty> {
    };
    struct _Num_int_base : public std::_Num_base {
        static constexpr bool is_bounded = (bool)(true);
        static constexpr bool is_exact = (bool)(true);
        static constexpr bool is_integer = (bool)(true);
        static constexpr bool is_modulo = (bool)(true);
        static constexpr bool is_specialized = (bool)(true);
        static constexpr int radix = (int)(2);
    };
    struct _Num_float_base : public std::_Num_base {
        static constexpr std::float_denorm_style has_denorm = (std::float_denorm_style)(denorm_present);
        static constexpr bool has_denorm_loss = (bool)(true);
        static constexpr bool has_infinity = (bool)(true);
        static constexpr bool has_quiet_NaN = (bool)(true);
        static constexpr bool has_signaling_NaN = (bool)(true);
        static constexpr bool is_bounded = (bool)(true);
        static constexpr bool is_exact = (bool)(false);
        static constexpr bool is_iec559 = (bool)(true);
        static constexpr bool is_integer = (bool)(false);
        static constexpr bool is_modulo = (bool)(false);
        static constexpr bool is_signed = (bool)(true);
        static constexpr bool is_specialized = (bool)(true);
        static constexpr bool tinyness_before = (bool)(true);
        static constexpr bool traps = (bool)(false);
        static constexpr std::float_round_style round_style = (std::float_round_style)(round_to_nearest);
        static constexpr int radix = (int)(2);
    };
    template<> class numeric_limits<char> : public std::_Num_int_base {
    public:
        typedef char _Ty;
        static constexpr std::numeric_limits<char>::_Ty (min)() noexcept         {
            return ((-127 - 1));
        }
        static constexpr std::numeric_limits<char>::_Ty (max)() noexcept         {
            return (127);
        }
        static constexpr std::numeric_limits<char>::_Ty lowest() noexcept         {
            return ((min)());
        }
        static constexpr std::numeric_limits<char>::_Ty epsilon() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char>::_Ty round_error() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char>::_Ty denorm_min() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char>::_Ty infinity() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char>::_Ty quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char>::_Ty signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = (bool)((-127 - 1) != 0);
        static constexpr int digits = (int)(8 - ((-127 - 1) != 0 ? 1 : 0));
        static constexpr int digits10 = (int)((8 - ((-127 - 1) != 0 ? 1 : 0)) * 301L / 1000);
    };
    template<> class numeric_limits<wchar_t> : public std::_Num_int_base {
    public:
        typedef wchar_t _Ty;
        static constexpr std::numeric_limits<wchar_t>::_Ty (min)() noexcept         {
            return ((std::numeric_limits<wchar_t>::_Ty)0);
        }
        static constexpr std::numeric_limits<wchar_t>::_Ty (max)() noexcept         {
            return ((std::numeric_limits<wchar_t>::_Ty)65535);
        }
        static constexpr std::numeric_limits<wchar_t>::_Ty lowest() noexcept         {
            return ((min)());
        }
        static constexpr std::numeric_limits<wchar_t>::_Ty epsilon() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<wchar_t>::_Ty round_error() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<wchar_t>::_Ty denorm_min() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<wchar_t>::_Ty infinity() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<wchar_t>::_Ty quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<wchar_t>::_Ty signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = (bool)(0 != 0);
        static constexpr int digits = (int)(8 * sizeof(wchar_t) - (0 != 0 ? 1 : 0));
        static constexpr int digits10 = (int)((8 * sizeof(wchar_t) - (0 != 0 ? 1 : 0)) * 301L / 1000);
    };
    template<> class numeric_limits<bool> : public std::_Num_int_base {
    public:
        typedef bool _Ty;
        static constexpr std::numeric_limits<bool>::_Ty (min)() noexcept         {
            return (false);
        }
        static constexpr std::numeric_limits<bool>::_Ty (max)() noexcept         {
            return (true);
        }
        static constexpr std::numeric_limits<bool>::_Ty lowest() noexcept         {
            return ((min)());
        }
        static constexpr std::numeric_limits<bool>::_Ty epsilon() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<bool>::_Ty round_error() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<bool>::_Ty denorm_min() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<bool>::_Ty infinity() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<bool>::_Ty quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<bool>::_Ty signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_modulo = (bool)(false);
        static constexpr bool is_signed = (bool)(false);
        static constexpr int digits = (int)(1);
        static constexpr int digits10 = (int)(0);
    };
    template<> class numeric_limits<signed char> : public std::_Num_int_base {
    public:
        typedef signed char _Ty;
        static constexpr std::numeric_limits<signed char>::_Ty (min)() noexcept         {
            return ((-127 - 1));
        }
        static constexpr std::numeric_limits<signed char>::_Ty (max)() noexcept         {
            return (127);
        }
        static constexpr std::numeric_limits<signed char>::_Ty lowest() noexcept         {
            return ((min)());
        }
        static constexpr std::numeric_limits<signed char>::_Ty epsilon() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<signed char>::_Ty round_error() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<signed char>::_Ty denorm_min() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<signed char>::_Ty infinity() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<signed char>::_Ty quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<signed char>::_Ty signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = (bool)(true);
        static constexpr int digits = (int)(8 - 1);
        static constexpr int digits10 = (int)((8 - 1) * 301L / 1000);
    };
    template<> class numeric_limits<unsigned char> : public std::_Num_int_base {
    public:
        typedef unsigned char _Ty;
        static constexpr std::numeric_limits<unsigned char>::_Ty (min)() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned char>::_Ty (max)() noexcept         {
            return ((127 * 2 + 1));
        }
        static constexpr std::numeric_limits<unsigned char>::_Ty lowest() noexcept         {
            return ((min)());
        }
        static constexpr std::numeric_limits<unsigned char>::_Ty epsilon() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned char>::_Ty round_error() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned char>::_Ty denorm_min() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned char>::_Ty infinity() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned char>::_Ty quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned char>::_Ty signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = (bool)(false);
        static constexpr int digits = (int)(8);
        static constexpr int digits10 = (int)(8 * 301L / 1000);
    };
    template<> class numeric_limits<short> : public std::_Num_int_base {
    public:
        typedef short _Ty;
        static constexpr std::numeric_limits<short>::_Ty (min)() noexcept         {
            return ((-32767 - 1));
        }
        static constexpr std::numeric_limits<short>::_Ty (max)() noexcept         {
            return (32767);
        }
        static constexpr std::numeric_limits<short>::_Ty lowest() noexcept         {
            return ((min)());
        }
        static constexpr std::numeric_limits<short>::_Ty epsilon() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<short>::_Ty round_error() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<short>::_Ty denorm_min() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<short>::_Ty infinity() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<short>::_Ty quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<short>::_Ty signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = (bool)(true);
        static constexpr int digits = (int)(8 * sizeof(short) - 1);
        static constexpr int digits10 = (int)((8 * sizeof(short) - 1) * 301L / 1000);
    };
    template<> class numeric_limits<unsigned short> : public std::_Num_int_base {
    public:
        typedef unsigned short _Ty;
        static constexpr std::numeric_limits<unsigned short>::_Ty (min)() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned short>::_Ty (max)() noexcept         {
            return ((32767 * 2 + 1));
        }
        static constexpr std::numeric_limits<unsigned short>::_Ty lowest() noexcept         {
            return ((min)());
        }
        static constexpr std::numeric_limits<unsigned short>::_Ty epsilon() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned short>::_Ty round_error() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned short>::_Ty denorm_min() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned short>::_Ty infinity() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned short>::_Ty quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned short>::_Ty signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = (bool)(false);
        static constexpr int digits = (int)(8 * sizeof(unsigned short));
        static constexpr int digits10 = (int)(8 * sizeof(unsigned short) * 301L / 1000);
    };
    template<> class numeric_limits<char16_t> : public std::_Num_int_base {
    public:
        typedef char16_t _Ty;
        static constexpr std::numeric_limits<char16_t>::_Ty (min)() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char16_t>::_Ty (max)() noexcept         {
            return ((32767 * 2 + 1));
        }
        static constexpr std::numeric_limits<char16_t>::_Ty lowest() noexcept         {
            return ((min)());
        }
        static constexpr std::numeric_limits<char16_t>::_Ty epsilon() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char16_t>::_Ty round_error() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char16_t>::_Ty denorm_min() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char16_t>::_Ty infinity() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char16_t>::_Ty quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char16_t>::_Ty signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = (bool)(false);
        static constexpr int digits = (int)(8 * sizeof(char16_t));
        static constexpr int digits10 = (int)(8 * sizeof(char16_t) * 301L / 1000);
    };
    template<> class numeric_limits<int> : public std::_Num_int_base {
    public:
        typedef int _Ty;
        static constexpr std::numeric_limits<int>::_Ty (min)() noexcept         {
            return ((-2147483647 - 1));
        }
        static constexpr std::numeric_limits<int>::_Ty (max)() noexcept         {
            return (2147483647);
        }
        static constexpr std::numeric_limits<int>::_Ty lowest() noexcept         {
            return ((min)());
        }
        static constexpr std::numeric_limits<int>::_Ty epsilon() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<int>::_Ty round_error() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<int>::_Ty denorm_min() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<int>::_Ty infinity() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<int>::_Ty quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<int>::_Ty signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = (bool)(true);
        static constexpr int digits = (int)(8 * sizeof(int) - 1);
        static constexpr int digits10 = (int)((8 * sizeof(int) - 1) * 301L / 1000);
    };
    template<> class numeric_limits<unsigned int> : public std::_Num_int_base {
    public:
        typedef unsigned int _Ty;
        static constexpr std::numeric_limits<unsigned int>::_Ty (min)() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned int>::_Ty (max)() noexcept         {
            return ((2147483647 * 2U + 1U));
        }
        static constexpr std::numeric_limits<unsigned int>::_Ty lowest() noexcept         {
            return ((min)());
        }
        static constexpr std::numeric_limits<unsigned int>::_Ty epsilon() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned int>::_Ty round_error() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned int>::_Ty denorm_min() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned int>::_Ty infinity() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned int>::_Ty quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned int>::_Ty signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = (bool)(false);
        static constexpr int digits = (int)(8 * sizeof(unsigned int));
        static constexpr int digits10 = (int)(8 * sizeof(unsigned int) * 301L / 1000);
    };
    template<> class numeric_limits<long> : public std::_Num_int_base {
    public:
        typedef long _Ty;
        static constexpr std::numeric_limits<long>::_Ty (min)() noexcept         {
            return ((-2147483647L - 1L));
        }
        static constexpr std::numeric_limits<long>::_Ty (max)() noexcept         {
            return (2147483647L);
        }
        static constexpr std::numeric_limits<long>::_Ty lowest() noexcept         {
            return ((min)());
        }
        static constexpr std::numeric_limits<long>::_Ty epsilon() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<long>::_Ty round_error() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<long>::_Ty denorm_min() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<long>::_Ty infinity() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<long>::_Ty quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<long>::_Ty signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = (bool)(true);
        static constexpr int digits = (int)(8 * sizeof(long) - 1);
        static constexpr int digits10 = (int)((8 * sizeof(long) - 1) * 301L / 1000);
    };
    template<> class numeric_limits<unsigned long> : public std::_Num_int_base {
    public:
        typedef unsigned long _Ty;
        static constexpr std::numeric_limits<unsigned long>::_Ty (min)() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned long>::_Ty (max)() noexcept         {
            return ((2147483647L * 2UL + 1UL));
        }
        static constexpr std::numeric_limits<unsigned long>::_Ty lowest() noexcept         {
            return ((min)());
        }
        static constexpr std::numeric_limits<unsigned long>::_Ty epsilon() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned long>::_Ty round_error() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned long>::_Ty denorm_min() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned long>::_Ty infinity() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned long>::_Ty quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned long>::_Ty signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = (bool)(false);
        static constexpr int digits = (int)(8 * sizeof(unsigned long));
        static constexpr int digits10 = (int)(8 * sizeof(unsigned long) * 301L / 1000);
    };
    template<> class numeric_limits<char32_t> : public std::_Num_int_base {
    public:
        typedef char32_t _Ty;
        static constexpr std::numeric_limits<char32_t>::_Ty (min)() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char32_t>::_Ty (max)() noexcept         {
            return ((2147483647 * 2U + 1U));
        }
        static constexpr std::numeric_limits<char32_t>::_Ty lowest() noexcept         {
            return ((min)());
        }
        static constexpr std::numeric_limits<char32_t>::_Ty epsilon() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char32_t>::_Ty round_error() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char32_t>::_Ty denorm_min() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char32_t>::_Ty infinity() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char32_t>::_Ty quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<char32_t>::_Ty signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = (bool)(false);
        static constexpr int digits = (int)(8 * sizeof(char32_t));
        static constexpr int digits10 = (int)(8 * sizeof(char32_t) * 301L / 1000);
    };
    template<> class numeric_limits<long long> : public std::_Num_int_base {
    public:
        typedef long long _Ty;
        static constexpr std::numeric_limits<long long>::_Ty (min)() noexcept         {
            return ((-9223372036854775807LL - 1LL));
        }
        static constexpr std::numeric_limits<long long>::_Ty (max)() noexcept         {
            return (9223372036854775807LL);
        }
        static constexpr std::numeric_limits<long long>::_Ty lowest() noexcept         {
            return ((min)());
        }
        static constexpr std::numeric_limits<long long>::_Ty epsilon() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<long long>::_Ty round_error() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<long long>::_Ty denorm_min() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<long long>::_Ty infinity() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<long long>::_Ty quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<long long>::_Ty signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = (bool)(true);
        static constexpr int digits = (int)(8 * sizeof(long long) - 1);
        static constexpr int digits10 = (int)((8 * sizeof(long long) - 1) * 301L / 1000);
    };
    template<> class numeric_limits<unsigned long long> : public std::_Num_int_base {
    public:
        typedef unsigned long long _Ty;
        static constexpr std::numeric_limits<unsigned long long>::_Ty (min)() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned long long>::_Ty (max)() noexcept         {
            return ((9223372036854775807LL * 2ULL + 1ULL));
        }
        static constexpr std::numeric_limits<unsigned long long>::_Ty lowest() noexcept         {
            return ((min)());
        }
        static constexpr std::numeric_limits<unsigned long long>::_Ty epsilon() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned long long>::_Ty round_error() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned long long>::_Ty denorm_min() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned long long>::_Ty infinity() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned long long>::_Ty quiet_NaN() noexcept         {
            return (0);
        }
        static constexpr std::numeric_limits<unsigned long long>::_Ty signaling_NaN() noexcept         {
            return (0);
        }
        static constexpr bool is_signed = (bool)(false);
        static constexpr int digits = (int)(8 * sizeof(unsigned long long));
        static constexpr int digits10 = (int)(8 * sizeof(unsigned long long) * 301L / 1000);
    };
    template<> class numeric_limits<float> : public std::_Num_float_base {
    public:
        typedef float _Ty;
        static constexpr std::numeric_limits<float>::_Ty (min)() noexcept         {
            return (1.17549435E-38F);
        }
        static constexpr std::numeric_limits<float>::_Ty (max)() noexcept         {
            return (3.40282347E+38F);
        }
        static constexpr std::numeric_limits<float>::_Ty lowest() noexcept         {
            return (-(max)());
        }
        static constexpr std::numeric_limits<float>::_Ty epsilon() noexcept         {
            return (1.1920929E-7F);
        }
        static constexpr std::numeric_limits<float>::_Ty round_error() noexcept         {
            return (0.5F);
        }
        static constexpr std::numeric_limits<float>::_Ty denorm_min() noexcept         {
            return (1.40129846E-45F);
        }
        static constexpr std::numeric_limits<float>::_Ty infinity() noexcept         {
            return (__builtin_huge_valf());
        }
        static constexpr std::numeric_limits<float>::_Ty quiet_NaN() noexcept         {
            return (__builtin_nanf("0"));
        }
        static constexpr std::numeric_limits<float>::_Ty signaling_NaN() noexcept         {
            return (__builtin_nansf("1"));
        }
        static constexpr int digits = (int)(24);
        static constexpr int digits10 = (int)(6);
        static constexpr int max_digits10 = (int)(2 + 24 * 301L / 1000);
        static constexpr int max_exponent = (int)((int)128);
        static constexpr int max_exponent10 = (int)((int)38);
        static constexpr int min_exponent = (int)((int)(-125));
        static constexpr int min_exponent10 = (int)((int)(-37));
    };
    template<> class numeric_limits<double> : public std::_Num_float_base {
    public:
        typedef double _Ty;
        static constexpr std::numeric_limits<double>::_Ty (min)() noexcept         {
            return (2.2250738585072014E-308);
        }
        static constexpr std::numeric_limits<double>::_Ty (max)() noexcept         {
            return (1.7976931348623157E+308);
        }
        static constexpr std::numeric_limits<double>::_Ty lowest() noexcept         {
            return (-(max)());
        }
        static constexpr std::numeric_limits<double>::_Ty epsilon() noexcept         {
            return (2.2204460492503131E-16);
        }
        static constexpr std::numeric_limits<double>::_Ty round_error() noexcept         {
            return (0.5);
        }
        static constexpr std::numeric_limits<double>::_Ty denorm_min() noexcept         {
            return (4.9406564584124654E-324);
        }
        static constexpr std::numeric_limits<double>::_Ty infinity() noexcept         {
            return (__builtin_huge_val());
        }
        static constexpr std::numeric_limits<double>::_Ty quiet_NaN() noexcept         {
            return (__builtin_nan("0"));
        }
        static constexpr std::numeric_limits<double>::_Ty signaling_NaN() noexcept         {
            return (__builtin_nans("1"));
        }
        static constexpr int digits = (int)(53);
        static constexpr int digits10 = (int)(15);
        static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);
        static constexpr int max_exponent = (int)((int)1024);
        static constexpr int max_exponent10 = (int)((int)308);
        static constexpr int min_exponent = (int)((int)(-1021));
        static constexpr int min_exponent10 = (int)((int)(-307));
    };
    template<> class numeric_limits<long double> : public std::_Num_float_base {
    public:
        typedef long double _Ty;
        static constexpr std::numeric_limits<long double>::_Ty (min)() noexcept         {
            return (2.2250738585072014E-308L);
        }
        static constexpr std::numeric_limits<long double>::_Ty (max)() noexcept         {
            return (1.7976931348623157E+308L);
        }
        static constexpr std::numeric_limits<long double>::_Ty lowest() noexcept         {
            return (-(max)());
        }
        static constexpr std::numeric_limits<long double>::_Ty epsilon() noexcept         {
            return (2.2204460492503131E-16L);
        }
        static constexpr std::numeric_limits<long double>::_Ty round_error() noexcept         {
            return (0.5L);
        }
        static constexpr std::numeric_limits<long double>::_Ty denorm_min() noexcept         {
            return (4.9406564584124654E-324L);
        }
        static constexpr std::numeric_limits<long double>::_Ty infinity() noexcept         {
            return (__builtin_huge_val());
        }
        static constexpr std::numeric_limits<long double>::_Ty quiet_NaN() noexcept         {
            return (__builtin_nan("0"));
        }
        static constexpr std::numeric_limits<long double>::_Ty signaling_NaN() noexcept         {
            return (__builtin_nans("1"));
        }
        static constexpr int digits = (int)(53);
        static constexpr int digits10 = (int)(15);
        static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);
        static constexpr int max_exponent = (int)((int)1024);
        static constexpr int max_exponent10 = (int)((int)308);
        static constexpr int min_exponent = (int)((int)(-1021));
        static constexpr int min_exponent10 = (int)((int)(-307));
    };
}
namespace std {
    template <class _Ty, _Ty ..._Vals> struct integer_sequence {
        static_assert(is_integral_v<_Ty>, "integer_sequence<T, I...> requires T to be an integral type.");
        using value_type = _Ty;
        static constexpr size_t size() noexcept         {
            return (sizeof...(_Vals));
        }
    };
    template <class _Ty, _Ty _Size> using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;
    template <size_t ..._Vals> using index_sequence = integer_sequence<size_t, _Vals...>;
    template <size_t _Size> using make_index_sequence = make_integer_sequence<size_t, _Size>;
    template <class ..._Types> using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
    template <bool ..._Bools> constexpr bool _None_of_v = is_same_v<integer_sequence<bool, false, _Bools...>, integer_sequence<bool, _Bools..., false> >;
    template <class _Ty, class ..._Types> constexpr bool _Is_any_of_v = !_None_of_v<is_same<_Ty, _Types>::value...>;
    template <class ..._Types> struct _Arg_types {
    };
    template <class _Ty1> struct _Arg_types<<type-parameter-0-0>> {
        typedef _Ty1 argument_type;
    };
    template <class _Ty1, class _Ty2> struct _Arg_types<<type-parameter-0-0, type-parameter-0-1>> {
        typedef _Ty1 first_argument_type;
        typedef _Ty2 second_argument_type;
    };
    template <class _Ty> struct _Is_function {
        using _Bool_type = std::false_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...)> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall))> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) const> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) const> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) volatile> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) volatile> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) const volatile> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) const volatile> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) &> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) &> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) const &> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) const &> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) volatile &> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) volatile &> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) const volatile &> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) const volatile &> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) &&> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) &&> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) const &&> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) const &&> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) volatile &&> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) volatile &&> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) const volatile &&> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall)) const volatile &&> : _Arg_types<_Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...)> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) const> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) volatile> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) const volatile> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) &> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) const &> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) volatile &> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) const volatile &> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) &&> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) const &&> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) volatile &&> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class ..._Types> struct _Is_function<type-parameter-0-0 (type-parameter-0-1..., ...) const volatile &&> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
    };
    template <class _Ty> struct is_function : _Is_function<_Ty>::_Bool_type {
    };
    template <class _Ty> constexpr bool is_function_v = is_function<_Ty>::value;
    template <class _Ty> struct _Is_memfunptr {
        using _Bool_type = std::false_type;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...)> : _Arg_types<_Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall))> : _Arg_types<_Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) const> : _Arg_types<const _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) const> : _Arg_types<const _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) volatile> : _Arg_types<volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) volatile> : _Arg_types<volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) const volatile> : _Arg_types<const volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) const volatile> : _Arg_types<const volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) &> : _Arg_types<_Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) &> : _Arg_types<_Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) const &> : _Arg_types<const _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) const &> : _Arg_types<const _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) &&> : _Arg_types<_Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &&, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) &&> : _Arg_types<_Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &&, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) const &&> : _Arg_types<const _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &&, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) const &&> : _Arg_types<const _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &&, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &&, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &&, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &&, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2...) __attribute__((vectorcall)) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int &&, int &&>, _Ret (_Types...)>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...)> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) const> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) volatile> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) const volatile> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) &> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) const &> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) volatile &> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) const volatile &> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) &&> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) const &&> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) volatile &&> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr<type-parameter-0-0 (type-parameter-0-1::*)(type-parameter-0-2..., ...) const volatile &&> {
        using _Bool_type = std::true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ty> struct is_void : std::false_type {
    };
    template<> struct is_void<void> : std::true_type {
    };
    template<> struct is_void<const void> : std::true_type {
    };
    template<> struct is_void<volatile void> : std::true_type {
    };
    template<> struct is_void<const volatile void> : std::true_type {
    };
    template <class _Ty> constexpr bool is_void_v = is_void<_Ty>::value;
    template <class ..._Types> using void_t = void;
    template <class _Ty> struct add_const {
        using type = const _Ty;
    };
    template <class _Ty> using add_const_t = typename add_const<_Ty>::type;
    template <class _Ty> struct add_volatile {
        using type = volatile _Ty;
    };
    template <class _Ty> using add_volatile_t = typename add_volatile<_Ty>::type;
    template <class _Ty> struct add_cv {
        using type = const volatile _Ty;
    };
    template <class _Ty> using add_cv_t = typename add_cv<_Ty>::type;
    template <class _Ty, class  = void> struct _Add_reference {
        using _Lvalue = _Ty;
        using _Rvalue = _Ty;
    };
template<> struct _Add_reference<v8::internal::ScriptStreamingData, void> {
        using _Lvalue = v8::internal::ScriptStreamingData &;
        using _Rvalue = v8::internal::ScriptStreamingData &&;
    };
template<> struct _Add_reference<v8::WasmStreaming::WasmStreamingImpl, void> {
        using _Lvalue = v8::WasmStreaming::WasmStreamingImpl &;
        using _Rvalue = v8::WasmStreaming::WasmStreamingImpl &&;
    };
    template <class _Ty> struct _Add_reference<_Ty, void> {
        using _Lvalue = _Ty &;
        using _Rvalue = _Ty &&;
    };
    template <class _Ty> struct add_lvalue_reference {
        using type = typename _Add_reference<_Ty>::_Lvalue;
    };
template<> struct add_lvalue_reference<v8::internal::ScriptStreamingData> {
        using type = typename _Add_reference<ScriptStreamingData>::_Lvalue;
    };
template<> struct add_lvalue_reference<v8::WasmStreaming::WasmStreamingImpl> {
        using type = typename _Add_reference<WasmStreamingImpl>::_Lvalue;
    };
    template <class _Ty> using add_lvalue_reference_t = typename add_lvalue_reference<_Ty>::type;
    template <class _Ty> struct add_rvalue_reference {
        using type = typename _Add_reference<_Ty>::_Rvalue;
    };
    template <class _Ty> using add_rvalue_reference_t = typename add_rvalue_reference<_Ty>::type;
    template <class _Ty> add_rvalue_reference_t<_Ty> declval() noexcept;
    template <class _Ty> struct remove_extent {
        using type = _Ty;
    };
template<> struct remove_extent<v8::internal::wasm::NativeModule> {
        using type = v8::internal::wasm::NativeModule;
    };
template<> struct remove_extent<v8::internal::wasm::StreamingDecoder> {
        using type = v8::internal::wasm::StreamingDecoder;
    };
    template <class _Ty, size_t _Ix> struct remove_extent<type-parameter-0-0 [_SizeOfArray]> {
        using type = _Ty;
    };
    template <class _Ty> struct remove_extent<type-parameter-0-0 []> {
        using type = _Ty;
    };
    template <class _Ty> using remove_extent_t = typename remove_extent<_Ty>::type;
    template <class _Ty> struct remove_all_extents {
        using type = _Ty;
    };
    template <class _Ty, size_t _Ix> struct remove_all_extents<type-parameter-0-0 [_SizeOfArray]> {
        using type = typename remove_all_extents<_Ty>::type;
    };
    template <class _Ty> struct remove_all_extents<type-parameter-0-0 []> {
        using type = typename remove_all_extents<_Ty>::type;
    };
    template <class _Ty> using remove_all_extents_t = typename remove_all_extents<_Ty>::type;
    template <class _Ty> struct remove_pointer {
        using type = _Ty;
    };
template<> struct remove_pointer<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >> {
        using type = std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >;
    };
    template <class _Ty> struct remove_pointer<type-parameter-0-0 *> {
        using type = _Ty;
    };
    template <class _Ty> struct remove_pointer<type-parameter-0-0 *const> {
        using type = _Ty;
    };
    template <class _Ty> struct remove_pointer<type-parameter-0-0 *volatile> {
        using type = _Ty;
    };
    template <class _Ty> struct remove_pointer<type-parameter-0-0 *const volatile> {
        using type = _Ty;
    };
    template <class _Ty> using remove_pointer_t = typename remove_pointer<_Ty>::type;
    template <class _Ty, class  = void> struct _Add_pointer {
        using type = _Ty;
    };
    template <class _Ty> struct _Add_pointer<_Ty, void> {
        using type = remove_reference_t<_Ty> *;
    };
    template <class _Ty> struct add_pointer {
        using type = typename _Add_pointer<_Ty>::type;
    };
    template <class _Ty> using add_pointer_t = typename add_pointer<_Ty>::type;
    template <class _Ty> struct is_array : std::false_type {
    };
template<> struct is_array<v8::internal::ScriptStreamingData> : std::false_type {
    };
template<> struct is_array<unsigned char const[]> : std::true_type {
    };
template<> struct is_array<v8::internal::wasm::NativeModule> : std::false_type {
    };
template<> struct is_array<v8::WasmStreaming::WasmStreamingImpl> : std::false_type {
    };
template<> struct is_array<v8::internal::wasm::StreamingDecoder> : std::false_type {
    };
    template <class _Ty, size_t _Nx> struct is_array<type-parameter-0-0 [_SizeOfArray]> : std::true_type {
    };
    template <class _Ty> struct is_array<type-parameter-0-0 []> : std::true_type {
    };
    template <class _Ty> constexpr bool is_array_v = is_array<_Ty>::value;
    template <class _Ty> struct is_lvalue_reference : std::false_type {
    };
template<> struct is_lvalue_reference<std::default_delete<v8::internal::ScriptStreamingData>> : std::false_type {
    };
template<> struct is_lvalue_reference<std::default_delete<unsigned char const[]>> : std::false_type {
    };
template<> struct is_lvalue_reference<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> : std::false_type {
    };
    template <class _Ty> struct is_lvalue_reference<type-parameter-0-0 &> : std::true_type {
    };
    template <class _Ty> constexpr bool is_lvalue_reference_v = is_lvalue_reference<_Ty>::value;
    template <class _Ty> struct is_rvalue_reference : std::false_type {
    };
template<> struct is_rvalue_reference<std::default_delete<v8::internal::ScriptStreamingData>> : std::false_type {
    };
template<> struct is_rvalue_reference<std::default_delete<unsigned char const[]>> : std::false_type {
    };
template<> struct is_rvalue_reference<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> : std::false_type {
    };
    template <class _Ty> struct is_rvalue_reference<type-parameter-0-0 &&> : std::true_type {
    };
    template <class _Ty> constexpr bool is_rvalue_reference_v = is_rvalue_reference<_Ty>::value;
    template <class _Ty> struct is_reference : bool_constant<is_lvalue_reference_v<_Ty> || is_rvalue_reference_v<_Ty> > {
    };
template<> struct is_reference<std::default_delete<v8::internal::ScriptStreamingData>> : bool_constant<is_lvalue_reference_v<std::default_delete<v8::internal::ScriptStreamingData> > || is_rvalue_reference_v<std::default_delete<v8::internal::ScriptStreamingData> > > {
    };
template<> struct is_reference<std::default_delete<unsigned char const[]>> : bool_constant<is_lvalue_reference_v<std::default_delete<unsigned char const[]> > || is_rvalue_reference_v<std::default_delete<unsigned char const[]> > > {
    };
template<> struct is_reference<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> : bool_constant<is_lvalue_reference_v<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > || is_rvalue_reference_v<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > > {
    };
    template <class _Ty> constexpr bool is_reference_v = is_reference<_Ty>::value;
    template <class _Ty, bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value> struct _Is_member_object_pointer : std::false_type {
    };
    template <class _Ty1, class _Ty2> struct _Is_member_object_pointer<type-parameter-0-0 type-parameter-0-1::*, false> : std::true_type {
        using _Class_type = _Ty2;
    };
    template <class _Ty> struct is_member_object_pointer : _Is_member_object_pointer<remove_cv_t<_Ty> >::type {
    };
    template <class _Ty> constexpr bool is_member_object_pointer_v = is_member_object_pointer<_Ty>::value;
    template <class _Ty> struct is_member_function_pointer : _Is_memfunptr<remove_cv_t<_Ty> >::_Bool_type {
    };
    template <class _Ty> constexpr bool is_member_function_pointer_v = is_member_function_pointer<_Ty>::value;
    template <class _Ty> struct _Is_pointer : std::false_type {
    };
template<> struct _Is_pointer<std::default_delete<v8::internal::ScriptStreamingData>> : std::false_type {
    };
template<> struct _Is_pointer<std::default_delete<unsigned char const[]>> : std::false_type {
    };
template<> struct _Is_pointer<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >> : std::false_type {
    };
template<> struct _Is_pointer<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> : std::false_type {
    };
    template <class _Ty> struct _Is_pointer<type-parameter-0-0 *> : std::true_type {
    };
    template <class _Ty> struct is_pointer : _Is_pointer<remove_cv_t<_Ty> >::type {
    };
template<> struct is_pointer<std::default_delete<v8::internal::ScriptStreamingData>> : _Is_pointer<remove_cv_t<default_delete<ScriptStreamingData> > >::type {
    };
template<> struct is_pointer<std::default_delete<unsigned char const[]>> : _Is_pointer<remove_cv_t<default_delete<unsigned char const[]> > >::type {
    };
template<> struct is_pointer<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >> : _Is_pointer<remove_cv_t<unique_ptr<unsigned char const[], default_delete<unsigned char const[]> > > >::type {
    };
template<> struct is_pointer<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> : _Is_pointer<remove_cv_t<default_delete<WasmStreamingImpl> > >::type {
    };
    template <class _Ty> constexpr bool is_pointer_v = is_pointer<_Ty>::value;
    template <class _Ty> struct is_null_pointer : bool_constant<is_same_v<remove_cv_t<_Ty>, std::nullptr_t> > {
    };
    template <class _Ty> constexpr bool is_null_pointer_v = is_null_pointer<_Ty>::value;
    template <class _Ty> struct is_union : bool_constant<__is_union(_Ty)> {
    };
    template <class _Ty> constexpr bool is_union_v = __is_union(_Ty);
    template <class _Ty> struct is_class : bool_constant<__is_class(_Ty)> {
    };
    template <class _Ty> constexpr bool is_class_v = __is_class(_Ty);
    template <class _Ty> struct is_fundamental : bool_constant<is_arithmetic_v<_Ty> || is_void_v<_Ty> || is_null_pointer_v<_Ty> > {
    };
    template <class _Ty> constexpr bool is_fundamental_v = is_fundamental<_Ty>::value;
    template <class _Ty> struct is_object : bool_constant<!is_function_v<_Ty> && !is_reference_v<_Ty> && !is_void_v<_Ty> > {
    };
    template <class _Ty> constexpr bool is_object_v = is_object<_Ty>::value;
    template <class _From, class _To> struct is_convertible : bool_constant<__is_convertible_to(_From, _To)> {
    };
template<> struct is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *> : bool_constant<__is_convertible_to(v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *)> {
    };
template<> struct is_convertible<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData>> : bool_constant<__is_convertible_to(std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData>)> {
    };
template<> struct is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]>> : bool_constant<__is_convertible_to(std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]>)> {
    };
template<> struct is_convertible<unsigned char const (*)[], unsigned char const (*)[]> : bool_constant<__is_convertible_to(unsigned char const (*)[], unsigned char const (*)[])> {
    };
template<> struct is_convertible<v8::internal::wasm::NativeModule *, v8::internal::wasm::NativeModule *> : bool_constant<__is_convertible_to(v8::internal::wasm::NativeModule *, v8::internal::wasm::NativeModule *)> {
    };
template<> struct is_convertible<v8::WasmStreaming::WasmStreamingImpl *, v8::WasmStreaming::WasmStreamingImpl *> : bool_constant<__is_convertible_to(v8::WasmStreaming::WasmStreamingImpl *, v8::WasmStreaming::WasmStreamingImpl *)> {
    };
template<> struct is_convertible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> : bool_constant<__is_convertible_to(std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl>)> {
    };
template<> struct is_convertible<v8::internal::wasm::StreamingDecoder *, v8::internal::wasm::StreamingDecoder *> : bool_constant<__is_convertible_to(v8::internal::wasm::StreamingDecoder *, v8::internal::wasm::StreamingDecoder *)> {
    };
    template <class _From, class _To> constexpr bool is_convertible_v = __is_convertible_to(_From, _To);
    template <class _Ty> struct is_enum : bool_constant<__is_enum(_Ty)> {
    };
    template <class _Ty> constexpr bool is_enum_v = __is_enum(_Ty);
    template <class _Ty> struct is_compound : bool_constant<!is_fundamental_v<_Ty> > {
    };
    template <class _Ty> constexpr bool is_compound_v = is_compound<_Ty>::value;
    template <class _Ty> struct is_member_pointer : bool_constant<is_member_object_pointer_v<_Ty> || is_member_function_pointer_v<_Ty> > {
    };
    template <class _Ty> constexpr bool is_member_pointer_v = is_member_pointer<_Ty>::value;
    template <class _Ty> struct is_scalar : bool_constant<is_arithmetic_v<_Ty> || is_enum_v<_Ty> || is_pointer_v<_Ty> || is_member_pointer_v<_Ty> || is_null_pointer_v<_Ty> > {
    };
    template <class _Ty> constexpr bool is_scalar_v = is_scalar<_Ty>::value;
    template <class _Ty> struct is_const : std::false_type {
    };
template<> struct is_const<char> : std::false_type {
    };
    template <class _Ty> struct is_const<_Ty> : std::true_type {
    };
    template <class _Ty> constexpr bool is_const_v = is_const<_Ty>::value;
    template <class _Ty> struct is_volatile : std::false_type {
    };
    template <class _Ty> struct is_volatile<_Ty> : std::true_type {
    };
    template <class _Ty> constexpr bool is_volatile_v = is_volatile<_Ty>::value;
    template <class _Ty> struct is_pod : bool_constant<__is_pod(_Ty)> {
    };
    template <class _Ty> constexpr bool is_pod_v = __is_pod(_Ty);
    template <class _Ty> struct is_empty : bool_constant<__is_empty(_Ty)> {
    };
    template <class _Ty> constexpr bool is_empty_v = __is_empty(_Ty);
    template <class _Ty> struct is_polymorphic : bool_constant<__is_polymorphic(_Ty)> {
    };
    template <class _Ty> constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);
    template <class _Ty> struct is_abstract : bool_constant<__is_abstract(_Ty)> {
    };
    template <class _Ty> constexpr bool is_abstract_v = __is_abstract(_Ty);
    template <class _Ty> struct is_final : bool_constant<__is_final(_Ty)> {
    };
    template <class _Ty> constexpr bool is_final_v = __is_final(_Ty);
    template <class _Ty> struct is_standard_layout : bool_constant<__is_standard_layout(_Ty)> {
    };
    template <class _Ty> constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);
    template <class _Ty> struct is_literal_type : bool_constant<__is_literal(_Ty)> {
    };
    template <class _Ty> constexpr bool is_literal_type_v = __is_literal(_Ty);
    template <class _Ty> struct is_trivial : bool_constant<__is_trivial(_Ty)> {
    };
    template <class _Ty> constexpr bool is_trivial_v = __is_trivial(_Ty);
    template <class _Ty> struct is_trivially_copyable : bool_constant<__is_trivially_copyable(_Ty)> {
    };
    template <class _Ty> constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);
    template <class _Ty> struct has_virtual_destructor : bool_constant<__has_virtual_destructor(_Ty)> {
    };
    template <class _Ty> constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);
    template <class _Ty, class ..._Args> struct is_constructible : bool_constant<__is_constructible(_Ty, _Args...)> {
    };
template<> struct is_constructible<std::default_delete<v8::internal::ScriptStreamingData>, <>> : bool_constant<__is_constructible(std::default_delete<v8::internal::ScriptStreamingData>)> {
    };
template<> struct is_constructible<std::default_delete<unsigned char const[]>, <>> : bool_constant<__is_constructible(std::default_delete<unsigned char const[]>)> {
    };
template<> struct is_constructible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, <>> : bool_constant<__is_constructible(std::default_delete<v8::WasmStreaming::WasmStreamingImpl>)> {
    };
    template <class _Ty, class ..._Args> constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);
    template <class _Ty> struct is_copy_constructible : is_constructible<_Ty, add_lvalue_reference_t<const _Ty> >::type {
    };
    template <class _Ty> constexpr bool is_copy_constructible_v = is_copy_constructible<_Ty>::value;
    template <class _Ty> struct is_default_constructible : is_constructible<_Ty>::type {
    };
template<> struct is_default_constructible<std::default_delete<v8::internal::ScriptStreamingData>> : is_constructible<default_delete<ScriptStreamingData> >::type {
    };
template<> struct is_default_constructible<std::default_delete<unsigned char const[]>> : is_constructible<default_delete<unsigned char const[]> >::type {
    };
template<> struct is_default_constructible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> : is_constructible<default_delete<WasmStreamingImpl> >::type {
    };
    template <class _Ty> constexpr bool is_default_constructible_v = __is_constructible(_Ty);
    template <class _Ty> struct is_move_constructible : is_constructible<_Ty, _Ty>::type {
    };
    template <class _Ty> constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);
    template <class _To, class _From> struct is_assignable : bool_constant<__is_assignable(_To, _From)> {
    };
template<> struct is_assignable<std::default_delete<v8::internal::ScriptStreamingData> &, std::default_delete<v8::internal::ScriptStreamingData>> : bool_constant<__is_assignable(std::default_delete<v8::internal::ScriptStreamingData> &, std::default_delete<v8::internal::ScriptStreamingData>)> {
    };
template<> struct is_assignable<std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]>> : bool_constant<__is_assignable(std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]>)> {
    };
    template <class _To, class _From> constexpr bool is_assignable_v = __is_assignable(_To, _From);
    template <class _Ty> struct is_copy_assignable : is_assignable<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty> >::type {
    };
    template <class _Ty> constexpr bool is_copy_assignable_v = is_copy_assignable<_Ty>::value;
    template <class _Ty> struct is_move_assignable : is_assignable<add_lvalue_reference_t<_Ty>, _Ty>::type {
    };
    template <class _Ty> constexpr bool is_move_assignable_v = is_move_assignable<_Ty>::value;
    template <class _Ty> struct is_destructible : bool_constant<__is_destructible(_Ty)> {
    };
    template <class _Ty> constexpr bool is_destructible_v = __is_destructible(_Ty);
    template <class _Ty, class ..._Args> struct is_trivially_constructible : bool_constant<__is_trivially_constructible(_Ty, _Args...)> {
    };
    template <class _Ty, class ..._Args> constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);
    template <class _Ty> struct is_trivially_copy_constructible : is_trivially_constructible<_Ty, add_lvalue_reference_t<const _Ty> >::type {
    };
    template <class _Ty> constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<_Ty>::value;
    template <class _Ty> struct is_trivially_default_constructible : is_trivially_constructible<_Ty>::type {
    };
    template <class _Ty> constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);
    template <class _Ty> struct is_trivially_move_constructible : is_trivially_constructible<_Ty, _Ty>::type {
    };
    template <class _Ty> constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);
    template <class _To, class _From> struct is_trivially_assignable : bool_constant<__is_trivially_assignable(_To, _From)> {
    };
    template <class _To, class _From> constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);
    template <class _Ty> struct is_trivially_copy_assignable : is_trivially_assignable<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty> >::type {
    };
    template <class _Ty> constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<_Ty>::value;
    template <class _Ty> struct is_trivially_move_assignable : is_trivially_assignable<add_lvalue_reference_t<_Ty>, _Ty>::type {
    };
    template <class _Ty> constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<_Ty>::value;
    template <class _Ty> struct is_trivially_destructible : bool_constant<__is_trivially_destructible(_Ty)> {
    };
    template <class _Ty> constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);
    template <class _Ty, class ..._Args> struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Args...)> {
    };
    template <class _Ty, class ..._Args> constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);
    template <class _Ty> struct is_nothrow_copy_constructible : is_nothrow_constructible<_Ty, add_lvalue_reference_t<const _Ty> >::type {
    };
    template <class _Ty> constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<_Ty>::value;
    template <class _Ty> struct is_nothrow_default_constructible : is_nothrow_constructible<_Ty>::type {
    };
    template <class _Ty> constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);
    template <class _Ty> struct is_nothrow_move_constructible : is_nothrow_constructible<_Ty, _Ty>::type {
    };
    template <class _Ty> constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);
    template <class _To, class _From> struct is_nothrow_assignable : bool_constant<__is_nothrow_assignable(_To, _From)> {
    };
    template <class _To, class _From> constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);
    template <class _Ty> struct is_nothrow_copy_assignable : is_nothrow_assignable<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty> >::type {
    };
    template <class _Ty> constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<_Ty>::value;
    template <class _Ty> struct is_nothrow_move_assignable : is_nothrow_assignable<add_lvalue_reference_t<_Ty>, _Ty>::type {
    };
    template <class _Ty> constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Ty>::value;
    template <class _Ty> struct is_nothrow_destructible : bool_constant<__is_nothrow_destructible(_Ty)> {
    };
    template <class _Ty> constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);
    template <class _Ty, bool = is_integral_v<_Ty>> struct _Sign_base {
        using _Uty = remove_cv_t<_Ty>;
        using _Signed = bool_constant<std::_Sign_base::_Uty(-1) < std::_Sign_base::_Uty(0)>;
        using _Unsigned = bool_constant<std::_Sign_base::_Uty(0) < std::_Sign_base::_Uty(-1)>;
    };
    template <class _Ty> struct _Sign_base<_Ty, false> {
        using _Signed = typename is_floating_point<_Ty>::type;
        using _Unsigned = std::false_type;
    };
    template <class _Ty> struct is_signed : _Sign_base<_Ty>::_Signed {
    };
    template <class _Ty> constexpr bool is_signed_v = is_signed<_Ty>::value;
    template <class _Ty> struct is_unsigned : _Sign_base<_Ty>::_Unsigned {
    };
    template <class _Ty> constexpr bool is_unsigned_v = is_unsigned<_Ty>::value;
    template <class _Ty> using _Is_nonbool_integral = bool_constant<is_integral_v<_Ty> && !is_same_v<remove_cv_t<_Ty>, bool> >;
    template <class _Ty> struct _Change_sign {
        static_assert(_Is_nonbool_integral<_Ty>::value || is_enum_v<_Ty>, "make_signed<T>/make_unsigned<T> require that T shall be a (possibly cv-qualified) integral type or enumeration but not a bool type.");
        using _Signed = conditional_t<_Is_any_of_v<_Ty, long, unsigned long>, long, conditional_t<sizeof(_Ty) == 1, signed char, conditional_t<sizeof(_Ty) == 2, short, conditional_t<sizeof(_Ty) == 4, int, long long> > > >;
        using _Unsigned = conditional_t<_Is_any_of_v<_Ty, long, unsigned long>, unsigned long, conditional_t<sizeof(_Ty) == 1, unsigned char, conditional_t<sizeof(_Ty) == 2, unsigned short, conditional_t<sizeof(_Ty) == 4, unsigned int, unsigned long long> > > >;
    };
    template <class _Ty> struct _Change_sign<_Ty> {
        using _Signed = const typename _Change_sign<_Ty>::_Signed;
        using _Unsigned = const typename _Change_sign<_Ty>::_Unsigned;
    };
    template <class _Ty> struct _Change_sign<_Ty> {
        using _Signed = volatile typename _Change_sign<_Ty>::_Signed;
        using _Unsigned = volatile typename _Change_sign<_Ty>::_Unsigned;
    };
    template <class _Ty> struct _Change_sign<_Ty> {
        using _Signed = const volatile typename _Change_sign<_Ty>::_Signed;
        using _Unsigned = const volatile typename _Change_sign<_Ty>::_Unsigned;
    };
    template <class _Ty> struct make_signed {
        using type = typename _Change_sign<_Ty>::_Signed;
    };
    template <class _Ty> using make_signed_t = typename make_signed<_Ty>::type;
    template <class _Ty> struct make_unsigned {
        using type = typename _Change_sign<_Ty>::_Unsigned;
    };
    template <class _Ty> using make_unsigned_t = typename make_unsigned<_Ty>::type;
    template <class _Rep> constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val)     {
        return (static_cast<make_unsigned_t<_Rep>>(_Val));
    }
    template <class _Ty> struct alignment_of : integral_constant<size_t, alignof(_Ty)> {
    };
    template <class _Ty> constexpr size_t alignment_of_v = alignof(_Ty);
    template <class _Ty, size_t _Len> union _Align_type {
        _Ty _Val;
        char _Pad[_Len];
    };
    template <size_t _Len, size_t _Align, class _Ty, bool _Ok> struct _Aligned;
    template <size_t _Len, size_t _Align, class _Ty> struct _Aligned<_Len, _Align, _Ty, true> {
        using type = _Align_type<_Ty, _Len>;
    };
    template <size_t _Len, size_t _Align> struct _Aligned<_Len, _Align, double, false> {
        using type = _Align_type<std::max_align_t, _Len>;
    };
    template <size_t _Len, size_t _Align> struct _Aligned<_Len, _Align, int, false> {
        using type = typename _Aligned<_Len, _Align, double, _Align <= alignof(double)>::type;
    };
    template <size_t _Len, size_t _Align> struct _Aligned<_Len, _Align, short, false> {
        using type = typename _Aligned<_Len, _Align, int, _Align <= alignof(int)>::type;
    };
    template <size_t _Len, size_t _Align> struct _Aligned<_Len, _Align, char, false> {
        using type = typename _Aligned<_Len, _Align, short, _Align <= alignof(short)>::type;
    };
    template <size_t _Len, size_t _Align = alignof(std::max_align_t)> struct aligned_storage {
        using type = typename _Aligned<_Len, _Align, char, _Align <= alignof(char)>::type;
    };
    template <size_t _Len, size_t _Align = alignof(std::max_align_t)> using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
    template <size_t ..._Vals> struct _Maximum;
    template<> struct _Maximum<<>> : integral_constant<size_t, 0> {
    };
    template <size_t _Val> struct _Maximum<<_Val>> : integral_constant<size_t, _Val> {
    };
    template <size_t _First, size_t _Second, size_t ..._Rest> struct _Maximum<<_First, _Second, _Rest...>> : _Maximum<(_First < _Second ? _Second : _First), _Rest...>::type {
    };
    template <size_t _Len, class ..._Types> struct aligned_union {
        static constexpr size_t _Max_len = _Maximum<_Len, sizeof(_Types)...>::value;
        static constexpr size_t alignment_value = _Maximum<alignof(_Types)...>::value;
        using type = aligned_storage_t<_Max_len, alignment_value>;
    };
    template <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
    template <class _Ty> struct underlying_type {
        using type = __underlying_type(_Ty);
    };
    template <class _Ty> using underlying_type_t = typename underlying_type<_Ty>::type;
    template <class _Ty> struct rank : integral_constant<size_t, 0> {
    };
    template <class _Ty, size_t _Ix> struct rank<type-parameter-0-0 [_SizeOfArray]> : integral_constant<size_t, rank<_Ty>::value + 1> {
    };
    template <class _Ty> struct rank<type-parameter-0-0 []> : integral_constant<size_t, rank<_Ty>::value + 1> {
    };
    template <class _Ty> constexpr size_t rank_v = rank<_Ty>::value;
    template <class _Ty, unsigned int _Nx> struct _Extent : integral_constant<size_t, 0> {
    };
    template <class _Ty, size_t _Ix> struct _Extent<type-parameter-0-0 [_SizeOfArray], 0> : integral_constant<size_t, _Ix> {
    };
    template <class _Ty, unsigned int _Nx, size_t _Ix> struct _Extent<type-parameter-0-0 [_Ix], _Nx> : _Extent<_Ty, _Nx - 1> {
    };
    template <class _Ty, unsigned int _Nx> struct _Extent<type-parameter-0-0 [], _Nx> : _Extent<_Ty, _Nx - 1> {
    };
    template <class _Ty, unsigned int _Nx = 0> struct extent : _Extent<_Ty, _Nx> {
    };
    template <class _Ty, unsigned int _Ix = 0> constexpr size_t extent_v = extent<_Ty, _Ix>::value;
    template <class _Base, class _Derived> struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)> {
    };
    template <class _Base, class _Derived> constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);
    template <class _Ty> struct decay {
        using _Ty1 = remove_reference_t<_Ty>;
        using type = conditional_t<is_array_v<std::decay::_Ty1>, add_pointer_t<remove_extent_t<std::decay::_Ty1> >, conditional_t<is_function_v<std::decay::_Ty1>, add_pointer_t<std::decay::_Ty1>, remove_cv_t<std::decay::_Ty1> > >;
    };
    template <class _Ty> using decay_t = typename decay<_Ty>::type;
    template <bool _First_value, class _First, class ..._Rest> struct _Conjunction {
        using type = _First;
    };
template<> struct _Conjunction<true, std::negation<std::is_pointer<std::default_delete<v8::internal::ScriptStreamingData> > >, <std::is_default_constructible<std::default_delete<v8::internal::ScriptStreamingData> >>> {
        using type = typename _Conjunction<is_default_constructible<default_delete<ScriptStreamingData> >::value, is_default_constructible<default_delete<ScriptStreamingData> > >::type;
    };
template<> struct _Conjunction<true, std::is_default_constructible<std::default_delete<v8::internal::ScriptStreamingData> >, <>> {
        using type = std::is_default_constructible<std::default_delete<v8::internal::ScriptStreamingData> >;
    };
template<> struct _Conjunction<true, std::negation<std::is_array<v8::internal::ScriptStreamingData> >, <std::is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *>, std::is_convertible<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData> >>> {
        using type = typename _Conjunction<is_convertible<ScriptStreamingData *, ScriptStreamingData *>::value, is_convertible<ScriptStreamingData *, ScriptStreamingData *>, is_convertible<default_delete<ScriptStreamingData>, default_delete<ScriptStreamingData> > >::type;
    };
template<> struct _Conjunction<true, std::is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *>, <std::is_convertible<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData> >>> {
        using type = typename _Conjunction<is_convertible<default_delete<ScriptStreamingData>, default_delete<ScriptStreamingData> >::value, is_convertible<default_delete<ScriptStreamingData>, default_delete<ScriptStreamingData> > >::type;
    };
template<> struct _Conjunction<true, std::is_convertible<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData> >, <>> {
        using type = std::is_convertible<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData> >;
    };
template<> struct _Conjunction<true, std::negation<std::is_array<v8::internal::ScriptStreamingData> >, <std::is_assignable<std::default_delete<v8::internal::ScriptStreamingData> &, std::default_delete<v8::internal::ScriptStreamingData> >, std::is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *>>> {
        using type = typename _Conjunction<is_assignable<default_delete<ScriptStreamingData> &, default_delete<ScriptStreamingData> >::value, is_assignable<default_delete<ScriptStreamingData> &, default_delete<ScriptStreamingData> >, is_convertible<ScriptStreamingData *, ScriptStreamingData *> >::type;
    };
template<> struct _Conjunction<true, std::is_assignable<std::default_delete<v8::internal::ScriptStreamingData> &, std::default_delete<v8::internal::ScriptStreamingData> >, <std::is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *>>> {
        using type = typename _Conjunction<is_convertible<ScriptStreamingData *, ScriptStreamingData *>::value, is_convertible<ScriptStreamingData *, ScriptStreamingData *> >::type;
    };
template<> struct _Conjunction<true, std::is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *>, <>> {
        using type = std::is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *>;
    };
template<> struct _Conjunction<true, std::negation<std::is_pointer<std::default_delete<unsigned char const[]> > >, <std::is_default_constructible<std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_default_constructible<default_delete<unsigned char const[]> >::value, is_default_constructible<default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_default_constructible<std::default_delete<unsigned char const[]> >, <>> {
        using type = std::is_default_constructible<std::default_delete<unsigned char const[]> >;
    };
template<> struct _Conjunction<true, std::is_array<unsigned char const[]>, <std::is_same<const unsigned char *, const unsigned char *>, std::is_same<const unsigned char *, const unsigned char *>, std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_same<const unsigned char *, const unsigned char *>::value, is_same<const unsigned char *, const unsigned char *>, is_same<const unsigned char *, const unsigned char *>, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_convertible<default_delete<unsigned char const[]>, default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_same<const unsigned char *, const unsigned char *>, <std::is_same<const unsigned char *, const unsigned char *>, std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_same<const unsigned char *, const unsigned char *>::value, is_same<const unsigned char *, const unsigned char *>, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_convertible<default_delete<unsigned char const[]>, default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_same<const unsigned char *, const unsigned char *>, <std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_convertible<unsigned char const (*)[], unsigned char const (*)[]>::value, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_convertible<default_delete<unsigned char const[]>, default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, <std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_convertible<default_delete<unsigned char const[]>, default_delete<unsigned char const[]> >::value, is_convertible<default_delete<unsigned char const[]>, default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >, <>> {
        using type = std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >;
    };
template<> struct _Conjunction<true, std::is_array<unsigned char const[]>, <std::is_same<const unsigned char *, const unsigned char *>, std::is_same<const unsigned char *, const unsigned char *>, std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, std::is_assignable<std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_same<const unsigned char *, const unsigned char *>::value, is_same<const unsigned char *, const unsigned char *>, is_same<const unsigned char *, const unsigned char *>, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_assignable<default_delete<unsigned char const[]> &, default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_same<const unsigned char *, const unsigned char *>, <std::is_same<const unsigned char *, const unsigned char *>, std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, std::is_assignable<std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_same<const unsigned char *, const unsigned char *>::value, is_same<const unsigned char *, const unsigned char *>, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_assignable<default_delete<unsigned char const[]> &, default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_same<const unsigned char *, const unsigned char *>, <std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, std::is_assignable<std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_convertible<unsigned char const (*)[], unsigned char const (*)[]>::value, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_assignable<default_delete<unsigned char const[]> &, default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, <std::is_assignable<std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]> >>> {
        using type = typename _Conjunction<is_assignable<default_delete<unsigned char const[]> &, default_delete<unsigned char const[]> >::value, is_assignable<default_delete<unsigned char const[]> &, default_delete<unsigned char const[]> > >::type;
    };
template<> struct _Conjunction<true, std::is_assignable<std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]> >, <>> {
        using type = std::is_assignable<std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]> >;
    };
template<> struct _Conjunction<true, std::negation<std::is_pointer<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > >, <std::is_default_constructible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >>> {
        using type = typename _Conjunction<is_default_constructible<default_delete<WasmStreamingImpl> >::value, is_default_constructible<default_delete<WasmStreamingImpl> > >::type;
    };
template<> struct _Conjunction<true, std::is_default_constructible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >, <>> {
        using type = std::is_default_constructible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >;
    };
template<> struct _Conjunction<true, std::negation<std::is_array<v8::WasmStreaming::WasmStreamingImpl> >, <std::is_convertible<v8::WasmStreaming::WasmStreamingImpl *, v8::WasmStreaming::WasmStreamingImpl *>, std::is_convertible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >>> {
        using type = typename _Conjunction<is_convertible<WasmStreamingImpl *, WasmStreamingImpl *>::value, is_convertible<WasmStreamingImpl *, WasmStreamingImpl *>, is_convertible<default_delete<WasmStreamingImpl>, default_delete<WasmStreamingImpl> > >::type;
    };
template<> struct _Conjunction<true, std::is_convertible<v8::WasmStreaming::WasmStreamingImpl *, v8::WasmStreaming::WasmStreamingImpl *>, <std::is_convertible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >>> {
        using type = typename _Conjunction<is_convertible<default_delete<WasmStreamingImpl>, default_delete<WasmStreamingImpl> >::value, is_convertible<default_delete<WasmStreamingImpl>, default_delete<WasmStreamingImpl> > >::type;
    };
template<> struct _Conjunction<true, std::is_convertible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >, <>> {
        using type = std::is_convertible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >;
    };
    template <class _True, class _Next, class ..._Rest> struct _Conjunction<true, _True, <type-parameter-0-1, type-parameter-0-2...>> {
        using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;
    };
    template <class ..._Traits> struct conjunction : std::true_type {
    };
template<> struct conjunction<<std::negation<std::is_pointer<std::default_delete<v8::internal::ScriptStreamingData> > >, std::is_default_constructible<std::default_delete<v8::internal::ScriptStreamingData> >>> : _Conjunction<negation<is_pointer<default_delete<ScriptStreamingData> > >::value, negation<is_pointer<default_delete<ScriptStreamingData> > >, is_default_constructible<default_delete<ScriptStreamingData> > >::type {
    };
template<> struct conjunction<<std::negation<std::is_array<v8::internal::ScriptStreamingData> >, std::is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *>, std::is_convertible<std::default_delete<v8::internal::ScriptStreamingData>, std::default_delete<v8::internal::ScriptStreamingData> >>> : _Conjunction<negation<is_array<ScriptStreamingData> >::value, negation<is_array<ScriptStreamingData> >, is_convertible<ScriptStreamingData *, ScriptStreamingData *>, is_convertible<default_delete<ScriptStreamingData>, default_delete<ScriptStreamingData> > >::type {
    };
template<> struct conjunction<<std::negation<std::is_array<v8::internal::ScriptStreamingData> >, std::is_assignable<std::default_delete<v8::internal::ScriptStreamingData> &, std::default_delete<v8::internal::ScriptStreamingData> >, std::is_convertible<v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *>>> : _Conjunction<negation<is_array<ScriptStreamingData> >::value, negation<is_array<ScriptStreamingData> >, is_assignable<default_delete<ScriptStreamingData> &, default_delete<ScriptStreamingData> >, is_convertible<ScriptStreamingData *, ScriptStreamingData *> >::type {
    };
template<> struct conjunction<<std::negation<std::is_pointer<std::default_delete<unsigned char const[]> > >, std::is_default_constructible<std::default_delete<unsigned char const[]> >>> : _Conjunction<negation<is_pointer<default_delete<unsigned char const[]> > >::value, negation<is_pointer<default_delete<unsigned char const[]> > >, is_default_constructible<default_delete<unsigned char const[]> > >::type {
    };
template<> struct conjunction<<std::is_array<unsigned char const[]>, std::is_same<const unsigned char *, const unsigned char *>, std::is_same<const unsigned char *, const unsigned char *>, std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, std::is_convertible<std::default_delete<unsigned char const[]>, std::default_delete<unsigned char const[]> >>> : _Conjunction<is_array<unsigned char const[]>::value, is_array<unsigned char const[]>, is_same<const unsigned char *, const unsigned char *>, is_same<const unsigned char *, const unsigned char *>, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_convertible<default_delete<unsigned char const[]>, default_delete<unsigned char const[]> > >::type {
    };
template<> struct conjunction<<std::is_array<unsigned char const[]>, std::is_same<const unsigned char *, const unsigned char *>, std::is_same<const unsigned char *, const unsigned char *>, std::is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, std::is_assignable<std::default_delete<unsigned char const[]> &, std::default_delete<unsigned char const[]> >>> : _Conjunction<is_array<unsigned char const[]>::value, is_array<unsigned char const[]>, is_same<const unsigned char *, const unsigned char *>, is_same<const unsigned char *, const unsigned char *>, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_assignable<default_delete<unsigned char const[]> &, default_delete<unsigned char const[]> > >::type {
    };
template<> struct conjunction<<std::negation<std::is_pointer<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > >, std::is_default_constructible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >>> : _Conjunction<negation<is_pointer<default_delete<WasmStreamingImpl> > >::value, negation<is_pointer<default_delete<WasmStreamingImpl> > >, is_default_constructible<default_delete<WasmStreamingImpl> > >::type {
    };
template<> struct conjunction<<std::negation<std::is_array<v8::WasmStreaming::WasmStreamingImpl> >, std::is_convertible<v8::WasmStreaming::WasmStreamingImpl *, v8::WasmStreaming::WasmStreamingImpl *>, std::is_convertible<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >>> : _Conjunction<negation<is_array<WasmStreamingImpl> >::value, negation<is_array<WasmStreamingImpl> >, is_convertible<WasmStreamingImpl *, WasmStreamingImpl *>, is_convertible<default_delete<WasmStreamingImpl>, default_delete<WasmStreamingImpl> > >::type {
    };
    template <class _First, class ..._Rest> struct conjunction<<type-parameter-0-0, type-parameter-0-1...>> : _Conjunction<_First::value, _First, _Rest...>::type {
    };
    template <class ..._Traits> constexpr bool conjunction_v = conjunction<_Traits...>::value;
    template <class ..._Traits> using _Conjunction_t = typename conjunction<_Traits...>::type;
    template <bool _First_value, class _First, class ..._Rest> struct _Disjunction {
        using type = _First;
    };
    template <class _False, class _Next, class ..._Rest> struct _Disjunction<false, _False, <type-parameter-0-1, type-parameter-0-2...>> {
        using type = typename _Disjunction<_Next::value, _Next, _Rest...>::type;
    };
    template <class ..._Traits> struct disjunction : std::false_type {
    };
    template <class _First, class ..._Rest> struct disjunction<<type-parameter-0-0, type-parameter-0-1...>> : _Disjunction<_First::value, _First, _Rest...>::type {
    };
    template <class ..._Traits> constexpr bool disjunction_v = disjunction<_Traits...>::value;
    template <class ..._Traits> using _Disjunction_t = typename disjunction<_Traits...>::type;
    template <class _Trait> struct negation : bool_constant<!static_cast<bool>(_Trait::value)> {
    };
template<> struct negation<std::is_pointer<std::default_delete<v8::internal::ScriptStreamingData> >> : bool_constant<!static_cast<bool>(is_pointer<default_delete<ScriptStreamingData> >::value)> {
    };
template<> struct negation<std::is_array<v8::internal::ScriptStreamingData>> : bool_constant<!static_cast<bool>(is_array<ScriptStreamingData>::value)> {
    };
template<> struct negation<std::is_pointer<std::default_delete<unsigned char const[]> >> : bool_constant<!static_cast<bool>(is_pointer<default_delete<unsigned char const[]> >::value)> {
    };
template<> struct negation<std::is_pointer<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >> : bool_constant<!static_cast<bool>(is_pointer<default_delete<WasmStreamingImpl> >::value)> {
    };
template<> struct negation<std::is_array<v8::WasmStreaming::WasmStreamingImpl>> : bool_constant<!static_cast<bool>(is_array<WasmStreamingImpl>::value)> {
    };
    template <class _Trait> constexpr bool negation_v = negation<_Trait>::value;
    struct _Unique_tag_common_type {
    };
    template <class _Ty1, class _Ty2, class  = void> struct _Decayed_cond_oper {
    };
    template <class _Ty1, class _Ty2> struct _Decayed_cond_oper<_Ty1, _Ty2, void> {
        using type = decay_t<decltype(false ? ::std::declval<_Ty1>() : ::std::declval<_Ty2>())>;
    };
    template <class ..._Ty> struct common_type;
    template <class ..._Ty> using common_type_t = typename common_type<_Ty...>::type;
    template<> struct common_type<<>> {
    };
    template <class _Ty1> struct common_type<<type-parameter-0-0>> : common_type<_Ty1, _Ty1> {
    };
    template <class _Ty1, class _Ty2, class _Decayed1 = decay_t<_Ty1>, class _Decayed2 = decay_t<_Ty2>> struct _Common_type2 : common_type<_Decayed1, _Decayed2> {
    };
    template <class _Ty1, class _Ty2> struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2> : _Decayed_cond_oper<_Ty1, _Ty2> {
    };
    template <class _Ty1, class _Ty2> struct common_type<<type-parameter-0-0, type-parameter-0-1>> : _Common_type2<_Ty1, _Ty2> {
    };
    template <class _Void, class _Ty1, class _Ty2, class ..._Rest> struct _Common_type3 {
    };
    template <class _Ty1, class _Ty2, class ..._Rest> struct _Common_type3<void, _Ty1, _Ty2, <type-parameter-0-2...>> : common_type<common_type_t<_Ty1, _Ty2>, _Rest...> {
    };
    template <class _Ty1, class _Ty2, class ..._Rest> struct common_type<<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2...>> : _Common_type3<void, _Ty1, _Ty2, _Rest...> {
    };
    template <class _Ty> struct [[deprecated("warning STL4003: The non-Standard std::identity struct is deprecated and will be REMOVED. You can define _SILENCE_IDENTITY_STRUCT_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] identity {
        using type = _Ty;
        const _Ty &operator()(const _Ty &_Left) const     };
    template <class _Ty> struct _Identity {
        using type = _Ty;
    };
    template <class _Ty> using _Identity_t = typename _Identity<_Ty>::type;
    template <class _Type, template <class ...> class _Template> struct _Is_specialization : std::false_type {
    };
template<> struct _Is_specialization<std::char_traits<char>, char_traits> : std::true_type {
    };
    template <template <class ...> class _Template, class ..._Types> struct _Is_specialization<<type-parameter-0-1...>, _Template> : std::true_type {
    };
    template <class _Ty> constexpr _Ty &&forward(remove_reference_t<_Ty> &_Arg) noexcept     {
        return (static_cast<_Ty &&>(_Arg));
    }
    template<> constexpr const unsigned char *&forward<const unsigned char *&>(remove_reference_t<const unsigned char *&> &_Arg) noexcept     {
        return (static_cast<const unsigned char *&>(_Arg));
    }
    template<> constexpr std::default_delete<unsigned char const[]> &&forward<std::default_delete<unsigned char const[]>>(remove_reference_t<std::default_delete<unsigned char const[]> > &_Arg) noexcept     {
        return (static_cast<std::default_delete<unsigned char const[]> &&>(_Arg));
    }
    template <class _Ty> constexpr _Ty &&forward(remove_reference_t<_Ty> &&_Arg) noexcept     {
        static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
        return (static_cast<_Ty &&>(_Arg));
    }
    template <class _Ty> constexpr remove_reference_t<_Ty> &&move(_Ty &&_Arg) noexcept     {
        return (static_cast<remove_reference_t<_Ty> &&>(_Arg));
    }
    template<> constexpr remove_reference_t<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &> &&move<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &>(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &_Arg) noexcept     {
        return (static_cast<remove_reference_t<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &> &&>(_Arg));
    }
    template<> constexpr remove_reference_t<std::shared_ptr<v8::internal::wasm::NativeModule> &> &&move<std::shared_ptr<v8::internal::wasm::NativeModule> &>(std::shared_ptr<v8::internal::wasm::NativeModule> &_Arg) noexcept     {
        return (static_cast<remove_reference_t<std::shared_ptr<v8::internal::wasm::NativeModule> &> &&>(_Arg));
    }
    template<> constexpr remove_reference_t<v8::OwnedBuffer &> &&move<v8::OwnedBuffer &>(v8::OwnedBuffer &_Arg) noexcept     {
        return (static_cast<remove_reference_t<v8::OwnedBuffer &> &&>(_Arg));
    }
    template <class _Ty> constexpr conditional_t<!is_nothrow_move_constructible_v<_Ty> && is_copy_constructible_v<_Ty>, const _Ty &, _Ty &&> move_if_noexcept(_Ty &_Arg) noexcept     {
        return (::std::move(_Arg));
    }
    template <class _Ty> class reference_wrapper;
    template <class _Callable, class ..._Types> struct _Invoker;
    template <class _Callable, class ..._Types> inline auto invoke(_Callable &&_Obj, _Types &&..._Args) noexcept(noexcept(_Invoker<_Callable, _Types...>::_Call(::std::forward<_Callable>(_Obj), ::std::forward<_Types>(_Args)...))invoke(_Callable &&_Obj, _Types &&..._Args) noexcept(noexcept(_Invoker<_Callable, _Types...>::_Call(::std::forward<_Callable>(_Obj), ::std::forward<_Types>(_Args)...))) -> decltype(_Invoker<_Callable, _Types...>::_Call(::std::forward<_Callable>(_Obj), ::std::forward<_Types>(_Args)...));
    struct _Unforced {
    };
    template <class _To> void _Implicitly_convert_to(_To) noexcept;
    template <class _From, class _To, bool = is_convertible_v<_From, _To>> struct _Is_nothrow_convertible : bool_constant<noexcept(_Implicitly_convert_to<_To>(::std::declval<_From>()))> {
    };
    template <class _From, class _To> struct _Is_nothrow_convertible<_From, _To, false> : std::false_type {
    };
    struct _Unique_tag_invoke_traits {
    };
    template <class _Void, class ..._Types> struct _Invoke_traits {
        using _Is_invocable = std::false_type;
        using _Is_nothrow_invocable = std::false_type;
        template <class _Rx> using _Is_invocable_r = std::false_type;
        template <class _Rx> using _Is_nothrow_invocable_r = std::false_type;
    };
    template <class ..._Types> struct _Invoke_traits<void, <type-parameter-0-0...>> {
        using type = decltype(::std::invoke(::std::declval<_Types>()...));
        using _Is_invocable = std::true_type;
        using _Is_nothrow_invocable = bool_constant<noexcept(::std::invoke(::std::declval<_Types>()...))>;
        template <class _Rx> using _Is_invocable_r = _Disjunction_t<is_void<_Rx>, is_convertible<std::_Invoke_traits<void, type-parameter-0-0...>::type, _Rx> >;
        template <class _Rx> using _Is_nothrow_invocable_r = _Conjunction_t<std::_Invoke_traits<void, type-parameter-0-0...>::_Is_nothrow_invocable, disjunction<is_void<_Rx>, _Is_nothrow_convertible<std::_Invoke_traits<void, type-parameter-0-0...>::type, _Rx> > >;
    };
    template <class _Fty> struct result_of {
        static_assert(_Always_false<_Fty>::value, "result_of<CallableType> is invalid; use result_of<CallableType(zero or more argument types)> instead.");
    };
    template <class _Callable, class ..._Args> struct result_of<type-parameter-0-0 (type-parameter-0-1...)> : _Invoke_traits<void, _Callable, _Args...> {
    };
    template <class _Callable, class ..._Args> struct result_of<type-parameter-0-0 (type-parameter-0-1...) __attribute__((vectorcall))> : _Invoke_traits<void, _Callable, _Args...> {
    };
    template <class _Ty> using result_of_t = typename result_of<_Ty>::type;
    template <class _Callable, class ..._Args> using _Invoke_result_t = typename _Invoke_traits<void, _Callable, _Args...>::type;
    template <class _Rx, class _Callable, class ..._Args> using _Is_invocable_r_ = typename _Invoke_traits<void, _Callable, _Args...>::_Is_invocable_r<_Rx>;
    template <class _Rx, class _Callable, class ..._Args> struct _Is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...> {
    };
    template <class _Ty, class  = void> struct _Weak_result_type {
    };
    template <class _Ty> struct _Weak_result_type<_Ty, void> {
        typedef typename _Ty::result_type result_type;
    };
    template <class _Ty, class  = void> struct _Weak_argument_type : _Weak_result_type<_Ty> {
    };
    template <class _Ty> struct _Weak_argument_type<_Ty, void> : _Weak_result_type<_Ty> {
        typedef typename _Ty::argument_type argument_type;
    };
    template <class _Ty, class  = void> struct _Weak_binary_args : _Weak_argument_type<_Ty> {
    };
    template <class _Ty> struct _Weak_binary_args<_Ty, void> : _Weak_argument_type<_Ty> {
        typedef typename _Ty::first_argument_type first_argument_type;
        typedef typename _Ty::second_argument_type second_argument_type;
    };
    template <class _Ty> struct _Weak_types {
        using _Is_f_or_pf = _Is_function<remove_pointer_t<_Ty> >;
        using _Is_pmf = _Is_memfunptr<remove_cv_t<_Ty> >;
        using type = conditional_t<_Is_f_or_pf::_Bool_type::value, std::_Weak_types::_Is_f_or_pf, conditional_t<_Is_pmf::_Bool_type::value, std::_Weak_types::_Is_pmf, _Weak_binary_args<_Ty> > >;
    };
    template <class _Ty> class reference_wrapper : public _Weak_types<_Ty>::type {
    public:
        static_assert(is_object_v<_Ty> || is_function_v<_Ty>, "reference_wrapper<T> requires T to be an object type or a function type.");
        using type = _Ty;
        reference_wrapper<_Ty>(_Ty &_Val) noexcept         operator _Ty &() const noexcept         _Ty &get() const noexcept         template <class ..._Types> auto operator()(_Types &&..._Args) const -> decltype(::std::invoke(this->get(), ::std::forward<_Types>(_Args)...))         reference_wrapper<_Ty>(_Ty &&) = delete
    private:
        _Ty *_Ptr;
    };
    template <class _Ty> inline reference_wrapper<_Ty> ref(_Ty &_Val) noexcept     template <class _Ty> void ref(const _Ty &&) = delete
    template <class _Ty> inline reference_wrapper<_Ty> ref(reference_wrapper<_Ty> _Val) noexcept     template <class _Ty> inline reference_wrapper<const _Ty> cref(const _Ty &_Val) noexcept     template <class _Ty> void cref(const _Ty &&) = delete
    template <class _Ty> inline reference_wrapper<const _Ty> cref(reference_wrapper<_Ty> _Val) noexcept     template <class _Ty> struct _Is_swappable;
    template <class _Ty> struct _Is_nothrow_swappable;
    template <class _Ty, class  = void> inline void swap(_Ty &, _Ty &) noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>swap(_Ty &, _Ty &) noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>);
    template <class _Ty, size_t _Size, class  = enable_if_t<_Is_swappable<_Ty>::value>> inline void swap(_Ty (&)[_Size], _Ty (&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::valueswap(_Ty (&)[_Size], _Ty (&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value);
    template <class _Ty1, class _Ty2, class  = void> struct _Swappable_with_helper : std::false_type {
    };
    struct _Swappable_with_helper_unique_type {
    };
    template <class _Ty1, class _Ty2> struct _Swappable_with_helper<_Ty1, _Ty2, void> : std::true_type {
    };
    template <class _Ty1, class _Ty2> struct _Is_swappable_with : _Conjunction_t<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1> > {
    };
    template <class _Ty> struct _Is_swappable : _Is_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty> >::type {
    };
    template <class _Ty1, class _Ty2> struct _Swap_cannot_throw : bool_constant<noexcept(swap(::std::declval<_Ty1>(), ::std::declval<_Ty2>())) && noexcept(swap(::std::declval<_Ty2>(), ::std::declval<_Ty1>()))> {
    };
    template <class _Ty1, class _Ty2> struct _Is_nothrow_swappable_with : _Conjunction_t<_Is_swappable_with<_Ty1, _Ty2>, _Swap_cannot_throw<_Ty1, _Ty2> > {
    };
    template <class _Ty> struct _Is_nothrow_swappable : _Is_nothrow_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty> >::type {
    };
    namespace _Has_ADL_swap_detail {
        void swap();
        struct _Has_ADL_swap_unique_type {
        };
        template <class , class  = void> struct _Has_ADL_swap : std::false_type {
        };
        template <class _Ty> struct _Has_ADL_swap<_Ty, void> : std::true_type {
        };
    }
    using _Has_ADL_swap_detail::_Has_ADL_swap;
    template <class _Ty> struct _Is_trivially_swappable : _Conjunction_t<is_trivially_destructible<_Ty>, is_trivially_move_constructible<_Ty>, is_trivially_move_assignable<_Ty>, negation<_Has_ADL_swap<_Ty> > > {
    };
    template <class _Ty> constexpr bool _Is_trivially_swappable_v = _Is_trivially_swappable<_Ty>::value;
    struct _Fnv1a_hasher {
        static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
        size_t _Val = 14695981039346656037ULL;
        static constexpr size_t _FNV_prime = 1099511628211ULL;
        size_t _Add_bytes(const unsigned char *_First, const unsigned char *const _Last) noexcept         {
            for (; _First != _Last; ++_First) {
                this->_Val ^= static_cast<size_t>(*_First);
                this->_Val *= _FNV_prime;
            }
            return (this->_Val);
        }
        template <class _Ty> size_t _Add_range(const _Ty *const _First, const _Ty *const _Last) noexcept         void _Add_value(const wchar_t _Ch) noexcept         {
            this->_Val ^= static_cast<size_t>(_Ch & 255);
            this->_Val *= _FNV_prime;
            this->_Val ^= static_cast<size_t>(_Ch >> 8);
            this->_Val *= _FNV_prime;
        }
    };
    inline size_t _Hash_bytes(const unsigned char *_First, size_t _Count) noexcept     {
        std::_Fnv1a_hasher _Hasher;
        return (_Hasher._Add_bytes(_First, _First + _Count));
    }
    template <class _Kty> inline size_t _Hash_representation(const _Kty &_Keyval) noexcept     {
        return (_Hash_bytes(&reinterpret_cast<const unsigned char &>(_Keyval), sizeof(_Kty)));
    }
    template<> inline size_t _Hash_representation<float>(const float &_Keyval) noexcept     {
        return (_Hash_bytes(&reinterpret_cast<const unsigned char &>(_Keyval), sizeof(float)));
    }
    template<> inline size_t _Hash_representation<double>(const double &_Keyval) noexcept     {
        return (_Hash_bytes(&reinterpret_cast<const unsigned char &>(_Keyval), sizeof(double)));
    }
    template<> inline size_t _Hash_representation<long double>(const long double &_Keyval) noexcept     {
        return (_Hash_bytes(&reinterpret_cast<const unsigned char &>(_Keyval), sizeof(long double)));
    }
    template<> inline size_t _Hash_representation<void *>(void *const &_Keyval) noexcept     {
        return (_Hash_bytes(&reinterpret_cast<const unsigned char &>(_Keyval), sizeof(void *)));
    }
    template <class _Kty> inline size_t _Hash_array_representation(const _Kty *const _First, const size_t _Count) noexcept     template <class _Kty> struct hash;
    template <class _Kty, bool _Enabled> struct _Conditionally_enabled_hash {
        typedef _Kty argument_type;
        typedef size_t result_type;
        size_t operator()(const _Kty &_Keyval) const noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval))operator()(const _Kty &_Keyval) const noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval)))     };
    template <class _Kty> struct _Conditionally_enabled_hash<_Kty, false> {
        _Conditionally_enabled_hash<type-parameter-0-0, false>() = delete
        _Conditionally_enabled_hash<type-parameter-0-0, false>(const _Conditionally_enabled_hash<type-parameter-0-0, false> &) = delete
        _Conditionally_enabled_hash<type-parameter-0-0, false>(_Conditionally_enabled_hash<type-parameter-0-0, false> &&) = delete
        _Conditionally_enabled_hash<type-parameter-0-0, false> &operator=(const _Conditionally_enabled_hash<type-parameter-0-0, false> &) = delete
        _Conditionally_enabled_hash<type-parameter-0-0, false> &operator=(_Conditionally_enabled_hash<type-parameter-0-0, false> &&) = delete
    };
    template <class _Kty> struct hash : _Conditionally_enabled_hash<_Kty, !is_const_v<_Kty> && !is_volatile_v<_Kty> && (is_enum_v<_Kty> || is_integral_v<_Kty> || is_pointer_v<_Kty>)> {
        static size_t _Do_hash(const _Kty &_Keyval) noexcept     };
    template<> struct hash<float> {
        typedef float argument_type;
        typedef size_t result_type;
        size_t operator()(const float _Keyval) const noexcept         {
            return (_Hash_representation(_Keyval == 0.F ? 0.F : _Keyval));
        }
    };
    template<> struct hash<double> {
        typedef double argument_type;
        typedef size_t result_type;
        size_t operator()(const double _Keyval) const noexcept         {
            return (_Hash_representation(_Keyval == 0. ? 0. : _Keyval));
        }
    };
    template<> struct hash<long double> {
        typedef long double argument_type;
        typedef size_t result_type;
        size_t operator()(const long double _Keyval) const noexcept         {
            return (_Hash_representation(_Keyval == 0.L ? 0.L : _Keyval));
        }
    };
    template<> struct hash<nullptr_t> {
        typedef std::nullptr_t argument_type;
        typedef size_t result_type;
        size_t operator()(std::nullptr_t) const noexcept         {
            void *_Null{};
            return (_Hash_representation(_Null));
        }
    };
    struct _Unique_tag_is_nothrow_hashable {
    };
    template <class _Kty, class  = void> struct _Is_nothrow_hashable : std::false_type {
    };
    template <class _Kty> struct _Is_nothrow_hashable<_Kty, void> : bool_constant<noexcept(hash<_Kty>({})(::std::declval<const _Kty &>()))> {
    };
    namespace tr1 {
        using ::std::add_const;
        using ::std::add_cv;
        using ::std::add_pointer;
        using ::std::add_volatile;
        using ::std::aligned_storage;
        using ::std::alignment_of;
        using ::std::conditional;
        using ::std::decay;
        using ::std::enable_if;
        using ::std::extent;
        using ::std::false_type;
        using ::std::has_virtual_destructor;
        using ::std::integral_constant;
        using ::std::is_abstract;
        using ::std::is_arithmetic;
        using ::std::is_array;
        using ::std::is_base_of;
        using ::std::is_class;
        using ::std::is_compound;
        using ::std::is_const;
        using ::std::is_convertible;
        using ::std::is_empty;
        using ::std::is_enum;
        using ::std::is_floating_point;
        using ::std::is_function;
        using ::std::is_fundamental;
        using ::std::is_integral;
        using ::std::is_member_function_pointer;
        using ::std::is_member_object_pointer;
        using ::std::is_member_pointer;
        using ::std::is_object;
        using ::std::is_pod;
        using ::std::is_pointer;
        using ::std::is_polymorphic;
        using ::std::is_reference;
        using ::std::is_same;
        using ::std::is_scalar;
        using ::std::is_signed;
        using ::std::is_union;
        using ::std::is_unsigned;
        using ::std::is_void;
        using ::std::is_volatile;
        using ::std::make_signed;
        using ::std::make_unsigned;
        using ::std::rank;
        using ::std::remove_all_extents;
        using ::std::remove_const;
        using ::std::remove_cv;
        using ::std::remove_extent;
        using ::std::remove_pointer;
        using ::std::remove_reference;
        using ::std::remove_volatile;
        using ::std::true_type;
        using ::std::cref;
        using ::std::ref;
        using ::std::reference_wrapper;
        using ::std::result_of;
        using ::std::hash;
    }
    struct _Invoker_pmf_object {
        template <class _Decayed, class _Ty1, class ..._Types2> static inline auto _Call(_Decayed _Pmf, _Ty1 &&_Arg1, _Types2 &&..._Args2) noexcept(noexcept((::std::forward<_Ty1>(_Arg1) .* _Pmf)(::std::forward<_Types2>(_Args2)...))_Call(_Decayed _Pmf, _Ty1 &&_Arg1, _Types2 &&..._Args2) noexcept(noexcept((::std::forward<_Ty1>(_Arg1) .* _Pmf)(::std::forward<_Types2>(_Args2)...))) -> decltype((::std::forward<_Ty1>(_Arg1) .* _Pmf)(::std::forward<_Types2>(_Args2)...))     };
    struct _Invoker_pmf_refwrap {
        template <class _Decayed, class _Ty1, class ..._Types2> static inline auto _Call(_Decayed _Pmf, _Ty1 &&_Arg1, _Types2 &&..._Args2) noexcept(noexcept((::std::forward<_Ty1>(_Arg1).get() .* _Pmf)(::std::forward<_Types2>(_Args2)...))_Call(_Decayed _Pmf, _Ty1 &&_Arg1, _Types2 &&..._Args2) noexcept(noexcept((::std::forward<_Ty1>(_Arg1).get() .* _Pmf)(::std::forward<_Types2>(_Args2)...))) -> decltype((::std::forward<_Ty1>(_Arg1).get() .* _Pmf)(::std::forward<_Types2>(_Args2)...))     };
    struct _Invoker_pmf_pointer {
        template <class _Decayed, class _Ty1, class ..._Types2> static inline auto _Call(_Decayed _Pmf, _Ty1 &&_Arg1, _Types2 &&..._Args2) noexcept(noexcept(((*::std::forward<_Ty1>(_Arg1)) .* _Pmf)(::std::forward<_Types2>(_Args2)...))_Call(_Decayed _Pmf, _Ty1 &&_Arg1, _Types2 &&..._Args2) noexcept(noexcept(((*::std::forward<_Ty1>(_Arg1)) .* _Pmf)(::std::forward<_Types2>(_Args2)...))) -> decltype(((*::std::forward<_Ty1>(_Arg1)) .* _Pmf)(::std::forward<_Types2>(_Args2)...))     };
    struct _Invoker_pmd_object {
        template <class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1 &&_Arg1) noexcept(noexcept(::std::forward<_Ty1>(_Arg1) .* _Pmd)_Call(_Decayed _Pmd, _Ty1 &&_Arg1) noexcept(noexcept(::std::forward<_Ty1>(_Arg1) .* _Pmd)) -> decltype(::std::forward<_Ty1>(_Arg1) .* _Pmd)     };
    struct _Invoker_pmd_refwrap {
        template <class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1 &&_Arg1) noexcept(noexcept(::std::forward<_Ty1>(_Arg1).get() .* _Pmd)_Call(_Decayed _Pmd, _Ty1 &&_Arg1) noexcept(noexcept(::std::forward<_Ty1>(_Arg1).get() .* _Pmd)) -> decltype(::std::forward<_Ty1>(_Arg1).get() .* _Pmd)     };
    struct _Invoker_pmd_pointer {
        template <class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1 &&_Arg1) noexcept(noexcept((*::std::forward<_Ty1>(_Arg1)) .* _Pmd)_Call(_Decayed _Pmd, _Ty1 &&_Arg1) noexcept(noexcept((*::std::forward<_Ty1>(_Arg1)) .* _Pmd)) -> decltype((*::std::forward<_Ty1>(_Arg1)) .* _Pmd)     };
    struct _Invoker_functor {
        template <class _Callable, class ..._Types> static inline auto _Call(_Callable &&_Obj, _Types &&..._Args) noexcept(noexcept(::std::forward<_Callable>(_Obj)(::std::forward<_Types>(_Args)...))_Call(_Callable &&_Obj, _Types &&..._Args) noexcept(noexcept(::std::forward<_Callable>(_Obj)(::std::forward<_Types>(_Args)...))) -> decltype(::std::forward<_Callable>(_Obj)(::std::forward<_Types>(_Args)...))     };
    template <class _Callable, class _Ty1, class _Removed_cvref = remove_cv_t<remove_reference_t<_Callable> >, bool _Is_pmf = is_member_function_pointer_v<_Removed_cvref>, bool _Is_pmd = is_member_object_pointer_v<_Removed_cvref>> struct _Invoker1;
    template <class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, true, false> : conditional_t<is_base_of_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1> >, std::_Invoker_pmf_object, conditional_t<_Is_specialization<remove_cv_t<remove_reference_t<_Ty1> >, reference_wrapper>::value, std::_Invoker_pmf_refwrap, std::_Invoker_pmf_pointer> > {
    };
    template <class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, true> : conditional_t<is_base_of_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1> >, std::_Invoker_pmd_object, conditional_t<_Is_specialization<remove_cv_t<remove_reference_t<_Ty1> >, reference_wrapper>::value, std::_Invoker_pmd_refwrap, std::_Invoker_pmd_pointer> > {
    };
    template <class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : std::_Invoker_functor {
    };
    template <class _Callable, class ..._Types> struct _Invoker;
    template <class _Callable> struct _Invoker<_Callable, <>> : std::_Invoker_functor {
    };
    template <class _Callable, class _Ty1, class ..._Types2> struct _Invoker<_Callable, <type-parameter-0-1, type-parameter-0-2...>> : _Invoker1<_Callable, _Ty1> {
    };
    template <class _Callable, class ..._Types> inline auto invoke(_Callable &&_Obj, _Types &&..._Args) noexcept(noexcept(_Invoker<_Callable, _Types...>::_Call(::std::forward<_Callable>(_Obj), ::std::forward<_Types>(_Args)...))invoke(_Callable &&_Obj, _Types &&..._Args) noexcept(noexcept(_Invoker<_Callable, _Types...>::_Call(::std::forward<_Callable>(_Obj), ::std::forward<_Types>(_Args)...))) -> decltype(_Invoker<_Callable, _Types...>::_Call(::std::forward<_Callable>(_Obj), ::std::forward<_Types>(_Args)...))     template <class _Rx, bool = is_void_v<_Rx>> struct _Invoker_ret {
    };
    template <class _Cv_void> struct _Invoker_ret<_Cv_void, true> {
        template <class ..._Valtys> static void _Call(_Valtys &&..._Vals)     };
    template <class _Rx> struct _Invoker_ret<_Rx, false> {
        template <class ..._Valtys> static _Rx _Call(_Valtys &&..._Vals)     };
    template<> struct _Invoker_ret<std::_Unforced, false> {
        template <class ..._Valtys> static auto _Call(_Valtys &&..._Vals) -> decltype(::std::invoke(::std::forward<_Valtys>(_Vals)...))     };
    constexpr bool is_empty_v = __is_empty(std::_Container_base0);
    constexpr bool is_const_v = is_const<char>::value;
    constexpr bool is_empty_v = __is_empty(std::allocator<char>);
    constexpr bool is_final_v = __is_final(std::allocator<char>);
    constexpr bool is_trivial_v = __is_trivial(char *);
    constexpr bool is_empty_v = __is_empty(std::default_delete<v8::internal::ScriptStreamingData>);
    constexpr bool is_final_v = __is_final(std::default_delete<v8::internal::ScriptStreamingData>);
    constexpr bool is_reference_v = is_reference<default_delete<ScriptStreamingData> >::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<default_delete<ScriptStreamingData> >::value;
    constexpr bool is_rvalue_reference_v = is_rvalue_reference<default_delete<ScriptStreamingData> >::value;
    constexpr bool is_convertible_v = __is_convertible_to(v8::internal::ScriptStreamingData *, v8::internal::ScriptStreamingData *);
    constexpr bool conjunction_v = conjunction<negation<is_pointer<default_delete<ScriptStreamingData> > >, is_default_constructible<default_delete<ScriptStreamingData> > >::value;
    constexpr bool conjunction_v = conjunction<negation<is_array<ScriptStreamingData> >, is_convertible<ScriptStreamingData *, ScriptStreamingData *>, is_convertible<default_delete<ScriptStreamingData>, default_delete<ScriptStreamingData> > >::value;
    constexpr bool conjunction_v = conjunction<negation<is_array<ScriptStreamingData> >, is_assignable<default_delete<ScriptStreamingData> &, default_delete<ScriptStreamingData> >, is_convertible<ScriptStreamingData *, ScriptStreamingData *> >::value;
    constexpr bool is_empty_v = __is_empty(std::default_delete<unsigned char const[]>);
    constexpr bool is_final_v = __is_final(std::default_delete<unsigned char const[]>);
    constexpr bool is_reference_v = is_reference<default_delete<unsigned char const[]> >::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<default_delete<unsigned char const[]> >::value;
    constexpr bool is_rvalue_reference_v = is_rvalue_reference<default_delete<unsigned char const[]> >::value;
    constexpr bool is_convertible_v = __is_convertible_to(unsigned char const (*)[], unsigned char const (*)[]);
    constexpr bool conjunction_v = conjunction<negation<is_pointer<default_delete<unsigned char const[]> > >, is_default_constructible<default_delete<unsigned char const[]> > >::value;
    constexpr bool is_pointer_v = is_pointer<unique_ptr<unsigned char const[], default_delete<unsigned char const[]> > >::value;
    constexpr bool is_convertible_v = __is_convertible_to(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > (*)[], unsigned char const (*)[]);
    constexpr bool conjunction_v = conjunction<is_array<unsigned char const[]>, is_same<const unsigned char *, const unsigned char *>, is_same<const unsigned char *, const unsigned char *>, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_convertible<default_delete<unsigned char const[]>, default_delete<unsigned char const[]> > >::value;
    constexpr bool conjunction_v = conjunction<is_array<unsigned char const[]>, is_same<const unsigned char *, const unsigned char *>, is_same<const unsigned char *, const unsigned char *>, is_convertible<unsigned char const (*)[], unsigned char const (*)[]>, is_assignable<default_delete<unsigned char const[]> &, default_delete<unsigned char const[]> > >::value;
    constexpr bool is_array_v = is_array<NativeModule>::value;
    constexpr bool is_empty_v = __is_empty(std::default_delete<v8::WasmStreaming::WasmStreamingImpl>);
    constexpr bool is_final_v = __is_final(std::default_delete<v8::WasmStreaming::WasmStreamingImpl>);
    constexpr bool is_reference_v = is_reference<default_delete<WasmStreamingImpl> >::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<default_delete<WasmStreamingImpl> >::value;
    constexpr bool is_rvalue_reference_v = is_rvalue_reference<default_delete<WasmStreamingImpl> >::value;
    constexpr bool is_convertible_v = __is_convertible_to(v8::WasmStreaming::WasmStreamingImpl *, v8::WasmStreaming::WasmStreamingImpl *);
    constexpr bool conjunction_v = conjunction<negation<is_pointer<default_delete<WasmStreamingImpl> > >, is_default_constructible<default_delete<WasmStreamingImpl> > >::value;
    constexpr bool conjunction_v = conjunction<negation<is_array<WasmStreamingImpl> >, is_convertible<WasmStreamingImpl *, WasmStreamingImpl *>, is_convertible<default_delete<WasmStreamingImpl>, default_delete<WasmStreamingImpl> > >::value;
    constexpr bool is_array_v = is_array<StreamingDecoder>::value;
}
namespace std {
    bool uncaught_exception() noexcept;
    int uncaught_exceptions() noexcept;
}
extern "C" {
    typedef struct _heapinfo {
        int *_pentry;
        size_t _size;
        int _useflag;
    } _HEAPINFO;
    void *_alloca(size_t _Size) throw();
    intptr_t _get_heap_handle();
    int _heapmin();
    int _heapwalk(_HEAPINFO *_EntryInfo);
    int _heapchk();
    int _resetstkoflw();
    typedef char __static_assert_t[1];
    inline void *_MarkAllocaS(void *_Ptr, unsigned int _Marker)     {
        if (_Ptr) {
            *((unsigned int *)_Ptr) = _Marker;
            _Ptr = (char *)_Ptr + 16;
        }
        return _Ptr;
    }
    inline size_t _MallocaComputeSize(size_t _Size)     {
        size_t _MarkedSize = _Size + 16;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }
    inline void _freea(void *_Memory)     {
        unsigned int _Marker;
        if (_Memory) {
            _Memory = (char *)_Memory - 16;
            _Marker = *(unsigned int *)_Memory;
            if (_Marker == 56797) {
                free(_Memory);
            }
        }
    }
}
extern "C" {
    typedef void (*terminate_handler)() __attribute__((cdecl));
    typedef void (*terminate_function)() __attribute__((cdecl));
    void abort();
    void terminate() throw();
    terminate_handler set_terminate(terminate_handler _NewTerminateHandler) throw();
    terminate_handler _get_terminate();
}
extern "C" {
    typedef void (*unexpected_handler)() __attribute__((cdecl));
    typedef void (*unexpected_function)() __attribute__((cdecl));
    struct _EXCEPTION_POINTERS;
    void unexpected() noexcept(falseunexpected() noexcept(false);
    unexpected_handler set_unexpected(unexpected_handler _NewUnexpectedHandler) noexcept;
    unexpected_handler _get_unexpected() noexcept;
    typedef void (*_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS *) __attribute__((cdecl));
    _se_translator_function _set_se_translator(_se_translator_function _NewSETranslator);
    class type_info;
    int _is_exception_typeof(const type_info &_Type, _EXCEPTION_POINTERS *_ExceptionPtr);
    bool __uncaught_exception();
    int __uncaught_exceptions();
}
extern "C" {
    struct __std_exception_data {
        const char *_What;
        bool _DoFree;
    };
    void __std_exception_copy(const __std_exception_data *_From, __std_exception_data *_To);
    void __std_exception_destroy(__std_exception_data *_Data);
}
namespace std {
    class exception {
    public:
        exception() noexcept : _Data()         {
        }
        explicit exception(const char *const _Message) noexcept : _Data()         {
            __std_exception_data _InitData = {_Message, true};
            __std_exception_copy(&_InitData, &this->_Data);
        }
        exception(const char *const _Message, int) noexcept : _Data()         {
            this->_Data._What = _Message;
        }
        exception(const std::exception &_Other) noexcept : _Data()         {
            __std_exception_copy(&_Other._Data, &this->_Data);
        }
        std::exception &operator=(const std::exception &_Other) noexcept         {
            if (this == &_Other) {
                return *this;
            }
            __std_exception_destroy(&this->_Data);
            __std_exception_copy(&_Other._Data, &this->_Data);
            return *this;
        }
        virtual ~exception() noexcept         {
            __std_exception_destroy(&this->_Data);
        }
        virtual const char *what() const         {
            return this->_Data._What ? this->_Data._What : "Unknown exception";
        }
    private:
        __std_exception_data _Data;
    };
    class bad_exception : public std::exception {
    public:
        bad_exception() noexcept : std::exception("bad exception", 1)         {
        }
    };
    class bad_alloc : public std::exception {
    public:
        bad_alloc() noexcept : std::exception("bad allocation", 1)         {
        }
    private:
        friend  class bad_array_new_length;
        bad_alloc(const char *const _Message) noexcept : std::exception(_Message, 1)         {
        }
    };
    class bad_array_new_length : public std::bad_alloc {
    public:
        bad_array_new_length() noexcept : std::bad_alloc("bad array new length")         {
        }
    };
}
namespace std {
    using ::terminate;
    using ::set_terminate;
    using ::terminate_handler;
    inline terminate_handler get_terminate() noexcept     {
        return (_get_terminate());
    }
    using ::unexpected;
    using ::set_unexpected;
    using ::unexpected_handler;
    inline unexpected_handler get_unexpected() noexcept     {
        return (_get_unexpected());
    }
}
void __ExceptionPtrCreate(void *);
void __ExceptionPtrDestroy(void *);
void __ExceptionPtrCopy(void *, const void *);
void __ExceptionPtrAssign(void *, const void *);
bool __ExceptionPtrCompare(const void *, const void *);
bool __ExceptionPtrToBool(const void *);
void __ExceptionPtrSwap(void *, void *);
void __ExceptionPtrCurrentException(void *);
void __ExceptionPtrRethrow(const void *) [[noreturn]];
void __ExceptionPtrCopyException(void *, const void *, const void *);
namespace std {
    class exception_ptr {
    public:
        exception_ptr() noexcept         {
            __ExceptionPtrCreate(this);
        }
        exception_ptr(std::nullptr_t) noexcept         {
            __ExceptionPtrCreate(this);
        }
        ~exception_ptr() noexcept         {
            __ExceptionPtrDestroy(this);
        }
        exception_ptr(const std::exception_ptr &_Rhs) noexcept         {
            __ExceptionPtrCopy(this, &_Rhs);
        }
        std::exception_ptr &operator=(const std::exception_ptr &_Rhs) noexcept         {
            __ExceptionPtrAssign(this, &_Rhs);
            return *this;
        }
        std::exception_ptr &operator=(std::nullptr_t) noexcept         {
            std::exception_ptr _Ptr;
            __ExceptionPtrAssign(this, &_Ptr);
            return *this;
        }
        explicit operator bool() const noexcept         {
            return __ExceptionPtrToBool(this);
        }
        void _RethrowException() const [[noreturn]]         {
            __ExceptionPtrRethrow(this);
        }
        static std::exception_ptr _Current_exception() noexcept         {
            std::exception_ptr _Retval;
            __ExceptionPtrCurrentException(&_Retval);
            return _Retval;
        }
        static std::exception_ptr _Copy_exception(void *_Except, const void *_Ptr)         {
            std::exception_ptr _Retval;
            if (!_Ptr) {
                return _Retval;
            }
            __ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
            return _Retval;
        }
    private:
        void *_Data1;
        void *_Data2;
    };
    inline void swap(std::exception_ptr &_Lhs, std::exception_ptr &_Rhs) noexcept     {
        __ExceptionPtrSwap(&_Lhs, &_Rhs);
    }
    inline bool operator==(const std::exception_ptr &_Lhs, const std::exception_ptr &_Rhs) noexcept     {
        return __ExceptionPtrCompare(&_Lhs, &_Rhs);
    }
    inline bool operator==(std::nullptr_t, const std::exception_ptr &_Rhs) noexcept     {
        return !_Rhs;
    }
    inline bool operator==(const std::exception_ptr &_Lhs, std::nullptr_t) noexcept     {
        return !_Lhs;
    }
    inline bool operator!=(const std::exception_ptr &_Lhs, const std::exception_ptr &_Rhs) noexcept     {
        return !(_Lhs == _Rhs);
    }
    inline bool operator!=(std::nullptr_t _Lhs, const std::exception_ptr &_Rhs) noexcept     {
        return !(_Lhs == _Rhs);
    }
    inline bool operator!=(const std::exception_ptr &_Lhs, std::nullptr_t _Rhs) noexcept     {
        return !(_Lhs == _Rhs);
    }
    inline std::exception_ptr current_exception() noexcept     {
        return exception_ptr::_Current_exception();
    }
    inline void rethrow_exception(std::exception_ptr _Ptr) [[noreturn]]     {
        _Ptr._RethrowException();
    }
    template <class _Ex> void *__GetExceptionInfo(_Ex);
    template <class _Ex> std::exception_ptr make_exception_ptr(_Ex _Except) noexcept     class nested_exception {
    public:
        nested_exception() noexcept : _Exc(::std::current_exception())         {
        }
        nested_exception(const std::nested_exception &) = default
        std::nested_exception &operator=(const std::nested_exception &) = default
        virtual ~nested_exception() noexcept         {
        }
        void rethrow_nested() const [[noreturn]]         {
            if (this->_Exc)
                ::std::rethrow_exception(this->_Exc);
            else
                ::std::terminate();
        }
        std::exception_ptr nested_ptr() const noexcept         {
            return (this->_Exc);
        }
    private:
        std::exception_ptr _Exc;
    };
    template <class _Ty, class _Uty> struct _With_nested : _Uty, std::nested_exception {
        explicit _With_nested<_Ty, _Uty>(_Ty &&_Arg)     };
    template <class _Ty> inline void _Throw_with_nested(_Ty &&_Arg, std::true_type) [[noreturn]]     template <class _Ty> inline void _Throw_with_nested(_Ty &&_Arg, std::false_type) [[noreturn]]     template <class _Ty> inline void throw_with_nested(_Ty &&_Arg) [[noreturn]]     template <class _Ty> inline void _Rethrow_if_nested(const _Ty *_Ptr, std::true_type)     template <class _Ty> inline void _Rethrow_if_nested(const _Ty *, std::false_type)     template <class _Ty> inline void rethrow_if_nested(const _Ty &_Arg) }
extern "C++" {
    namespace std {
        struct nothrow_t {
        };
        extern const std::nothrow_t nothrow;
    }
    void *operator new(size_t _Size);
    void *operator new(size_t _Size, const std::nothrow_t &) noexcept;
    void *operator new[](size_t _Size);
    void *operator new[](size_t _Size, const std::nothrow_t &) noexcept;
    void operator delete(void *_Block) noexcept;
    void operator delete(void *_Block, const std::nothrow_t &) noexcept;
    void operator delete[](void *_Block) noexcept;
    void operator delete[](void *_Block, const std::nothrow_t &) noexcept;
    void operator delete(void *_Block, size_t _Size) noexcept;
    void operator delete[](void *_Block, size_t _Size) noexcept;
    inline void *operator new(size_t _Size, void *_Where) noexcept     {
        (void)_Size;
        return _Where;
    }
    inline void operator delete(void *, void *) noexcept     {
        return;
    }
    inline void *operator new[](size_t _Size, void *_Where) noexcept     {
        (void)_Size;
        return _Where;
    }
    inline void operator delete[](void *, void *) noexcept     {
    }
}
namespace std {
    typedef void (*new_handler)() __attribute__((cdecl));
    std::new_handler set_new_handler(std::new_handler) noexcept;
    std::new_handler get_new_handler() noexcept;
}
typedef FILE FILE;
namespace std {
    using ::FILE;
    using ::_Mbstatet;
    using ::size_t;
    using ::fpos_t;
    using ::FILE;
    using ::clearerr;
    using ::fclose;
    using ::feof;
    using ::ferror;
    using ::fflush;
    using ::fgetc;
    using ::fgetpos;
    using ::fgets;
    using ::fopen;
    using ::fprintf;
    using ::fputc;
    using ::fputs;
    using ::fread;
    using ::freopen;
    using ::fscanf;
    using ::fseek;
    using ::fsetpos;
    using ::ftell;
    using ::fwrite;
    using ::getc;
    using ::getchar;
    using ::perror;
    using ::putc;
    using ::putchar;
    using ::printf;
    using ::puts;
    using ::remove;
    using ::rename;
    using ::rewind;
    using ::scanf;
    using ::setbuf;
    using ::setvbuf;
    using ::sprintf;
    using ::sscanf;
    using ::tmpfile;
    using ::tmpnam;
    using ::ungetc;
    using ::vfprintf;
    using ::vprintf;
    using ::vsprintf;
    using ::snprintf;
    using ::vsnprintf;
    using ::vfscanf;
    using ::vscanf;
    using ::vsscanf;
}
extern "C" {
    int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size);
    int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale);
    void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _memccpy. See online help for details."));
    int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _memicmp. See online help for details."));
    extern "C++" inline void *memchr(void *_Pv, int _C, size_t _N)     {
        const void *const _Pvc = _Pv;
        return const_cast<void *>(memchr(_Pvc, _C, _N));
    }

}
extern "C" {
    errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source);
    errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source);
    errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber);
    errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount);
    errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount);
    char *strtok_s(char *_String, const char *_Delimiter, char **_Context);
    void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount);
    extern "C++" {
        template <size_t _Size> inline errno_t strcat_s(char (&_Destination)[_Size], const char *_Source) throw()     }
    char *strcat(char *_Destination, const char *_Source) __declspec(deprecated("This function or variable may be unsafe. Consider using strcat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int strcmp(const char *_Str1, const char *_Str2);
    int _strcmpi(const char *_String1, const char *_String2);
    int strcoll(const char *_String1, const char *_String2);
    int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale);
    extern "C++" {
        template <size_t _Size> inline errno_t strcpy_s(char (&_Destination)[_Size], const char *_Source) throw()     }
    char *strcpy(char *_Destination, const char *_Source) __declspec(deprecated("This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    size_t strcspn(const char *_Str, const char *_Control);
    char *_strdup(const char *_Source);
    char *_strerror(const char *_ErrorMessage) __declspec(deprecated("This function or variable may be unsafe. Consider using _strerror_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage);
    extern "C++" {
        template <size_t _Size> inline errno_t _strerror_s(char (&_Buffer)[_Size], const char *_ErrorMessage) throw()     }
    char *strerror(int _ErrorMessage) __declspec(deprecated("This function or variable may be unsafe. Consider using strerror_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    extern "C++" {
        template <size_t _Size> inline errno_t strerror_s(char (&_Buffer)[_Size], int _ErrorMessage) throw()     }
    int _stricmp(const char *_String1, const char *_String2);
    int _stricoll(const char *_String1, const char *_String2);
    int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale);
    int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale);
    size_t strlen(const char *_Str);
    errno_t _strlwr_s(char *_String, size_t _Size);
    extern "C++" {
        template <size_t _Size> inline errno_t _strlwr_s(char (&_String)[_Size]) throw()     }
    char *_strlwr(char *_String) __declspec(deprecated("This function or variable may be unsafe. Consider using _strlwr_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale);
    extern "C++" {
        template <size_t _Size> inline errno_t _strlwr_s_l(char (&_String)[_Size], _locale_t _Locale) throw()     }
    char *_strlwr_l(char *_String, _locale_t _Locale) __declspec(deprecated("This function or variable may be unsafe. Consider using _strlwr_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    extern "C++" {
        template <size_t _Size> inline errno_t strncat_s(char (&_Destination)[_Size], const char *_Source, size_t _Count) throw()     }
    char *strncat(char *_Destination, const char *_Source, size_t _Count) __declspec(deprecated("This function or variable may be unsafe. Consider using strncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount);
    int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount);
    int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale);
    int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount);
    int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale);
    int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount);
    int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale);
    size_t __strncnt(const char *_String, size_t _Count);
    extern "C++" {
        template <size_t _Size> inline errno_t strncpy_s(char (&_Destination)[_Size], const char *_Source, size_t _Count) throw()     }
    char *strncpy(char *_Destination, const char *_Source, size_t _Count) __declspec(deprecated("This function or variable may be unsafe. Consider using strncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    size_t strnlen(const char *_String, size_t _MaxCount);
    static inline size_t strnlen_s(const char *_String, size_t _MaxCount)     {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }
    errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount);
    extern "C++" {
        template <size_t _Size> inline errno_t _strnset_s(char (&_Destination)[_Size], int _Value, size_t _Count) throw()     }
    char *_strnset(char *_Destination, int _Value, size_t _Count) __declspec(deprecated("This function or variable may be unsafe. Consider using _strnset_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    const char *strpbrk(const char *_Str, const char *_Control);
    char *_strrev(char *_Str);
    errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value);
    extern "C++" {
        template <size_t _Size> inline errno_t _strset_s(char (&_Destination)[_Size], int _Value) throw()     }
    char *_strset(char *_Destination, int _Value) __declspec(deprecated("This function or variable may be unsafe. Consider using _strset_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    size_t strspn(const char *_Str, const char *_Control);
    char *strtok(char *_String, const char *_Delimiter) __declspec(deprecated("This function or variable may be unsafe. Consider using strtok_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _strupr_s(char *_String, size_t _Size);
    extern "C++" {
        template <size_t _Size> inline errno_t _strupr_s(char (&_String)[_Size]) throw()     }
    char *_strupr(char *_String) __declspec(deprecated("This function or variable may be unsafe. Consider using _strupr_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale);
    extern "C++" {
        template <size_t _Size> inline errno_t _strupr_s_l(char (&_String)[_Size], _locale_t _Locale) throw()     }
    char *_strupr_l(char *_String, _locale_t _Locale) __declspec(deprecated("This function or variable may be unsafe. Consider using _strupr_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."));
    size_t strxfrm(char *_Destination, const char *_Source, size_t _MaxCount);
    size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale);
    extern "C++" {
        inline char *strchr(char *const _String, const int _Ch)         {
            return const_cast<char *>(strchr(static_cast<const char *>(_String), _Ch));
        }
        inline char *strpbrk(char *const _String, const char *const _Control)         {
            return const_cast<char *>(strpbrk(static_cast<const char *>(_String), _Control));
        }
        inline char *strrchr(char *const _String, const int _Ch)         {
            return const_cast<char *>(strrchr(static_cast<const char *>(_String), _Ch));
        }
        inline char *strstr(char *const _String, const char *const _SubString)         {
            return const_cast<char *>(strstr(static_cast<const char *>(_String), _SubString));
        }
    }
    char *strdup(const char *_String) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _strdup. See online help for details."));
    int strcmpi(const char *_String1, const char *_String2) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _strcmpi. See online help for details."));
    int stricmp(const char *_String1, const char *_String2) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _stricmp. See online help for details."));
    char *strlwr(char *_String) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _strlwr. See online help for details."));
    int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _strnicmp. See online help for details."));
    char *strnset(char *_String, int _Value, size_t _MaxCount) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _strnset. See online help for details."));
    char *strrev(char *_String) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _strrev. See online help for details."));
    char *strset(char *_String, int _Value) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _strset. See online help for details."));
    char *strupr(char *_String) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name: _strupr. See online help for details."));
}
namespace std {
    using ::size_t;
    using ::memchr;
    using ::memcmp;
    using ::memcpy;
    using ::memmove;
    using ::memset;
    using ::strcat;
    using ::strchr;
    using ::strcmp;
    using ::strcoll;
    using ::strcpy;
    using ::strcspn;
    using ::strerror;
    using ::strlen;
    using ::strncat;
    using ::strncmp;
    using ::strncpy;
    using ::strpbrk;
    using ::strrchr;
    using ::strspn;
    using ::strstr;
    using ::strtok;
    using ::strxfrm;
}
extern "C++" {
    void *operator new(size_t _Size, int _BlockUse, const char *_FileName, int _LineNumber);
    void *operator new[](size_t _Size, int _BlockUse, const char *_FileName, int _LineNumber);
    void operator delete(void *_Block, int _BlockUse, const char *_FileName, int _LineNumber) noexcept;
    void operator delete[](void *_Block, int _BlockUse, const char *_FileName, int _LineNumber) noexcept;
}
extern "C" {
    typedef void *_HFILE;
    typedef int (*_CRT_REPORT_HOOK)(int, char *, int *) __attribute__((cdecl));
    typedef int (*_CRT_REPORT_HOOKW)(int, wchar_t *, int *) __attribute__((cdecl));
    typedef int (*_CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int) __attribute__((cdecl));
    typedef void (*_CRT_DUMP_CLIENT)(void *, size_t) __attribute__((cdecl));
    struct _CrtMemBlockHeader;
    typedef struct _CrtMemState {
        struct _CrtMemBlockHeader *pBlockHeader;
        size_t lCounts[5];
        size_t lSizes[5];
        size_t lHighWaterCount;
        size_t lTotalCount;
    } _CrtMemState;
}
namespace std {
    using streamoff = long long;
    using streamsize = long long;
    extern const std::streamoff _BADOFF;
    template <class _Statetype> class fpos {
    public:
        fpos<_Statetype>(std::streamoff _Off = 0)         fpos<_Statetype>(_Statetype _State, fpos_t _Fileposition)         _Statetype state() const         void state(_Statetype _State)         fpos_t seekpos() const         operator streamoff() const         std::streamoff operator-(const fpos<_Statetype> &_Right) const         fpos<_Statetype> &operator+=(std::streamoff _Off)         fpos<_Statetype> &operator-=(std::streamoff _Off)         fpos<_Statetype> operator+(std::streamoff _Off) const         fpos<_Statetype> operator-(std::streamoff _Off) const         bool operator==(const fpos<_Statetype> &_Right) const         bool operator==(std::streamoff _Right) const         bool operator!=(const fpos<_Statetype> &_Right) const     private:
        std::streamoff _Myoff;
        fpos_t _Fpos;
        _Statetype _Mystate;
    };
    using streampos = fpos<_Mbstatet>;
    using wstreampos = std::streampos;
    template <class _Elem, class _Int_type> struct _Char_traits {
        using char_type = _Elem;
        using int_type = _Int_type;
        using pos_type = std::streampos;
        using off_type = std::streamoff;
        using state_type = _Mbstatet;
        static inline int compare(const _Elem *_First1, const _Elem *_First2, size_t _Count) noexcept         static inline size_t length(const _Elem *_First) noexcept         static _Elem *copy(_Elem *const _First1, const _Elem *_First2, size_t _Count) noexcept         static _Elem *_Copy_s(_Elem *const _First1, const size_t _Dest_size, const _Elem *const _First2, const size_t _Count) noexcept         static inline const _Elem *find(const _Elem *_First, size_t _Count, const _Elem &_Ch) noexcept         static _Elem *move(_Elem *const _First1, const _Elem *_First2, size_t _Count) noexcept         static _Elem *assign(_Elem *const _First, size_t _Count, const _Elem _Ch) noexcept         static inline void assign(_Elem &_Left, const _Elem &_Right) noexcept         static constexpr bool eq(const _Elem &_Left, const _Elem &_Right) noexcept         {
            return (_Left == _Right);
        }
        static constexpr bool lt(const _Elem &_Left, const _Elem &_Right) noexcept         {
            return (_Left < _Right);
        }
        static constexpr _Elem to_char_type(const std::_Char_traits::int_type &_Meta) noexcept         {
            return (static_cast<_Elem>(_Meta));
        }
        static constexpr std::_Char_traits::int_type to_int_type(const _Elem &_Ch) noexcept         {
            return (static_cast<std::_Char_traits::int_type>(_Ch));
        }
        static constexpr bool eq_int_type(const std::_Char_traits::int_type &_Left, const std::_Char_traits::int_type &_Right) noexcept         {
            return (_Left == _Right);
        }
        static constexpr std::_Char_traits::int_type not_eof(const std::_Char_traits::int_type &_Meta) noexcept         {
            return (_Meta != eof() ? _Meta : !eof());
        }
        static constexpr std::_Char_traits::int_type eof() noexcept         {
            return (static_cast<std::_Char_traits::int_type>((-1)));
        }
    };
template<> struct _Char_traits<char32_t, unsigned int> {
        using char_type = char32_t;
        using int_type = unsigned int;
        using pos_type = std::streampos;
        using off_type = std::streamoff;
        using state_type = _Mbstatet;
        static inline int compare(const char32_t *_First1, const char32_t *_First2, size_t _Count) noexcept;
        static inline size_t length(const char32_t *_First) noexcept;
        static char32_t *copy(char32_t *const _First1, const char32_t *_First2, size_t _Count) noexcept;
        static char32_t *_Copy_s(char32_t *const _First1, const size_t _Dest_size, const char32_t *const _First2, const size_t _Count) noexcept;
        static inline const char32_t *find(const char32_t *_First, size_t _Count, const char32_t &_Ch) noexcept;
        static char32_t *move(char32_t *const _First1, const char32_t *_First2, size_t _Count) noexcept;
        static char32_t *assign(char32_t *const _First, size_t _Count, const char32_t _Ch) noexcept;
        static inline void assign(char32_t &_Left, const char32_t &_Right) noexcept;
        static constexpr bool eq(const char32_t &_Left, const char32_t &_Right) noexcept;
        static constexpr bool lt(const char32_t &_Left, const char32_t &_Right) noexcept;
        static constexpr char32_t to_char_type(const std::_Char_traits<char32_t, unsigned int>::int_type &_Meta) noexcept;
        static constexpr std::_Char_traits<char32_t, unsigned int>::int_type to_int_type(const char32_t &_Ch) noexcept;
        static constexpr bool eq_int_type(const std::_Char_traits<char32_t, unsigned int>::int_type &_Left, const std::_Char_traits<char32_t, unsigned int>::int_type &_Right) noexcept;
        static constexpr std::_Char_traits<char32_t, unsigned int>::int_type not_eof(const std::_Char_traits<char32_t, unsigned int>::int_type &_Meta) noexcept;
        static constexpr std::_Char_traits<char32_t, unsigned int>::int_type eof() noexcept;
    };
    template <class _Elem> struct _WChar_traits {
        using char_type = _Elem;
        using int_type = unsigned short;
        using pos_type = std::streampos;
        using off_type = std::streamoff;
        using state_type = _Mbstatet;
        static inline int compare(const _Elem *const _First1, const _Elem *const _First2, const size_t _Count) noexcept         static inline size_t length(const _Elem *_First) noexcept         static _Elem *copy(_Elem *const _First1, const _Elem *const _First2, const size_t _Count) noexcept         static _Elem *_Copy_s(_Elem *const _First1, const size_t _Size_in_words, const _Elem *const _First2, const size_t _Count) noexcept         static inline const _Elem *find(const _Elem *_First, const size_t _Count, const _Elem &_Ch) noexcept         static _Elem *move(_Elem *const _First1, const _Elem *const _First2, const size_t _Count) noexcept         static _Elem *assign(_Elem *const _First, size_t _Count, _Elem _Ch) noexcept         static inline void assign(_Elem &_Left, const _Elem &_Right) noexcept         static constexpr bool eq(const _Elem &_Left, const _Elem &_Right) noexcept         {
            return (_Left == _Right);
        }
        static constexpr bool lt(const _Elem &_Left, const _Elem &_Right) noexcept         {
            return (_Left < _Right);
        }
        static constexpr _Elem to_char_type(const std::_WChar_traits::int_type &_Meta) noexcept         {
            return (_Meta);
        }
        static constexpr std::_WChar_traits::int_type to_int_type(const _Elem &_Ch) noexcept         {
            return (_Ch);
        }
        static constexpr bool eq_int_type(const std::_WChar_traits::int_type &_Left, const std::_WChar_traits::int_type &_Right) noexcept         {
            return (_Left == _Right);
        }
        static constexpr std::_WChar_traits::int_type not_eof(const std::_WChar_traits::int_type &_Meta) noexcept         {
            return (_Meta != eof() ? _Meta : !eof());
        }
        static constexpr std::_WChar_traits::int_type eof() noexcept         {
            return (((wint_t)(65535)));
        }
    };
template<> struct _WChar_traits<char16_t> {
        using char_type = char16_t;
        using int_type = unsigned short;
        using pos_type = std::streampos;
        using off_type = std::streamoff;
        using state_type = _Mbstatet;
        static inline int compare(const char16_t *const _First1, const char16_t *const _First2, const size_t _Count) noexcept;
        static inline size_t length(const char16_t *_First) noexcept;
        static char16_t *copy(char16_t *const _First1, const char16_t *const _First2, const size_t _Count) noexcept;
        static char16_t *_Copy_s(char16_t *const _First1, const size_t _Size_in_words, const char16_t *const _First2, const size_t _Count) noexcept;
        static inline const char16_t *find(const char16_t *_First, const size_t _Count, const char16_t &_Ch) noexcept;
        static char16_t *move(char16_t *const _First1, const char16_t *const _First2, const size_t _Count) noexcept;
        static char16_t *assign(char16_t *const _First, size_t _Count, char16_t _Ch) noexcept;
        static inline void assign(char16_t &_Left, const char16_t &_Right) noexcept;
        static constexpr bool eq(const char16_t &_Left, const char16_t &_Right) noexcept;
        static constexpr bool lt(const char16_t &_Left, const char16_t &_Right) noexcept;
        static constexpr char16_t to_char_type(const std::_WChar_traits::int_type &_Meta) noexcept;
        static constexpr std::_WChar_traits<char16_t>::int_type to_int_type(const char16_t &_Ch) noexcept;
        static constexpr bool eq_int_type(const std::_WChar_traits::int_type &_Left, const std::_WChar_traits::int_type &_Right) noexcept;
        static constexpr std::_WChar_traits<char16_t>::int_type not_eof(const std::_WChar_traits::int_type &_Meta) noexcept;
        static constexpr std::_WChar_traits::int_type eof() noexcept;
    };
template<> struct _WChar_traits<wchar_t> {
        using char_type = wchar_t;
        using int_type = unsigned short;
        using pos_type = std::streampos;
        using off_type = std::streamoff;
        using state_type = _Mbstatet;
        static inline int compare(const wchar_t *const _First1, const wchar_t *const _First2, const size_t _Count) noexcept;
        static inline size_t length(const wchar_t *_First) noexcept;
        static wchar_t *copy(wchar_t *const _First1, const wchar_t *const _First2, const size_t _Count) noexcept;
        static wchar_t *_Copy_s(wchar_t *const _First1, const size_t _Size_in_words, const wchar_t *const _First2, const size_t _Count) noexcept;
        static inline const wchar_t *find(const wchar_t *_First, const size_t _Count, const wchar_t &_Ch) noexcept;
        static wchar_t *move(wchar_t *const _First1, const wchar_t *const _First2, const size_t _Count) noexcept;
        static wchar_t *assign(wchar_t *const _First, size_t _Count, wchar_t _Ch) noexcept;
        static inline void assign(wchar_t &_Left, const wchar_t &_Right) noexcept;
        static constexpr bool eq(const wchar_t &_Left, const wchar_t &_Right) noexcept;
        static constexpr bool lt(const wchar_t &_Left, const wchar_t &_Right) noexcept;
        static constexpr wchar_t to_char_type(const std::_WChar_traits::int_type &_Meta) noexcept;
        static constexpr std::_WChar_traits<wchar_t>::int_type to_int_type(const wchar_t &_Ch) noexcept;
        static constexpr bool eq_int_type(const std::_WChar_traits::int_type &_Left, const std::_WChar_traits::int_type &_Right) noexcept;
        static constexpr std::_WChar_traits<wchar_t>::int_type not_eof(const std::_WChar_traits::int_type &_Meta) noexcept;
        static constexpr std::_WChar_traits::int_type eof() noexcept;
    };
template<> struct _WChar_traits<unsigned short> {
        using char_type = unsigned short;
        using int_type = unsigned short;
        using pos_type = std::streampos;
        using off_type = std::streamoff;
        using state_type = _Mbstatet;
        static inline int compare(const unsigned short *const _First1, const unsigned short *const _First2, const size_t _Count) noexcept;
        static inline size_t length(const unsigned short *_First) noexcept;
        static unsigned short *copy(unsigned short *const _First1, const unsigned short *const _First2, const size_t _Count) noexcept;
        static unsigned short *_Copy_s(unsigned short *const _First1, const size_t _Size_in_words, const unsigned short *const _First2, const size_t _Count) noexcept;
        static inline const unsigned short *find(const unsigned short *_First, const size_t _Count, const unsigned short &_Ch) noexcept;
        static unsigned short *move(unsigned short *const _First1, const unsigned short *const _First2, const size_t _Count) noexcept;
        static unsigned short *assign(unsigned short *const _First, size_t _Count, unsigned short _Ch) noexcept;
        static inline void assign(unsigned short &_Left, const unsigned short &_Right) noexcept;
        static constexpr bool eq(const unsigned short &_Left, const unsigned short &_Right) noexcept;
        static constexpr bool lt(const unsigned short &_Left, const unsigned short &_Right) noexcept;
        static constexpr unsigned short to_char_type(const std::_WChar_traits::int_type &_Meta) noexcept;
        static constexpr std::_WChar_traits<unsigned short>::int_type to_int_type(const unsigned short &_Ch) noexcept;
        static constexpr bool eq_int_type(const std::_WChar_traits::int_type &_Left, const std::_WChar_traits::int_type &_Right) noexcept;
        static constexpr std::_WChar_traits<unsigned short>::int_type not_eof(const std::_WChar_traits::int_type &_Meta) noexcept;
        static constexpr std::_WChar_traits::int_type eof() noexcept;
    };
    template <class _Elem> struct char_traits : _Char_traits<_Elem, long> {
    };
    template<> struct char_traits<char16_t> : _WChar_traits<char16_t> {
    };
    using u16streampos = std::streampos;
    template<> struct char_traits<char32_t> : _Char_traits<char32_t, unsigned int> {
    };
    using u32streampos = std::streampos;
    template<> struct char_traits<wchar_t> : _WChar_traits<wchar_t> {
    };
    template<> struct char_traits<unsigned short> : _WChar_traits<unsigned short> {
    };
    template<> struct char_traits<char> {
        using char_type = char;
        using int_type = int;
        using pos_type = std::streampos;
        using off_type = std::streamoff;
        using state_type = _Mbstatet;
        static inline int compare(const char *const _First1, const char *const _First2, const size_t _Count) noexcept         {
            return (::memcmp(_First1, _First2, _Count));
        }
        static inline size_t length(const char *const _First) noexcept         {
            return (::strlen(_First));
        }
        static char *copy(char *const _First1, const char *const _First2, const size_t _Count) noexcept         {
            return (static_cast<char *>(::memcpy(_First1, _First2, _Count)));
        }
        static char *_Copy_s(char *const _First1, const size_t _Size_in_bytes, const char *const _First2, const size_t _Count) noexcept         {
            ::memcpy_s((_First1), (_Size_in_bytes), (_First2), (_Count));
            return (_First1);
        }
        static inline const char *find(const char *const _First, const size_t _Count, const char &_Ch) noexcept         {
            return (static_cast<const char *>(::memchr(_First, _Ch, _Count)));
        }
        static char *move(char *const _First1, const char *const _First2, const size_t _Count) noexcept         {
            return (static_cast<char *>(::memmove(_First1, _First2, _Count)));
        }
        static char *assign(char *const _First, const size_t _Count, const char _Ch) noexcept         {
            return (static_cast<char *>(::memset(_First, _Ch, _Count)));
        }
        static inline void assign(char &_Left, const char &_Right) noexcept         {
            _Left = _Right;
        }
        static constexpr bool eq(const char &_Left, const char &_Right) noexcept         {
            return (_Left == _Right);
        }
        static constexpr bool lt(const char &_Left, const char &_Right) noexcept         {
            return (static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right));
        }
        static constexpr char to_char_type(const std::char_traits<char>::int_type &_Meta) noexcept         {
            return (static_cast<char>(_Meta));
        }
        static constexpr std::char_traits<char>::int_type to_int_type(const char &_Ch) noexcept         {
            return (static_cast<unsigned char>(_Ch));
        }
        static constexpr bool eq_int_type(const std::char_traits<char>::int_type &_Left, const std::char_traits<char>::int_type &_Right) noexcept         {
            return (_Left == _Right);
        }
        static constexpr std::char_traits<char>::int_type not_eof(const std::char_traits<char>::int_type &_Meta) noexcept         {
            return (_Meta != eof() ? _Meta : !eof());
        }
        static constexpr std::char_traits<char>::int_type eof() noexcept         {
            return ((-1));
        }
    };
    template <class _Ty> class allocator
template<> class allocator<char> {
    public:
        static_assert(!is_const_v<char>, "The C++ Standard forbids containers of const elements because allocator<const T> is ill-formed.");
        using _Not_user_specialized = void;
        using value_type = char;
        typedef char *pointer;
        typedef const char *const_pointer;
        typedef char &reference;
        typedef const char &const_reference;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal = std::true_type;
        template <class _Other> struct rebind;
        char *address(char &_Val) const noexcept;
        const char *address(const char &_Val) const noexcept;
        allocator() noexcept;
        allocator(const std::allocator<char> &) = default
        template <class _Other> allocator(const allocator<_Other> &) noexcept;
        template<> allocator<char>(const allocator<char> &) noexcept;
        void deallocate(char *const _Ptr, const size_t _Count);
        char *allocate(const size_t _Count);
        char *allocate(const size_t _Count, const void *);
        template <class _Objty, class ..._Types> void construct(_Objty *const _Ptr, _Types &&..._Args);
        template <class _Uty> void destroy(_Uty *const _Ptr);
        size_t max_size() const noexcept;
    };
    class ios_base;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_ios;
    template <class _Elem, class _Traits = char_traits<_Elem>> class istreambuf_iterator;
    template <class _Elem, class _Traits = char_traits<_Elem>> class ostreambuf_iterator;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_streambuf;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_istream;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_ostream;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_iostream;
    template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>> class basic_stringbuf;
    template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>> class basic_istringstream;
    template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>> class basic_ostringstream;
    template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>> class basic_stringstream;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_filebuf;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_ifstream;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_ofstream;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_fstream;
    using ios = basic_ios<char, char_traits<char> >;
    using streambuf = basic_streambuf<char, char_traits<char> >;
    using istream = basic_istream<char, char_traits<char> >;
    using ostream = basic_ostream<char, char_traits<char> >;
    using iostream = basic_iostream<char, char_traits<char> >;
    using stringbuf = basic_stringbuf<char, char_traits<char>, allocator<char> >;
    using istringstream = basic_istringstream<char, char_traits<char>, allocator<char> >;
    using ostringstream = basic_ostringstream<char, char_traits<char>, allocator<char> >;
    using stringstream = basic_stringstream<char, char_traits<char>, allocator<char> >;
    using filebuf = basic_filebuf<char, char_traits<char> >;
    using ifstream = basic_ifstream<char, char_traits<char> >;
    using ofstream = basic_ofstream<char, char_traits<char> >;
    using fstream = basic_fstream<char, char_traits<char> >;
    using wios = basic_ios<wchar_t, char_traits<wchar_t> >;
    using wstreambuf = basic_streambuf<wchar_t, char_traits<wchar_t> >;
    using wistream = basic_istream<wchar_t, char_traits<wchar_t> >;
    using wostream = basic_ostream<wchar_t, char_traits<wchar_t> >;
    using wiostream = basic_iostream<wchar_t, char_traits<wchar_t> >;
    using wstringbuf = basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >;
    using wistringstream = basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >;
    using wostringstream = basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >;
    using wstringstream = basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >;
    using wfilebuf = basic_filebuf<wchar_t, char_traits<wchar_t> >;
    using wifstream = basic_ifstream<wchar_t, char_traits<wchar_t> >;
    using wofstream = basic_ofstream<wchar_t, char_traits<wchar_t> >;
    using wfstream = basic_fstream<wchar_t, char_traits<wchar_t> >;
}
namespace std {
    template <class _Ty> constexpr const _Ty &_Min_value(const _Ty &_Left, const _Ty &_Right) noexcept(noexcept(_Right < _Left)_Min_value(const _Ty &_Left, const _Ty &_Right) noexcept(noexcept(_Right < _Left))     {
        return (_Right < _Left ? _Right : _Left);
    }
    template<> constexpr const unsigned long long &_Min_value<unsigned long long>(const unsigned long long &_Left, const unsigned long long &_Right) noexcept(noexcept(_Right < _Left)_Min_value<unsigned long long>(const unsigned long long &_Left, const unsigned long long &_Right) noexcept(noexcept(_Right < _Left))     {
        return (_Right < _Left ? _Right : _Left);
    }
    template <class _Ty> constexpr const _Ty &_Max_value(const _Ty &_Left, const _Ty &_Right) noexcept(noexcept(_Left < _Right)_Max_value(const _Ty &_Left, const _Ty &_Right) noexcept(noexcept(_Left < _Right))     {
        return (_Left < _Right ? _Right : _Left);
    }
    template<> constexpr const unsigned long long &_Max_value<unsigned long long>(const unsigned long long &_Left, const unsigned long long &_Right) noexcept(noexcept(_Left < _Right)_Max_value<unsigned long long>(const unsigned long long &_Left, const unsigned long long &_Right) noexcept(noexcept(_Left < _Right))     {
        return (_Left < _Right ? _Right : _Left);
    }
    template <class _FwdIt1, class _FwdIt2> inline void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)     template <class _Ty, size_t _Size, class  = enable_if_t<_Is_swappable<_Ty>::value>> inline void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::valueswap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value)     template <class _Ty, class  = void> inline void swap(_Ty &_Left, _Ty &_Right) noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>swap(_Ty &_Left, _Ty &_Right) noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>)     template <class _Ty> inline void _Swap_adl(_Ty &_Left, _Ty &_Right) noexcept(_Is_nothrow_swappable<_Ty>::value_Swap_adl(_Ty &_Left, _Ty &_Right) noexcept(_Is_nothrow_swappable<_Ty>::value)     struct piecewise_construct_t {
    };
    constexpr std::piecewise_construct_t piecewise_construct{};
    template <class ...> class tuple;
    template <class _Ty1, class _Ty2> struct pair {
        using first_type = _Ty1;
        using second_type = _Ty2;
        template <class _Uty1 = _Ty1, class _Uty2 = _Ty2, enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2> >, int> = 0> constexpr pair<_Ty1, _Ty2>() : first(), second()         {
        }
        template <class _Uty1 = _Ty1, class _Uty2 = _Ty2, enable_if_t<conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>, is_convertible<const _Uty1 &, _Uty1>, is_convertible<const _Uty2 &, _Uty2> >, int> = 0> constexpr pair<_Ty1, _Ty2>(const _Ty1 &_Val1, const _Ty2 &_Val2) : first(_Val1), second(_Val2)         {
        }
        template <class _Uty1 = _Ty1, class _Uty2 = _Ty2, enable_if_t<conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>, negation<conjunction<is_convertible<const _Uty1 &, _Uty1>, is_convertible<const _Uty2 &, _Uty2> > > >, int> = 0> constexpr explicit pair<_Ty1, _Ty2>(const _Ty1 &_Val1, const _Ty2 &_Val2) : first(_Val1), second(_Val2)         {
        }
        pair<_Ty1, _Ty2>(const pair<_Ty1, _Ty2> &) = default
        pair<_Ty1, _Ty2>(pair<_Ty1, _Ty2> &&) = default
        template <class _Other1, class _Other2, enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1 &>, is_constructible<_Ty2, const _Other2 &>, is_convertible<const _Other1 &, _Ty1>, is_convertible<const _Other2 &, _Ty2> >, int> = 0> constexpr pair<_Ty1, _Ty2>(const pair<_Other1, _Other2> &_Right) : first(_Right.first), second(_Right.second)         {
        }
        template <class _Other1, class _Other2, enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1 &>, is_constructible<_Ty2, const _Other2 &>, negation<conjunction<is_convertible<const _Other1 &, _Ty1>, is_convertible<const _Other2 &, _Ty2> > > >, int> = 0> constexpr explicit pair<_Ty1, _Ty2>(const pair<_Other1, _Other2> &_Right) : first(_Right.first), second(_Right.second)         {
        }
        template <class _Other1, class _Other2> pair<_Ty1, _Ty2> &operator=(const pair<_Other1, _Other2> &_Right)         template <class _Tuple1, class _Tuple2, size_t ..._Indexes1, size_t ..._Indexes2> inline pair<_Ty1, _Ty2>(_Tuple1 &_Val1, _Tuple2 &_Val2, index_sequence<_Indexes1...>, index_sequence<_Indexes2...>);
        template <class ..._Types1, class ..._Types2> inline pair<_Ty1, _Ty2>(std::piecewise_construct_t, tuple<_Types1...> _Val1, tuple<_Types2...> _Val2);
        template <class _Other1, class _Other2, enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>, is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2> >, int> = 0> constexpr pair<_Ty1, _Ty2>(_Other1 &&_Val1, _Other2 &&_Val2) noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>pair<_Ty1, _Ty2>(_Other1 &&_Val1, _Other2 &&_Val2) noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>) : first(::std::forward<_Other1>(_Val1)), second(::std::forward<_Other2>(_Val2))         {
        }
        template <class _Other1, class _Other2, enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>, negation<conjunction<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2> > > >, int> = 0> constexpr explicit pair<_Ty1, _Ty2>(_Other1 &&_Val1, _Other2 &&_Val2) noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>pair<_Ty1, _Ty2>(_Other1 &&_Val1, _Other2 &&_Val2) noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>) : first(::std::forward<_Other1>(_Val1)), second(::std::forward<_Other2>(_Val2))         {
        }
        template <class _Other1, class _Other2, enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>, is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2> >, int> = 0> constexpr pair<_Ty1, _Ty2>(pair<_Other1, _Other2> &&_Right) noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>pair<_Ty1, _Ty2>(pair<_Other1, _Other2> &&_Right) noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>) : first(::std::forward<_Other1>(_Right.first)), second(::std::forward<_Other2>(_Right.second))         {
        }
        template <class _Other1, class _Other2, enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>, negation<conjunction<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2> > > >, int> = 0> constexpr explicit pair<_Ty1, _Ty2>(pair<_Other1, _Other2> &&_Right) noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>pair<_Ty1, _Ty2>(pair<_Other1, _Other2> &&_Right) noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>) : first(::std::forward<_Other1>(_Right.first)), second(::std::forward<_Other2>(_Right.second))         {
        }
        template <class _Other1, class _Other2> pair<_Ty1, _Ty2> &operator=(pair<_Other1, _Other2> &&_Right)         pair<_Ty1, _Ty2> &operator=(pair<_Ty1, _Ty2> &&_Right) noexcept(is_nothrow_move_assignable_v<_Ty1> && is_nothrow_move_assignable_v<_Ty2>operator=(pair<_Ty1, _Ty2> &&_Right) noexcept(is_nothrow_move_assignable_v<_Ty1> && is_nothrow_move_assignable_v<_Ty2>)         pair<_Ty1, _Ty2> &operator=(const pair<_Ty1, _Ty2> &_Right)         void swap(pair<_Ty1, _Ty2> &_Right) noexcept(_Is_nothrow_swappable<_Ty1>::value && _Is_nothrow_swappable<_Ty2>::valueswap(pair<_Ty1, _Ty2> &_Right) noexcept(_Is_nothrow_swappable<_Ty1>::value && _Is_nothrow_swappable<_Ty2>::value)         _Ty1 first;
        _Ty2 second;
    };
    template <class _Ty1, class _Ty2, class  = enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value>> inline void swap(pair<_Ty1, _Ty2> &_Left, pair<_Ty1, _Ty2> &_Right) noexcept(noexcept(_Left.swap(_Right))swap(pair<_Ty1, _Ty2> &_Left, pair<_Ty1, _Ty2> &_Right) noexcept(noexcept(_Left.swap(_Right)))     template <class _Ty1, class _Ty2> constexpr bool operator==(const pair<_Ty1, _Ty2> &_Left, const pair<_Ty1, _Ty2> &_Right)     {
        return (_Left.first == _Right.first && _Left.second == _Right.second);
    }
    template <class _Ty1, class _Ty2> constexpr bool operator!=(const pair<_Ty1, _Ty2> &_Left, const pair<_Ty1, _Ty2> &_Right)     {
        return (!(_Left == _Right));
    }
    template <class _Ty1, class _Ty2> constexpr bool operator<(const pair<_Ty1, _Ty2> &_Left, const pair<_Ty1, _Ty2> &_Right)     {
        return (_Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second));
    }
    template <class _Ty1, class _Ty2> constexpr bool operator>(const pair<_Ty1, _Ty2> &_Left, const pair<_Ty1, _Ty2> &_Right)     {
        return (_Right < _Left);
    }
    template <class _Ty1, class _Ty2> constexpr bool operator<=(const pair<_Ty1, _Ty2> &_Left, const pair<_Ty1, _Ty2> &_Right)     {
        return (!(_Right < _Left));
    }
    template <class _Ty1, class _Ty2> constexpr bool operator>=(const pair<_Ty1, _Ty2> &_Left, const pair<_Ty1, _Ty2> &_Right)     {
        return (!(_Left < _Right));
    }
    template <class _Ty> struct _Unrefwrap_helper {
        using type = _Ty;
    };
    template <class _Ty> struct _Unrefwrap_helper<reference_wrapper<type-parameter-0-0>> {
        using type = _Ty &;
    };
    template <class _Ty> using _Unrefwrap_t = typename _Unrefwrap_helper<decay_t<_Ty> >::type;
    template <class _Ty1, class _Ty2> constexpr pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2> > make_pair(_Ty1 &&_Val1, _Ty2 &&_Val2)     {
        using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2> >;
        return (_Mypair(::std::forward<_Ty1>(_Val1), ::std::forward<_Ty2>(_Val2)));
    }
    namespace rel_ops {
        template <class _Ty> inline bool operator!=(const _Ty &_Left, const _Ty &_Right)         template <class _Ty> inline bool operator>(const _Ty &_Left, const _Ty &_Right)         template <class _Ty> inline bool operator<=(const _Ty &_Left, const _Ty &_Right)         template <class _Ty> inline bool operator>=(const _Ty &_Left, const _Ty &_Right)     }
}
namespace std {
    template <class _Tuple> struct tuple_size;
    struct _Unique_tag_tuple_size_sfinae {
    };
    template <class _Tuple, class  = void> struct _Tuple_size_sfinae {
    };
    template <class _Tuple> struct _Tuple_size_sfinae<_Tuple, void> : integral_constant<size_t, tuple_size<_Tuple>::value> {
    };
    template <class _Tuple> struct tuple_size<_Tuple> : _Tuple_size_sfinae<_Tuple> {
    };
    template <class _Tuple> struct tuple_size<_Tuple> : _Tuple_size_sfinae<_Tuple> {
    };
    template <class _Tuple> struct tuple_size<_Tuple> : _Tuple_size_sfinae<_Tuple> {
    };
    template <class _Ty> constexpr size_t tuple_size_v = tuple_size<_Ty>::value;
    template <size_t _Index, class _Tuple> struct tuple_element;
    template <size_t _Index, class _Tuple> struct tuple_element<_Index, _Tuple> : public tuple_element<_Index, _Tuple> {
        using _Mybase = tuple_element<_Index, _Tuple>;
        using type = add_const_t<typename _Mybase::type>;
    };
    template <size_t _Index, class _Tuple> struct tuple_element<_Index, _Tuple> : public tuple_element<_Index, _Tuple> {
        using _Mybase = tuple_element<_Index, _Tuple>;
        using type = add_volatile_t<typename _Mybase::type>;
    };
    template <size_t _Index, class _Tuple> struct tuple_element<_Index, _Tuple> : public tuple_element<_Index, _Tuple> {
        using _Mybase = tuple_element<_Index, _Tuple>;
        using type = add_cv_t<typename _Mybase::type>;
    };
    template <size_t _Index, class _Tuple> using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;
    template <class _Ty, size_t _Size> class array;
    template <class _Ty, size_t _Size> struct tuple_size<array<type-parameter-0-0, _Size>> : integral_constant<size_t, _Size> {
    };
    template <size_t _Idx, class _Ty, size_t _Size> struct tuple_element<_Idx, array<type-parameter-0-1, _Size>> {
        static_assert(_Idx < _Size, "array index out of bounds");
        using type = _Ty;
    };
    template <class ..._Types> struct tuple_size<tuple<type-parameter-0-0...>> : integral_constant<size_t, sizeof...(_Types)> {
    };
    template <size_t _Index> struct tuple_element<_Index, std::tuple<>> {
        static_assert(_Always_false<integral_constant<size_t, _Index> >::value, "tuple index out of bounds");
    };
    template <class _This, class ..._Rest> struct tuple_element<0, tuple<type-parameter-0-0, type-parameter-0-1...>> {
        using type = _This;
        using _Ttype = tuple<_This, _Rest...>;
    };
    template <size_t _Index, class _This, class ..._Rest> struct tuple_element<_Index, tuple<type-parameter-0-1, type-parameter-0-2...>> : public tuple_element<_Index - 1, tuple<_Rest...> > {
    };
    template <class _Ty1, class _Ty2> struct tuple_size<pair<type-parameter-0-0, type-parameter-0-1>> : integral_constant<size_t, 2> {
    };
    template <class _Ty1, class _Ty2> struct tuple_element<0, pair<type-parameter-0-0, type-parameter-0-1>> {
        using type = _Ty1;
    };
    template <class _Ty1, class _Ty2> struct tuple_element<1, pair<type-parameter-0-0, type-parameter-0-1>> {
        using type = _Ty2;
    };
    template <class _Ret, class _Pair> constexpr _Ret _Pair_get(_Pair &_Pr, integral_constant<size_t, 0>) noexcept     {
        return (_Pr.first);
    }
    template <class _Ret, class _Pair> constexpr _Ret _Pair_get(_Pair &_Pr, integral_constant<size_t, 1>) noexcept     {
        return (_Pr.second);
    }
    template <size_t _Idx, class _Ty1, class _Ty2> constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2> > &get(pair<_Ty1, _Ty2> &_Pr) noexcept     {
        using _Rtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2> > &;
        return (_Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>()));
    }
    template <class _Ty1, class _Ty2> constexpr _Ty1 &get(pair<_Ty1, _Ty2> &_Pr) noexcept     {
        return (::std::get<0>(_Pr));
    }
    template <class _Ty2, class _Ty1> constexpr _Ty2 &get(pair<_Ty1, _Ty2> &_Pr) noexcept     {
        return (::std::get<1>(_Pr));
    }
    template <size_t _Idx, class _Ty1, class _Ty2> constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2> > &get(const pair<_Ty1, _Ty2> &_Pr) noexcept     {
        using _Ctype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2> > &;
        return (_Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>()));
    }
    template <class _Ty1, class _Ty2> constexpr const _Ty1 &get(const pair<_Ty1, _Ty2> &_Pr) noexcept     {
        return (::std::get<0>(_Pr));
    }
    template <class _Ty2, class _Ty1> constexpr const _Ty2 &get(const pair<_Ty1, _Ty2> &_Pr) noexcept     {
        return (::std::get<1>(_Pr));
    }
    template <size_t _Idx, class _Ty1, class _Ty2> constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2> > &&get(pair<_Ty1, _Ty2> &&_Pr) noexcept     {
        using _RRtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2> > &&;
        return (::std::forward<_RRtype>(::std::get<_Idx>(_Pr)));
    }
    template <class _Ty1, class _Ty2> constexpr _Ty1 &&get(pair<_Ty1, _Ty2> &&_Pr) noexcept     {
        return (::std::get<0>(::std::move(_Pr)));
    }
    template <class _Ty2, class _Ty1> constexpr _Ty2 &&get(pair<_Ty1, _Ty2> &&_Pr) noexcept     {
        return (::std::get<1>(::std::move(_Pr)));
    }
    template <size_t _Idx, class _Ty1, class _Ty2> constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2> > &&get(const pair<_Ty1, _Ty2> &&_Pr) noexcept     {
        using _RRtype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2> > &&;
        return (::std::forward<_RRtype>(::std::get<_Idx>(_Pr)));
    }
    template <class _Ty1, class _Ty2> constexpr const _Ty1 &&get(const pair<_Ty1, _Ty2> &&_Pr) noexcept     {
        return (::std::get<0>(::std::move(_Pr)));
    }
    template <class _Ty2, class _Ty1> constexpr const _Ty2 &&get(const pair<_Ty1, _Ty2> &&_Pr) noexcept     {
        return (::std::get<1>(::std::move(_Pr)));
    }
    template <class _Ty, class _Other = _Ty> inline _Ty exchange(_Ty &_Val, _Other &&_New_val)     template <class _Ty> constexpr add_const_t<_Ty> &as_const(_Ty &_Val) noexcept     {
        return (_Val);
    }
    template <class _Ty> void as_const(const _Ty &&) = delete
    namespace tr1 {
        using ::std::get;
        using ::std::tuple_element;
        using ::std::tuple_size;
    }
}
extern "C" {
    void __std_reverse_trivially_swappable_1(void *_First, void *_Last) noexcept __declspec(noalias);
    void __std_reverse_trivially_swappable_2(void *_First, void *_Last) noexcept __declspec(noalias);
    void __std_reverse_trivially_swappable_4(void *_First, void *_Last) noexcept __declspec(noalias);
    void __std_reverse_trivially_swappable_8(void *_First, void *_Last) noexcept __declspec(noalias);
}
namespace std {
    struct _Container_proxy;
    struct _Container_base12;
    struct _Iterator_base12;
    struct _Container_base0 {
        void _Orphan_all() noexcept         {
        }
        void _Swap_all(std::_Container_base0 &) noexcept         {
        }
    };
    struct _Iterator_base0 {
        void _Adopt(const void *) noexcept         {
        }
        const std::_Container_base0 *_Getcont() const noexcept         {
            return (0);
        }
    };
    struct _Container_proxy {
        _Container_proxy() noexcept : _Mycont(0), _Myfirstiter(0)         {
        }
        const std::_Container_base12 *_Mycont;
        std::_Iterator_base12 *_Myfirstiter;
    };
    struct _Container_base12 {
    public:
        _Container_base12() : _Myproxy(0)         {
        }
        _Container_base12(const std::_Container_base12 &) noexcept : _Myproxy(0)         {
        }
        std::_Container_base12 &operator=(const std::_Container_base12 &) noexcept         {
            return (*this);
        }
        std::_Iterator_base12 **_Getpfirst() const noexcept         {
            return (this->_Myproxy == 0 ? 0 : &this->_Myproxy->_Myfirstiter);
        }
        void _Orphan_all() noexcept;
        void _Swap_all(std::_Container_base12 &) noexcept;
        std::_Container_proxy *_Myproxy;
    };
    struct _Iterator_base12 {
    public:
        _Iterator_base12() noexcept : _Myproxy(0), _Mynextiter(0)         {
        }
        _Iterator_base12(const std::_Iterator_base12 &_Right) noexcept : _Myproxy(0), _Mynextiter(0)         {
            *this = _Right;
        }
        std::_Iterator_base12 &operator=(const std::_Iterator_base12 &_Right) noexcept         {
            if (this->_Myproxy == _Right._Myproxy)
                ;
            else if (_Right._Myproxy != 0)
                this->_Adopt(_Right._Myproxy->_Mycont);
            else {
            }
            return (*this);
        }
        ~_Iterator_base12() noexcept         {
        }
        void _Adopt(const std::_Container_base12 *_Parent) noexcept         {
            if (_Parent == 0) {
            } else {
                std::_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
                this->_Myproxy = _Parent_proxy;
            }
        }
        void _Clrcont() noexcept         {
            this->_Myproxy = 0;
        }
        const std::_Container_base12 *_Getcont() const noexcept         {
            return (this->_Myproxy == 0 ? 0 : this->_Myproxy->_Mycont);
        }
        std::_Iterator_base12 **_Getpnext() noexcept         {
            return (&this->_Mynextiter);
        }
        void _Orphan_me() noexcept         {
        }
        std::_Container_proxy *_Myproxy;
        std::_Iterator_base12 *_Mynextiter;
    };
    inline void _Container_base12::_Orphan_all() noexcept     {
    }
    inline void _Container_base12::_Swap_all(std::_Container_base12 &_Right) noexcept     {
        std::_Container_proxy *_Temp = this->_Myproxy;
        this->_Myproxy = _Right._Myproxy;
        _Right._Myproxy = _Temp;
        if (this->_Myproxy != 0)
            this->_Myproxy->_Mycont = (std::_Container_base12 *)this;
        if (_Right._Myproxy != 0)
            _Right._Myproxy->_Mycont = (std::_Container_base12 *)&_Right;
    }
    using _Container_base = std::_Container_base0;
    using _Iterator_base = std::_Iterator_base0;
    struct _Zero_then_variadic_args_t {
    };
    struct _One_then_variadic_args_t {
    };
    template <class _Ty1, class _Ty2, bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>> class final _Compressed_pair : private _Ty1 {
    private:
        _Ty2 _Myval2;
        using _Mybase = _Ty1;
    public:
        template <class ..._Other2> constexpr explicit _Compressed_pair<_Ty1, _Ty2, >(std::_Zero_then_variadic_args_t, _Other2 &&..._Val2) : _Ty1(), _Myval2(::std::forward<_Other2>(_Val2)...)         {
        }
        template <class _Other1, class ..._Other2> _Compressed_pair<_Ty1, _Ty2, >(std::_One_then_variadic_args_t, _Other1 &&_Val1, _Other2 &&..._Val2) : _Ty1(::std::forward<_Other1>(_Val1)), _Myval2(::std::forward<_Other2>(_Val2)...)         {
        }
        _Ty1 &_Get_first() noexcept         {
            return (*this);
        }
        const _Ty1 &_Get_first() const noexcept         volatile _Ty1 &_Get_first() volatile noexcept         const volatile _Ty1 &_Get_first() const volatile noexcept         _Ty2 &_Get_second() noexcept         {
            return (this->_Myval2);
        }
        const _Ty2 &_Get_second() const noexcept         {
            return (this->_Myval2);
        }
        volatile _Ty2 &_Get_second() volatile noexcept         const volatile _Ty2 &_Get_second() const volatile noexcept     };
template<> class final _Compressed_pair<std::allocator<char>, std::_String_val<std::_Simple_types<char> >, true> : private std::allocator<char> {
    private:
        std::_String_val<std::_Simple_types<char> > _Myval2;
        using _Mybase = std::allocator<char>;
    public:
        template <class ..._Other2> constexpr explicit _Compressed_pair(std::_Zero_then_variadic_args_t, _Other2 &&..._Val2);
        template <class _Other1, class ..._Other2> _Compressed_pair(std::_One_then_variadic_args_t, _Other1 &&_Val1, _Other2 &&..._Val2);
        std::allocator<char> &_Get_first() noexcept;
        const std::allocator<char> &_Get_first() const noexcept;
        volatile std::allocator<char> &_Get_first() volatile noexcept;
        const volatile std::allocator<char> &_Get_first() const volatile noexcept;
        std::_String_val<std::_Simple_types<char> > &_Get_second() noexcept;
        const std::_String_val<std::_Simple_types<char> > &_Get_second() const noexcept         {
            return (this->_Myval2);
        }
        volatile std::_String_val<std::_Simple_types<char> > &_Get_second() volatile noexcept;
        const volatile std::_String_val<std::_Simple_types<char> > &_Get_second() const volatile noexcept;
    };
template<> class final _Compressed_pair<std::default_delete<v8::internal::ScriptStreamingData>, v8::internal::ScriptStreamingData *, true> : private std::default_delete<v8::internal::ScriptStreamingData> {
    private:
        v8::internal::ScriptStreamingData *_Myval2;
        using _Mybase = std::default_delete<v8::internal::ScriptStreamingData>;
    public:
        template <class ..._Other2> constexpr explicit _Compressed_pair(std::_Zero_then_variadic_args_t, _Other2 &&..._Val2);
        template <class _Other1, class ..._Other2> _Compressed_pair(std::_One_then_variadic_args_t, _Other1 &&_Val1, _Other2 &&..._Val2);
        std::default_delete<v8::internal::ScriptStreamingData> &_Get_first() noexcept;
        const std::default_delete<v8::internal::ScriptStreamingData> &_Get_first() const noexcept;
        volatile std::default_delete<v8::internal::ScriptStreamingData> &_Get_first() volatile noexcept;
        const volatile std::default_delete<v8::internal::ScriptStreamingData> &_Get_first() const volatile noexcept;
        v8::internal::ScriptStreamingData *&_Get_second() noexcept;
        v8::internal::ScriptStreamingData *const &_Get_second() const noexcept         {
            return (this->_Myval2);
        }
        v8::internal::ScriptStreamingData *volatile &_Get_second() volatile noexcept;
        v8::internal::ScriptStreamingData *const volatile &_Get_second() const volatile noexcept;
    };
template<> class final _Compressed_pair<std::default_delete<unsigned char const[]>, const unsigned char *, true> : private std::default_delete<unsigned char const[]> {
    private:
        const unsigned char *_Myval2;
        using _Mybase = std::default_delete<unsigned char const[]>;
    public:
        template <class ..._Other2> constexpr explicit _Compressed_pair(std::_Zero_then_variadic_args_t, _Other2 &&..._Val2);
        template<> constexpr explicit _Compressed_pair<<const unsigned char *&>>(std::_Zero_then_variadic_args_t, const unsigned char *&_Val2) : std::default_delete<unsigned char const[]>(), _Myval2(::std::forward<const unsigned char *&>(_Val2))         {
        }
;
        template <class _Other1, class ..._Other2> _Compressed_pair(std::_One_then_variadic_args_t, _Other1 &&_Val1, _Other2 &&..._Val2);
        template<> _Compressed_pair<std::default_delete<unsigned char const[]>, <const unsigned char *&>>(std::_One_then_variadic_args_t, std::default_delete<unsigned char const[]> &&_Val1, const unsigned char *&_Val2) : std::default_delete<unsigned char const[]>(::std::forward<std::default_delete<unsigned char const[]> >(_Val1)), _Myval2(::std::forward<const unsigned char *&>(_Val2))         {
        }
;
        std::default_delete<unsigned char const[]> &_Get_first() noexcept         {
            return (*this);
        }
        const std::default_delete<unsigned char const[]> &_Get_first() const noexcept;
        volatile std::default_delete<unsigned char const[]> &_Get_first() volatile noexcept;
        const volatile std::default_delete<unsigned char const[]> &_Get_first() const volatile noexcept;
        const unsigned char *&_Get_second() noexcept         {
            return (this->_Myval2);
        }
        const unsigned char *const &_Get_second() const noexcept         {
            return (this->_Myval2);
        }
        const unsigned char *volatile &_Get_second() volatile noexcept;
        const unsigned char *const volatile &_Get_second() const volatile noexcept;
    };
template<> class final _Compressed_pair<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, v8::WasmStreaming::WasmStreamingImpl *, true> : private std::default_delete<v8::WasmStreaming::WasmStreamingImpl> {
    private:
        v8::WasmStreaming::WasmStreamingImpl *_Myval2;
        using _Mybase = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>;
    public:
        template <class ..._Other2> constexpr explicit _Compressed_pair(std::_Zero_then_variadic_args_t, _Other2 &&..._Val2);
        template <class _Other1, class ..._Other2> _Compressed_pair(std::_One_then_variadic_args_t, _Other1 &&_Val1, _Other2 &&..._Val2);
        std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &_Get_first() noexcept;
        const std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &_Get_first() const noexcept;
        volatile std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &_Get_first() volatile noexcept;
        const volatile std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &_Get_first() const volatile noexcept;
        v8::WasmStreaming::WasmStreamingImpl *&_Get_second() noexcept;
        v8::WasmStreaming::WasmStreamingImpl *const &_Get_second() const noexcept;
        v8::WasmStreaming::WasmStreamingImpl *volatile &_Get_second() volatile noexcept;
        v8::WasmStreaming::WasmStreamingImpl *const volatile &_Get_second() const volatile noexcept;
    };
    template <class _Ty1, class _Ty2> class final _Compressed_pair<_Ty1, _Ty2, false> {
    private:
        _Ty1 _Myval1;
        _Ty2 _Myval2;
    public:
        template <class ..._Other2> constexpr explicit _Compressed_pair<type-parameter-0-0, type-parameter-0-1, false>(std::_Zero_then_variadic_args_t, _Other2 &&..._Val2) : _Myval1(), _Myval2(::std::forward<_Other2>(_Val2)...)         {
        }
        template <class _Other1, class ..._Other2> _Compressed_pair<type-parameter-0-0, type-parameter-0-1, false>(std::_One_then_variadic_args_t, _Other1 &&_Val1, _Other2 &&..._Val2)         _Ty1 &_Get_first() noexcept         const _Ty1 &_Get_first() const noexcept         volatile _Ty1 &_Get_first() volatile noexcept         const volatile _Ty1 &_Get_first() const volatile noexcept         _Ty2 &_Get_second() noexcept         const _Ty2 &_Get_second() const noexcept         volatile _Ty2 &_Get_second() volatile noexcept         const volatile _Ty2 &_Get_second() const volatile noexcept     };
    template <class _Ty, class  = void> struct _Is_checked_helper : std::false_type {
    };
    template <class _Ty> struct _Is_checked_helper<_Ty, void> : std::true_type {
    };
    template <class _Iter> inline typename _Is_checked_helper<_Iter>::type _Is_checked(_Iter)     template <class _Iter> constexpr _Iter _Unchecked(_Iter _Src)     {
        return (_Src);
    }
    template <class _Iter> using _Unchecked_t = decltype(_Unchecked(::std::declval<_Iter>()));
    template <class _Iter> inline _Unchecked_t<_Iter> _Unchecked_idl0(_Iter _Src)     template <class _Iter, class _UIter> constexpr _Iter &_Rechecked(_Iter &_Dest, const _UIter _Src)     {
        _Dest = _Src;
        return (_Dest);
    }
    template <class _Fx> struct _Ref_fn {
        template <class ..._Args> constexpr decltype(auto) operator()(_Args &&..._Vals)         {
            return (this->_Fn(::std::forward<_Args>(_Vals)...));
        }
        _Fx &_Fn;
    };
    template <class _Fn> constexpr bool _Pass_functor_by_value_v = sizeof(_Fn) <= sizeof(void *) && conjunction_v<is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn> >;
    template <class _Fn, enable_if_t<_Pass_functor_by_value_v<_Fn>, int> = 0> constexpr _Fn _Pass_fn(_Fn _Val)     {
        return (_Val);
    }
    template <class _Fn, enable_if_t<!_Pass_functor_by_value_v<_Fn>, int> = 0> constexpr _Ref_fn<_Fn> _Pass_fn(_Fn &_Val)     {
        return {_Val};
    }
    struct input_iterator_tag {
    };
    struct output_iterator_tag {
    };
    struct forward_iterator_tag : std::input_iterator_tag {
    };
    struct bidirectional_iterator_tag : std::forward_iterator_tag {
    };
    struct random_access_iterator_tag : std::bidirectional_iterator_tag {
    };
    struct _General_ptr_iterator_tag {
    };
    struct _Trivially_copyable_ptr_iterator_tag : std::_General_ptr_iterator_tag {
    };
    struct _Really_trivial_ptr_iterator_tag : std::_Trivially_copyable_ptr_iterator_tag {
    };
    struct _Unused_parameter {
        _Unused_parameter() = default
        template <class _Ty> constexpr _Unused_parameter(_Ty &&) noexcept         {
        }
    };
    using _Any_tag = std::_Unused_parameter;
    template <class _Ty> using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;
    template <class , class  = void> struct _Iterator_traits_base {
    };
    template <class _Iter> struct _Iterator_traits_base<_Iter, void> {
        using iterator_category = typename _Iter::iterator_category;
        using value_type = typename _Iter::value_type;
        using difference_type = typename _Iter::difference_type;
        using pointer = typename _Iter::pointer;
        using reference = typename _Iter::reference;
    };
    template <class _Ty, bool = is_object_v<_Ty>> struct _Iterator_traits_pointer_base {
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<_Ty>;
        using difference_type = ptrdiff_t;
        using pointer = _Ty *;
        using reference = _Ty &;
    };
    template <class _Ty> struct _Iterator_traits_pointer_base<_Ty, false> {
    };
    template <class _Iter> struct iterator_traits : _Iterator_traits_base<_Iter> {
    };
    template <class _Ty> struct iterator_traits<type-parameter-0-0 *> : _Iterator_traits_pointer_base<_Ty> {
    };
    template <class _Iter> using _Iter_value_t = typename iterator_traits<_Iter>::value_type;
    template <class _Iter> using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;
    template <class ..._Iters> using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;
    template <class _Iter> using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;
    template <class _Ty, class  = void> constexpr bool _Is_iterator_v = false;
    constexpr bool _Is_iterator_v = true;
    template <class _Ty> struct _Is_iterator : bool_constant<_Is_iterator_v<_Ty> > {
    };
    template <class _Iter> constexpr bool _Is_input_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, std::input_iterator_tag>;
    template <class _Iter> constexpr bool _Is_fwd_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, std::forward_iterator_tag>;
    template <class _Iter> constexpr bool _Is_bidi_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, std::bidirectional_iterator_tag>;
    template <class _Iter> constexpr bool _Is_random_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, std::random_access_iterator_tag>;
    template <size_t _Value> struct _Priority_tag : _Priority_tag<_Value - 1> {
    };
    template<> struct _Priority_tag<0> {
    };
    struct _Distance_unknown {
    };
    template <class _Checked, class _Iter> inline std::_Distance_unknown _Idl_distance(const _Iter &, const _Iter &)     template <class _Iter, class _Diff> inline auto _Unchecked_n(_Iter _Src, _Diff)     {
        return (_Unchecked(_Src));
    }
    template <class _Iter, class _Diff> inline auto _Unchecked_n_backward(_Iter _Src, _Diff)     {
        return (_Unchecked(_Src));
    }
    template <class _Ty1, class _Ty2> struct _Is_same_size : bool_constant<sizeof(_Ty1) == sizeof(_Ty2)> {
    };
    template <class _Elem, bool _Is_enum = is_enum_v<_Elem>> struct _Unwrap_enum {
        using type = underlying_type_t<_Elem>;
    };
    template <class _Elem> struct _Unwrap_enum<_Elem, false> {
        using type = _Elem;
    };
    template <class _Elem> using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;
    template <class _Ty1, class _Ty2> struct _Both_or_neither_bool : bool_constant<is_same_v<bool, _Ty1> == is_same_v<bool, _Ty2> > {
    };
    template <class _Source, class _Dest> struct _Ptr_cat_helper {
        using _USource = _Unwrap_enum_t<_Source>;
        using _UDest = _Unwrap_enum_t<_Dest>;
        using type = conditional_t<conjunction_v<_Is_same_size<std::_Ptr_cat_helper::_USource, std::_Ptr_cat_helper::_UDest>, is_integral<std::_Ptr_cat_helper::_USource>, is_integral<std::_Ptr_cat_helper::_UDest>, _Both_or_neither_bool<std::_Ptr_cat_helper::_USource, std::_Ptr_cat_helper::_UDest> >, std::_Really_trivial_ptr_iterator_tag, std::_General_ptr_iterator_tag>;
    };
    template <class _Elem> struct _Ptr_cat_helper<_Elem, _Elem> {
        using type = conditional_t<is_trivially_copyable_v<_Elem>, conditional_t<is_trivial_v<_Elem>, std::_Really_trivial_ptr_iterator_tag, std::_Trivially_copyable_ptr_iterator_tag>, std::_General_ptr_iterator_tag>;
    };
    template <class _Anything> struct _Ptr_cat_helper<type-parameter-0-0 *, const type-parameter-0-0 *> {
        using type = std::_Really_trivial_ptr_iterator_tag;
    };
    template <class _Anything> struct _Ptr_cat_helper<type-parameter-0-0 *, volatile type-parameter-0-0 *> {
        using type = std::_Really_trivial_ptr_iterator_tag;
    };
    template <class _Anything> struct _Ptr_cat_helper<type-parameter-0-0 *, const volatile type-parameter-0-0 *> {
        using type = std::_Really_trivial_ptr_iterator_tag;
    };
    template <class _Source, class _Dest> inline std::_General_ptr_iterator_tag _Ptr_copy_cat(const _Source &, const _Dest &)     template <class _Source, class _Dest> inline conditional_t<is_trivially_assignable_v<_Dest &, _Source &>, typename _Ptr_cat_helper<remove_cv_t<_Source>, remove_cv_t<_Dest> >::type, std::_General_ptr_iterator_tag> _Ptr_copy_cat(_Source *const &, _Dest *const &)     template <class _Source, class _Dest> inline std::_General_ptr_iterator_tag _Ptr_move_cat(const _Source &, const _Dest &)     template <class _Source, class _Dest> inline conditional_t<is_trivially_assignable_v<_Dest &, _Source>, typename _Ptr_cat_helper<remove_cv_t<_Source>, remove_cv_t<_Dest> >::type, std::_General_ptr_iterator_tag> _Ptr_move_cat(_Source *const &, _Dest *const &)     template <class _InIt, class _Diff> inline void _Advance1(_InIt &_Where, _Diff _Off, std::input_iterator_tag)     template <class _BidIt, class _Diff> inline void _Advance1(_BidIt &_Where, _Diff _Off, std::bidirectional_iterator_tag)     template <class _RanIt, class _Diff> inline void _Advance1(_RanIt &_Where, _Diff _Off, std::random_access_iterator_tag)     template <class _InIt, class _Diff> inline void advance(_InIt &_Where, _Diff _Off)     template <class _InIt> inline _Iter_diff_t<_InIt> _Distance1(_InIt _First, _InIt _Last, std::input_iterator_tag)     template <class _RanIt> inline _Iter_diff_t<_RanIt> _Distance1(_RanIt _First, _RanIt _Last, std::random_access_iterator_tag)     template <class _InIt> inline _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last)     template <class _InIt> constexpr _InIt _Next_iter(_InIt _First)     {
        return (++_First);
    }
    template <class _InIt> inline _InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1)     template <class _BidIt> constexpr _BidIt _Prev_iter(_BidIt _First)     {
        return (--_First);
    }
    template <class _BidIt> inline _BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1)     template <class _Ty> struct pointer_traits;
    template <class _Iterator> constexpr _Iterator _Operator_arrow(_Iterator _Target, std::true_type)     {
        return (_Target);
    }
    template <class _Iterator> constexpr decltype(auto) _Operator_arrow(_Iterator &&_Target, std::false_type)     {
        return (::std::forward<_Iterator>(_Target).operator->());
    }
    template <class _RanIt> class reverse_iterator {
    public:
        using iterator_category = typename iterator_traits<_RanIt>::iterator_category;
        using value_type = typename iterator_traits<_RanIt>::value_type;
        using difference_type = typename iterator_traits<_RanIt>::difference_type;
        using pointer = typename iterator_traits<_RanIt>::pointer;
        using reference = typename iterator_traits<_RanIt>::reference;
        using iterator_type = _RanIt;
        inline reverse_iterator<_RanIt>()         inline explicit reverse_iterator<_RanIt>(_RanIt _Right)         template <class _Other> inline reverse_iterator<_RanIt>(const reverse_iterator<_Other> &_Right)         template <class _Other> inline reverse_iterator<_RanIt> &operator=(const reverse_iterator<_Other> &_Right)         inline _RanIt base() const         inline std::reverse_iterator::reference operator*() const         inline std::reverse_iterator::pointer operator->() const         inline reverse_iterator<_RanIt> &operator++()         inline reverse_iterator<_RanIt> operator++(int)         inline reverse_iterator<_RanIt> &operator--()         inline reverse_iterator<_RanIt> operator--(int)         inline reverse_iterator<_RanIt> &operator+=(std::reverse_iterator::difference_type _Off)         inline reverse_iterator<_RanIt> operator+(std::reverse_iterator::difference_type _Off) const         inline reverse_iterator<_RanIt> &operator-=(std::reverse_iterator::difference_type _Off)         inline reverse_iterator<_RanIt> operator-(std::reverse_iterator::difference_type _Off) const         inline std::reverse_iterator::reference operator[](std::reverse_iterator::difference_type _Off) const     protected:
        _RanIt current;
    };
    template <class _RanIt> struct _Is_checked_helper<reverse_iterator<type-parameter-0-0>, void> : public _Is_checked_helper<_RanIt> {
    };
    template <class _RanIt> inline reverse_iterator<_RanIt> operator+(typename reverse_iterator<_RanIt>::difference_type _Off, const reverse_iterator<_RanIt> &_Right)     template <class _RanIt1, class _RanIt2> inline auto operator-(const reverse_iterator<_RanIt1> &_Left, const reverse_iterator<_RanIt2> &_Right) -> decltype(_Right.base() - _Left.base())     template <class _RanIt1, class _RanIt2> inline bool operator==(const reverse_iterator<_RanIt1> &_Left, const reverse_iterator<_RanIt2> &_Right)     template <class _RanIt1, class _RanIt2> inline bool operator!=(const reverse_iterator<_RanIt1> &_Left, const reverse_iterator<_RanIt2> &_Right)     template <class _RanIt1, class _RanIt2> inline bool operator<(const reverse_iterator<_RanIt1> &_Left, const reverse_iterator<_RanIt2> &_Right)     template <class _RanIt1, class _RanIt2> inline bool operator>(const reverse_iterator<_RanIt1> &_Left, const reverse_iterator<_RanIt2> &_Right)     template <class _RanIt1, class _RanIt2> inline bool operator<=(const reverse_iterator<_RanIt1> &_Left, const reverse_iterator<_RanIt2> &_Right)     template <class _RanIt1, class _RanIt2> inline bool operator>=(const reverse_iterator<_RanIt1> &_Left, const reverse_iterator<_RanIt2> &_Right)     template <class _RanIt> inline reverse_iterator<_RanIt> make_reverse_iterator(_RanIt _Iter)     template <class _Container> inline auto begin(_Container &_Cont) -> decltype(_Cont.begin())     template <class _Container> inline auto begin(const _Container &_Cont) -> decltype(_Cont.begin())     template <class _Container> inline auto end(_Container &_Cont) -> decltype(_Cont.end())     template <class _Container> inline auto end(const _Container &_Cont) -> decltype(_Cont.end())     template <class _Ty, size_t _Size> constexpr _Ty *begin(_Ty (&_Array)[_Size]) noexcept     {
        return (_Array);
    }
    template <class _Ty, size_t _Size> constexpr _Ty *end(_Ty (&_Array)[_Size]) noexcept     {
        return (_Array + _Size);
    }
    template <class _Container> constexpr auto cbegin(const _Container &_Cont) noexcept(noexcept(::std::begin(_Cont))cbegin(const _Container &_Cont) noexcept(noexcept(::std::begin(_Cont))) -> decltype(::std::begin(_Cont))     {
        return (::std::begin(_Cont));
    }
    template <class _Container> constexpr auto cend(const _Container &_Cont) noexcept(noexcept(::std::end(_Cont))cend(const _Container &_Cont) noexcept(noexcept(::std::end(_Cont))) -> decltype(::std::end(_Cont))     {
        return (::std::end(_Cont));
    }
    template <class _Container> inline auto rbegin(_Container &_Cont) -> decltype(_Cont.rbegin())     template <class _Container> inline auto rbegin(const _Container &_Cont) -> decltype(_Cont.rbegin())     template <class _Container> inline auto rend(_Container &_Cont) -> decltype(_Cont.rend())     template <class _Container> inline auto rend(const _Container &_Cont) -> decltype(_Cont.rend())     template <class _Ty, size_t _Size> inline reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])     template <class _Ty, size_t _Size> inline reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])     template <class _Elem> inline reverse_iterator<const _Elem *> rbegin(initializer_list<_Elem> _Ilist)     template <class _Elem> inline reverse_iterator<const _Elem *> rend(initializer_list<_Elem> _Ilist)     template <class _Container> inline auto crbegin(const _Container &_Cont) -> decltype(::std::rbegin(_Cont))     template <class _Container> inline auto crend(const _Container &_Cont) -> decltype(::std::rend(_Cont))     template <class _Container> constexpr auto size(const _Container &_Cont) -> decltype(_Cont.size())     {
        return (_Cont.size());
    }
    template <class _Ty, size_t _Size> constexpr size_t size(const _Ty (&)[_Size]) noexcept     {
        return (_Size);
    }
    template <class _Container> constexpr auto empty(const _Container &_Cont) -> decltype(_Cont.empty())     {
        return (_Cont.empty());
    }
    template <class _Ty, size_t _Size> constexpr bool empty(const _Ty (&)[_Size]) noexcept     {
        return (false);
    }
    template <class _Elem> constexpr bool empty(initializer_list<_Elem> _Ilist) noexcept     {
        return (_Ilist.size() == 0);
    }
    template <class _Container> constexpr auto data(_Container &_Cont) -> decltype(_Cont.data())     {
        return (_Cont.data());
    }
    template <class _Container> constexpr auto data(const _Container &_Cont) -> decltype(_Cont.data())     {
        return (_Cont.data());
    }
    template <class _Ty, size_t _Size> constexpr _Ty *data(_Ty (&_Array)[_Size]) noexcept     {
        return (_Array);
    }
    template <class _Elem> constexpr const _Elem *data(initializer_list<_Elem> _Ilist) noexcept     {
        return (_Ilist.begin());
    }
    template <class _Ty, size_t _Size> class _Array_const_iterator {
    public:
        using iterator_category = std::random_access_iterator_tag;
        using value_type = _Ty;
        using difference_type = ptrdiff_t;
        using pointer = const _Ty *;
        using reference = const _Ty &;
        enum  {
            _EEN_SIZE = _Size
        };
        inline _Array_const_iterator<_Ty, _Size>()         inline explicit _Array_const_iterator<_Ty, _Size>(std::_Array_const_iterator::pointer _Parg, size_t _Off = 0)         using _Unchecked_type = std::_Array_const_iterator::pointer;
        inline std::_Array_const_iterator::reference operator*() const         inline std::_Array_const_iterator::pointer operator->() const         inline _Array_const_iterator<_Ty, _Size> &operator++()         inline _Array_const_iterator<_Ty, _Size> operator++(int)         inline _Array_const_iterator<_Ty, _Size> &operator--()         inline _Array_const_iterator<_Ty, _Size> operator--(int)         inline _Array_const_iterator<_Ty, _Size> &operator+=(ptrdiff_t _Off)         inline _Array_const_iterator<_Ty, _Size> operator+(ptrdiff_t _Off) const         inline _Array_const_iterator<_Ty, _Size> &operator-=(ptrdiff_t _Off)         inline _Array_const_iterator<_Ty, _Size> operator-(ptrdiff_t _Off) const         inline ptrdiff_t operator-(const _Array_const_iterator<_Ty, _Size> &_Right) const         inline std::_Array_const_iterator::reference operator[](ptrdiff_t _Off) const         inline bool operator==(const _Array_const_iterator<_Ty, _Size> &_Right) const         inline bool operator!=(const _Array_const_iterator<_Ty, _Size> &_Right) const         inline bool operator<(const _Array_const_iterator<_Ty, _Size> &_Right) const         inline bool operator>(const _Array_const_iterator<_Ty, _Size> &_Right) const         inline bool operator<=(const _Array_const_iterator<_Ty, _Size> &_Right) const         inline bool operator>=(const _Array_const_iterator<_Ty, _Size> &_Right) const         std::_Array_const_iterator::pointer _Ptr;
    };
    template <class _Ty, size_t _Size> inline _Array_const_iterator<_Ty, _Size> operator+(ptrdiff_t _Off, _Array_const_iterator<_Ty, _Size> _Next)     template <class _Ty, size_t _Size> inline _Array_const_iterator<_Ty, _Size> &_Rechecked(_Array_const_iterator<_Ty, _Size> &_Iter, const typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type _Right)     template <class _Ty, size_t _Size> inline typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type _Unchecked(const _Array_const_iterator<_Ty, _Size> &_Iter)     template <class _Ty, size_t _Size> class _Array_iterator : public _Array_const_iterator<_Ty, _Size> {
    public:
        using _Mybase = _Array_const_iterator<_Ty, _Size>;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = _Ty;
        using difference_type = ptrdiff_t;
        using pointer = _Ty *;
        using reference = _Ty &;
        inline _Array_iterator<_Ty, _Size>()         inline explicit _Array_iterator<_Ty, _Size>(std::_Array_iterator::pointer _Parg, size_t _Off = 0)         enum  {
            _EEN_SIZE = _Size
        };
        using _Unchecked_type = std::_Array_iterator::pointer;
        inline std::_Array_iterator::reference operator*() const         inline std::_Array_iterator::pointer operator->() const         inline _Array_iterator<_Ty, _Size> &operator++()         inline _Array_iterator<_Ty, _Size> operator++(int)         inline _Array_iterator<_Ty, _Size> &operator--()         inline _Array_iterator<_Ty, _Size> operator--(int)         inline _Array_iterator<_Ty, _Size> &operator+=(ptrdiff_t _Off)         inline _Array_iterator<_Ty, _Size> operator+(ptrdiff_t _Off) const         inline _Array_iterator<_Ty, _Size> &operator-=(ptrdiff_t _Off)         inline _Array_iterator<_Ty, _Size> operator-(ptrdiff_t _Off) const         inline ptrdiff_t operator-(const std::_Array_iterator::_Mybase &_Right) const         inline std::_Array_iterator::reference operator[](ptrdiff_t _Off) const     };
    template <class _Ty, size_t _Size> inline _Array_iterator<_Ty, _Size> operator+(ptrdiff_t _Off, _Array_iterator<_Ty, _Size> _Next)     template <class _Ty, size_t _Size> inline _Array_iterator<_Ty, _Size> &_Rechecked(_Array_iterator<_Ty, _Size> &_Iter, const typename _Array_iterator<_Ty, _Size>::_Unchecked_type _Right)     template <class _Ty, size_t _Size> inline typename _Array_iterator<_Ty, _Size>::_Unchecked_type _Unchecked(const _Array_iterator<_Ty, _Size> &_Iter)     template <class _RanIt> class move_iterator {
    public:
        using iterator_category = typename iterator_traits<_RanIt>::iterator_category;
        using value_type = typename iterator_traits<_RanIt>::value_type;
        using difference_type = typename iterator_traits<_RanIt>::difference_type;
        using pointer = _RanIt;
        using _Ref0 = typename iterator_traits<_RanIt>::reference;
        using reference = conditional_t<is_reference_v<std::move_iterator::_Ref0>, remove_reference_t<std::move_iterator::_Ref0> &&, std::move_iterator::_Ref0>;
        using iterator_type = _RanIt;
        inline move_iterator<_RanIt>()         inline explicit move_iterator<_RanIt>(std::move_iterator::iterator_type _Right)         template <class _RanIt2> inline move_iterator<_RanIt>(const move_iterator<_RanIt2> &_Right)         template <class _RanIt2> inline move_iterator<_RanIt> &operator=(const move_iterator<_RanIt2> &_Right)         inline _RanIt base() const         inline std::move_iterator::reference operator*() const         inline std::move_iterator::pointer operator->() const         inline move_iterator<_RanIt> &operator++()         inline move_iterator<_RanIt> operator++(int)         inline move_iterator<_RanIt> &operator--()         inline move_iterator<_RanIt> operator--(int)         inline move_iterator<_RanIt> &operator+=(std::move_iterator::difference_type _Off)         inline move_iterator<_RanIt> operator+(std::move_iterator::difference_type _Off) const         inline move_iterator<_RanIt> &operator-=(std::move_iterator::difference_type _Off)         inline move_iterator<_RanIt> operator-(std::move_iterator::difference_type _Off) const         inline std::move_iterator::reference operator[](std::move_iterator::difference_type _Off) const     protected:
        std::move_iterator::iterator_type current;
    };
    template <class _RanIt> struct _Is_checked_helper<move_iterator<type-parameter-0-0>, void> : public _Is_checked_helper<_RanIt> {
    };
    template <class _RanIt> inline move_iterator<_RanIt> operator+(typename move_iterator<_RanIt>::difference_type _Off, const move_iterator<_RanIt> &_Right)     template <class _RanIt1, class _RanIt2> inline auto operator-(const move_iterator<_RanIt1> &_Left, const move_iterator<_RanIt2> &_Right) -> decltype(_Left.base() - _Right.base())     template <class _RanIt1, class _RanIt2> inline bool operator==(const move_iterator<_RanIt1> &_Left, const move_iterator<_RanIt2> &_Right)     template <class _RanIt1, class _RanIt2> inline bool operator!=(const move_iterator<_RanIt1> &_Left, const move_iterator<_RanIt2> &_Right)     template <class _RanIt1, class _RanIt2> inline bool operator<(const move_iterator<_RanIt1> &_Left, const move_iterator<_RanIt2> &_Right)     template <class _RanIt1, class _RanIt2> inline bool operator>(const move_iterator<_RanIt1> &_Left, const move_iterator<_RanIt2> &_Right)     template <class _RanIt1, class _RanIt2> inline bool operator<=(const move_iterator<_RanIt1> &_Left, const move_iterator<_RanIt2> &_Right)     template <class _RanIt1, class _RanIt2> inline bool operator>=(const move_iterator<_RanIt1> &_Left, const move_iterator<_RanIt2> &_Right)     template <class _RanIt> inline move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)     template <class _Traits> struct _Char_traits_eq {
        using _Elem = typename _Traits::char_type;
        bool operator()(std::_Char_traits_eq::_Elem _Left, std::_Char_traits_eq::_Elem _Right) const     };
    template <class _Traits> struct _Char_traits_lt {
        using _Elem = typename _Traits::char_type;
        bool operator()(std::_Char_traits_lt::_Elem _Left, std::_Char_traits_lt::_Elem _Right) const     };
    template <class _InIt, class _OutIt> inline _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest)     template <class _InIt, class _OutIt> inline _OutIt _Copy_unchecked1(_InIt _First, _InIt _Last, _OutIt _Dest, std::_General_ptr_iterator_tag)     template <class _InIt, class _OutIt> inline _OutIt _Copy_unchecked1(_InIt _First, _InIt _Last, _OutIt _Dest, std::_Trivially_copyable_ptr_iterator_tag)     template <class _InIt, class _OutIt> inline _OutIt _Copy_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest)     template <class _InIt, class _OutIt> inline _OutIt _Copy_no_deprecate(_InIt _First, _InIt _Last, _OutIt _Dest)     template <class _InIt, class _OutIt> inline _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest)     template <class _InIt, class _Diff, class _OutIt> inline _OutIt _Copy_n_unchecked2(_InIt _First, _Diff _Count, _OutIt _Dest, std::input_iterator_tag)     template <class _InIt, class _Diff, class _OutIt> inline _OutIt _Copy_n_unchecked2(_InIt _First, _Diff _Count, _OutIt _Dest, std::forward_iterator_tag)     template <class _InIt, class _Diff, class _OutIt> inline _OutIt _Copy_n_unchecked1(_InIt _First, _Diff _Count, _OutIt _Dest, std::_General_ptr_iterator_tag)     template <class _InIt, class _Diff, class _OutIt> inline _OutIt _Copy_n_unchecked1(_InIt _First, _Diff _Count, _OutIt _Dest, std::_Trivially_copyable_ptr_iterator_tag)     template <class _InIt, class _Diff, class _OutIt> inline _OutIt _Copy_n_unchecked(_InIt _First, _Diff _Count, _OutIt _Dest)     template <class _InIt, class _Diff, class _OutIt> inline _OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest)     template <class _BidIt1, class _BidIt2> inline _BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)     template <class _BidIt1, class _BidIt2> inline _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, std::_General_ptr_iterator_tag)     template <class _BidIt1, class _BidIt2> inline _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, std::_Trivially_copyable_ptr_iterator_tag)     template <class _BidIt1, class _BidIt2> inline _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)     template <class _InIt, class _OutIt> inline _OutIt _Move_unchecked1(_InIt _First, _InIt _Last, _OutIt _Dest, std::_General_ptr_iterator_tag)     template <class _InIt, class _OutIt> inline _OutIt _Move_unchecked1(_InIt _First, _InIt _Last, _OutIt _Dest, std::_Trivially_copyable_ptr_iterator_tag)     template <class _InIt, class _OutIt> inline _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest)     template <class _InIt, class _OutIt> inline _OutIt _Move_no_deprecate(_InIt _First, _InIt _Last, _OutIt _Dest)     template <class _InIt, class _OutIt> inline _OutIt move(_InIt _First, _InIt _Last, _OutIt _Dest)     template <class _BidIt1, class _BidIt2> inline _BidIt2 _Move_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, std::_General_ptr_iterator_tag)     template <class _BidIt1, class _BidIt2> inline _BidIt2 _Move_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, std::_Trivially_copyable_ptr_iterator_tag)     template <class _BidIt1, class _BidIt2> inline _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)     template <class _BidIt1, class _BidIt2> inline _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)     template <class _Ty> struct _Is_character : std::false_type {
    };
    template<> struct _Is_character<char> : std::true_type {
    };
    template<> struct _Is_character<signed char> : std::true_type {
    };
    template<> struct _Is_character<unsigned char> : std::true_type {
    };
    template <class _FwdIt, class _Ty> struct _Fill_memset_is_safe_helper {
        using _Value_type = _Iter_value_t<_FwdIt>;
        using _Raw_ty = _Unwrap_enum_t<_Ty>;
        using _Raw_value_type = _Unwrap_enum_t<std::_Fill_memset_is_safe_helper::_Value_type>;
        using type = _Conjunction_t<is_pointer<_FwdIt>, disjunction<conjunction<_Is_character<std::_Fill_memset_is_safe_helper::_Raw_ty>, _Is_character<std::_Fill_memset_is_safe_helper::_Raw_value_type> >, conjunction<is_same<bool, std::_Fill_memset_is_safe_helper::_Raw_ty>, is_same<bool, std::_Fill_memset_is_safe_helper::_Raw_value_type> > >, is_convertible<_Ty, std::_Fill_memset_is_safe_helper::_Value_type> >;
    };
    template <class _FwdIt, class _Ty> inline typename _Fill_memset_is_safe_helper<_FwdIt, _Ty>::type _Fill_memset_is_safe(const _FwdIt &, const _Ty &)     template <class _FwdIt, class _Ty> inline void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty &_Val, std::false_type)     template <class _FwdIt, class _Ty> inline void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty &_Val, std::true_type)     template <class _FwdIt, class _Ty> inline void _Fill_unchecked(_FwdIt _First, _FwdIt _Last, const _Ty &_Val)     template <class _FwdIt, class _Ty> inline void fill(_FwdIt _First, _FwdIt _Last, const _Ty &_Val)     template <class _OutIt, class _Diff, class _Ty> inline _OutIt _Fill_n_unchecked1(_OutIt _Dest, _Diff _Count, const _Ty &_Val, std::false_type)     template <class _OutIt, class _Diff, class _Ty> inline _OutIt _Fill_n_unchecked1(_OutIt _Dest, _Diff _Count, const _Ty &_Val, std::true_type)     template <class _OutIt, class _Diff, class _Ty> inline _OutIt _Fill_n_unchecked(_OutIt _Dest, _Diff _Count, const _Ty &_Val)     template <class _OutIt, class _Diff, class _Ty> inline _OutIt fill_n(_OutIt _Dest, _Diff _Count_raw, const _Ty &_Val)     template <class _Elem1, class _Elem2> struct _Value_equality_is_bitwise_equality : bool_constant<static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1)> {
    };
    template <class _Elem1, class _Elem2, class _Pr> struct _Equal_memcmp_is_safe_helper : std::false_type {
    };
    template <class _Elem1, class _Elem2> struct _Equal_memcmp_is_safe_helper<_Elem1, _Elem2, std::equal_to<void>> : _Conjunction_t<_Is_same_size<_Elem1, _Elem2>, _Is_nonbool_integral<_Elem1>, _Is_nonbool_integral<_Elem2>, negation<is_volatile<_Elem1> >, negation<is_volatile<_Elem2> >, _Value_equality_is_bitwise_equality<_Elem1, _Elem2> > {
    };
    template <class _Elem1, class _Elem2> struct _Equal_memcmp_is_safe_helper<type-parameter-0-0 *, type-parameter-0-1 *, std::equal_to<void>> : is_same<remove_cv_t<_Elem1>, remove_cv_t<_Elem2> >::type {
    };
    template <class _Elem> struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<type-parameter-0-0> >> : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<> >::type {
    };
    template <class _Elem> struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<type-parameter-0-0>> : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<> >::type {
    };
    template <class _Iter1, class _Iter2, class _Pr> inline std::false_type _Equal_memcmp_is_safe(const _Iter1 &, const _Iter2 &, const _Pr &)     template <class _Obj1, class _Obj2, class _Pr> inline typename _Equal_memcmp_is_safe_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _Pr>::type _Equal_memcmp_is_safe(_Obj1 *const &, _Obj2 *const &, const _Pr &)     template <class _InIt1, class _InIt2, class _Pr> inline bool _Equal_unchecked1(_InIt1 _First1, const _InIt1 _Last1, _InIt2 _First2, _Pr _Pred, std::false_type)     template <class _InIt1, class _InIt2, class _Pr> inline bool _Equal_unchecked1(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr, std::true_type)     template <class _InIt1, class _InIt2, class _Pr> inline bool _Equal_unchecked(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred)     template <class _InIt1, class _InIt2, class _Pr> inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred)     template <class _InIt1, class _InIt2> inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2)     template <class _InIt1, class _InIt2, class _Pr> inline bool _Equal_unchecked(_InIt1 _First1, const _InIt1 _Last1, _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred, std::input_iterator_tag, std::input_iterator_tag)     template <class _InIt1, class _InIt2, class _Pr> inline bool _Equal_unchecked(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred, std::random_access_iterator_tag, std::random_access_iterator_tag)     template <class _InIt1, class _InIt2, class _Pr> inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred)     template <class _InIt1, class _InIt2> inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2)     template <class _Elem1, class _Elem2, class _FTy> struct _Lex_compare_check_element_types_helper : _Conjunction_t<_Is_character<_Elem1>, _Is_character<_Elem2>, _Is_character<_FTy>, is_unsigned<_FTy> > {
    };
    template <class _Elem1, class _Elem2> struct _Lex_compare_check_element_types_helper<_Elem1, _Elem2, void> : _Conjunction_t<_Is_character<_Elem1>, _Is_character<_Elem2>, is_unsigned<_Elem1>, is_unsigned<_Elem2> > {
    };
    template <class _Memcmp_pr> struct _Lex_compare_optimize {
    };
    template <class _Memcmp_pr, class _Obj1, class _Obj2, class _FTy> using _Lex_compare_check_element_types = _Lex_compare_optimize<conditional_t<_Lex_compare_check_element_types_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _FTy>::value, _Memcmp_pr, void> >;
    template <class _InIt1, class _InIt2, class _Pr> inline _Lex_compare_optimize<void> _Lex_compare_memcmp_classify(const _InIt1 &, const _InIt2 &, const _Pr &)     template <class _Obj1, class _Obj2, class _FTy> inline _Lex_compare_check_element_types<less<int>, _Obj1, _Obj2, _FTy> _Lex_compare_memcmp_classify(_Obj1 *const &, _Obj2 *const &, const less<_FTy> &)     template <class _Obj1, class _Obj2, class _FTy> inline _Lex_compare_check_element_types<greater<int>, _Obj1, _Obj2, _FTy> _Lex_compare_memcmp_classify(_Obj1 *const &, _Obj2 *const &, const greater<_FTy> &)     template <class _InIt1, class _InIt2, class _Pr> inline bool _Lex_compare_unchecked(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred, _Lex_compare_optimize<void>)     template <class _InIt1, class _InIt2, class _Pr, class _Memcmp_pr> inline bool _Lex_compare_unchecked(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr, _Lex_compare_optimize<_Memcmp_pr>)     template <class _InIt1, class _InIt2, class _Pr> inline bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)     template <class _InIt1, class _InIt2> inline bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2)     template <class _Ty> inline bool _Within_limits(const _Ty &_Val, std::true_type, std::true_type, std::_Any_tag)     template <class _Ty> inline bool _Within_limits(const _Ty &_Val, std::true_type, std::false_type, std::true_type)     template <class _Ty> inline bool _Within_limits(const _Ty &_Val, std::true_type, std::false_type, std::false_type)     template <class _Ty> inline bool _Within_limits(const _Ty &_Val, std::false_type, std::true_type, std::_Any_tag)     template <class _Ty> inline bool _Within_limits(const _Ty &_Val, std::false_type, std::false_type, std::_Any_tag)     template <class _InIt, class _Ty> inline bool _Within_limits(_InIt, const _Ty &_Val)     template <class _InIt> inline bool _Within_limits(_InIt, const bool &)     template <class _InIt, class _Ty> inline _InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty &_Val, std::true_type)     template <class _InIt, class _Ty> inline _InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty &_Val, std::false_type)     template <class _InIt, class _Ty> inline _InIt _Find_unchecked(const _InIt _First, const _InIt _Last, const _Ty &_Val)     template <class _InIt, class _Ty> inline _InIt find(_InIt _First, const _InIt _Last, const _Ty &_Val)     template <class _InIt, class _Ty, class _Pr> inline _InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty &_Val, _Pr _Pred)     template <class _InIt, class _Ty> inline _Iter_diff_t<_InIt> count(const _InIt _First, const _InIt _Last, const _Ty &_Val)     template <class _InIt, class _Ty, class _Pr> inline _Iter_diff_t<_InIt> _Count_pr(_InIt _First, _InIt _Last, const _Ty &_Val, _Pr _Pred)     template <class _FwdIt1, class _FwdIt2, class _Pr> inline void _Trim_matching_suffixes(_FwdIt1 &, _FwdIt2 &, _Pr, std::forward_iterator_tag, std::forward_iterator_tag)     template <class _FwdIt1, class _FwdIt2, class _Pr> inline void _Trim_matching_suffixes(_FwdIt1 &_Last1, _FwdIt2 &_Last2, _Pr _Pred, std::bidirectional_iterator_tag, std::bidirectional_iterator_tag)     template <class _FwdIt1, class _FwdIt2, class _Pr> inline bool _Check_match_counts(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)     template <class _FwdIt1, class _FwdIt2, class _Pr> inline bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred)     template <class _FwdIt1, class _FwdIt2, class _Pr> inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred)     template <class _FwdIt1, class _FwdIt2> inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)     template <class _FwdIt1, class _FwdIt2, class _Pr> inline bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, std::forward_iterator_tag, std::forward_iterator_tag)     template <class _FwdIt1, class _FwdIt2, class _Pr> inline bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, std::random_access_iterator_tag, std::random_access_iterator_tag)     template <class _FwdIt1, class _FwdIt2, class _Pr> inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)     template <class _FwdIt1, class _FwdIt2> inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2)     template <class _BidIt> inline void _Reverse_unchecked1(_BidIt _First, _BidIt _Last, integral_constant<size_t, 0>)     template <class _BidIt> inline void _Reverse_unchecked1(const _BidIt _First, const _BidIt _Last, integral_constant<size_t, 1>)     template <class _BidIt> inline void _Reverse_unchecked1(const _BidIt _First, const _BidIt _Last, integral_constant<size_t, 2>)     template <class _BidIt> inline void _Reverse_unchecked1(const _BidIt _First, const _BidIt _Last, integral_constant<size_t, 4>)     template <class _BidIt> inline void _Reverse_unchecked1(const _BidIt _First, const _BidIt _Last, integral_constant<size_t, 8>)     template <class _BidIt> inline void _Reverse_unchecked(const _BidIt _First, const _BidIt _Last)     template <class _BidIt> inline void reverse(const _BidIt _First, const _BidIt _Last)     template <class _FwdIt> inline _FwdIt _Rotate_unchecked1(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, std::forward_iterator_tag)     template <class _BidIt> inline pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(_BidIt _First, _BidIt _Sentinel, _BidIt _Last)     template <class _BidIt> inline _BidIt _Rotate_unchecked1(_BidIt _First, _BidIt _Mid, _BidIt _Last, std::bidirectional_iterator_tag)     template <class _RanIt> inline _RanIt _Rotate_unchecked1(_RanIt _First, _RanIt _Mid, _RanIt _Last, std::random_access_iterator_tag)     template <class _FwdIt> inline _FwdIt _Rotate_unchecked(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)     template <class _FwdIt> inline _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)     template <class _FwdIt, class _Ty, class _Pr> inline _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty &_Val, _Pr _Pred)     template <class _Diff, class _Urng> class _Rng_from_urng {
    public:
        using _Ty0 = make_unsigned_t<_Diff>;
        using _Ty1 = typename _Urng::result_type;
        using _Udiff = conditional_t<sizeof(std::_Rng_from_urng::_Ty1) < sizeof(std::_Rng_from_urng::_Ty0), std::_Rng_from_urng::_Ty0, std::_Rng_from_urng::_Ty1>;
        explicit _Rng_from_urng<_Diff, _Urng>(_Urng &_Func)         _Diff operator()(_Diff _Index)         std::_Rng_from_urng::_Udiff _Get_all_bits()         _Rng_from_urng<_Diff, _Urng>(const _Rng_from_urng<_Diff, _Urng> &) = delete
        _Rng_from_urng<_Diff, _Urng> &operator=(const _Rng_from_urng<_Diff, _Urng> &) = delete
    private:
        std::_Rng_from_urng::_Udiff _Get_bits()         _Urng &_Ref;
        size_t _Bits;
        std::_Rng_from_urng::_Udiff _Bmask;
    };
    template <class _Elem> class _Yarn {
    public:
        _Yarn<_Elem>()         _Yarn<_Elem>(const _Yarn<_Elem> &_Right)         _Yarn<_Elem>(const _Elem *_Right)         _Yarn<_Elem> &operator=(const _Yarn<_Elem> &_Right)         _Yarn<_Elem> &operator=(const _Elem *_Right)         ~_Yarn<_Elem>() noexcept         bool empty() const         const _Elem *c_str() const         bool _Empty() const         const _Elem *_C_str() const     private:
        void _Tidy()         _Elem *_Myptr;
        _Elem _Nul;
    };
    template <class _Container> class back_insert_iterator {
    public:
        using iterator_category = std::output_iterator_tag;
        using value_type = void;
        using difference_type = void;
        using pointer = void;
        using reference = void;
        using container_type = _Container;
        explicit back_insert_iterator<_Container>(_Container &_Cont)         back_insert_iterator<_Container> &operator=(const typename _Container::value_type &_Val)         back_insert_iterator<_Container> &operator=(typename _Container::value_type &&_Val)         back_insert_iterator<_Container> &operator*()         back_insert_iterator<_Container> &operator++()         back_insert_iterator<_Container> operator++(int)     protected:
        _Container *container;
    };
    template <class _Container> struct _Is_checked_helper<back_insert_iterator<type-parameter-0-0>, void> : public std::true_type {
    };
    template <class _Container> inline back_insert_iterator<_Container> back_inserter(_Container &_Cont)     template <class _Ty, class _Alloc, class  = void> struct _Has_allocator_type : std::false_type {
    };
    template <class _Ty, class _Alloc> struct _Has_allocator_type<_Ty, _Alloc, void> : is_convertible<_Alloc, typename _Ty::allocator_type>::type {
    };
    struct allocator_arg_t {
    };
    constexpr std::allocator_arg_t allocator_arg{};
    void _Xbad_alloc() [[noreturn]];
    void _Xinvalid_argument(const char *) [[noreturn]];
    void _Xlength_error(const char *) [[noreturn]];
    void _Xout_of_range(const char *) [[noreturn]];
    void _Xoverflow_error(const char *) [[noreturn]];
    void _Xruntime_error(const char *) [[noreturn]];
    template <class _Ty, class _Alloc> struct uses_allocator : _Has_allocator_type<_Ty, _Alloc>::type {
    };
    template <class _Ty, class _Alloc> constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;
    template <class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty *, class _Reference = _Ty &> struct iterator {
        using iterator_category = _Category;
        using value_type = _Ty;
        using difference_type = _Diff;
        using pointer = _Pointer;
        using reference = _Reference;
    };
}
namespace std {
    template <size_t _Ty_size> inline size_t _Get_size_of_n(const size_t _Count)     template<> inline size_t _Get_size_of_n<1>(const size_t _Count)     {
        return (_Count);
    }
    template <class _Ty> constexpr size_t _New_alignof = _Max_value(alignof(_Ty), static_cast<size_t>(16ULL));
    struct _Default_allocate_traits {
        static void *_Allocate(const size_t _Bytes)         {
            return (::operator new(_Bytes));
        }
    };
    constexpr bool _Is_pow_2(const size_t _Value) noexcept     {
        return (_Value != 0 && (_Value & (_Value - 1)) == 0);
    }
    constexpr size_t _Big_allocation_threshold = 4096;
    constexpr size_t _Big_allocation_alignment = 32;
    static_assert(2 * sizeof(void *) <= _Big_allocation_alignment, "Big allocation alignment should at least match vector register alignment");
    static_assert(_Is_pow_2(_Big_allocation_alignment), "Big allocation alignment must be a power of two");
    constexpr size_t _Non_user_size = sizeof(void *) + _Big_allocation_alignment - 1;
    template <class _Traits> inline void *_Allocate_manually_vector_aligned(const size_t _Bytes)     inline void _Adjust_manually_vector_aligned(void *&_Ptr, size_t &_Bytes)     {
        _Bytes += _Non_user_size;
        const uintptr_t *const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
        const uintptr_t _Ptr_container = _Ptr_user[-1];
        constexpr uintptr_t _Min_back_shift = sizeof(void *);
        const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
        if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size) {
            ::_invalid_parameter_noinfo_noreturn();
        }
        _Ptr = reinterpret_cast<void *>(_Ptr_container);
    }
    template <size_t _Align, class _Traits = std::_Default_allocate_traits, enable_if_t<(!0 || _Align <= 16ULL), int> = 0> inline void *_Allocate(const size_t _Bytes)     template <size_t _Align, enable_if_t<(!0 || _Align <= 16ULL), int> = 0> inline void _Deallocate(void *_Ptr, size_t _Bytes)     template <class _Ty, class ..._Types> inline void _Construct_in_place(_Ty &_Obj, _Types &&..._Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>_Construct_in_place(_Ty &_Obj, _Types &&..._Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>)     template <class _Ty, class ..._Types> inline _Ty *_Global_new(_Types &&..._Args)     template <class _Ty> struct _Get_first_parameter;
    template <template <class , class ...> class _Ty, class _First, class ..._Rest> struct _Get_first_parameter<<type-parameter-0-1, type-parameter-0-2...>> {
        using type = _First;
    };
    template <class _Newfirst, class _Ty> struct _Replace_first_parameter;
    template <class _Newfirst, template <class , class ...> class _Ty, class _First, class ..._Rest> struct _Replace_first_parameter<_Newfirst, <type-parameter-0-2, type-parameter-0-3...>> {
        using type = _Ty<_Newfirst, _Rest...>;
    };
    template <class _Ty, class  = void> struct _Get_element_type {
        using type = typename _Get_first_parameter<_Ty>::type;
    };
    template <class _Ty> struct _Get_element_type<_Ty, void> {
        using type = typename _Ty::element_type;
    };
    template <class _Ty, class  = void> struct _Get_ptr_difference_type {
        using type = ptrdiff_t;
    };
    template <class _Ty> struct _Get_ptr_difference_type<_Ty, void> {
        using type = typename _Ty::difference_type;
    };
    template <class _Ty, class _Other, class  = void> struct _Get_rebind_alias {
        using type = typename _Replace_first_parameter<_Other, _Ty>::type;
    };
    template <class _Ty, class _Other> struct _Get_rebind_alias<_Ty, _Other, void> {
        using type = typename _Ty::rebind<_Other>;
    };
    template <class _Ty> struct pointer_traits {
        using element_type = typename _Get_element_type<_Ty>::type;
        using pointer = _Ty;
        using difference_type = typename _Get_ptr_difference_type<_Ty>::type;
        template <class _Other> using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;
        using _Reftype = conditional_t<is_void_v<std::pointer_traits::element_type>, char &, add_lvalue_reference_t<std::pointer_traits::element_type> >;
        static std::pointer_traits::pointer pointer_to(std::pointer_traits::_Reftype _Val)     };
    template <class _Ty> struct pointer_traits<type-parameter-0-0 *> {
        using element_type = _Ty;
        using pointer = _Ty *;
        using difference_type = ptrdiff_t;
        template <class _Other> using rebind = _Other *;
        using _Reftype = conditional_t<is_void_v<_Ty>, char &, add_lvalue_reference_t<_Ty> >;
        static std::pointer_traits<type-parameter-0-0 *>::pointer pointer_to(std::pointer_traits<type-parameter-0-0 *>::_Reftype _Val)     };
    template <class _Ptr, class _Ty> using _Rebind_pointer_t = typename pointer_traits<_Ptr>::rebind<_Ty>;
    template <class _Pointer, enable_if_t<!is_pointer_v<_Pointer>, int> = 0> inline _Pointer _Refancy(typename pointer_traits<_Pointer>::element_type *_Ptr)     template <class _Pointer, enable_if_t<is_pointer_v<_Pointer>, int> = 0> inline _Pointer _Refancy(_Pointer _Ptr)     template <class _Ty> inline void _Destroy_in_place(_Ty &_Obj) noexcept     template <class _Ptrty> inline auto _Const_cast(_Ptrty _Ptr)     {
        using _Elem = typename pointer_traits<_Ptrty>::element_type;
        using _Modifiable = remove_const_t<_Elem>;
        using _Dest = typename pointer_traits<_Ptrty>::rebind<_Modifiable>;
        return (pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable &>(*_Ptr)));
    }
    template <class _Ty> inline auto _Const_cast(_Ty *_Ptr)     {
        return (const_cast<remove_const_t<_Ty> *>(_Ptr));
    }
    template <class _Ty, class  = void> struct _Get_pointer_type {
        using type = typename _Ty::value_type *;
    };
    template <class _Ty> struct _Get_pointer_type<_Ty, void> {
        using type = typename _Ty::pointer;
    };
    template <class _Ty, class  = void> struct _Get_const_pointer_type {
        using _Ptrty = typename _Get_pointer_type<_Ty>::type;
        using _Valty = typename _Ty::value_type;
        using type = typename pointer_traits<_Ptrty>::rebind<const std::_Get_const_pointer_type::_Valty>;
    };
    template <class _Ty> struct _Get_const_pointer_type<_Ty, void> {
        using type = typename _Ty::const_pointer;
    };
    template <class _Ty, class  = void> struct _Get_void_pointer_type {
        using _Ptrty = typename _Get_pointer_type<_Ty>::type;
        using type = typename pointer_traits<_Ptrty>::rebind<void>;
    };
    template <class _Ty> struct _Get_void_pointer_type<_Ty, void> {
        using type = typename _Ty::void_pointer;
    };
    template <class _Ty, class  = void> struct _Get_const_void_pointer_type {
        using _Ptrty = typename _Get_pointer_type<_Ty>::type;
        using type = typename pointer_traits<_Ptrty>::rebind<const void>;
    };
    template <class _Ty> struct _Get_const_void_pointer_type<_Ty, void> {
        using type = typename _Ty::const_void_pointer;
    };
    template <class _Ty, class  = void> struct _Get_difference_type {
        using _Ptrty = typename _Get_pointer_type<_Ty>::type;
        using type = typename pointer_traits<_Ptrty>::difference_type;
    };
    template <class _Ty> struct _Get_difference_type<_Ty, void> {
        using type = typename _Ty::difference_type;
    };
    template <class _Ty, class  = void> struct _Get_size_type {
        using type = make_unsigned_t<typename _Get_difference_type<_Ty>::type>;
    };
    template <class _Ty> struct _Get_size_type<_Ty, void> {
        using type = typename _Ty::size_type;
    };
    template <class _Ty, class  = void> struct _Get_propagate_on_container_copy {
        using type = std::false_type;
    };
    template <class _Ty> struct _Get_propagate_on_container_copy<_Ty, void> {
        using type = typename _Ty::propagate_on_container_copy_assignment;
    };
    template <class _Ty, class  = void> struct _Get_propagate_on_container_move {
        using type = std::false_type;
    };
    template <class _Ty> struct _Get_propagate_on_container_move<_Ty, void> {
        using type = typename _Ty::propagate_on_container_move_assignment;
    };
    template <class _Ty, class  = void> struct _Get_propagate_on_container_swap {
        using type = std::false_type;
    };
    template <class _Ty> struct _Get_propagate_on_container_swap<_Ty, void> {
        using type = typename _Ty::propagate_on_container_swap;
    };
    template <class _Ty, class  = void> struct _Get_is_always_equal {
        using type = typename is_empty<_Ty>::type;
    };
    template <class _Ty> struct _Get_is_always_equal<_Ty, void> {
        using type = typename _Ty::is_always_equal;
    };
    template <class _Ty, class _Other, class  = void> struct _Get_rebind_type {
        using type = typename _Replace_first_parameter<_Other, _Ty>::type;
    };
    template <class _Ty, class _Other> struct _Get_rebind_type<_Ty, _Other, void> {
        using type = typename _Ty::template _Ty::rebind<_Other>::other;
    };
    template <class _Ty> class allocator
template<> class allocator<char> {
    public:
        static_assert(!is_const_v<char>, "The C++ Standard forbids containers of const elements because allocator<const T> is ill-formed.");
        using _Not_user_specialized = void;
        using value_type = char;
        typedef char *pointer;
        typedef const char *const_pointer;
        typedef char &reference;
        typedef const char &const_reference;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal = std::true_type;
        template <class _Other> struct rebind;
        char *address(char &_Val) const noexcept;
        const char *address(const char &_Val) const noexcept;
        allocator() noexcept;
        allocator(const std::allocator<char> &) = default
        template <class _Other> allocator(const allocator<_Other> &) noexcept;
        template<> allocator<char>(const allocator<char> &) noexcept;
        void deallocate(char *const _Ptr, const size_t _Count);
        char *allocate(const size_t _Count);
        char *allocate(const size_t _Count, const void *);
        template <class _Objty, class ..._Types> void construct(_Objty *const _Ptr, _Types &&..._Args);
        template <class _Uty> void destroy(_Uty *const _Ptr);
        size_t max_size() const noexcept;
    };
    template <class _Alloc, class  = void> struct _Is_default_allocator : std::false_type {
    };
template<> struct _Is_default_allocator<std::allocator<char>, void> : std::true_type {
    };
    template <class _Ty> struct _Is_default_allocator<allocator<type-parameter-0-0>, typename allocator<type-parameter-0-0>::_Not_user_specialized> : std::true_type {
    };
    struct _Has_no_alloc_construct_tag {
    };
    template <class _Void, class ..._Types> struct _Has_no_alloc_construct : std::true_type {
    };
    template <class _Alloc, class _Ptr, class ..._Args> struct _Has_no_alloc_construct<void, <type-parameter-0-0, type-parameter-0-1, type-parameter-0-2...>> : std::false_type {
    };
    template <class _Alloc, class _Ptr, class ..._Args> using _Uses_default_construct = disjunction<_Is_default_allocator<_Alloc>, _Has_no_alloc_construct<void, _Alloc, _Ptr, _Args...> >;
    template <class _Alloc, class _Ptr, class ..._Args> using _Uses_default_construct_t = typename _Uses_default_construct<_Alloc, _Ptr, _Args...>::type;
    struct _Has_no_alloc_destroy_tag {
    };
    template <class _Alloc, class _Ptr, class  = void> struct _Has_no_alloc_destroy : std::true_type {
    };
    template <class _Alloc, class _Ptr> struct _Has_no_alloc_destroy<_Alloc, _Ptr, void> : std::false_type {
    };
    template <class _Alloc, class _Ptr> using _Uses_default_destroy = disjunction<_Is_default_allocator<_Alloc>, _Has_no_alloc_destroy<_Alloc, _Ptr> >;
    template <class _Alloc, class _Ptr> using _Uses_default_destroy_t = typename _Uses_default_destroy<_Alloc, _Ptr>::type;
    struct _Has_allocate_hint_tag {
    };
    template <class _Alloc, class _Size_type, class _Const_void_pointer, class  = void> struct _Has_allocate_hint : std::false_type {
    };
    template <class _Alloc, class _Size_type, class _Const_void_pointer> struct _Has_allocate_hint<_Alloc, _Size_type, _Const_void_pointer, void> : std::true_type {
    };
    struct _Has_max_size_tag {
    };
    template <class _Alloc, class  = void> struct _Has_max_size : std::false_type {
    };
    template <class _Alloc> struct _Has_max_size<_Alloc, void> : std::true_type {
    };
    struct _Has_select_on_container_copy_construction_tag {
    };
    template <class _Alloc, class  = void> struct _Has_select_on_container_copy_construction : std::false_type {
    };
    template <class _Alloc> struct _Has_select_on_container_copy_construction<_Alloc, void> : std::true_type {
    };
    template <class _Alloc> struct allocator_traits
template<> struct allocator_traits<std::allocator<char>> : conditional_t<_Is_default_allocator<allocator<char> >::value, _Default_allocator_traits<std::allocator<char> >, _Normal_allocator_traits<std::allocator<char> > > {
    };
    template <class _Alloc> struct _Normal_allocator_traits {
        using allocator_type = _Alloc;
        using value_type = typename _Alloc::value_type;
        using pointer = typename _Get_pointer_type<_Alloc>::type;
        using const_pointer = typename _Get_const_pointer_type<_Alloc>::type;
        using void_pointer = typename _Get_void_pointer_type<_Alloc>::type;
        using const_void_pointer = typename _Get_const_void_pointer_type<_Alloc>::type;
        using size_type = typename _Get_size_type<_Alloc>::type;
        using difference_type = typename _Get_difference_type<_Alloc>::type;
        using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy<_Alloc>::type;
        using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move<_Alloc>::type;
        using propagate_on_container_swap = typename _Get_propagate_on_container_swap<_Alloc>::type;
        using is_always_equal = typename _Get_is_always_equal<_Alloc>::type;
        template <class _Other> using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
        template <class _Other> using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
        static std::_Normal_allocator_traits::pointer allocate(_Alloc &_Al, const std::_Normal_allocator_traits::size_type _Count)         static std::_Normal_allocator_traits::pointer _Allocate1(_Alloc &_Al, const std::_Normal_allocator_traits::size_type _Count, const std::_Normal_allocator_traits::const_void_pointer _Hint, std::true_type)         static std::_Normal_allocator_traits::pointer _Allocate1(_Alloc &_Al, const std::_Normal_allocator_traits::size_type _Count, std::_Normal_allocator_traits::const_void_pointer, std::false_type)         static std::_Normal_allocator_traits::pointer allocate(_Alloc &_Al, const std::_Normal_allocator_traits::size_type _Count, const std::_Normal_allocator_traits::const_void_pointer _Hint)         static void deallocate(_Alloc &_Al, std::_Normal_allocator_traits::pointer _Ptr, std::_Normal_allocator_traits::size_type _Count)         template <class _Ty, class ..._Types> static void _Construct1(std::true_type, _Alloc &, _Ty *_Ptr, _Types &&..._Args)         template <class _Ty, class ..._Types> static void _Construct1(std::false_type, _Alloc &_Al, _Ty *_Ptr, _Types &&..._Args)         template <class _Ty, class ..._Types> static void construct(_Alloc &_Al, _Ty *_Ptr, _Types &&..._Args)         template <class _Ty> static void _Destroy1(_Alloc &, _Ty *_Ptr, std::true_type)         template <class _Ty> static void _Destroy1(_Alloc &_Al, _Ty *_Ptr, std::false_type)         template <class _Ty> static void destroy(_Alloc &_Al, _Ty *_Ptr)         static std::_Normal_allocator_traits::size_type _Max_size1(const _Alloc &_Al, std::true_type) noexcept         static std::_Normal_allocator_traits::size_type _Max_size1(const _Alloc &, std::false_type) noexcept         static std::_Normal_allocator_traits::size_type max_size(const _Alloc &_Al) noexcept         static _Alloc _Select_on_container_copy_construction1(const _Alloc &_Al, std::true_type)         static _Alloc _Select_on_container_copy_construction1(const _Alloc &_Al, std::false_type)         static _Alloc select_on_container_copy_construction(const _Alloc &_Al)     };
    template <class _Alloc> struct _Default_allocator_traits {
        using allocator_type = _Alloc;
        using value_type = typename _Alloc::value_type;
        using pointer = std::_Default_allocator_traits::value_type *;
        using const_pointer = const std::_Default_allocator_traits::value_type *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <class _Other> using rebind_alloc = allocator<_Other>;
        template <class _Other> using rebind_traits = allocator_traits<allocator<_Other> >;
        static std::_Default_allocator_traits::pointer allocate(_Alloc &, const std::_Default_allocator_traits::size_type _Count)         static std::_Default_allocator_traits::pointer allocate(_Alloc &, const std::_Default_allocator_traits::size_type _Count, std::_Default_allocator_traits::const_void_pointer)         static void deallocate(_Alloc &, const std::_Default_allocator_traits::pointer _Ptr, const std::_Default_allocator_traits::size_type _Count)         template <class _Objty, class ..._Types> static void construct(_Alloc &, _Objty *const _Ptr, _Types &&..._Args)         template <class _Uty> static void destroy(_Alloc &, _Uty *const _Ptr)         static std::_Default_allocator_traits::size_type max_size(const _Alloc &) noexcept         static _Alloc select_on_container_copy_construction(const _Alloc &_Al)     };
template<> struct _Default_allocator_traits<std::allocator<char>> {
        using allocator_type = std::allocator<char>;
        using value_type = typename allocator<char>::value_type;
        using pointer = std::_Default_allocator_traits<std::allocator<char> >::value_type *;
        using const_pointer = const std::_Default_allocator_traits<std::allocator<char> >::value_type *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <class _Other> using rebind_alloc = allocator<_Other>;
        template <class _Other> using rebind_traits = allocator_traits<allocator<_Other> >;
        static std::_Default_allocator_traits<std::allocator<char> >::pointer allocate(std::allocator<char> &, const std::_Default_allocator_traits::size_type _Count);
        static std::_Default_allocator_traits<std::allocator<char> >::pointer allocate(std::allocator<char> &, const std::_Default_allocator_traits::size_type _Count, std::_Default_allocator_traits::const_void_pointer);
        static void deallocate(std::allocator<char> &, const std::_Default_allocator_traits<std::allocator<char> >::pointer _Ptr, const std::_Default_allocator_traits::size_type _Count);
        template <class _Objty, class ..._Types> static void construct(std::allocator<char> &, _Objty *const _Ptr, _Types &&..._Args);
        template <class _Uty> static void destroy(std::allocator<char> &, _Uty *const _Ptr);
        static std::_Default_allocator_traits<std::allocator<char> >::size_type max_size(const std::allocator<char> &) noexcept;
        static std::allocator<char> select_on_container_copy_construction(const std::allocator<char> &_Al);
    };
    template <class _Alloc> struct allocator_traits : conditional_t<_Is_default_allocator<_Alloc>::value, _Default_allocator_traits<_Alloc>, _Normal_allocator_traits<_Alloc> > {
    };
template<> struct allocator_traits<std::allocator<char>> : conditional_t<_Is_default_allocator<allocator<char> >::value, _Default_allocator_traits<std::allocator<char> >, _Normal_allocator_traits<std::allocator<char> > > {
    };
    template <class _Alloc> constexpr bool _Always_equal_after_move = allocator_traits<_Alloc>::is_always_equal::value || allocator_traits<_Alloc>::propagate_on_container_move_assignment::value;
    template <class _Alloc, class _Value_type> using _Rebind_alloc_t = typename allocator_traits<_Alloc>::rebind_alloc<_Value_type>;
    template <class _Alloc> constexpr bool _Is_simple_alloc_v = is_same_v<typename allocator_traits<_Alloc>::size_type, size_t> && is_same_v<typename allocator_traits<_Alloc>::difference_type, ptrdiff_t> && is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type *> && is_same_v<typename allocator_traits<_Alloc>::const_pointer, const typename _Alloc::value_type *>;
    template <class _Value_type> struct _Simple_types {
        using value_type = _Value_type;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        using pointer = std::_Simple_types::value_type *;
        using const_pointer = const std::_Simple_types::value_type *;
    };
template<> struct _Simple_types<char> {
        using value_type = char;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        using pointer = std::_Simple_types<char>::value_type *;
        using const_pointer = const std::_Simple_types<char>::value_type *;
    };
    template <class _Ty> class allocator {
    public:
        static_assert(!is_const_v<_Ty>, "The C++ Standard forbids containers of const elements because allocator<const T> is ill-formed.");
        using _Not_user_specialized = void;
        using value_type = _Ty;
        typedef _Ty *pointer;
        typedef const _Ty *const_pointer;
        typedef _Ty &reference;
        typedef const _Ty &const_reference;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal = std::true_type;
        template <class _Other> struct rebind {
            using other = allocator<_Other>;
        };
        _Ty *address(_Ty &_Val) const noexcept         const _Ty *address(const _Ty &_Val) const noexcept         allocator<_Ty>() noexcept         allocator<_Ty>(const allocator<_Ty> &) noexcept = default
        template <class _Other> allocator<_Ty>(const allocator<_Other> &) noexcept         void deallocate(_Ty *const _Ptr, const size_t _Count)         _Ty *allocate(const size_t _Count)         _Ty *allocate(const size_t _Count, const void *)         template <class _Objty, class ..._Types> void construct(_Objty *const _Ptr, _Types &&..._Args)         template <class _Uty> void destroy(_Uty *const _Ptr)         size_t max_size() const noexcept     };
template<> class allocator<char> {
    public:
        static_assert(!is_const_v<char>, "The C++ Standard forbids containers of const elements because allocator<const T> is ill-formed.");
        using _Not_user_specialized = void;
        using value_type = char;
        typedef char *pointer;
        typedef const char *const_pointer;
        typedef char &reference;
        typedef const char &const_reference;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal = std::true_type;
        template <class _Other> struct rebind;
        char *address(char &_Val) const noexcept;
        const char *address(const char &_Val) const noexcept;
        allocator() noexcept;
        allocator(const std::allocator<char> &) = default
        template <class _Other> allocator(const allocator<_Other> &) noexcept;
        template<> allocator<char>(const allocator<char> &) noexcept;
        void deallocate(char *const _Ptr, const size_t _Count);
        char *allocate(const size_t _Count);
        char *allocate(const size_t _Count, const void *);
        template <class _Objty, class ..._Types> void construct(_Objty *const _Ptr, _Types &&..._Args);
        template <class _Uty> void destroy(_Uty *const _Ptr);
        size_t max_size() const noexcept;
    };
    template<> class allocator<void> {
    public:
        using value_type = void;
        using pointer = void *;
        using const_pointer = const void *;
        template <class _Other> struct rebind {
            using other = allocator<_Other>;
        };
    };
    template <class _Ty, class _Other> inline bool operator==(const allocator<_Ty> &, const allocator<_Other> &) noexcept     template <class _Ty, class _Other> inline bool operator!=(const allocator<_Ty> &, const allocator<_Other> &) noexcept     template <class _Alloc> inline void _Pocca(_Alloc &_Left, const _Alloc &_Right, std::true_type) noexcept     template <class _Alloc> inline void _Pocca(_Alloc &, const _Alloc &, std::false_type) noexcept     template <class _Alloc> inline void _Pocca(_Alloc &_Left, const _Alloc &_Right) noexcept     template <class _Alloc> inline void _Pocma(_Alloc &_Left, _Alloc &_Right, std::true_type) noexcept     template <class _Alloc> inline void _Pocma(_Alloc &, _Alloc &, std::false_type) noexcept     template <class _Alloc> inline void _Pocma(_Alloc &_Left, _Alloc &_Right) noexcept     template <class _Alloc> inline void _Pocs(_Alloc &_Left, _Alloc &_Right, std::true_type) noexcept     template <class _Alloc> inline void _Pocs(_Alloc &_Left, _Alloc &_Right, std::false_type) noexcept     template <class _Alloc> inline void _Pocs(_Alloc &_Left, _Alloc &_Right) noexcept     template <class _Alloc> inline void _Destroy_range1(typename allocator_traits<_Alloc>::pointer _First, typename allocator_traits<_Alloc>::pointer _Last, _Alloc &_Al, std::false_type)     template <class _Alloc> inline void _Destroy_range1(typename allocator_traits<_Alloc>::pointer, typename allocator_traits<_Alloc>::pointer, _Alloc &, std::true_type)     template <class _Alloc> inline void _Destroy_range(typename allocator_traits<_Alloc>::pointer _First, typename allocator_traits<_Alloc>::pointer _Last, _Alloc &_Al)     template <class _FwdIt> inline void _Destroy_range1(_FwdIt _First, _FwdIt _Last, std::false_type)     template <class _FwdIt> inline void _Destroy_range1(_FwdIt, _FwdIt, std::true_type)     template <class _FwdIt> inline void _Destroy_range(_FwdIt _First, _FwdIt _Last)     template <class _Size_type> inline _Size_type _Convert_size(const size_t _Len)     template<> inline size_t _Convert_size<unsigned long long>(const size_t _Len)     {
        return (_Len);
    }
    template <class _Iter1, class _Iter2, class _UIter1, class _UIter2> constexpr pair<_Iter1, _Iter2> _Rechecked_both(_Iter1 _Dest1, _Iter2 _Dest2, pair<_UIter1, _UIter2> _Src)     {
        return {_Rechecked(_Dest1, _Src.first), _Rechecked(_Dest2, _Src.second)};
    }
    template <class _Alloc, enable_if_t<is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type *>, int> = 0> inline void _Deallocate_plain(_Alloc &_Al, typename _Alloc::value_type *const _Ptr)     template <class _Alloc, enable_if_t<!is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type *>, int> = 0> inline void _Deallocate_plain(_Alloc &_Al, typename _Alloc::value_type *const _Ptr)     constexpr bool _Is_simple_alloc_v = is_same_v<typename allocator_traits<allocator<char> >::size_type, size_t> && is_same_v<typename allocator_traits<allocator<char> >::difference_type, ptrdiff_t> && is_same_v<typename allocator_traits<allocator<char> >::pointer, typename allocator<char>::value_type *> && is_same_v<typename allocator_traits<allocator<char> >::const_pointer, const typename allocator<char>::value_type *>;
}
namespace std {
    typedef enum memory_order {
        memory_order_relaxed,
        memory_order_consume,
        memory_order_acquire,
        memory_order_release,
        memory_order_acq_rel,
        memory_order_seq_cst
    } memory_order;
    typedef _Uint32t _Uint4_t;
    typedef std::_Uint4_t _Atomic_integral_t;
    typedef std::_Atomic_integral_t _Atomic_counter_t;
    inline std::_Atomic_integral_t _Get_atomic_count(const std::_Atomic_counter_t &_Counter)     {
        return (_Counter);
    }
}
extern "C" {
    unsigned char _BitScanReverse(unsigned long *_Index, unsigned long _Mask) throw();
    unsigned char _BitScanReverse64(unsigned long *_Index, unsigned long long _Mask) throw();
    unsigned char _bittest(const long *, long) throw();
    long _InterlockedAnd(volatile long *_Value, long _Mask) throw();
    short _InterlockedAnd16(volatile short *_Value, short _Mask) throw();
    long long _InterlockedAnd64(volatile long long *_Value, long long _Mask) throw();
    char _InterlockedAnd8(volatile char *_Value, char _Mask) throw();
    long _InterlockedCompareExchange(volatile long *_Destination, long _Exchange, long _Comparand) throw();
    short _InterlockedCompareExchange16(volatile short *_Destination, short _Exchange, short _Comparand) throw();
    long long _InterlockedCompareExchange64(volatile long long *_Destination, long long _Exchange, long long _Comparand) throw();
    char _InterlockedCompareExchange8(volatile char *_Destination, char _Exchange, char _Comparand) throw();
    long _InterlockedDecrement(volatile long *_Addend) throw();
    long _InterlockedExchange(volatile long *_Target, long _Value) throw();
    short _InterlockedExchange16(volatile short *_Target, short _Value) throw();
    long long _InterlockedExchange64(volatile long long *_Target, long long _Value) throw();
    char _InterlockedExchange8(volatile char *_Target, char _Value) throw();
    long _InterlockedExchangeAdd(volatile long *_Addend, long _Value) throw();
    short _InterlockedExchangeAdd16(volatile short *_Addend, short _Value) throw();
    long long _InterlockedExchangeAdd64(volatile long long *_Addend, long long _Value) throw();
    char _InterlockedExchangeAdd8(volatile char *_Addend, char _Value) throw();
    long _InterlockedIncrement(volatile long *_Addend) throw();
    long _InterlockedOr(volatile long *_Value, long _Mask) throw();
    short _InterlockedOr16(volatile short *_Value, short _Mask) throw();
    long long _InterlockedOr64(volatile long long *_Value, long long _Mask) throw();
    char _InterlockedOr8(volatile char *_Value, char _Mask) throw();
    long _InterlockedXor(volatile long *_Value, long _Mask) throw();
    short _InterlockedXor16(volatile short *_Value, short _Mask) throw();
    long long _InterlockedXor64(volatile long long *_Value, long long _Mask) throw();
    char _InterlockedXor8(volatile char *_Value, char _Mask) throw();
    void _ReadWriteBarrier() throw();
    unsigned char _interlockedbittestandset(volatile long *, long) throw();
}
namespace std {
    template <class _Ty> inline pair<_Ty *, ptrdiff_t> _Get_temporary_buffer(ptrdiff_t _Count) noexcept     template <class _Ty> inline void _Return_temporary_buffer(_Ty *const _Pbuf)     template <class _FwdIt> struct _Uninitialized_backout {
        _FwdIt _First;
        _FwdIt _Last;
        explicit _Uninitialized_backout<_FwdIt>(_FwdIt _Dest)         _Uninitialized_backout<_FwdIt>(_FwdIt _First_, _FwdIt _Last_)         _Uninitialized_backout<_FwdIt>(const _Uninitialized_backout<_FwdIt> &) = delete
        _Uninitialized_backout<_FwdIt> &operator=(const _Uninitialized_backout<_FwdIt> &) = delete
        ~_Uninitialized_backout<_FwdIt>()         template <class ..._Types> void _Emplace_back(_Types &&..._Vals)         _FwdIt _Release()     };
    template <class _InIt, class _FwdIt> inline _FwdIt _Uninitialized_move_unchecked1(_InIt _First, const _InIt _Last, const _FwdIt _Dest, std::_General_ptr_iterator_tag)     template <class _InIt, class _FwdIt> inline _FwdIt _Uninitialized_move_unchecked1(const _InIt _First, const _InIt _Last, const _FwdIt _Dest, std::_Really_trivial_ptr_iterator_tag)     template <class _InIt, class _FwdIt> inline _FwdIt _Uninitialized_move_unchecked(const _InIt _First, const _InIt _Last, const _FwdIt _Dest)     template <class _FwdIt, class _Alloc> class _Uninitialized_backout_al {
    public:
        _Uninitialized_backout_al<_FwdIt, _Alloc>(_FwdIt _Dest, _Alloc &_Al_)         _Uninitialized_backout_al<_FwdIt, _Alloc>(const _Uninitialized_backout_al<_FwdIt, _Alloc> &) = delete
        _Uninitialized_backout_al<_FwdIt, _Alloc> &operator=(const _Uninitialized_backout_al<_FwdIt, _Alloc> &) = delete
        ~_Uninitialized_backout_al<_FwdIt, _Alloc>()         template <class ..._Types> void _Emplace_back(_Types &&..._Vals)         _FwdIt _Release()     private:
        _FwdIt _First;
        _FwdIt _Last;
        _Alloc &_Al;
    };
    template <class _InIt, class _FwdIt, class _Alloc> inline _FwdIt _Uninitialized_copy_al_unchecked(_InIt _First, const _InIt _Last, const _FwdIt _Dest, _Alloc &_Al, std::_General_ptr_iterator_tag, std::_Any_tag)     template <class _Ty1, class _Ty2, class _Alloc> inline _Ty2 *_Uninitialized_copy_al_unchecked(_Ty1 *const _First, _Ty1 *const _Last, _Ty2 *const _Dest, _Alloc &, std::_Really_trivial_ptr_iterator_tag, std::true_type)     template <class _InIt, class _FwdIt, class _Alloc> inline _FwdIt _Uninitialized_copy(const _InIt _First, const _InIt _Last, _FwdIt _Dest, _Alloc &_Al)     template <class _InIt, class _FwdIt, class _Alloc> inline _FwdIt _Uninitialized_move_al_unchecked(_InIt _First, const _InIt _Last, const _FwdIt _Dest, _Alloc &_Al, std::_General_ptr_iterator_tag, std::_Any_tag)     template <class _Ty1, class _Ty2, class _Alloc> inline _Ty2 *_Uninitialized_move_al_unchecked(_Ty1 *const _First, _Ty1 *const _Last, _Ty2 *const _Dest, _Alloc &, std::_Really_trivial_ptr_iterator_tag, std::true_type)     template <class _InIt, class _FwdIt, class _Alloc> inline _FwdIt _Uninitialized_move(const _InIt _First, const _InIt _Last, _FwdIt _Dest, _Alloc &_Al)     template <class _FwdIt, class _Diff, class _Alloc> inline _FwdIt _Uninit_alloc_fill_n1(const _FwdIt _First, _Diff _Count, const _Iter_value_t<_FwdIt> &_Val, _Alloc &_Al, std::false_type)     template <class _FwdIt, class _Diff, class _Alloc> inline _FwdIt _Uninit_alloc_fill_n1(const _FwdIt _First, const _Diff _Count, const _Iter_value_t<_FwdIt> &_Val, _Alloc &, std::true_type)     template <class _FwdIt, class _Diff, class _Alloc> inline _FwdIt _Uninitialized_fill_n(const _FwdIt _First, const _Diff _Count, const _Iter_value_t<_FwdIt> &_Val, _Alloc &_Al)     template <class _FwdIt> using _Use_memset_value_construct_t = _Conjunction_t<is_pointer<_FwdIt>, is_scalar<_Iter_value_t<_FwdIt> >, negation<is_volatile<_Iter_value_t<_FwdIt> > >, negation<is_member_pointer<_Iter_value_t<_FwdIt> > > >;
    template <class _FwdIt> inline _FwdIt _Zero_range(const _FwdIt _First, const _FwdIt _Last)     template <class _FwdIt, class _Diff, class _Alloc> inline _FwdIt _Uninitialized_value_construct_n1(const _FwdIt _First, _Diff _Count, _Alloc &_Al, std::false_type)     template <class _FwdIt, class _Diff, class _Alloc> inline _FwdIt _Uninitialized_value_construct_n1(_FwdIt _First, _Diff _Count, _Alloc &, std::true_type)     template <class _FwdIt, class _Diff, class _Alloc> inline _FwdIt _Uninitialized_value_construct_n(_FwdIt _First, _Diff _Count, _Alloc &_Al)     struct _Not_a_node_tag {
    };
    template <class _Ty> pair<_Ty *, ptrdiff_t> get_temporary_buffer(ptrdiff_t _Count) noexcept     template <class _Ty> void return_temporary_buffer(_Ty *_Pbuf) }
struct __type_info_node;
extern __type_info_node __type_info_root_node;
extern "C" {
    struct __std_type_info_data {
        const char *_UndecoratedName;
        const char _DecoratedName[1];
        __std_type_info_data() = delete
        __std_type_info_data(const __std_type_info_data &) = delete
        __std_type_info_data(__std_type_info_data &&) = delete
        __std_type_info_data &operator=(const __std_type_info_data &) = delete
        __std_type_info_data &operator=(__std_type_info_data &&) = delete
    };
    int __std_type_info_compare(const __std_type_info_data *_Lhs, const __std_type_info_data *_Rhs);
    size_t __std_type_info_hash(const __std_type_info_data *_Data);
    const char *__std_type_info_name(__std_type_info_data *_Data, __type_info_node *_RootNode);
}
class type_info {
public:
    type_info(const type_info &) = delete
    type_info &operator=(const type_info &) = delete
    size_t hash_code() const noexcept     {
        return __std_type_info_hash(&this->_Data);
    }
    bool operator==(const type_info &_Other) const noexcept     {
        return __std_type_info_compare(&this->_Data, &_Other._Data) == 0;
    }
    bool operator!=(const type_info &_Other) const noexcept     {
        return __std_type_info_compare(&this->_Data, &_Other._Data) != 0;
    }
    bool before(const type_info &_Other) const noexcept     {
        return __std_type_info_compare(&this->_Data, &_Other._Data) < 0;
    }
    const char *name() const noexcept     {
        return __std_type_info_name(&this->_Data, &__type_info_root_node);
    }
    const char *raw_name() const noexcept     {
        return this->_Data._DecoratedName;
    }
    virtual ~type_info() noexcept;
private:
    mutable __std_type_info_data _Data;
};
namespace std {
    using ::type_info;
}
namespace std {
    class bad_cast : public std::exception {
    public:
        bad_cast() noexcept : std::exception("bad cast", 1)         {
        }
        static std::bad_cast __construct_from_string_literal(const char *const _Message) noexcept         {
            return std::bad_cast(_Message, 1);
        }
    private:
        bad_cast(const char *const _Message, int) noexcept : std::exception(_Message, 1)         {
        }
    };
    class bad_typeid : public std::exception {
    public:
        bad_typeid() noexcept : std::exception("bad typeid", 1)         {
        }
        static std::bad_typeid __construct_from_string_literal(const char *const _Message) noexcept         {
            return std::bad_typeid(_Message, 1);
        }
    private:
        friend  class __non_rtti_object;
        bad_typeid(const char *const _Message, int) noexcept : std::exception(_Message, 1)         {
        }
    };
    class __non_rtti_object : public std::bad_typeid {
    public:
        static std::__non_rtti_object __construct_from_string_literal(const char *const _Message) noexcept         {
            return std::__non_rtti_object(_Message, 1);
        }
    private:
        __non_rtti_object(const char *const _Message, int) noexcept : std::bad_typeid(_Message, 1)         {
        }
    };
}
namespace std {
    constexpr int _Small_object_num_ptrs = 6 + 16 / sizeof(void *);
}
namespace std {
    template <class _InIt, class _FwdIt> inline _FwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last, const _FwdIt _Dest, std::_General_ptr_iterator_tag)     template <class _InIt, class _FwdIt> inline _FwdIt _Uninitialized_copy_unchecked(const _InIt _First, const _InIt _Last, const _FwdIt _Dest, std::_Really_trivial_ptr_iterator_tag)     template <class _InIt, class _FwdIt> inline _FwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _FwdIt _Dest)     template <class _InIt, class _Diff, class _FwdIt> inline _FwdIt _Uninitialized_copy_n_unchecked1(_InIt _First, _Diff _Count, const _FwdIt _Dest, std::_General_ptr_iterator_tag)     template <class _InIt, class _Diff, class _FwdIt> inline _FwdIt _Uninitialized_copy_n_unchecked1(const _InIt _First, const _Diff _Count, const _FwdIt _Dest, std::_Really_trivial_ptr_iterator_tag)     template <class _InIt, class _Diff, class _FwdIt> inline _FwdIt _Uninitialized_copy_n_unchecked(const _InIt _First, const _Diff _Count, const _FwdIt _Dest)     template <class _InIt, class _Diff, class _FwdIt> inline _FwdIt uninitialized_copy_n(const _InIt _First, const _Diff _Count, _FwdIt _Dest)     template <class _FwdIt, class _Tval> inline void _Uninitialized_fill_unchecked(const _FwdIt _First, const _FwdIt _Last, const _Tval &_Val, std::false_type)     template <class _FwdIt, class _Tval> inline void _Uninitialized_fill_unchecked(const _FwdIt _First, const _FwdIt _Last, const _Tval &_Val, std::true_type)     template <class _FwdIt, class _Tval> inline void uninitialized_fill(const _FwdIt _First, const _FwdIt _Last, const _Tval &_Val)     template <class _FwdIt, class _Diff, class _Tval> inline _FwdIt _Uninitialized_fill_n_unchecked(const _FwdIt _First, _Diff _Count, const _Tval &_Val, std::false_type)     template <class _FwdIt, class _Diff, class _Tval> inline _FwdIt _Uninitialized_fill_n_unchecked(const _FwdIt _First, const _Diff _Count, const _Tval &_Val, std::true_type)     template <class _FwdIt, class _Diff, class _Tval> inline _FwdIt uninitialized_fill_n(_FwdIt _First, const _Diff _Count, const _Tval &_Val)     template <class _OutIt, class _Ty> class raw_storage_iterator {
    public:
        using iterator_category = std::output_iterator_tag;
        using value_type = void;
        using difference_type = void;
        using pointer = void;
        using reference = void;
        explicit raw_storage_iterator<_OutIt, _Ty>(_OutIt _First)         raw_storage_iterator<_OutIt, _Ty> &operator*()         raw_storage_iterator<_OutIt, _Ty> &operator=(const _Ty &_Val)         raw_storage_iterator<_OutIt, _Ty> &operator=(_Ty &&_Val)         raw_storage_iterator<_OutIt, _Ty> &operator++()         raw_storage_iterator<_OutIt, _Ty> operator++(int)         _OutIt base() const     private:
        _OutIt _Next;
    };
    template <class _Ty> class auto_ptr;
    template <class _Ty> struct auto_ptr_ref {
        explicit auto_ptr_ref<_Ty>(_Ty *_Right)         _Ty *_Ref;
    };
    template <class _Ty> class auto_ptr {
    public:
        typedef _Ty element_type;
        explicit auto_ptr<_Ty>(_Ty *_Ptr = 0) noexcept         auto_ptr<_Ty>(auto_ptr<_Ty> &_Right) noexcept         auto_ptr<_Ty>(auto_ptr_ref<_Ty> _Right) noexcept         template <class _Other> operator auto_ptr<_Other>() noexcept         template <class _Other> operator auto_ptr_ref<_Other>() noexcept         template <class _Other> auto_ptr<_Ty> &operator=(auto_ptr<_Other> &_Right) noexcept         template <class _Other> auto_ptr<_Ty>(auto_ptr<_Other> &_Right) noexcept         auto_ptr<_Ty> &operator=(auto_ptr<_Ty> &_Right) noexcept         auto_ptr<_Ty> &operator=(auto_ptr_ref<_Ty> _Right) noexcept         ~auto_ptr<_Ty>() noexcept         _Ty &operator*() const noexcept         _Ty *operator->() const noexcept         _Ty *get() const noexcept         _Ty *release() noexcept         void reset(_Ty *_Ptr = 0)     private:
        _Ty *_Myptr;
    };
    template<> class auto_ptr<void> {
    public:
        typedef void element_type;
    };
    class bad_weak_ptr : public std::exception {
    public:
        bad_weak_ptr() noexcept : std::exception()         {
        }
        virtual const char *what() const noexcept override         {
            return ("bad_weak_ptr");
        }
    };
    class __declspec(novtable) _Ref_count_base {
    private:
        virtual void _Destroy() noexcept = 0;
        virtual void _Delete_this() noexcept = 0;
        std::_Atomic_counter_t _Uses;
        std::_Atomic_counter_t _Weaks;
    protected:
        _Ref_count_base() : _Uses(1), _Weaks(1)         {
        }
    public:
        virtual ~_Ref_count_base() noexcept         {
        }
        bool _Incref_nz()         {
            for (;;) {
                std::_Atomic_integral_t _Count = static_cast<volatile std::_Atomic_counter_t &>(this->_Uses);
                if (_Count == 0)
                    return (false);
                if (static_cast<std::_Atomic_integral_t>(_InterlockedCompareExchange(reinterpret_cast<volatile long *>(&this->_Uses), _Count + 1, _Count)) == _Count)
                    return (true);
            }
        }
        void _Incref()         {
            _InterlockedIncrement(reinterpret_cast<volatile long *>(&this->_Uses));
        }
        void _Incwref()         {
            _InterlockedIncrement(reinterpret_cast<volatile long *>(&this->_Weaks));
        }
        void _Decref()         {
            if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&this->_Uses)) == 0) {
                this->_Destroy();
                this->_Decwref();
            }
        }
        void _Decwref()         {
            if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&this->_Weaks)) == 0) {
                this->_Delete_this();
            }
        }
        long _Use_count() const noexcept         {
            return (_Get_atomic_count(this->_Uses));
        }
        virtual void *_Get_deleter(const type_info &) const noexcept         {
            return (nullptr);
        }
    };
    template <class _Ty> class _Ref_count : public std::_Ref_count_base {
    public:
        explicit _Ref_count<_Ty>(_Ty *_Px)     private:
        virtual void _Destroy() noexcept override         virtual void _Delete_this() noexcept override         _Ty *_Ptr;
    };
    template <class _Resource, class _Dx> class _Ref_count_resource : public std::_Ref_count_base {
    public:
        _Ref_count_resource<_Resource, _Dx>(_Resource _Px, _Dx _Dt)         virtual void *_Get_deleter(const type_info &_Typeid) const noexcept override     private:
        virtual void _Destroy() noexcept override         virtual void _Delete_this() noexcept override         _Compressed_pair<_Dx, _Resource> _Mypair;
    };
    template <class _Resource, class _Dx, class _Alloc> class _Ref_count_resource_alloc : public std::_Ref_count_base {
    public:
        _Ref_count_resource_alloc<_Resource, _Dx, _Alloc>(_Resource _Px, _Dx _Dt, const _Alloc &_Ax)         virtual void *_Get_deleter(const type_info &_Typeid) const noexcept override     private:
        using _Myalty = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc<_Resource, _Dx, _Alloc> >;
        virtual void _Destroy() noexcept override         virtual void _Delete_this() noexcept override         _Compressed_pair<_Dx, _Compressed_pair<std::_Ref_count_resource_alloc::_Myalty, _Resource> > _Mypair;
    };
    template <class _Ty> struct default_delete
template<> struct default_delete<v8::internal::ScriptStreamingData> {
        default_delete() noexcept = default
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, v8::internal::ScriptStreamingData *>, int> = 0> default_delete(const default_delete<_Ty2> &) noexcept;
        template<> default_delete<v8::internal::ScriptStreamingData, 0>(const default_delete<v8::internal::ScriptStreamingData> &) noexcept;
        void operator()(v8::internal::ScriptStreamingData *_Ptr) const noexcept;
    }
template<> struct default_delete<unsigned char const[]> {
        default_delete() noexcept = default
        template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], const unsigned char (*)[]>, int> = 0> default_delete(const default_delete<_Uty []> &) noexcept;
        template<> default_delete<const unsigned char, 0>(const default_delete<const unsigned char []> &) noexcept;
        template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], const unsigned char (*)[]>, int> = 0> void operator()(_Uty *_Ptr) const noexcept;
        template<> void operator()<const unsigned char, 0>(const unsigned char *_Ptr) const noexcept         {
            static_assert(0 < sizeof(const unsigned char), "can't delete an incomplete type");
            delete [] _Ptr;
        }
;
    }
template<> struct default_delete<v8::WasmStreaming::WasmStreamingImpl> {
        default_delete() noexcept = default
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, v8::WasmStreaming::WasmStreamingImpl *>, int> = 0> default_delete(const default_delete<_Ty2> &) noexcept;
        template<> default_delete<v8::WasmStreaming::WasmStreamingImpl, 0>(const default_delete<v8::WasmStreaming::WasmStreamingImpl> &) noexcept;
        void operator()(v8::WasmStreaming::WasmStreamingImpl *_Ptr) const noexcept;
    };
    template <class _Ty, class _Dx = default_delete<_Ty>> class unique_ptr
template<> class unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData>> : public _Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > {
    public:
        typedef _Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > _Mybase;
        typedef typename _Mybase::pointer pointer;
        typedef v8::internal::ScriptStreamingData element_type;
        typedef std::default_delete<v8::internal::ScriptStreamingData> deleter_type;
        using _Mybase::get_deleter;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr() noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr(std::nullptr_t) noexcept;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=(std::nullptr_t) noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, _Unique_ptr_enable_default_t<_Dx2> = 0> explicit unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer _Ptr) noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, enable_if_t<is_constructible_v<_Dx2, const _Dx2 &>, int> = 0> unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer _Ptr, const std::default_delete<v8::internal::ScriptStreamingData> &_Dt) noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, enable_if_t<conjunction_v<negation<is_reference<_Dx2> >, is_constructible<_Dx2, _Dx2> >, int> = 0> unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer _Ptr, std::default_delete<v8::internal::ScriptStreamingData> &&_Dt) noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2> > >, int> = 0> unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer, remove_reference_t<std::default_delete<v8::internal::ScriptStreamingData> > &&) = delete
        unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &&_Right) noexcept;
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer>, conditional_t<is_reference_v<std::default_delete<v8::internal::ScriptStreamingData> >, is_same<_Dx2, std::default_delete<v8::internal::ScriptStreamingData> >, is_convertible<_Dx2, std::default_delete<v8::internal::ScriptStreamingData> > > >, int> = 0> unique_ptr(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept;
        template<> unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData>, 0>(unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &&_Right) noexcept;
        template <class _Ty2, enable_if_t<conjunction_v<is_convertible<_Ty2 *, v8::internal::ScriptStreamingData *>, is_same<std::default_delete<v8::internal::ScriptStreamingData>, default_delete<v8::internal::ScriptStreamingData> > >, int> = 0> unique_ptr(auto_ptr<_Ty2> &&_Right) noexcept;
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_assignable<std::default_delete<v8::internal::ScriptStreamingData> &, _Dx2>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer> >, int> = 0> std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept;
        template<> std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData>, 0>(unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &&_Right) noexcept;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &&_Right) noexcept;
        void swap(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &_Right) noexcept;
        ~unique_ptr<ScriptStreamingData, default_delete<ScriptStreamingData> >() noexcept;
        add_lvalue_reference_t<v8::internal::ScriptStreamingData> operator*() const;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer operator->() const noexcept;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer get() const noexcept         {
            return (this->_Myptr());
        }
        explicit operator bool() const noexcept;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer release() noexcept;
        void reset(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer _Ptr) noexcept;
        unique_ptr(const std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &) = delete
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=(const std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &) = delete
    }
template<> class unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]>> : public _Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> > {
    public:
        typedef _Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> > _Mybase;
        typedef typename _Mybase::pointer pointer;
        typedef const unsigned char element_type;
        typedef std::default_delete<unsigned char const[]> deleter_type;
        using _Mybase::get_deleter;
        template <class _Dx2 = std::default_delete<unsigned char const[]>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr() noexcept;
        template<> constexpr unique_ptr<std::default_delete<unsigned char const[]>, 0>() noexcept;
        template <class _Uty, class _Is_nullptr = is_same<_Uty, std::nullptr_t>> using _Enable_ctor_reset = enable_if_t<is_same_v<_Uty, std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer> || _Is_nullptr::value || (is_same_v<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer, std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::element_type *> && is_pointer_v<_Uty> && is_convertible_v<remove_pointer_t<_Uty> (*)[], std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::element_type (*)[]>)>;
        template <class _Uty, class _Dx2 = std::default_delete<unsigned char const[]>, _Unique_ptr_enable_default_t<_Dx2> = 0, class  = _Enable_ctor_reset<_Uty>> explicit unique_ptr(_Uty _Ptr) noexcept;
        template <class _Uty, class _Dx2 = std::default_delete<unsigned char const[]>, enable_if_t<is_constructible_v<_Dx2, const _Dx2 &>, int> = 0, class  = _Enable_ctor_reset<_Uty>> unique_ptr(_Uty _Ptr, const std::default_delete<unsigned char const[]> &_Dt) noexcept;
        template <class _Uty, class _Dx2 = std::default_delete<unsigned char const[]>, enable_if_t<conjunction_v<negation<is_reference<_Dx2> >, is_constructible<_Dx2, _Dx2> >, int> = 0, class  = _Enable_ctor_reset<_Uty>> unique_ptr(_Uty _Ptr, std::default_delete<unsigned char const[]> &&_Dt) noexcept;
        template <class _Uty, class _Dx2 = std::default_delete<unsigned char const[]>, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2> > >, int> = 0> unique_ptr(_Uty, remove_reference_t<std::default_delete<unsigned char const[]> > &&) = delete
        unique_ptr(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &&_Right) noexcept : std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::_Mybase(_Right.release(), ::std::forward<std::default_delete<unsigned char const[]> >(_Right.get_deleter()))         {
        }
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &&_Right) noexcept;
        template <class _Uty, class _Ex, class _More, class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer, class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type> using _Enable_conversion = enable_if_t<conjunction_v<is_array<_Uty>, is_same<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer, std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::element_type *>, is_same<_UP_pointer, _UP_element_type *>, is_convertible<_UP_element_type (*)[], std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::element_type (*)[]>, _More> >;
        template <class _Uty, class _Ex, class  = _Enable_conversion<_Uty, _Ex, conditional_t<is_reference_v<std::default_delete<unsigned char const[]> >, is_same<_Ex, std::default_delete<unsigned char const[]> >, is_convertible<_Ex, std::default_delete<unsigned char const[]> > > >> unique_ptr(unique_ptr<_Uty, _Ex> &&_Right) noexcept;
        template<> unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]>, void>(unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &&_Right) noexcept;
        template <class _Uty, class _Ex, class  = _Enable_conversion<_Uty, _Ex, is_assignable<std::default_delete<unsigned char const[]> &, _Ex> >> std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=(unique_ptr<_Uty, _Ex> &&_Right) noexcept;
        template<> std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=<unsigned char const[], std::default_delete<unsigned char const[]>, void>(unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &&_Right) noexcept;
        template <class _Dx2 = std::default_delete<unsigned char const[]>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr(std::nullptr_t) noexcept;
        template<> constexpr unique_ptr<std::default_delete<unsigned char const[]>, 0>(std::nullptr_t) noexcept : std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::_Mybase(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer())         {
        }
;
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=(std::nullptr_t) noexcept;
        void reset(std::nullptr_t) noexcept;
        void swap(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &_Right) noexcept;
        ~unique_ptr<unsigned char const[], default_delete<unsigned char const[]> >() noexcept         {
            this->_Delete();
        }
        const unsigned char &operator[](size_t _Idx) const;
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer get() const noexcept         {
            return (this->_Myptr());
        }
        explicit operator bool() const noexcept;
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer release() noexcept         {
            std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer _Ans = this->get();
            this->_Myptr() = std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer();
            return (_Ans);
        }
        template <class _Uty, class  = _Enable_ctor_reset<_Uty, std::false_type>> void reset(_Uty _Ptr) noexcept;
        unique_ptr(const std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &) = delete
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=(const std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &) = delete
    private:
        void _Delete()         {
            if (this->get() != std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer()) {
                this->get_deleter()(this->get());
            }
        }
    }
template<> class unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> : public _Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > {
    public:
        typedef _Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > _Mybase;
        typedef typename _Mybase::pointer pointer;
        typedef v8::WasmStreaming::WasmStreamingImpl element_type;
        typedef std::default_delete<v8::WasmStreaming::WasmStreamingImpl> deleter_type;
        using _Mybase::get_deleter;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr() noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr(std::nullptr_t) noexcept;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &operator=(std::nullptr_t) noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, _Unique_ptr_enable_default_t<_Dx2> = 0> explicit unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer _Ptr) noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, enable_if_t<is_constructible_v<_Dx2, const _Dx2 &>, int> = 0> unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer _Ptr, const std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &_Dt) noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, enable_if_t<conjunction_v<negation<is_reference<_Dx2> >, is_constructible<_Dx2, _Dx2> >, int> = 0> unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer _Ptr, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &&_Dt) noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2> > >, int> = 0> unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer, remove_reference_t<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &&) = delete
        unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &&_Right) noexcept;
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer>, conditional_t<is_reference_v<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >, is_same<_Dx2, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >, is_convertible<_Dx2, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > > >, int> = 0> unique_ptr(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept;
        template<> unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, 0>(unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &&_Right) noexcept;
        template <class _Ty2, enable_if_t<conjunction_v<is_convertible<_Ty2 *, v8::WasmStreaming::WasmStreamingImpl *>, is_same<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, default_delete<v8::WasmStreaming::WasmStreamingImpl> > >, int> = 0> unique_ptr(auto_ptr<_Ty2> &&_Right) noexcept;
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_assignable<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &, _Dx2>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer> >, int> = 0> std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &operator=(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &operator=(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &&_Right) noexcept;
        void swap(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &_Right) noexcept;
        ~unique_ptr<WasmStreamingImpl, default_delete<WasmStreamingImpl> >() noexcept;
        add_lvalue_reference_t<v8::WasmStreaming::WasmStreamingImpl> operator*() const;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer operator->() const noexcept;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer get() const noexcept;
        explicit operator bool() const noexcept;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer release() noexcept;
        void reset(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer _Ptr) noexcept;
        unique_ptr(const std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &) = delete
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &operator=(const std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &) = delete
    };
    template <class _Ty> class shared_ptr
template<> class shared_ptr<v8::internal::wasm::NativeModule> : public _Ptr_base<v8::internal::wasm::NativeModule> {
    private:
        using _Mybase = _Ptr_base<v8::internal::wasm::NativeModule>;
    public:
        using typename _Mybase::element_type;
        constexpr shared_ptr() noexcept : _Ptr_base<v8::internal::wasm::NativeModule>()         {
        }
        constexpr shared_ptr(std::nullptr_t) noexcept;
        template <class _Ux, enable_if_t<conjunction_v<conditional_t<is_array_v<v8::internal::wasm::NativeModule>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux> >, _SP_convertible<_Ux, v8::internal::wasm::NativeModule> >, int> = 0> explicit shared_ptr(_Ux *_Px);
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, v8::internal::wasm::NativeModule> >, int> = 0> shared_ptr(_Ux *_Px, _Dx _Dt);
        template <class _Ux, class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, v8::internal::wasm::NativeModule> >, int> = 0> shared_ptr(_Ux *_Px, _Dx _Dt, _Alloc _Ax);
        template <class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr(std::nullptr_t, _Dx _Dt);
        template <class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr(std::nullptr_t, _Dx _Dt, _Alloc _Ax);
        template <class _Ty2> shared_ptr(const shared_ptr<_Ty2> &_Right, std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type *_Px) noexcept;
        shared_ptr(const std::shared_ptr<v8::internal::wasm::NativeModule> &_Other) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, NativeModule>::value, int> = 0> shared_ptr(const shared_ptr<_Ty2> &_Other) noexcept;
        template<> shared_ptr<v8::internal::wasm::NativeModule, 0>(const shared_ptr<v8::internal::wasm::NativeModule> &_Other) noexcept;
        shared_ptr(std::shared_ptr<v8::internal::wasm::NativeModule> &&_Right) noexcept : _Ptr_base<v8::internal::wasm::NativeModule>()         {
            this->_Move_construct_from(::std::move(_Right));
        }
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, NativeModule>::value, int> = 0> shared_ptr(shared_ptr<_Ty2> &&_Right) noexcept;
        template<> shared_ptr<v8::internal::wasm::NativeModule, 0>(shared_ptr<v8::internal::wasm::NativeModule> &&_Right) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, NativeModule>::value, int> = 0> explicit shared_ptr(const weak_ptr<_Ty2> &_Other);
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, v8::internal::wasm::NativeModule *>, int> = 0> shared_ptr(auto_ptr<_Ty2> &&_Other);
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, v8::internal::wasm::NativeModule>, is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type *> >, int> = 0> shared_ptr(unique_ptr<_Ux, _Dx> &&_Other);
        ~shared_ptr<NativeModule>() noexcept         {
            this->_Decref();
        }
        std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(const std::shared_ptr<v8::internal::wasm::NativeModule> &_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(const shared_ptr<_Ty2> &_Right) noexcept;
        template<> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=<v8::internal::wasm::NativeModule>(const shared_ptr<v8::internal::wasm::NativeModule> &_Right) noexcept;
        std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(std::shared_ptr<v8::internal::wasm::NativeModule> &&_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(shared_ptr<_Ty2> &&_Right) noexcept;
        template<> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=<v8::internal::wasm::NativeModule>(shared_ptr<v8::internal::wasm::NativeModule> &&_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(auto_ptr<_Ty2> &&_Right);
        template <class _Ux, class _Dx> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(unique_ptr<_Ux, _Dx> &&_Right);
        void swap(std::shared_ptr<v8::internal::wasm::NativeModule> &_Other) noexcept;
        void reset() noexcept;
        template <class _Ux> void reset(_Ux *_Px);
        template <class _Ux, class _Dx> void reset(_Ux *_Px, _Dx _Dt);
        template <class _Ux, class _Dx, class _Alloc> void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax);
        using _Mybase::get;
        template <class _Ty2 = v8::internal::wasm::NativeModule, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2> >, int> = 0> _Ty2 &operator*() const noexcept;
        template <class _Ty2 = v8::internal::wasm::NativeModule, enable_if_t<!is_array_v<_Ty2>, int> = 0> _Ty2 *operator->() const noexcept;
        template <class _Ty2 = v8::internal::wasm::NativeModule, class _Elem = std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type, enable_if_t<is_array_v<_Ty2>, int> = 0> _Elem &operator[](ptrdiff_t _Idx) const;
        bool unique() const noexcept;
        explicit operator bool() const noexcept;
    private:
        template <class _Ux> void _Setp(_Ux *_Px, std::true_type);
        template <class _Ux> void _Setp(_Ux *_Px, std::false_type);
        template <class _UxptrOrNullptr, class _Dx> void _Setpd(_UxptrOrNullptr _Px, _Dx _Dt);
        template <class _UxptrOrNullptr, class _Dx, class _Alloc> void _Setpda(_UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax);
        friend template <class _Ty0, class ..._Types> shared_ptr<_Ty0> make_shared(_Types &&..._Args);
        friend template <class _Ty0, class _Alloc, class ..._Types> shared_ptr<_Ty0> allocate_shared(const _Alloc &_Al_arg, _Types &&..._Args);
        template <class _Ux> void _Set_ptr_rep_and_enable_shared(_Ux *_Px, std::_Ref_count_base *_Rx);
        void _Set_ptr_rep_and_enable_shared(std::nullptr_t, std::_Ref_count_base *_Rx);
    }
template<> class shared_ptr<v8::internal::wasm::StreamingDecoder> : public _Ptr_base<v8::internal::wasm::StreamingDecoder> {
    private:
        using _Mybase = _Ptr_base<v8::internal::wasm::StreamingDecoder>;
    public:
        using typename _Mybase::element_type;
        constexpr shared_ptr() noexcept;
        constexpr shared_ptr(std::nullptr_t) noexcept;
        template <class _Ux, enable_if_t<conjunction_v<conditional_t<is_array_v<v8::internal::wasm::StreamingDecoder>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux> >, _SP_convertible<_Ux, v8::internal::wasm::StreamingDecoder> >, int> = 0> explicit shared_ptr(_Ux *_Px);
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, v8::internal::wasm::StreamingDecoder> >, int> = 0> shared_ptr(_Ux *_Px, _Dx _Dt);
        template <class _Ux, class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, v8::internal::wasm::StreamingDecoder> >, int> = 0> shared_ptr(_Ux *_Px, _Dx _Dt, _Alloc _Ax);
        template <class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr(std::nullptr_t, _Dx _Dt);
        template <class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr(std::nullptr_t, _Dx _Dt, _Alloc _Ax);
        template <class _Ty2> shared_ptr(const shared_ptr<_Ty2> &_Right, std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type *_Px) noexcept;
        shared_ptr(const std::shared_ptr<v8::internal::wasm::StreamingDecoder> &_Other) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, StreamingDecoder>::value, int> = 0> shared_ptr(const shared_ptr<_Ty2> &_Other) noexcept;
        template<> shared_ptr<v8::internal::wasm::StreamingDecoder, 0>(const shared_ptr<v8::internal::wasm::StreamingDecoder> &_Other) noexcept;
        shared_ptr(std::shared_ptr<v8::internal::wasm::StreamingDecoder> &&_Right) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, StreamingDecoder>::value, int> = 0> shared_ptr(shared_ptr<_Ty2> &&_Right) noexcept;
        template<> shared_ptr<v8::internal::wasm::StreamingDecoder, 0>(shared_ptr<v8::internal::wasm::StreamingDecoder> &&_Right) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, StreamingDecoder>::value, int> = 0> explicit shared_ptr(const weak_ptr<_Ty2> &_Other);
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, v8::internal::wasm::StreamingDecoder *>, int> = 0> shared_ptr(auto_ptr<_Ty2> &&_Other);
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, v8::internal::wasm::StreamingDecoder>, is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type *> >, int> = 0> shared_ptr(unique_ptr<_Ux, _Dx> &&_Other);
        ~shared_ptr<StreamingDecoder>() noexcept;
        std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(const std::shared_ptr<v8::internal::wasm::StreamingDecoder> &_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(const shared_ptr<_Ty2> &_Right) noexcept;
        template<> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=<v8::internal::wasm::StreamingDecoder>(const shared_ptr<v8::internal::wasm::StreamingDecoder> &_Right) noexcept;
        std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(std::shared_ptr<v8::internal::wasm::StreamingDecoder> &&_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(shared_ptr<_Ty2> &&_Right) noexcept;
        template<> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=<v8::internal::wasm::StreamingDecoder>(shared_ptr<v8::internal::wasm::StreamingDecoder> &&_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(auto_ptr<_Ty2> &&_Right);
        template <class _Ux, class _Dx> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(unique_ptr<_Ux, _Dx> &&_Right);
        void swap(std::shared_ptr<v8::internal::wasm::StreamingDecoder> &_Other) noexcept;
        void reset() noexcept;
        template <class _Ux> void reset(_Ux *_Px);
        template <class _Ux, class _Dx> void reset(_Ux *_Px, _Dx _Dt);
        template <class _Ux, class _Dx, class _Alloc> void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax);
        using _Mybase::get;
        template <class _Ty2 = v8::internal::wasm::StreamingDecoder, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2> >, int> = 0> _Ty2 &operator*() const noexcept;
        template <class _Ty2 = v8::internal::wasm::StreamingDecoder, enable_if_t<!is_array_v<_Ty2>, int> = 0> _Ty2 *operator->() const noexcept;
        template <class _Ty2 = v8::internal::wasm::StreamingDecoder, class _Elem = std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type, enable_if_t<is_array_v<_Ty2>, int> = 0> _Elem &operator[](ptrdiff_t _Idx) const;
        bool unique() const noexcept;
        explicit operator bool() const noexcept;
    private:
        template <class _Ux> void _Setp(_Ux *_Px, std::true_type);
        template <class _Ux> void _Setp(_Ux *_Px, std::false_type);
        template <class _UxptrOrNullptr, class _Dx> void _Setpd(_UxptrOrNullptr _Px, _Dx _Dt);
        template <class _UxptrOrNullptr, class _Dx, class _Alloc> void _Setpda(_UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax);
        friend template <class _Ty0, class ..._Types> shared_ptr<_Ty0> make_shared(_Types &&..._Args);
        friend template <class _Ty0, class _Alloc, class ..._Types> shared_ptr<_Ty0> allocate_shared(const _Alloc &_Al_arg, _Types &&..._Args);
        template <class _Ux> void _Set_ptr_rep_and_enable_shared(_Ux *_Px, std::_Ref_count_base *_Rx);
        void _Set_ptr_rep_and_enable_shared(std::nullptr_t, std::_Ref_count_base *_Rx);
    };
    template <class _Ty> class weak_ptr;
    template <class _Yty, class  = void> struct _Can_enable_shared : std::false_type {
    };
    template <class _Yty> struct _Can_enable_shared<_Yty, void> : is_convertible<remove_cv_t<_Yty> *, typename _Yty::_Esft_type *>::type {
    };
    template <class _Other, class _Yty> void _Enable_shared_from_this1(const shared_ptr<_Other> &_This, _Yty *_Ptr, std::true_type)     template <class _Other, class _Yty> void _Enable_shared_from_this1(const shared_ptr<_Other> &, _Yty *, std::false_type)     template <class _Other, class _Yty> void _Enable_shared_from_this(const shared_ptr<_Other> &_This, _Yty *_Ptr)     template <class _Ty> class _Ptr_base {
    public:
        using element_type = remove_extent_t<_Ty>;
        long use_count() const noexcept         template <class _Ty2> bool owner_before(const _Ptr_base<_Ty2> &_Right) const noexcept         _Ptr_base<_Ty>(const _Ptr_base<_Ty> &) = delete
        _Ptr_base<_Ty> &operator=(const _Ptr_base<_Ty> &) = delete
    protected:
        std::_Ptr_base::element_type *get() const noexcept         _Ptr_base<_Ty>() noexcept = default
        ~_Ptr_base<_Ty>() = default
        template <class _Ty2> void _Move_construct_from(_Ptr_base<_Ty2> &&_Right)         {
            this->_Ptr = _Right._Ptr;
            this->_Rep = _Right._Rep;
            _Right._Ptr = nullptr;
            _Right._Rep = nullptr;
        }
        template <class _Ty2> void _Copy_construct_from(const shared_ptr<_Ty2> &_Other)         template <class _Ty2> void _Alias_construct_from(const shared_ptr<_Ty2> &_Other, std::_Ptr_base::element_type *_Px)         friend template <class _Ty0> class weak_ptr;
        template <class _Ty2> bool _Construct_from_weak(const weak_ptr<_Ty2> &_Other)         void _Decref()         {
            if (this->_Rep) {
                this->_Rep->_Decref();
            }
        }
        void _Swap(_Ptr_base<_Ty> &_Right) noexcept         void _Set_ptr_rep(std::_Ptr_base::element_type *_Other_ptr, std::_Ref_count_base *_Other_rep)         template <class _Ty2> void _Weakly_construct_from(const _Ptr_base<_Ty2> &_Other)         void _Decwref()     private:
        std::_Ptr_base::element_type *_Ptr {nullptr};
        std::_Ref_count_base *_Rep {nullptr};
        friend template <class _Ty0> class _Ptr_base;
        friend template <class _Dx, class _Ty0> _Dx *get_deleter(const shared_ptr<_Ty0> &_Sx) noexcept;
    };
template<> class _Ptr_base<v8::internal::wasm::NativeModule> {
    public:
        using element_type = remove_extent_t<v8::internal::wasm::NativeModule>;
        long use_count() const noexcept;
        template <class _Ty2> bool owner_before(const _Ptr_base<_Ty2> &_Right) const noexcept;
        _Ptr_base(const std::_Ptr_base<v8::internal::wasm::NativeModule> &) = delete
        std::_Ptr_base<v8::internal::wasm::NativeModule> &operator=(const std::_Ptr_base<v8::internal::wasm::NativeModule> &) = delete
    protected:
        std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type *get() const noexcept;
        _Ptr_base() noexcept = default        ~_Ptr_base<NativeModule>() noexcept = default
        template <class _Ty2> void _Move_construct_from(_Ptr_base<_Ty2> &&_Right);
        template<> void _Move_construct_from<v8::internal::wasm::NativeModule>(_Ptr_base<v8::internal::wasm::NativeModule> &&_Right)         {
            this->_Ptr = _Right._Ptr;
            this->_Rep = _Right._Rep;
            _Right._Ptr = nullptr;
            _Right._Rep = nullptr;
        }
;
        template <class _Ty2> void _Copy_construct_from(const shared_ptr<_Ty2> &_Other);
        template <class _Ty2> void _Alias_construct_from(const shared_ptr<_Ty2> &_Other, std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type *_Px);
        friend template <class _Ty0> class weak_ptr;
        template <class _Ty2> bool _Construct_from_weak(const weak_ptr<_Ty2> &_Other);
        void _Decref()         {
            if (this->_Rep) {
                this->_Rep->_Decref();
            }
        }
        void _Swap(std::_Ptr_base<v8::internal::wasm::NativeModule> &_Right) noexcept;
        void _Set_ptr_rep(std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type *_Other_ptr, std::_Ref_count_base *_Other_rep);
        template <class _Ty2> void _Weakly_construct_from(const _Ptr_base<_Ty2> &_Other);
        void _Decwref();
    private:
        std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type *_Ptr {nullptr};
        std::_Ref_count_base *_Rep {nullptr};
        friend template <class _Ty0> class _Ptr_base;
        friend template <class _Dx, class _Ty0> _Dx *get_deleter(const shared_ptr<_Ty0> &_Sx) noexcept;
    };
template<> class _Ptr_base<v8::internal::wasm::StreamingDecoder> {
    public:
        using element_type = remove_extent_t<v8::internal::wasm::StreamingDecoder>;
        long use_count() const noexcept;
        template <class _Ty2> bool owner_before(const _Ptr_base<_Ty2> &_Right) const noexcept;
        _Ptr_base(const std::_Ptr_base<v8::internal::wasm::StreamingDecoder> &) = delete
        std::_Ptr_base<v8::internal::wasm::StreamingDecoder> &operator=(const std::_Ptr_base<v8::internal::wasm::StreamingDecoder> &) = delete
    protected:
        std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type *get() const noexcept;
        _Ptr_base() = default
        ~_Ptr_base<StreamingDecoder>() noexcept = default
        template <class _Ty2> void _Move_construct_from(_Ptr_base<_Ty2> &&_Right);
        template <class _Ty2> void _Copy_construct_from(const shared_ptr<_Ty2> &_Other);
        template <class _Ty2> void _Alias_construct_from(const shared_ptr<_Ty2> &_Other, std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type *_Px);
        friend template <class _Ty0> class weak_ptr;
        template <class _Ty2> bool _Construct_from_weak(const weak_ptr<_Ty2> &_Other);
        void _Decref();
        void _Swap(std::_Ptr_base<v8::internal::wasm::StreamingDecoder> &_Right) noexcept;
        void _Set_ptr_rep(std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type *_Other_ptr, std::_Ref_count_base *_Other_rep);
        template <class _Ty2> void _Weakly_construct_from(const _Ptr_base<_Ty2> &_Other);
        void _Decwref();
    private:
        std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type *_Ptr {nullptr};
        std::_Ref_count_base *_Rep {nullptr};
        friend template <class _Ty0> class _Ptr_base;
        friend template <class _Dx, class _Ty0> _Dx *get_deleter(const shared_ptr<_Ty0> &_Sx) noexcept;
    };
    template <class _Yty, class  = void> struct _Can_scalar_delete : std::false_type {
    };
    struct _Can_scalar_delete_unique_type {
    };
    template <class _Yty> struct _Can_scalar_delete<_Yty, void> : std::true_type {
    };
    template <class _Yty, class  = void> struct _Can_array_delete : std::false_type {
    };
    struct _Can_array_delete_unique_type {
    };
    template <class _Yty> struct _Can_array_delete<_Yty, void> : std::true_type {
    };
    template <class _Fx, class _Arg, class  = void> struct _Can_call_function_object : std::false_type {
    };
    struct _Can_call_function_object_unique_type {
    };
    template <class _Fx, class _Arg> struct _Can_call_function_object<_Fx, _Arg, void> : std::true_type {
    };
    template <class _Yty, class _Ty> struct _SP_convertible : is_convertible<_Yty *, _Ty *>::type {
    };
    template <class _Yty, class _Uty> struct _SP_convertible<_Yty, type-parameter-0-1 []> : is_convertible<_Yty (*)[], _Uty (*)[]>::type {
    };
    template <class _Yty, class _Uty, size_t _Ext> struct _SP_convertible<_Yty, type-parameter-0-1 [_Ext]> : is_convertible<_Yty (*)[_Ext], _Uty (*)[_Ext]>::type {
    };
    template <class _Yty, class _Ty> struct _SP_pointer_compatible : is_convertible<_Yty *, _Ty *>::type {
    };
template<> struct _SP_pointer_compatible<v8::internal::wasm::NativeModule, v8::internal::wasm::NativeModule> : is_convertible<NativeModule *, NativeModule *>::type {
    };
template<> struct _SP_pointer_compatible<v8::internal::wasm::StreamingDecoder, v8::internal::wasm::StreamingDecoder> : is_convertible<StreamingDecoder *, StreamingDecoder *>::type {
    };
    template <class _Uty, size_t _Ext> struct _SP_pointer_compatible<type-parameter-0-0 [_SizeOfArray], type-parameter-0-0 []> : std::true_type {
    };
    template <class _Uty, size_t _Ext> struct _SP_pointer_compatible<type-parameter-0-0 [_SizeOfArray], type-parameter-0-0 const[]> : std::true_type {
    };
    template <class _Uty, size_t _Ext> struct _SP_pointer_compatible<type-parameter-0-0 [_SizeOfArray], type-parameter-0-0 volatile[]> : std::true_type {
    };
    template <class _Uty, size_t _Ext> struct _SP_pointer_compatible<type-parameter-0-0 [_SizeOfArray], type-parameter-0-0 const volatile[]> : std::true_type {
    };
    template <class _Ty> class shared_ptr : public _Ptr_base<_Ty> {
    private:
        using _Mybase = _Ptr_base<_Ty>;
    public:
        using typename _Mybase::element_type;
        constexpr shared_ptr<_Ty>() noexcept         {
        }
        constexpr shared_ptr<_Ty>(std::nullptr_t) noexcept         {
        }
        template <class _Ux, enable_if_t<conjunction_v<conditional_t<is_array_v<_Ty>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux> >, _SP_convertible<_Ux, _Ty> >, int> = 0> explicit shared_ptr<_Ty>(_Ux *_Px)         template <class _Ux, class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, _Ty> >, int> = 0> shared_ptr<_Ty>(_Ux *_Px, _Dx _Dt)         template <class _Ux, class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, _Ty> >, int> = 0> shared_ptr<_Ty>(_Ux *_Px, _Dx _Dt, _Alloc _Ax)         template <class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr<_Ty>(std::nullptr_t, _Dx _Dt)         template <class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr<_Ty>(std::nullptr_t, _Dx _Dt, _Alloc _Ax)         template <class _Ty2> shared_ptr<_Ty>(const shared_ptr<_Ty2> &_Right, std::shared_ptr::element_type *_Px) noexcept         shared_ptr<_Ty>(const shared_ptr<_Ty> &_Other) noexcept         template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0> shared_ptr<_Ty>(const shared_ptr<_Ty2> &_Other) noexcept         shared_ptr<_Ty>(shared_ptr<_Ty> &&_Right) noexcept         {
            this->_Move_construct_from(::std::move(_Right));
        }
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0> shared_ptr<_Ty>(shared_ptr<_Ty2> &&_Right) noexcept         template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0> explicit shared_ptr<_Ty>(const weak_ptr<_Ty2> &_Other)         template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, _Ty *>, int> = 0> shared_ptr<_Ty>(auto_ptr<_Ty2> &&_Other)         template <class _Ux, class _Dx, enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, _Ty>, is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, std::shared_ptr::element_type *> >, int> = 0> shared_ptr<_Ty>(unique_ptr<_Ux, _Dx> &&_Other)         ~shared_ptr<_Ty>() noexcept         {
            this->_Decref();
        }
        shared_ptr<_Ty> &operator=(const shared_ptr<_Ty> &_Right) noexcept         template <class _Ty2> shared_ptr<_Ty> &operator=(const shared_ptr<_Ty2> &_Right) noexcept         shared_ptr<_Ty> &operator=(shared_ptr<_Ty> &&_Right) noexcept         template <class _Ty2> shared_ptr<_Ty> &operator=(shared_ptr<_Ty2> &&_Right) noexcept         template <class _Ty2> shared_ptr<_Ty> &operator=(auto_ptr<_Ty2> &&_Right)         template <class _Ux, class _Dx> shared_ptr<_Ty> &operator=(unique_ptr<_Ux, _Dx> &&_Right)         void swap(shared_ptr<_Ty> &_Other) noexcept         void reset() noexcept         template <class _Ux> void reset(_Ux *_Px)         template <class _Ux, class _Dx> void reset(_Ux *_Px, _Dx _Dt)         template <class _Ux, class _Dx, class _Alloc> void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax)         using _Mybase::get;
        template <class _Ty2 = _Ty, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2> >, int> = 0> _Ty2 &operator*() const noexcept         template <class _Ty2 = _Ty, enable_if_t<!is_array_v<_Ty2>, int> = 0> _Ty2 *operator->() const noexcept         template <class _Ty2 = _Ty, class _Elem = std::shared_ptr::element_type, enable_if_t<is_array_v<_Ty2>, int> = 0> _Elem &operator[](ptrdiff_t _Idx) const         bool unique() const noexcept         explicit operator bool() const noexcept     private:
        template <class _Ux> void _Setp(_Ux *_Px, std::true_type)         template <class _Ux> void _Setp(_Ux *_Px, std::false_type)         template <class _UxptrOrNullptr, class _Dx> void _Setpd(_UxptrOrNullptr _Px, _Dx _Dt)         template <class _UxptrOrNullptr, class _Dx, class _Alloc> void _Setpda(_UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax)         friend template <class _Ty0, class ..._Types> shared_ptr<_Ty0> make_shared(_Types &&..._Args);
        friend template <class _Ty0, class _Alloc, class ..._Types> shared_ptr<_Ty0> allocate_shared(const _Alloc &_Al_arg, _Types &&..._Args);
        template <class _Ux> void _Set_ptr_rep_and_enable_shared(_Ux *_Px, std::_Ref_count_base *_Rx)         void _Set_ptr_rep_and_enable_shared(std::nullptr_t, std::_Ref_count_base *_Rx)     };
template<> class shared_ptr<v8::internal::wasm::NativeModule> : public _Ptr_base<v8::internal::wasm::NativeModule> {
    private:
        using _Mybase = _Ptr_base<v8::internal::wasm::NativeModule>;
    public:
        using typename _Mybase::element_type;
        constexpr shared_ptr() noexcept : _Ptr_base<v8::internal::wasm::NativeModule>()         {
        }
        constexpr shared_ptr(std::nullptr_t) noexcept;
        template <class _Ux, enable_if_t<conjunction_v<conditional_t<is_array_v<v8::internal::wasm::NativeModule>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux> >, _SP_convertible<_Ux, v8::internal::wasm::NativeModule> >, int> = 0> explicit shared_ptr(_Ux *_Px);
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, v8::internal::wasm::NativeModule> >, int> = 0> shared_ptr(_Ux *_Px, _Dx _Dt);
        template <class _Ux, class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, v8::internal::wasm::NativeModule> >, int> = 0> shared_ptr(_Ux *_Px, _Dx _Dt, _Alloc _Ax);
        template <class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr(std::nullptr_t, _Dx _Dt);
        template <class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr(std::nullptr_t, _Dx _Dt, _Alloc _Ax);
        template <class _Ty2> shared_ptr(const shared_ptr<_Ty2> &_Right, std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type *_Px) noexcept;
        shared_ptr(const std::shared_ptr<v8::internal::wasm::NativeModule> &_Other) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, NativeModule>::value, int> = 0> shared_ptr(const shared_ptr<_Ty2> &_Other) noexcept;
        template<> shared_ptr<v8::internal::wasm::NativeModule, 0>(const shared_ptr<v8::internal::wasm::NativeModule> &_Other) noexcept;
        shared_ptr(std::shared_ptr<v8::internal::wasm::NativeModule> &&_Right) noexcept : _Ptr_base<v8::internal::wasm::NativeModule>()         {
            this->_Move_construct_from(::std::move(_Right));
        }
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, NativeModule>::value, int> = 0> shared_ptr(shared_ptr<_Ty2> &&_Right) noexcept;
        template<> shared_ptr<v8::internal::wasm::NativeModule, 0>(shared_ptr<v8::internal::wasm::NativeModule> &&_Right) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, NativeModule>::value, int> = 0> explicit shared_ptr(const weak_ptr<_Ty2> &_Other);
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, v8::internal::wasm::NativeModule *>, int> = 0> shared_ptr(auto_ptr<_Ty2> &&_Other);
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, v8::internal::wasm::NativeModule>, is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type *> >, int> = 0> shared_ptr(unique_ptr<_Ux, _Dx> &&_Other);
        ~shared_ptr<NativeModule>() noexcept         {
            this->_Decref();
        }
        std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(const std::shared_ptr<v8::internal::wasm::NativeModule> &_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(const shared_ptr<_Ty2> &_Right) noexcept;
        template<> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=<v8::internal::wasm::NativeModule>(const shared_ptr<v8::internal::wasm::NativeModule> &_Right) noexcept;
        std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(std::shared_ptr<v8::internal::wasm::NativeModule> &&_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(shared_ptr<_Ty2> &&_Right) noexcept;
        template<> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=<v8::internal::wasm::NativeModule>(shared_ptr<v8::internal::wasm::NativeModule> &&_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(auto_ptr<_Ty2> &&_Right);
        template <class _Ux, class _Dx> std::shared_ptr<v8::internal::wasm::NativeModule> &operator=(unique_ptr<_Ux, _Dx> &&_Right);
        void swap(std::shared_ptr<v8::internal::wasm::NativeModule> &_Other) noexcept;
        void reset() noexcept;
        template <class _Ux> void reset(_Ux *_Px);
        template <class _Ux, class _Dx> void reset(_Ux *_Px, _Dx _Dt);
        template <class _Ux, class _Dx, class _Alloc> void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax);
        using _Mybase::get;
        template <class _Ty2 = v8::internal::wasm::NativeModule, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2> >, int> = 0> _Ty2 &operator*() const noexcept;
        template <class _Ty2 = v8::internal::wasm::NativeModule, enable_if_t<!is_array_v<_Ty2>, int> = 0> _Ty2 *operator->() const noexcept;
        template <class _Ty2 = v8::internal::wasm::NativeModule, class _Elem = std::_Ptr_base<v8::internal::wasm::NativeModule>::element_type, enable_if_t<is_array_v<_Ty2>, int> = 0> _Elem &operator[](ptrdiff_t _Idx) const;
        bool unique() const noexcept;
        explicit operator bool() const noexcept;
    private:
        template <class _Ux> void _Setp(_Ux *_Px, std::true_type);
        template <class _Ux> void _Setp(_Ux *_Px, std::false_type);
        template <class _UxptrOrNullptr, class _Dx> void _Setpd(_UxptrOrNullptr _Px, _Dx _Dt);
        template <class _UxptrOrNullptr, class _Dx, class _Alloc> void _Setpda(_UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax);
        friend template <class _Ty0, class ..._Types> shared_ptr<_Ty0> make_shared(_Types &&..._Args);
        friend template <class _Ty0, class _Alloc, class ..._Types> shared_ptr<_Ty0> allocate_shared(const _Alloc &_Al_arg, _Types &&..._Args);
        template <class _Ux> void _Set_ptr_rep_and_enable_shared(_Ux *_Px, std::_Ref_count_base *_Rx);
        void _Set_ptr_rep_and_enable_shared(std::nullptr_t, std::_Ref_count_base *_Rx);
    };
template<> class shared_ptr<v8::internal::wasm::StreamingDecoder> : public _Ptr_base<v8::internal::wasm::StreamingDecoder> {
    private:
        using _Mybase = _Ptr_base<v8::internal::wasm::StreamingDecoder>;
    public:
        using typename _Mybase::element_type;
        constexpr shared_ptr() noexcept;
        constexpr shared_ptr(std::nullptr_t) noexcept;
        template <class _Ux, enable_if_t<conjunction_v<conditional_t<is_array_v<v8::internal::wasm::StreamingDecoder>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux> >, _SP_convertible<_Ux, v8::internal::wasm::StreamingDecoder> >, int> = 0> explicit shared_ptr(_Ux *_Px);
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, v8::internal::wasm::StreamingDecoder> >, int> = 0> shared_ptr(_Ux *_Px, _Dx _Dt);
        template <class _Ux, class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, _Ux *&>, _SP_convertible<_Ux, v8::internal::wasm::StreamingDecoder> >, int> = 0> shared_ptr(_Ux *_Px, _Dx _Dt, _Alloc _Ax);
        template <class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr(std::nullptr_t, _Dx _Dt);
        template <class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx &, std::nullptr_t &> >, int> = 0> shared_ptr(std::nullptr_t, _Dx _Dt, _Alloc _Ax);
        template <class _Ty2> shared_ptr(const shared_ptr<_Ty2> &_Right, std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type *_Px) noexcept;
        shared_ptr(const std::shared_ptr<v8::internal::wasm::StreamingDecoder> &_Other) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, StreamingDecoder>::value, int> = 0> shared_ptr(const shared_ptr<_Ty2> &_Other) noexcept;
        template<> shared_ptr<v8::internal::wasm::StreamingDecoder, 0>(const shared_ptr<v8::internal::wasm::StreamingDecoder> &_Other) noexcept;
        shared_ptr(std::shared_ptr<v8::internal::wasm::StreamingDecoder> &&_Right) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, StreamingDecoder>::value, int> = 0> shared_ptr(shared_ptr<_Ty2> &&_Right) noexcept;
        template<> shared_ptr<v8::internal::wasm::StreamingDecoder, 0>(shared_ptr<v8::internal::wasm::StreamingDecoder> &&_Right) noexcept;
        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, StreamingDecoder>::value, int> = 0> explicit shared_ptr(const weak_ptr<_Ty2> &_Other);
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, v8::internal::wasm::StreamingDecoder *>, int> = 0> shared_ptr(auto_ptr<_Ty2> &&_Other);
        template <class _Ux, class _Dx, enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, v8::internal::wasm::StreamingDecoder>, is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type *> >, int> = 0> shared_ptr(unique_ptr<_Ux, _Dx> &&_Other);
        ~shared_ptr<StreamingDecoder>() noexcept;
        std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(const std::shared_ptr<v8::internal::wasm::StreamingDecoder> &_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(const shared_ptr<_Ty2> &_Right) noexcept;
        template<> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=<v8::internal::wasm::StreamingDecoder>(const shared_ptr<v8::internal::wasm::StreamingDecoder> &_Right) noexcept;
        std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(std::shared_ptr<v8::internal::wasm::StreamingDecoder> &&_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(shared_ptr<_Ty2> &&_Right) noexcept;
        template<> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=<v8::internal::wasm::StreamingDecoder>(shared_ptr<v8::internal::wasm::StreamingDecoder> &&_Right) noexcept;
        template <class _Ty2> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(auto_ptr<_Ty2> &&_Right);
        template <class _Ux, class _Dx> std::shared_ptr<v8::internal::wasm::StreamingDecoder> &operator=(unique_ptr<_Ux, _Dx> &&_Right);
        void swap(std::shared_ptr<v8::internal::wasm::StreamingDecoder> &_Other) noexcept;
        void reset() noexcept;
        template <class _Ux> void reset(_Ux *_Px);
        template <class _Ux, class _Dx> void reset(_Ux *_Px, _Dx _Dt);
        template <class _Ux, class _Dx, class _Alloc> void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax);
        using _Mybase::get;
        template <class _Ty2 = v8::internal::wasm::StreamingDecoder, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2> >, int> = 0> _Ty2 &operator*() const noexcept;
        template <class _Ty2 = v8::internal::wasm::StreamingDecoder, enable_if_t<!is_array_v<_Ty2>, int> = 0> _Ty2 *operator->() const noexcept;
        template <class _Ty2 = v8::internal::wasm::StreamingDecoder, class _Elem = std::_Ptr_base<v8::internal::wasm::StreamingDecoder>::element_type, enable_if_t<is_array_v<_Ty2>, int> = 0> _Elem &operator[](ptrdiff_t _Idx) const;
        bool unique() const noexcept;
        explicit operator bool() const noexcept;
    private:
        template <class _Ux> void _Setp(_Ux *_Px, std::true_type);
        template <class _Ux> void _Setp(_Ux *_Px, std::false_type);
        template <class _UxptrOrNullptr, class _Dx> void _Setpd(_UxptrOrNullptr _Px, _Dx _Dt);
        template <class _UxptrOrNullptr, class _Dx, class _Alloc> void _Setpda(_UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax);
        friend template <class _Ty0, class ..._Types> shared_ptr<_Ty0> make_shared(_Types &&..._Args);
        friend template <class _Ty0, class _Alloc, class ..._Types> shared_ptr<_Ty0> allocate_shared(const _Alloc &_Al_arg, _Types &&..._Args);
        template <class _Ux> void _Set_ptr_rep_and_enable_shared(_Ux *_Px, std::_Ref_count_base *_Rx);
        void _Set_ptr_rep_and_enable_shared(std::nullptr_t, std::_Ref_count_base *_Rx);
    };
    template <class _Ty1, class _Ty2> bool operator==(const shared_ptr<_Ty1> &_Left, const shared_ptr<_Ty2> &_Right) noexcept     template <class _Ty1, class _Ty2> bool operator!=(const shared_ptr<_Ty1> &_Left, const shared_ptr<_Ty2> &_Right) noexcept     template <class _Ty1, class _Ty2> bool operator<(const shared_ptr<_Ty1> &_Left, const shared_ptr<_Ty2> &_Right) noexcept     template <class _Ty1, class _Ty2> bool operator>=(const shared_ptr<_Ty1> &_Left, const shared_ptr<_Ty2> &_Right) noexcept     template <class _Ty1, class _Ty2> bool operator>(const shared_ptr<_Ty1> &_Left, const shared_ptr<_Ty2> &_Right) noexcept     template <class _Ty1, class _Ty2> bool operator<=(const shared_ptr<_Ty1> &_Left, const shared_ptr<_Ty2> &_Right) noexcept     template <class _Ty> bool operator==(const shared_ptr<_Ty> &_Left, std::nullptr_t) noexcept     template <class _Ty> bool operator==(std::nullptr_t, const shared_ptr<_Ty> &_Right) noexcept     template <class _Ty> bool operator!=(const shared_ptr<_Ty> &_Left, std::nullptr_t) noexcept     template <class _Ty> bool operator!=(std::nullptr_t, const shared_ptr<_Ty> &_Right) noexcept     template <class _Ty> bool operator<(const shared_ptr<_Ty> &_Left, std::nullptr_t) noexcept     template <class _Ty> bool operator<(std::nullptr_t, const shared_ptr<_Ty> &_Right) noexcept     template <class _Ty> bool operator>=(const shared_ptr<_Ty> &_Left, std::nullptr_t) noexcept     template <class _Ty> bool operator>=(std::nullptr_t, const shared_ptr<_Ty> &_Right) noexcept     template <class _Ty> bool operator>(const shared_ptr<_Ty> &_Left, std::nullptr_t) noexcept     template <class _Ty> bool operator>(std::nullptr_t, const shared_ptr<_Ty> &_Right) noexcept     template <class _Ty> bool operator<=(const shared_ptr<_Ty> &_Left, std::nullptr_t) noexcept     template <class _Ty> bool operator<=(std::nullptr_t, const shared_ptr<_Ty> &_Right) noexcept     template <class _Elem, class _Traits, class _Ty> basic_ostream<_Elem, _Traits> &operator<<(basic_ostream<_Elem, _Traits> &_Out, const shared_ptr<_Ty> &_Px)     template <class _Ty> void swap(shared_ptr<_Ty> &_Left, shared_ptr<_Ty> &_Right) noexcept     template <class _Ty1, class _Ty2> shared_ptr<_Ty1> static_pointer_cast(const shared_ptr<_Ty2> &_Other) noexcept     template <class _Ty1, class _Ty2> shared_ptr<_Ty1> const_pointer_cast(const shared_ptr<_Ty2> &_Other) noexcept     template <class _Ty1, class _Ty2> shared_ptr<_Ty1> reinterpret_pointer_cast(const shared_ptr<_Ty2> &_Other) noexcept     template <class _Ty1, class _Ty2> shared_ptr<_Ty1> dynamic_pointer_cast(const shared_ptr<_Ty2> &_Other) noexcept     template <class _Dx, class _Ty> _Dx *get_deleter(const shared_ptr<_Ty> &_Sx) noexcept     template <class _Ty> class _Ref_count_obj : public std::_Ref_count_base {
    public:
        template <class ..._Types> explicit _Ref_count_obj<_Ty>(_Types &&..._Args)         _Ty *_Getptr()     private:
        virtual void _Destroy() noexcept override         virtual void _Delete_this() noexcept override         aligned_union_t<1, _Ty> _Storage;
    };
    template <class _Ty, class _Alloc> class _Ref_count_obj_alloc : public std::_Ref_count_base {
    public:
        template <class ..._Types> explicit _Ref_count_obj_alloc<_Ty, _Alloc>(const _Alloc &_Al_arg, _Types &&..._Args)         _Ty *_Getptr()     private:
        using _Myalty = _Rebind_alloc_t<_Alloc, _Ref_count_obj_alloc<_Ty, _Alloc> >;
        using _Mystoragety = aligned_union_t<1, _Ty>;
        virtual void _Destroy() noexcept override         virtual void _Delete_this() noexcept override         _Compressed_pair<std::_Ref_count_obj_alloc::_Myalty, std::_Ref_count_obj_alloc::_Mystoragety> _Mypair;
    };
    template <class _Ty, class ..._Types> inline shared_ptr<_Ty> make_shared(_Types &&..._Args)     template <class _Ty, class _Alloc, class ..._Types> inline shared_ptr<_Ty> allocate_shared(const _Alloc &_Al_arg, _Types &&..._Args)     template <class _Ty> class weak_ptr : public _Ptr_base<_Ty> {
    public:
        constexpr weak_ptr<_Ty>() noexcept         {
        }
        weak_ptr<_Ty>(const weak_ptr<_Ty> &_Other) noexcept         template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0> weak_ptr<_Ty>(const shared_ptr<_Ty2> &_Other) noexcept         template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0> weak_ptr<_Ty>(const weak_ptr<_Ty2> &_Other) noexcept         weak_ptr<_Ty>(weak_ptr<_Ty> &&_Other) noexcept         template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0> weak_ptr<_Ty>(weak_ptr<_Ty2> &&_Other) noexcept         ~weak_ptr<_Ty>() noexcept         weak_ptr<_Ty> &operator=(const weak_ptr<_Ty> &_Right) noexcept         template <class _Ty2> weak_ptr<_Ty> &operator=(const weak_ptr<_Ty2> &_Right) noexcept         weak_ptr<_Ty> &operator=(weak_ptr<_Ty> &&_Right) noexcept         template <class _Ty2> weak_ptr<_Ty> &operator=(weak_ptr<_Ty2> &&_Right) noexcept         template <class _Ty2> weak_ptr<_Ty> &operator=(const shared_ptr<_Ty2> &_Right) noexcept         void reset() noexcept         void swap(weak_ptr<_Ty> &_Other) noexcept         bool expired() const noexcept         shared_ptr<_Ty> lock() const noexcept     };
    template <class _Ty> void swap(weak_ptr<_Ty> &_Left, weak_ptr<_Ty> &_Right) noexcept     template <class _Ty> class enable_shared_from_this {
    public:
        using _Esft_type = enable_shared_from_this<_Ty>;
        shared_ptr<_Ty> shared_from_this()         shared_ptr<const _Ty> shared_from_this() const         weak_ptr<_Ty> weak_from_this() noexcept         weak_ptr<const _Ty> weak_from_this() const noexcept     protected:
        constexpr enable_shared_from_this<_Ty>() noexcept : _Wptr()         {
        }
        enable_shared_from_this<_Ty>(const enable_shared_from_this<_Ty> &) noexcept         enable_shared_from_this<_Ty> &operator=(const enable_shared_from_this<_Ty> &) noexcept         ~enable_shared_from_this<_Ty>() = default
    private:
        friend template <class _Other, class _Yty> void _Enable_shared_from_this1(const shared_ptr<_Other> &_This, _Yty *_Ptr, std::true_type);
        mutable weak_ptr<_Ty> _Wptr;
    };
    template <class _Ty> struct default_delete {
        default_delete<_Ty>() noexcept = default
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, _Ty *>, int> = 0> default_delete<_Ty>(const default_delete<_Ty2> &) noexcept         void operator()(_Ty *_Ptr) const noexcept     };
template<> struct default_delete<v8::internal::ScriptStreamingData> {
        default_delete() noexcept = default
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, v8::internal::ScriptStreamingData *>, int> = 0> default_delete(const default_delete<_Ty2> &) noexcept;
        template<> default_delete<v8::internal::ScriptStreamingData, 0>(const default_delete<v8::internal::ScriptStreamingData> &) noexcept;
        void operator()(v8::internal::ScriptStreamingData *_Ptr) const noexcept;
    };
template<> struct default_delete<unsigned char const[]> {
        default_delete() noexcept = default
        template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], const unsigned char (*)[]>, int> = 0> default_delete(const default_delete<_Uty []> &) noexcept;
        template<> default_delete<const unsigned char, 0>(const default_delete<const unsigned char []> &) noexcept;
        template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], const unsigned char (*)[]>, int> = 0> void operator()(_Uty *_Ptr) const noexcept;
        template<> void operator()<const unsigned char, 0>(const unsigned char *_Ptr) const noexcept         {
            static_assert(0 < sizeof(const unsigned char), "can't delete an incomplete type");
            delete [] _Ptr;
        }
;
    };
template<> struct default_delete<v8::WasmStreaming::WasmStreamingImpl> {
        default_delete() noexcept = default
        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2 *, v8::WasmStreaming::WasmStreamingImpl *>, int> = 0> default_delete(const default_delete<_Ty2> &) noexcept;
        template<> default_delete<v8::WasmStreaming::WasmStreamingImpl, 0>(const default_delete<v8::WasmStreaming::WasmStreamingImpl> &) noexcept;
        void operator()(v8::WasmStreaming::WasmStreamingImpl *_Ptr) const noexcept;
    };
    template <class _Ty> struct default_delete<type-parameter-0-0 []> {
        default_delete<type-parameter-0-0 []>() noexcept = default
        template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0> default_delete<type-parameter-0-0 []>(const default_delete<_Uty []> &) noexcept         template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0> void operator()(_Uty *_Ptr) const noexcept         {
            static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
            delete [] _Ptr;
        }
    };
    template <class _Ty, class _Dx_noref, class  = void> struct _Get_deleter_pointer_type {
        typedef _Ty *type;
    };
template<> struct _Get_deleter_pointer_type<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData>, void> {
        typedef v8::internal::ScriptStreamingData *type;
    };
template<> struct _Get_deleter_pointer_type<const unsigned char, std::default_delete<unsigned char const[]>, void> {
        typedef const unsigned char *type;
    };
template<> struct _Get_deleter_pointer_type<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, void> {
        typedef v8::WasmStreaming::WasmStreamingImpl *type;
    };
    template <class _Ty, class _Dx_noref> struct _Get_deleter_pointer_type<_Ty, _Dx_noref, void> {
        typedef typename _Dx_noref::pointer type;
    };
    template <class _Ty, class _Dx> class _Unique_ptr_base {
    public:
        typedef remove_reference_t<_Dx> _Dx_noref;
        typedef typename _Get_deleter_pointer_type<_Ty, _Dx_noref>::type pointer;
        template <class _Ptr2, class _Dx2> _Unique_ptr_base<_Ty, _Dx>(_Ptr2 _Ptr, _Dx2 &&_Dt) : _Mypair(std::_One_then_variadic_args_t(), ::std::forward<_Dx2>(_Dt), _Ptr)         {
        }
        template <class _Ptr2> constexpr _Unique_ptr_base<_Ty, _Dx>(_Ptr2 _Ptr) : _Mypair(std::_Zero_then_variadic_args_t(), _Ptr)         {
        }
        _Dx &get_deleter() noexcept         {
            return (this->_Mypair._Get_first());
        }
        const _Dx &get_deleter() const noexcept         std::_Unique_ptr_base::pointer &_Myptr() noexcept         {
            return (this->_Mypair._Get_second());
        }
        const std::_Unique_ptr_base::pointer &_Myptr() const noexcept         {
            return (this->_Mypair._Get_second());
        }
        _Compressed_pair<_Dx, std::_Unique_ptr_base::pointer> _Mypair;
    };
template<> class _Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData>> {
    public:
        typedef remove_reference_t<std::default_delete<v8::internal::ScriptStreamingData> > _Dx_noref;
        typedef typename _Get_deleter_pointer_type<ScriptStreamingData, _Dx_noref>::type pointer;
        template <class _Ptr2, class _Dx2> _Unique_ptr_base(_Ptr2 _Ptr, _Dx2 &&_Dt);
        template <class _Ptr2> constexpr _Unique_ptr_base(_Ptr2 _Ptr);
        template<> constexpr _Unique_ptr_base<std::_Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >>(std::_Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > _Ptr);
        std::default_delete<v8::internal::ScriptStreamingData> &get_deleter() noexcept;
        const std::default_delete<v8::internal::ScriptStreamingData> &get_deleter() const noexcept;
        std::_Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer &_Myptr() noexcept;
        const std::_Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer &_Myptr() const noexcept         {
            return (this->_Mypair._Get_second());
        }
        _Compressed_pair<std::default_delete<v8::internal::ScriptStreamingData>, std::_Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer> _Mypair;
    };
template<> class _Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]>> {
    public:
        typedef remove_reference_t<std::default_delete<unsigned char const[]> > _Dx_noref;
        typedef typename _Get_deleter_pointer_type<const unsigned char, _Dx_noref>::type pointer;
        template <class _Ptr2, class _Dx2> _Unique_ptr_base(_Ptr2 _Ptr, _Dx2 &&_Dt);
        template<> _Unique_ptr_base<const unsigned char *, std::default_delete<unsigned char const[]>>(const unsigned char *_Ptr, std::default_delete<unsigned char const[]> &&_Dt) : _Mypair(std::_One_then_variadic_args_t(), ::std::forward<std::default_delete<unsigned char const[]> >(_Dt), _Ptr)         {
        }
;
        template <class _Ptr2> constexpr _Unique_ptr_base(_Ptr2 _Ptr);
        template<> constexpr _Unique_ptr_base<std::_Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> >>(std::_Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> > _Ptr);
        template<> constexpr _Unique_ptr_base<const unsigned char *>(const unsigned char *_Ptr) : _Mypair(std::_Zero_then_variadic_args_t(), _Ptr)         {
        }
;
        std::default_delete<unsigned char const[]> &get_deleter() noexcept         {
            return (this->_Mypair._Get_first());
        }
        const std::default_delete<unsigned char const[]> &get_deleter() const noexcept;
        std::_Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> >::pointer &_Myptr() noexcept         {
            return (this->_Mypair._Get_second());
        }
        const std::_Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> >::pointer &_Myptr() const noexcept         {
            return (this->_Mypair._Get_second());
        }
        _Compressed_pair<std::default_delete<unsigned char const[]>, std::_Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> >::pointer> _Mypair;
    };
template<> class _Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> {
    public:
        typedef remove_reference_t<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > _Dx_noref;
        typedef typename _Get_deleter_pointer_type<WasmStreamingImpl, _Dx_noref>::type pointer;
        template <class _Ptr2, class _Dx2> _Unique_ptr_base(_Ptr2 _Ptr, _Dx2 &&_Dt);
        template <class _Ptr2> constexpr _Unique_ptr_base(_Ptr2 _Ptr);
        template<> constexpr _Unique_ptr_base<std::_Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >>(std::_Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > _Ptr);
        std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &get_deleter() noexcept;
        const std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &get_deleter() const noexcept;
        std::_Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer &_Myptr() noexcept;
        const std::_Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer &_Myptr() const noexcept;
        _Compressed_pair<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, std::_Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer> _Mypair;
    };
    template <class _Dx2> using _Unique_ptr_enable_default_t = enable_if_t<conjunction_v<negation<is_pointer<_Dx2> >, is_default_constructible<_Dx2> >, int>;
    template <class _Ty, class _Dx = default_delete<_Ty>> class unique_ptr : public _Unique_ptr_base<_Ty, _Dx> {
    public:
        typedef _Unique_ptr_base<_Ty, _Dx> _Mybase;
        typedef typename _Mybase::pointer pointer;
        typedef _Ty element_type;
        typedef _Dx deleter_type;
        using _Mybase::get_deleter;
        template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr<_Ty, _Dx>() noexcept : std::unique_ptr::_Mybase(std::unique_ptr::pointer())         {
        }
        template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr<_Ty, _Dx>(std::nullptr_t) noexcept : std::unique_ptr::_Mybase(std::unique_ptr::pointer())         {
        }
        unique_ptr<_Ty, _Dx> &operator=(std::nullptr_t) noexcept         template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0> explicit unique_ptr<_Ty, _Dx>(std::unique_ptr::pointer _Ptr) noexcept         template <class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2 &>, int> = 0> unique_ptr<_Ty, _Dx>(std::unique_ptr::pointer _Ptr, const _Dx &_Dt) noexcept         template <class _Dx2 = _Dx, enable_if_t<conjunction_v<negation<is_reference<_Dx2> >, is_constructible<_Dx2, _Dx2> >, int> = 0> unique_ptr<_Ty, _Dx>(std::unique_ptr::pointer _Ptr, _Dx &&_Dt) noexcept         template <class _Dx2 = _Dx, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2> > >, int> = 0> unique_ptr<_Ty, _Dx>(std::unique_ptr::pointer, remove_reference_t<_Dx> &&) = delete
        unique_ptr<_Ty, _Dx>(unique_ptr<_Ty, _Dx> &&_Right) noexcept         template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr::pointer>, conditional_t<is_reference_v<_Dx>, is_same<_Dx2, _Dx>, is_convertible<_Dx2, _Dx> > >, int> = 0> unique_ptr<_Ty, _Dx>(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept         template <class _Ty2, enable_if_t<conjunction_v<is_convertible<_Ty2 *, _Ty *>, is_same<_Dx, default_delete<_Ty> > >, int> = 0> unique_ptr<_Ty, _Dx>(auto_ptr<_Ty2> &&_Right) noexcept         template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_assignable<_Dx &, _Dx2>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr::pointer> >, int> = 0> unique_ptr<_Ty, _Dx> &operator=(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept         unique_ptr<_Ty, _Dx> &operator=(unique_ptr<_Ty, _Dx> &&_Right) noexcept         void swap(unique_ptr<_Ty, _Dx> &_Right) noexcept         ~unique_ptr<_Ty, _Dx>() noexcept         add_lvalue_reference_t<_Ty> operator*() const         std::unique_ptr::pointer operator->() const noexcept         std::unique_ptr::pointer get() const noexcept         {
            return (this->_Myptr());
        }
        explicit operator bool() const noexcept         std::unique_ptr::pointer release() noexcept         void reset(std::unique_ptr::pointer _Ptr = std::unique_ptr::pointer()) noexcept         unique_ptr<_Ty, _Dx>(const unique_ptr<_Ty, _Dx> &) = delete
        unique_ptr<_Ty, _Dx> &operator=(const unique_ptr<_Ty, _Dx> &) = delete
    };
template<> class unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData>> : public _Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > {
    public:
        typedef _Unique_ptr_base<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > _Mybase;
        typedef typename _Mybase::pointer pointer;
        typedef v8::internal::ScriptStreamingData element_type;
        typedef std::default_delete<v8::internal::ScriptStreamingData> deleter_type;
        using _Mybase::get_deleter;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr() noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr(std::nullptr_t) noexcept;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=(std::nullptr_t) noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, _Unique_ptr_enable_default_t<_Dx2> = 0> explicit unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer _Ptr) noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, enable_if_t<is_constructible_v<_Dx2, const _Dx2 &>, int> = 0> unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer _Ptr, const std::default_delete<v8::internal::ScriptStreamingData> &_Dt) noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, enable_if_t<conjunction_v<negation<is_reference<_Dx2> >, is_constructible<_Dx2, _Dx2> >, int> = 0> unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer _Ptr, std::default_delete<v8::internal::ScriptStreamingData> &&_Dt) noexcept;
        template <class _Dx2 = std::default_delete<v8::internal::ScriptStreamingData>, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2> > >, int> = 0> unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer, remove_reference_t<std::default_delete<v8::internal::ScriptStreamingData> > &&) = delete
        unique_ptr(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &&_Right) noexcept;
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer>, conditional_t<is_reference_v<std::default_delete<v8::internal::ScriptStreamingData> >, is_same<_Dx2, std::default_delete<v8::internal::ScriptStreamingData> >, is_convertible<_Dx2, std::default_delete<v8::internal::ScriptStreamingData> > > >, int> = 0> unique_ptr(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept;
        template<> unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData>, 0>(unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &&_Right) noexcept;
        template <class _Ty2, enable_if_t<conjunction_v<is_convertible<_Ty2 *, v8::internal::ScriptStreamingData *>, is_same<std::default_delete<v8::internal::ScriptStreamingData>, default_delete<v8::internal::ScriptStreamingData> > >, int> = 0> unique_ptr(auto_ptr<_Ty2> &&_Right) noexcept;
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_assignable<std::default_delete<v8::internal::ScriptStreamingData> &, _Dx2>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer> >, int> = 0> std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept;
        template<> std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData>, 0>(unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &&_Right) noexcept;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &&_Right) noexcept;
        void swap(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &_Right) noexcept;
        ~unique_ptr<ScriptStreamingData, default_delete<ScriptStreamingData> >() noexcept;
        add_lvalue_reference_t<v8::internal::ScriptStreamingData> operator*() const;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer operator->() const noexcept;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer get() const noexcept         {
            return (this->_Myptr());
        }
        explicit operator bool() const noexcept;
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer release() noexcept;
        void reset(std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> >::pointer _Ptr) noexcept;
        unique_ptr(const std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &) = delete
        std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &operator=(const std::unique_ptr<v8::internal::ScriptStreamingData, std::default_delete<v8::internal::ScriptStreamingData> > &) = delete
    };
template<> class unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]>> : public _Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> > {
    public:
        typedef _Unique_ptr_base<const unsigned char, std::default_delete<unsigned char const[]> > _Mybase;
        typedef typename _Mybase::pointer pointer;
        typedef const unsigned char element_type;
        typedef std::default_delete<unsigned char const[]> deleter_type;
        using _Mybase::get_deleter;
        template <class _Dx2 = std::default_delete<unsigned char const[]>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr() noexcept;
        template<> constexpr unique_ptr<std::default_delete<unsigned char const[]>, 0>() noexcept;
        template <class _Uty, class _Is_nullptr = is_same<_Uty, std::nullptr_t>> using _Enable_ctor_reset = enable_if_t<is_same_v<_Uty, std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer> || _Is_nullptr::value || (is_same_v<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer, std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::element_type *> && is_pointer_v<_Uty> && is_convertible_v<remove_pointer_t<_Uty> (*)[], std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::element_type (*)[]>)>;
        template <class _Uty, class _Dx2 = std::default_delete<unsigned char const[]>, _Unique_ptr_enable_default_t<_Dx2> = 0, class  = _Enable_ctor_reset<_Uty>> explicit unique_ptr(_Uty _Ptr) noexcept;
        template <class _Uty, class _Dx2 = std::default_delete<unsigned char const[]>, enable_if_t<is_constructible_v<_Dx2, const _Dx2 &>, int> = 0, class  = _Enable_ctor_reset<_Uty>> unique_ptr(_Uty _Ptr, const std::default_delete<unsigned char const[]> &_Dt) noexcept;
        template <class _Uty, class _Dx2 = std::default_delete<unsigned char const[]>, enable_if_t<conjunction_v<negation<is_reference<_Dx2> >, is_constructible<_Dx2, _Dx2> >, int> = 0, class  = _Enable_ctor_reset<_Uty>> unique_ptr(_Uty _Ptr, std::default_delete<unsigned char const[]> &&_Dt) noexcept;
        template <class _Uty, class _Dx2 = std::default_delete<unsigned char const[]>, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2> > >, int> = 0> unique_ptr(_Uty, remove_reference_t<std::default_delete<unsigned char const[]> > &&) = delete
        unique_ptr(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &&_Right) noexcept : std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::_Mybase(_Right.release(), ::std::forward<std::default_delete<unsigned char const[]> >(_Right.get_deleter()))         {
        }
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &&_Right) noexcept;
        template <class _Uty, class _Ex, class _More, class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer, class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type> using _Enable_conversion = enable_if_t<conjunction_v<is_array<_Uty>, is_same<std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer, std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::element_type *>, is_same<_UP_pointer, _UP_element_type *>, is_convertible<_UP_element_type (*)[], std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::element_type (*)[]>, _More> >;
        template <class _Uty, class _Ex, class  = _Enable_conversion<_Uty, _Ex, conditional_t<is_reference_v<std::default_delete<unsigned char const[]> >, is_same<_Ex, std::default_delete<unsigned char const[]> >, is_convertible<_Ex, std::default_delete<unsigned char const[]> > > >> unique_ptr(unique_ptr<_Uty, _Ex> &&_Right) noexcept;
        template<> unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]>, void>(unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &&_Right) noexcept;
        template <class _Uty, class _Ex, class  = _Enable_conversion<_Uty, _Ex, is_assignable<std::default_delete<unsigned char const[]> &, _Ex> >> std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=(unique_ptr<_Uty, _Ex> &&_Right) noexcept;
        template<> std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=<unsigned char const[], std::default_delete<unsigned char const[]>, void>(unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &&_Right) noexcept;
        template <class _Dx2 = std::default_delete<unsigned char const[]>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr(std::nullptr_t) noexcept;
        template<> constexpr unique_ptr<std::default_delete<unsigned char const[]>, 0>(std::nullptr_t) noexcept : std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::_Mybase(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer())         {
        }
;
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=(std::nullptr_t) noexcept;
        void reset(std::nullptr_t) noexcept;
        void swap(std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &_Right) noexcept;
        ~unique_ptr<unsigned char const[], default_delete<unsigned char const[]> >() noexcept         {
            this->_Delete();
        }
        const unsigned char &operator[](size_t _Idx) const;
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer get() const noexcept         {
            return (this->_Myptr());
        }
        explicit operator bool() const noexcept;
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer release() noexcept         {
            std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer _Ans = this->get();
            this->_Myptr() = std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer();
            return (_Ans);
        }
        template <class _Uty, class  = _Enable_ctor_reset<_Uty, std::false_type>> void reset(_Uty _Ptr) noexcept;
        unique_ptr(const std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &) = delete
        std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &operator=(const std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> > &) = delete
    private:
        void _Delete()         {
            if (this->get() != std::unique_ptr<unsigned char const[], std::default_delete<unsigned char const[]> >::pointer()) {
                this->get_deleter()(this->get());
            }
        }
    };
template<> class unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl>> : public _Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > {
    public:
        typedef _Unique_ptr_base<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > _Mybase;
        typedef typename _Mybase::pointer pointer;
        typedef v8::WasmStreaming::WasmStreamingImpl element_type;
        typedef std::default_delete<v8::WasmStreaming::WasmStreamingImpl> deleter_type;
        using _Mybase::get_deleter;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr() noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr(std::nullptr_t) noexcept;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &operator=(std::nullptr_t) noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, _Unique_ptr_enable_default_t<_Dx2> = 0> explicit unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer _Ptr) noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, enable_if_t<is_constructible_v<_Dx2, const _Dx2 &>, int> = 0> unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer _Ptr, const std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &_Dt) noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, enable_if_t<conjunction_v<negation<is_reference<_Dx2> >, is_constructible<_Dx2, _Dx2> >, int> = 0> unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer _Ptr, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &&_Dt) noexcept;
        template <class _Dx2 = std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2> > >, int> = 0> unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer, remove_reference_t<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &&) = delete
        unique_ptr(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &&_Right) noexcept;
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer>, conditional_t<is_reference_v<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >, is_same<_Dx2, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >, is_convertible<_Dx2, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > > >, int> = 0> unique_ptr(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept;
        template<> unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, 0>(unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &&_Right) noexcept;
        template <class _Ty2, enable_if_t<conjunction_v<is_convertible<_Ty2 *, v8::WasmStreaming::WasmStreamingImpl *>, is_same<std::default_delete<v8::WasmStreaming::WasmStreamingImpl>, default_delete<v8::WasmStreaming::WasmStreamingImpl> > >, int> = 0> unique_ptr(auto_ptr<_Ty2> &&_Right) noexcept;
        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2> >, is_assignable<std::default_delete<v8::WasmStreaming::WasmStreamingImpl> &, _Dx2>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer> >, int> = 0> std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &operator=(unique_ptr<_Ty2, _Dx2> &&_Right) noexcept;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &operator=(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &&_Right) noexcept;
        void swap(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &_Right) noexcept;
        ~unique_ptr<WasmStreamingImpl, default_delete<WasmStreamingImpl> >() noexcept;
        add_lvalue_reference_t<v8::WasmStreaming::WasmStreamingImpl> operator*() const;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer operator->() const noexcept;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer get() const noexcept;
        explicit operator bool() const noexcept;
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer release() noexcept;
        void reset(std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> >::pointer _Ptr) noexcept;
        unique_ptr(const std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &) = delete
        std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &operator=(const std::unique_ptr<v8::WasmStreaming::WasmStreamingImpl, std::default_delete<v8::WasmStreaming::WasmStreamingImpl> > &) = delete
    };
    template <class _Ty, class _Dx> class unique_ptr<type-parameter-0-0 [], _Dx> : public _Unique_ptr_base<_Ty, _Dx> {
    public:
        typedef _Unique_ptr_base<_Ty, _Dx> _Mybase;
        typedef typename _Mybase::pointer pointer;
        typedef _Ty element_type;
        typedef _Dx deleter_type;
        using _Mybase::get_deleter;
        template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr<type-parameter-0-0 [], type-parameter-0-1>() noexcept : std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::_Mybase(std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer())         {
        }
        template <class _Uty, class _Is_nullptr = is_same<_Uty, std::nullptr_t>> using _Enable_ctor_reset = enable_if_t<is_same_v<_Uty, std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer> || _Is_nullptr::value || (is_same_v<std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer, std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::element_type *> && is_pointer_v<_Uty> && is_convertible_v<remove_pointer_t<_Uty> (*)[], std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::element_type (*)[]>)>;
        template <class _Uty, class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0, class  = _Enable_ctor_reset<_Uty>> explicit unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(_Uty _Ptr) noexcept         template <class _Uty, class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2 &>, int> = 0, class  = _Enable_ctor_reset<_Uty>> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(_Uty _Ptr, const _Dx &_Dt) noexcept         template <class _Uty, class _Dx2 = _Dx, enable_if_t<conjunction_v<negation<is_reference<_Dx2> >, is_constructible<_Dx2, _Dx2> >, int> = 0, class  = _Enable_ctor_reset<_Uty>> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(_Uty _Ptr, _Dx &&_Dt) noexcept         template <class _Uty, class _Dx2 = _Dx, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2> > >, int> = 0> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(_Uty, remove_reference_t<_Dx> &&) = delete
        unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &&_Right) noexcept : std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::_Mybase(_Right.release(), ::std::forward<_Dx>(_Right.get_deleter()))         {
        }
        unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &operator=(unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &&_Right) noexcept         template <class _Uty, class _Ex, class _More, class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer, class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type> using _Enable_conversion = enable_if_t<conjunction_v<is_array<_Uty>, is_same<std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer, std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::element_type *>, is_same<_UP_pointer, _UP_element_type *>, is_convertible<_UP_element_type (*)[], std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::element_type (*)[]>, _More> >;
        template <class _Uty, class _Ex, class  = _Enable_conversion<_Uty, _Ex, conditional_t<is_reference_v<_Dx>, is_same<_Ex, _Dx>, is_convertible<_Ex, _Dx> > >> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(unique_ptr<_Uty, _Ex> &&_Right) noexcept         template <class _Uty, class _Ex, class  = _Enable_conversion<_Uty, _Ex, is_assignable<_Dx &, _Ex> >> unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &operator=(unique_ptr<_Uty, _Ex> &&_Right) noexcept         template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0> constexpr unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(std::nullptr_t) noexcept : std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::_Mybase(std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer())         {
        }
        unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &operator=(std::nullptr_t) noexcept         void reset(std::nullptr_t = nullptr) noexcept         void swap(unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &_Right) noexcept         ~unique_ptr<type-parameter-0-0 [], type-parameter-0-1>() noexcept         {
            this->_Delete();
        }
        _Ty &operator[](size_t _Idx) const         std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer get() const noexcept         {
            return (this->_Myptr());
        }
        explicit operator bool() const noexcept         std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer release() noexcept         {
            std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer _Ans = this->get();
            this->_Myptr() = std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer();
            return (_Ans);
        }
        template <class _Uty, class  = _Enable_ctor_reset<_Uty, std::false_type>> void reset(_Uty _Ptr) noexcept         unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(const unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &) = delete
        unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &operator=(const unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &) = delete
    private:
        void _Delete()         {
            if (this->get() != std::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer()) {
                this->get_deleter()(this->get());
            }
        }
    };
    template <class _Ty, class ..._Types, enable_if_t<!is_array_v<_Ty>, int> = 0> inline unique_ptr<_Ty> make_unique(_Types &&..._Args)     template <class _Ty, enable_if_t<is_array_v<_Ty> && extent_v<_Ty> == 0, int> = 0> inline unique_ptr<_Ty> make_unique(size_t _Size)     template <class _Ty, class ..._Types, enable_if_t<extent_v<_Ty> != 0, int> = 0> void make_unique(_Types &&...) = delete
    template <class _Alloc> struct _Allocator_deleter {
        _Alloc _Al;
        using pointer = typename allocator_traits<_Alloc>::pointer;
        void operator()(std::_Allocator_deleter::pointer _Ptr) noexcept     };
    template <class _Alloc> using _Unique_ptr_alloc = unique_ptr<typename _Alloc::value_type, _Allocator_deleter<_Alloc> >;
    template <class _Alloc, class ..._Args> _Unique_ptr_alloc<_Alloc> _Make_unique_alloc(_Alloc &_Al, _Args &&..._Vals)     template <class _Ty, class _Dx, enable_if_t<_Is_swappable<_Dx>::value, int> = 0> void swap(unique_ptr<_Ty, _Dx> &_Left, unique_ptr<_Ty, _Dx> &_Right) noexcept     template <class _Ty1, class _Dx1, class _Ty2, class _Dx2> bool operator==(const unique_ptr<_Ty1, _Dx1> &_Left, const unique_ptr<_Ty2, _Dx2> &_Right)     template <class _Ty1, class _Dx1, class _Ty2, class _Dx2> bool operator!=(const unique_ptr<_Ty1, _Dx1> &_Left, const unique_ptr<_Ty2, _Dx2> &_Right)     template <class _Ty1, class _Dx1, class _Ty2, class _Dx2> bool operator<(const unique_ptr<_Ty1, _Dx1> &_Left, const unique_ptr<_Ty2, _Dx2> &_Right)     template <class _Ty1, class _Dx1, class _Ty2, class _Dx2> bool operator>=(const unique_ptr<_Ty1, _Dx1> &_Left, const unique_ptr<_Ty2, _Dx2> &_Right)     template <class _Ty1, class _Dx1, class _Ty2, class _Dx2> bool operator>(const unique_ptr<_Ty1, _Dx1> &_Left, const unique_ptr<_Ty2, _Dx2> &_Right)     template <class _Ty1, class _Dx1, class _Ty2, class _Dx2> bool operator<=(const unique_ptr<_Ty1, _Dx1> &_Left, const unique_ptr<_Ty2, _Dx2> &_Right)     template <class _Ty, class _Dx> bool operator==(const unique_ptr<_Ty, _Dx> &_Left, std::nullptr_t) noexcept     template <class _Ty, class _Dx> bool operator==(std::nullptr_t, const unique_ptr<_Ty, _Dx> &_Right) noexcept     template <class _Ty, class _Dx> bool operator!=(const unique_ptr<_Ty, _Dx> &_Left, std::nullptr_t _Right) noexcept     template <class _Ty, class _Dx> bool operator!=(std::nullptr_t _Left, const unique_ptr<_Ty, _Dx> &_Right) noexcept     template <class _Ty, class _Dx> bool operator<(const unique_ptr<_Ty, _Dx> &_Left, std::nullptr_t _Right)     template <class _Ty, class _Dx> bool operator<(std::nullptr_t _Left, const unique_ptr<_Ty, _Dx> &_Right)     template <class _Ty, class _Dx> bool operator>=(const unique_ptr<_Ty, _Dx> &_Left, std::nullptr_t _Right)     template <class _Ty, class _Dx> bool operator>=(std::nullptr_t _Left, const unique_ptr<_Ty, _Dx> &_Right)     template <class _Ty, class _Dx> bool operator>(const unique_ptr<_Ty, _Dx> &_Left, std::nullptr_t _Right)     template <class _Ty, class _Dx> bool operator>(std::nullptr_t _Left, const unique_ptr<_Ty, _Dx> &_Right)     template <class _Ty, class _Dx> bool operator<=(const unique_ptr<_Ty, _Dx> &_Left, std::nullptr_t _Right)     template <class _Ty, class _Dx> bool operator<=(std::nullptr_t _Left, const unique_ptr<_Ty, _Dx> &_Right)     enum class pointer_safety : int {
        relaxed,
        preferred,
        strict
    };
    inline void declare_reachable(void *)     {
    }
    template <class _Ty> inline _Ty *undeclare_reachable(_Ty *_Ptr)     inline void declare_no_pointers(char *, size_t)     {
    }
    inline void undeclare_no_pointers(char *, size_t)     {
    }
    inline std::pointer_safety get_pointer_safety() noexcept     {
        return (pointer_safety::relaxed);
    }
    template <class _Ty = void> struct owner_less;
    template <class _Ty> struct owner_less<shared_ptr<type-parameter-0-0>> {
        typedef shared_ptr<_Ty> first_argument_type;
        typedef shared_ptr<_Ty> second_argument_type;
        typedef bool result_type;
        bool operator()(const shared_ptr<_Ty> &_Left, const shared_ptr<_Ty> &_Right) const noexcept         bool operator()(const shared_ptr<_Ty> &_Left, const weak_ptr<_Ty> &_Right) const noexcept         bool operator()(const weak_ptr<_Ty> &_Left, const shared_ptr<_Ty> &_Right) const noexcept     };
    template <class _Ty> struct owner_less<weak_ptr<type-parameter-0-0>> {
        typedef weak_ptr<_Ty> first_argument_type;
        typedef weak_ptr<_Ty> second_argument_type;
        typedef bool result_type;
        bool operator()(const weak_ptr<_Ty> &_Left, const weak_ptr<_Ty> &_Right) const noexcept         bool operator()(const weak_ptr<_Ty> &_Left, const shared_ptr<_Ty> &_Right) const noexcept         bool operator()(const shared_ptr<_Ty> &_Left, const weak_ptr<_Ty> &_Right) const noexcept     };
    template<> struct owner_less<void> {
        using is_transparent = int;
        template <class _Ty, class _Uty> bool operator()(const shared_ptr<_Ty> &_Left, const shared_ptr<_Uty> &_Right) const noexcept         template <class _Ty, class _Uty> bool operator()(const shared_ptr<_Ty> &_Left, const weak_ptr<_Uty> &_Right) const noexcept         template <class _Ty, class _Uty> bool operator()(const weak_ptr<_Ty> &_Left, const shared_ptr<_Uty> &_Right) const noexcept         template <class _Ty, class _Uty> bool operator()(const weak_ptr<_Ty> &_Left, const weak_ptr<_Uty> &_Right) const noexcept     };
    template <class _Ty, class _Dx> struct hash<unique_ptr<type-parameter-0-0, type-parameter-0-1>> : _Conditionally_enabled_hash<unique_ptr<_Ty, _Dx>, is_default_constructible_v<hash<typename unique_ptr<_Ty, _Dx>::pointer> > > {
        static size_t _Do_hash(const unique_ptr<_Ty, _Dx> &_Keyval) noexcept(_Is_nothrow_hashable<typename unique_ptr<_Ty, _Dx>::pointer>::value_Do_hash(const unique_ptr<_Ty, _Dx> &_Keyval) noexcept(_Is_nothrow_hashable<typename unique_ptr<_Ty, _Dx>::pointer>::value)     };
    template <class _Ty> struct hash<shared_ptr<type-parameter-0-0>> {
        typedef shared_ptr<_Ty> argument_type;
        typedef size_t result_type;
        size_t operator()(const shared_ptr<_Ty> &_Keyval) const noexcept     };
    inline void *align(size_t _Bound, size_t _Size, void *&_Ptr, size_t &_Space) noexcept     {
        size_t _Off = static_cast<size_t>(reinterpret_cast<uintptr_t>(_Ptr) & (_Bound - 1));
        if (_Off != 0) {
            _Off = _Bound - _Off;
        }
        if (_Space < _Off || _Space - _Off < _Size) {
            return (0);
        }
        _Ptr = static_cast<char *>(_Ptr) + _Off;
        _Space -= _Off;
        return (_Ptr);
    }
    extern "C" {
        void _Lock_shared_ptr_spin_lock();
        void _Unlock_shared_ptr_spin_lock();
    }
    struct _Shared_ptr_spin_lock {
        _Shared_ptr_spin_lock()         {
            _Lock_shared_ptr_spin_lock();
        }
        ~_Shared_ptr_spin_lock() noexcept         {
            _Unlock_shared_ptr_spin_lock();
        }
    };
    template <class _Ty> inline bool atomic_is_lock_free(const shared_ptr<_Ty> *)     template <class _Ty> inline shared_ptr<_Ty> atomic_load_explicit(const shared_ptr<_Ty> *_Ptr, std::memory_order)     template <class _Ty> inline shared_ptr<_Ty> atomic_load(const shared_ptr<_Ty> *_Ptr)     template <class _Ty> inline void atomic_store_explicit(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other, std::memory_order)     template <class _Ty> inline void atomic_store(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other)     template <class _Ty> inline shared_ptr<_Ty> atomic_exchange_explicit(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other, std::memory_order)     template <class _Ty> inline shared_ptr<_Ty> atomic_exchange(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other)     template <class _Ty> inline bool atomic_compare_exchange_weak_explicit(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp, shared_ptr<_Ty> _Value, std::memory_order, std::memory_order)     template <class _Ty> inline bool atomic_compare_exchange_weak(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp, shared_ptr<_Ty> _Value)     template <class _Ty> inline bool atomic_compare_exchange_strong_explicit(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp, shared_ptr<_Ty> _Value, std::memory_order, std::memory_order)     template <class _Ty> inline bool atomic_compare_exchange_strong(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp, shared_ptr<_Ty> _Value)     namespace tr1 {
        using ::std::allocate_shared;
        using ::std::bad_weak_ptr;
        using ::std::const_pointer_cast;
        using ::std::dynamic_pointer_cast;
        using ::std::enable_shared_from_this;
        using ::std::get_deleter;
        using ::std::make_shared;
        using ::std::shared_ptr;
        using ::std::static_pointer_cast;
        using ::std::swap;
        using ::std::weak_ptr;
    }
}
namespace std {
    template <class _Traits> using _Traits_ch_t = typename _Traits::char_type;
    template <class _Traits> using _Traits_ptr_t = const typename _Traits::char_type *;
    template <class _Traits> constexpr bool _Traits_equal(const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size, const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept     {
        return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);
    }
    template <class _Traits> constexpr int _Traits_compare(const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size, const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept     {
        const int _Ans = _Traits::compare(_Left, _Right, _Min_value(_Left_size, _Right_size));
        if (_Ans != 0) {
            return (_Ans);
        }
        if (_Left_size < _Right_size) {
            return (-1);
        }
        if (_Left_size > _Right_size) {
            return (1);
        }
        return (0);
    }
    template <class _Traits> constexpr size_t _Traits_find(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size) noexcept     {
        if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {
            return (static_cast<size_t>(-1));
        }
        if (_Needle_size == 0) {
            return (_Start_at);
        }
        const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
        for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
            _Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);
            if (!_Match_try) {
                return (static_cast<size_t>(-1));
            }
            if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
                return (_Match_try - _Haystack);
            }
        }
    }
    template <class _Traits> constexpr size_t _Traits_find_ch(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept     {
        if (_Start_at < _Hay_size) {
            const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
            if (_Found_at) {
                return (_Found_at - _Haystack);
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_rfind(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size) noexcept     {
        if (_Needle_size == 0) {
            return (_Min_value(_Start_at, _Hay_size));
        }
        if (_Needle_size <= _Hay_size) {
            for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - _Needle_size);; --_Match_try) {
                if (_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
                    return (_Match_try - _Haystack);
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_rfind_ch(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept     {
        if (_Hay_size != 0) {
            for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (_Traits::eq(*_Match_try, _Ch)) {
                    return (_Match_try - _Haystack);
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Elem, bool = _Is_character<_Elem>::value> class _String_bitmap {
    public:
        constexpr bool _Mark(const _Elem *_First, const _Elem *const _Last)         {
            for (; _First != _Last; ++_First) {
                this->_Matches[static_cast<unsigned char>(*_First)] = true;
            }
            return (true);
        }
        constexpr bool _Match(const _Elem _Ch) const         {
            return (this->_Matches[static_cast<unsigned char>(_Ch)]);
        }
    private:
        bool _Matches[256] = {};
    };
    template <class _Elem> class _String_bitmap<_Elem, false> {
    public:
        static_assert(is_unsigned_v<_Elem>, "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. Visual C++ accepts other unsigned integral types as an extension.");
        constexpr bool _Mark(const _Elem *_First, const _Elem *const _Last)         {
            for (; _First != _Last; ++_First) {
                const auto _Ch = *_First;
                if (_Ch >= 256U) {
                    return (false);
                }
                this->_Matches[static_cast<unsigned char>(_Ch)] = true;
            }
            return (true);
        }
        constexpr bool _Match(const _Elem _Ch) const         {
            return (_Ch < 256U && this->_Matches[_Ch]);
        }
    private:
        bool _Matches[256] = {};
    };
    template <class _Traits> constexpr size_t _Traits_find_first_of(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, std::false_type) noexcept     {
        if (_Needle_size != 0 && _Start_at < _Hay_size) {
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return (_Match_try - _Haystack);
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_find_first_of(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, std::true_type) noexcept     {
        if (_Needle_size != 0 && _Start_at < _Hay_size) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) {
                return (_Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, std::false_type{}));
            }
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (_Matches._Match(*_Match_try)) {
                    return (_Match_try - _Haystack);
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_find_last_of(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, std::false_type) noexcept     {
        if (_Needle_size != 0 && _Hay_size != 0) {
            for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return (_Match_try - _Haystack);
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_find_last_of(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, std::true_type) noexcept     {
        if (_Needle_size != 0 && _Hay_size != 0) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) {
                return (_Traits_find_last_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, std::false_type{}));
            }
            for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (_Matches._Match(*_Match_try)) {
                    return (_Match_try - _Haystack);
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_find_first_not_of(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, std::false_type) noexcept     {
        if (_Start_at < _Hay_size) {
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return (_Match_try - _Haystack);
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_find_first_not_of(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, std::true_type) noexcept     {
        if (_Start_at < _Hay_size) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) {
                return (_Traits_find_first_not_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, std::false_type{}));
            }
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (!_Matches._Match(*_Match_try)) {
                    return (_Match_try - _Haystack);
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_find_not_ch(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept     {
        if (_Start_at < _Hay_size) {
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (!_Traits::eq(*_Match_try, _Ch)) {
                    return (_Match_try - _Haystack);
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_find_last_not_of(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, std::false_type) noexcept     {
        if (_Hay_size != 0) {
            for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return (_Match_try - _Haystack);
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_find_last_not_of(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, std::true_type) noexcept     {
        if (_Hay_size != 0) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) {
                return (_Traits_find_last_not_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, std::false_type{}));
            }
            for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (!_Matches._Match(*_Match_try)) {
                    return (_Match_try - _Haystack);
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Traits> constexpr size_t _Traits_rfind_not_ch(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept     {
        if (_Hay_size != 0) {
            for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (!_Traits::eq(*_Match_try, _Ch)) {
                    return (_Match_try - _Haystack);
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        }
        return (static_cast<size_t>(-1));
    }
    template <class _Mystr> class _String_const_iterator : public std::_Iterator_base {
    public:
        using iterator_category = std::random_access_iterator_tag;
        using value_type = typename _Mystr::value_type;
        using difference_type = typename _Mystr::difference_type;
        using pointer = typename _Mystr::const_pointer;
        using reference = const std::_String_const_iterator::value_type &;
        _String_const_iterator<_Mystr>()         _String_const_iterator<_Mystr>(std::_String_const_iterator::pointer _Parg, const std::_Container_base *_Pstring)         using _Unchecked_type = std::_String_const_iterator::pointer;
        std::_String_const_iterator::reference operator*() const         std::_String_const_iterator::pointer operator->() const         _String_const_iterator<_Mystr> &operator++()         _String_const_iterator<_Mystr> operator++(int)         _String_const_iterator<_Mystr> &operator--()         _String_const_iterator<_Mystr> operator--(int)         _String_const_iterator<_Mystr> &operator+=(const std::_String_const_iterator::difference_type _Off)         _String_const_iterator<_Mystr> operator+(const std::_String_const_iterator::difference_type _Off) const         _String_const_iterator<_Mystr> &operator-=(const std::_String_const_iterator::difference_type _Off)         _String_const_iterator<_Mystr> operator-(const std::_String_const_iterator::difference_type _Off) const         std::_String_const_iterator::difference_type operator-(const _String_const_iterator<_Mystr> &_Right) const         std::_String_const_iterator::reference operator[](const std::_String_const_iterator::difference_type _Off) const         bool operator==(const _String_const_iterator<_Mystr> &_Right) const         bool operator!=(const _String_const_iterator<_Mystr> &_Right) const         bool operator<(const _String_const_iterator<_Mystr> &_Right) const         bool operator>(const _String_const_iterator<_Mystr> &_Right) const         bool operator<=(const _String_const_iterator<_Mystr> &_Right) const         bool operator>=(const _String_const_iterator<_Mystr> &_Right) const         void _Compat(const _String_const_iterator<_Mystr> &) const         std::_String_const_iterator::pointer _Ptr;
    };
    template <class _Mystr> inline _String_const_iterator<_Mystr> operator+(typename _String_const_iterator<_Mystr>::difference_type _Off, _String_const_iterator<_Mystr> _Next)     template <class _Mystr> inline _String_const_iterator<_Mystr> &_Rechecked(_String_const_iterator<_Mystr> &_Iter, const typename _String_const_iterator<_Mystr>::_Unchecked_type _Right)     template <class _Mystr> inline typename _String_const_iterator<_Mystr>::_Unchecked_type _Unchecked(const _String_const_iterator<_Mystr> &_Iter)     template <class _Mystr> class _String_iterator : public _String_const_iterator<_Mystr> {
    public:
        using _Mybase = _String_const_iterator<_Mystr>;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = typename _Mystr::value_type;
        using difference_type = typename _Mystr::difference_type;
        using pointer = typename _Mystr::pointer;
        using reference = std::_String_iterator::value_type &;
        _String_iterator<_Mystr>()         _String_iterator<_Mystr>(std::_String_iterator::pointer _Parg, const std::_Container_base *_Pstring)         using _Unchecked_type = std::_String_iterator::pointer;
        std::_String_iterator::reference operator*() const         std::_String_iterator::pointer operator->() const         _String_iterator<_Mystr> &operator++()         _String_iterator<_Mystr> operator++(int)         _String_iterator<_Mystr> &operator--()         _String_iterator<_Mystr> operator--(int)         _String_iterator<_Mystr> &operator+=(const std::_String_iterator::difference_type _Off)         _String_iterator<_Mystr> operator+(const std::_String_iterator::difference_type _Off) const         _String_iterator<_Mystr> &operator-=(const std::_String_iterator::difference_type _Off)         _String_iterator<_Mystr> operator-(const std::_String_iterator::difference_type _Off) const         std::_String_iterator::difference_type operator-(const std::_String_iterator::_Mybase &_Right) const         std::_String_iterator::reference operator[](const std::_String_iterator::difference_type _Off) const     };
    template <class _Mystr> inline _String_iterator<_Mystr> operator+(typename _String_iterator<_Mystr>::difference_type _Off, _String_iterator<_Mystr> _Next)     template <class _Mystr> inline _String_iterator<_Mystr> &_Rechecked(_String_iterator<_Mystr> &_Iter, const typename _String_iterator<_Mystr>::_Unchecked_type _Right)     template <class _Mystr> inline typename _String_iterator<_Mystr>::_Unchecked_type _Unchecked(const _String_iterator<_Mystr> &_Iter)     template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer, class _Reference, class _Const_reference> struct _String_iter_types {
        using value_type = _Value_type;
        using size_type = _Size_type;
        using difference_type = _Difference_type;
        using pointer = _Pointer;
        using const_pointer = _Const_pointer;
    };
    template <class _Ty, class _Alloc> struct _String_base_types {
        using _Alty = _Rebind_alloc_t<_Alloc, _Ty>;
        using _Alty_traits = allocator_traits<std::_String_base_types::_Alty>;
        using _Val_types = conditional_t<_Is_simple_alloc_v<std::_String_base_types::_Alty>, _Simple_types<_Ty>, _String_iter_types<_Ty, typename _Alty_traits::size_type, typename _Alty_traits::difference_type, typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Ty &, const _Ty &> >;
    };
template<> struct _String_base_types<char, std::allocator<char>> {
        using _Alty = _Rebind_alloc_t<std::allocator<char>, char>;
        using _Alty_traits = allocator_traits<std::_String_base_types<char, std::allocator<char> >::_Alty>;
        using _Val_types = conditional_t<_Is_simple_alloc_v<std::_String_base_types<char, std::allocator<char> >::_Alty>, _Simple_types<char>, _String_iter_types<char, typename _Alty_traits::size_type, typename _Alty_traits::difference_type, typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, char &, const char &> >;
    };
    template <class _Val_types> class _String_val : public std::_Container_base {
    public:
        using value_type = typename _Val_types::value_type;
        using size_type = typename _Val_types::size_type;
        using difference_type = typename _Val_types::difference_type;
        using pointer = typename _Val_types::pointer;
        using const_pointer = typename _Val_types::const_pointer;
        using reference = std::_String_val::value_type &;
        using const_reference = const std::_String_val::value_type &;
        _String_val<_Val_types>()         enum  {
            _BUF_SIZE = 16 / sizeof(std::_String_val::value_type) < 1 ? 1 : 16 / sizeof(std::_String_val::value_type)
        };
        enum  {
            _ALLOC_MASK = sizeof(std::_String_val::value_type) <= 1 ? 15 : sizeof(std::_String_val::value_type) <= 2 ? 7 : sizeof(std::_String_val::value_type) <= 4 ? 3 : sizeof(std::_String_val::value_type) <= 8 ? 1 : 0
        };
        std::_String_val::value_type *_Myptr()         const std::_String_val::value_type *_Myptr() const         {
            const std::_String_val::value_type *_Result = this->_Bx._Buf;
            if (this->_Large_string_engaged()) {
                _Result = _Unfancy(this->_Bx._Ptr);
            }
            return (_Result);
        }
        bool _Large_string_engaged() const         {
            return (_BUF_SIZE <= this->_Myres);
        }
        void _Check_offset(const std::_String_val::size_type _Off) const         void _Check_offset_exclusive(const std::_String_val::size_type _Off) const         static void _Xran() [[noreturn]]         std::_String_val::size_type _Clamp_suffix_size(const std::_String_val::size_type _Off, const std::_String_val::size_type _Size) const noexcept         union _Bxty {
            _Bxty()             ~_Bxty() noexcept             std::_String_val::value_type _Buf[_BUF_SIZE];
            std::_String_val::pointer _Ptr;
            char _Alias[_BUF_SIZE];
        } _Bx;
        std::_String_val::size_type _Mysize;
        std::_String_val::size_type _Myres;
    };
template<> class _String_val<std::_Simple_types<char>> : public std::_Container_base {
    public:
        using value_type = typename _Simple_types<char>::value_type;
        using size_type = typename _Simple_types<char>::size_type;
        using difference_type = typename _Simple_types<char>::difference_type;
        using pointer = typename _Simple_types<char>::pointer;
        using const_pointer = typename _Simple_types<char>::const_pointer;
        using reference = std::_String_val<std::_Simple_types<char> >::value_type &;
        using const_reference = const std::_String_val<std::_Simple_types<char> >::value_type &;
        _String_val();
        enum  {
            _BUF_SIZE = 16 / sizeof(std::_String_val<std::_Simple_types<char> >::value_type) < 1 ? 1 : 16 / sizeof(std::_String_val<std::_Simple_types<char> >::value_type)
        };
        enum  {
            _ALLOC_MASK = sizeof(std::_String_val<std::_Simple_types<char> >::value_type) <= 1 ? 15 : sizeof(std::_String_val<std::_Simple_types<char> >::value_type) <= 2 ? 7 : sizeof(std::_String_val<std::_Simple_types<char> >::value_type) <= 4 ? 3 : sizeof(std::_String_val<std::_Simple_types<char> >::value_type) <= 8 ? 1 : 0
        };
        std::_String_val<std::_Simple_types<char> >::value_type *_Myptr();
        const std::_String_val<std::_Simple_types<char> >::value_type *_Myptr() const         {
            const std::_String_val<std::_Simple_types<char> >::value_type *_Result = this->_Bx._Buf;
            if (this->_Large_string_engaged()) {
                _Result = _Unfancy(this->_Bx._Ptr);
            }
            return (_Result);
        }
        bool _Large_string_engaged() const         {
            return (_BUF_SIZE <= this->_Myres);
        }
        void _Check_offset(const std::_String_val<std::_Simple_types<char> >::size_type _Off) const;
        void _Check_offset_exclusive(const std::_String_val<std::_Simple_types<char> >::size_type _Off) const;
        static void _Xran() [[noreturn]];
        std::_String_val<std::_Simple_types<char> >::size_type _Clamp_suffix_size(const std::_String_val<std::_Simple_types<char> >::size_type _Off, const std::_String_val<std::_Simple_types<char> >::size_type _Size) const noexcept;
        union _Bxty {
            std::_String_val<std::_Simple_types<char> >::value_type _Buf[16];
            std::_String_val<std::_Simple_types<char> >::pointer _Ptr;
            char _Alias[16];
        };
        union _Bxty _Bx;
        std::_String_val<std::_Simple_types<char> >::size_type _Mysize;
        std::_String_val<std::_Simple_types<char> >::size_type _Myres;
    };
    template <class _Alloc_types> class _String_alloc {
    public:
        using _Alty = typename _Alloc_types::_Alty;
        using _Alty_traits = typename _Alloc_types::_Alty_traits;
        using _Alproxy = _Rebind_alloc_t<std::_String_alloc::_Alty, std::_Container_proxy>;
        using _Alproxy_traits = allocator_traits<std::_String_alloc::_Alproxy>;
        using _Val_types = typename _Alloc_types::_Val_types;
        using _Mydata_t = _String_val<std::_String_alloc::_Val_types>;
        using _Bxty = typename _Mydata_t::_Bxty;
        using value_type = typename _Val_types::value_type;
        using size_type = typename _Val_types::size_type;
        using difference_type = typename _Val_types::difference_type;
        using pointer = typename _Val_types::pointer;
        using const_pointer = typename _Val_types::const_pointer;
        using reference = std::_String_alloc::value_type &;
        using const_reference = const std::_String_alloc::value_type &;
        using iterator = _String_iterator<std::_String_alloc::_Mydata_t>;
        using const_iterator = _String_const_iterator<std::_String_alloc::_Mydata_t>;
        enum  {
            _BUF_SIZE = _Mydata_t::_BUF_SIZE
        };
        enum  {
            _ALLOC_MASK = _Mydata_t::_ALLOC_MASK
        };
        _String_alloc<_Alloc_types>()         template <class _Any_alloc, class  = enable_if_t<!is_same_v<remove_cv_t<remove_reference_t<_Any_alloc> >, _String_alloc<_Alloc_types> > >> _String_alloc<_Alloc_types>(_Any_alloc &&_Al)         void _Copy_alloc(const std::_String_alloc::_Alty &_Al)         void _Move_alloc(std::_String_alloc::_Alty &_Al)         void _Orphan_all()         void _Swap_all(_String_alloc<_Alloc_types> &_Right)         std::_String_alloc::_Alty &_Getal() noexcept         const std::_String_alloc::_Alty &_Getal() const noexcept         std::_String_alloc::_Mydata_t &_Get_data() noexcept         const std::_String_alloc::_Mydata_t &_Get_data() const noexcept         {
            return (this->_Mypair._Get_second());
        }
    private:
        _Compressed_pair<std::_String_alloc::_Alty, std::_String_alloc::_Mydata_t> _Mypair;
    };
template<> class _String_alloc<std::_String_base_types<char, std::allocator<char> >> {
    public:
        using _Alty = typename _String_base_types<char, allocator<char> >::_Alty;
        using _Alty_traits = typename _String_base_types<char, allocator<char> >::_Alty_traits;
        using _Alproxy = _Rebind_alloc_t<std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Alty, std::_Container_proxy>;
        using _Alproxy_traits = allocator_traits<std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Alproxy>;
        using _Val_types = typename _String_base_types<char, allocator<char> >::_Val_types;
        using _Mydata_t = _String_val<std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Val_types>;
        using _Bxty = typename _Mydata_t::_Bxty;
        using value_type = typename _Val_types::value_type;
        using size_type = typename _Val_types::size_type;
        using difference_type = typename _Val_types::difference_type;
        using pointer = typename _Val_types::pointer;
        using const_pointer = typename _Val_types::const_pointer;
        using reference = std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::value_type &;
        using const_reference = const std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::value_type &;
        using iterator = _String_iterator<std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Mydata_t>;
        using const_iterator = _String_const_iterator<std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Mydata_t>;
        enum  {
            _BUF_SIZE = _Mydata_t::_BUF_SIZE
        };
        enum  {
            _ALLOC_MASK = _Mydata_t::_ALLOC_MASK
        };
        _String_alloc();
        template <class _Any_alloc, class  = enable_if_t<!is_same_v<remove_cv_t<remove_reference_t<_Any_alloc> >, std::_String_alloc<std::_String_base_types<char, std::allocator<char> > > > >> _String_alloc(_Any_alloc &&_Al);
        void _Copy_alloc(const std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Alty &_Al);
        void _Move_alloc(std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Alty &_Al);
        void _Orphan_all();
        void _Swap_all(std::_String_alloc<std::_String_base_types<char, std::allocator<char> > > &_Right);
        std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Alty &_Getal() noexcept;
        const std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Alty &_Getal() const noexcept;
        std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Mydata_t &_Get_data() noexcept;
        const std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Mydata_t &_Get_data() const noexcept         {
            return (this->_Mypair._Get_second());
        }
    private:
        _Compressed_pair<std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Alty, std::_String_alloc<std::_String_base_types<char, std::allocator<char> > >::_Mydata_t> _Mypair;
    };
    template <class _Ty> constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty);
    template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>> class basic_string : public _String_alloc<_String_base_types<_Elem, _Alloc> > {
    public:
        static_assert(!0 || is_same_v<_Elem, typename _Alloc::value_type>, "basic_string<T, Traits, Allocator> requires that Allocator's value_type match T (See N4659 26.2.1 [container.requirements.general]/16 allocator_type) Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0 to suppress this diagnostic.");
        static_assert(is_same_v<_Elem, typename _Traits::char_type>, "N4659 24.3.2.1 [string.require]/3 requires that the supplied char_traits character type match the string's character type.");
        using _Mybase = _String_alloc<_String_base_types<_Elem, _Alloc> >;
        using traits_type = _Traits;
        using allocator_type = _Alloc;
        using _Alty = typename _Mybase::_Alty;
        using _Alty_traits = typename _Mybase::_Alty_traits;
        using _Mydata_t = typename _Mybase::_Mydata_t;
        using value_type = typename _Mybase::value_type;
        using size_type = typename _Mybase::size_type;
        using difference_type = typename _Mybase::difference_type;
        using pointer = typename _Mybase::pointer;
        using const_pointer = typename _Mybase::const_pointer;
        using reference = std::basic_string::value_type &;
        using const_reference = const std::basic_string::value_type &;
        using iterator = typename _Mybase::iterator;
        using const_iterator = typename _Mybase::const_iterator;
        using reverse_iterator = ::std::reverse_iterator<iterator>;
        using const_reverse_iterator = ::std::reverse_iterator<const_iterator>;
        using _Use_memcpy_move = bool_constant<_Is_specialization<_Traits, char_traits>::value && is_trivial_v<std::basic_string::pointer> >;
        static constexpr size_t _Memcpy_move_offset = _Size_after_ebco_v<std::_Container_base>;
        static constexpr size_t _Memcpy_move_size = sizeof(std::basic_string::_Mydata_t) - _Memcpy_move_offset;
        template <class _Iter> using _Is_elem_cptr = _Disjunction_t<is_same<_Iter, const _Elem *const>, is_same<_Iter, _Elem *const>, is_same<_Iter, const _Elem *>, is_same<_Iter, _Elem *> >;
        basic_string<_Elem, _Traits, _Alloc>(const basic_string<_Elem, _Traits, _Alloc> &_Right)         basic_string<_Elem, _Traits, _Alloc>(const basic_string<_Elem, _Traits, _Alloc> &_Right, const _Alloc &_Al)         basic_string<_Elem, _Traits, _Alloc>() noexcept(is_nothrow_default_constructible_v<std::basic_string::_Alty>basic_string<_Elem, _Traits, _Alloc>() noexcept(is_nothrow_default_constructible_v<std::basic_string::_Alty>)         explicit basic_string<_Elem, _Traits, _Alloc>(const _Alloc &_Al) noexcept         basic_string<_Elem, _Traits, _Alloc>(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Roff, const _Alloc &_Al = _Alloc())         basic_string<_Elem, _Traits, _Alloc>(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Roff, const std::basic_string::size_type _Count, const _Alloc &_Al = _Alloc())         basic_string<_Elem, _Traits, _Alloc>(const _Elem *const _Ptr, const std::basic_string::size_type _Count)         basic_string<_Elem, _Traits, _Alloc>(const _Elem *const _Ptr, const std::basic_string::size_type _Count, const _Alloc &_Al)         basic_string<_Elem, _Traits, _Alloc>(const _Elem *const _Ptr)         basic_string<_Elem, _Traits, _Alloc>(const _Elem *const _Ptr, const _Alloc &_Al)         basic_string<_Elem, _Traits, _Alloc>(const std::basic_string::size_type _Count, const _Elem _Ch)         basic_string<_Elem, _Traits, _Alloc>(const std::basic_string::size_type _Count, const _Elem _Ch, const _Alloc &_Al)         template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> basic_string<_Elem, _Traits, _Alloc>(_Iter _First, _Iter _Last, const _Alloc &_Al = _Alloc())         template <class _Iter> void _Construct(_Iter _First, const _Iter _Last, std::input_iterator_tag)         template <class _Iter> void _Construct(const _Iter _First, const _Iter _Last, std::forward_iterator_tag)         void _Construct(_Elem *const _First, _Elem *const _Last, std::random_access_iterator_tag)         void _Construct(const _Elem *const _First, const _Elem *const _Last, std::random_access_iterator_tag)         basic_string<_Elem, _Traits, _Alloc>(basic_string<_Elem, _Traits, _Alloc> &&_Right) noexcept         basic_string<_Elem, _Traits, _Alloc>(basic_string<_Elem, _Traits, _Alloc> &&_Right, const _Alloc &_Al) noexcept(_Alty_traits::is_always_equal::valuebasic_string<_Elem, _Traits, _Alloc>(basic_string<_Elem, _Traits, _Alloc> &&_Right, const _Alloc &_Al) noexcept(_Alty_traits::is_always_equal::value)         basic_string<_Elem, _Traits, _Alloc> &operator=(basic_string<_Elem, _Traits, _Alloc> &&_Right) noexcept(_Always_equal_after_move<std::basic_string::_Alty>operator=(basic_string<_Elem, _Traits, _Alloc> &&_Right) noexcept(_Always_equal_after_move<std::basic_string::_Alty>)         basic_string<_Elem, _Traits, _Alloc> &assign(basic_string<_Elem, _Traits, _Alloc> &&_Right) noexcept(_Always_equal_after_move<std::basic_string::_Alty>assign(basic_string<_Elem, _Traits, _Alloc> &&_Right) noexcept(_Always_equal_after_move<std::basic_string::_Alty>)         void _Assign_rv_contents(basic_string<_Elem, _Traits, _Alloc> &&_Right, std::true_type) noexcept         void _Assign_rv_contents(basic_string<_Elem, _Traits, _Alloc> &&_Right, std::false_type)         void _Assign_rv_contents_with_alloc_always_equal(basic_string<_Elem, _Traits, _Alloc> &&_Right, std::true_type) noexcept         void _Assign_rv_contents_with_alloc_always_equal(basic_string<_Elem, _Traits, _Alloc> &&_Right, std::false_type) noexcept         void _Construct_lv_contents(const basic_string<_Elem, _Traits, _Alloc> &_Right)         basic_string<_Elem, _Traits, _Alloc>(initializer_list<_Elem> _Ilist, const _Alloc &_Al = std::basic_string::allocator_type())         basic_string<_Elem, _Traits, _Alloc> &operator=(initializer_list<_Elem> _Ilist)         basic_string<_Elem, _Traits, _Alloc> &operator+=(initializer_list<_Elem> _Ilist)         basic_string<_Elem, _Traits, _Alloc> &assign(initializer_list<_Elem> _Ilist)         basic_string<_Elem, _Traits, _Alloc> &append(initializer_list<_Elem> _Ilist)         std::basic_string::iterator insert(const std::basic_string::const_iterator _Where, const initializer_list<_Elem> _Ilist)         basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last, const initializer_list<_Elem> _Ilist)         ~basic_string<_Elem, _Traits, _Alloc>() noexcept         static constexpr auto npos{static_cast<std::basic_string::size_type>(-1)};
        basic_string<_Elem, _Traits, _Alloc> &operator=(const basic_string<_Elem, _Traits, _Alloc> &_Right)         basic_string<_Elem, _Traits, _Alloc> &operator=(const _Elem *const _Ptr)         basic_string<_Elem, _Traits, _Alloc> &operator=(const _Elem _Ch)         basic_string<_Elem, _Traits, _Alloc> &operator+=(const basic_string<_Elem, _Traits, _Alloc> &_Right)         basic_string<_Elem, _Traits, _Alloc> &operator+=(const _Elem *const _Ptr)         basic_string<_Elem, _Traits, _Alloc> &operator+=(_Elem _Ch)         basic_string<_Elem, _Traits, _Alloc> &append(const basic_string<_Elem, _Traits, _Alloc> &_Right)         basic_string<_Elem, _Traits, _Alloc> &append(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Roff, std::basic_string::size_type _Count = npos)         basic_string<_Elem, _Traits, _Alloc> &append(const _Elem *const _Ptr, const std::basic_string::size_type _Count)         basic_string<_Elem, _Traits, _Alloc> &append(const _Elem *const _Ptr)         basic_string<_Elem, _Traits, _Alloc> &append(const std::basic_string::size_type _Count, const _Elem _Ch)         template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> basic_string<_Elem, _Traits, _Alloc> &append(const _Iter _First, const _Iter _Last)         basic_string<_Elem, _Traits, _Alloc> &assign(const basic_string<_Elem, _Traits, _Alloc> &_Right)         basic_string<_Elem, _Traits, _Alloc> &assign(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Roff, std::basic_string::size_type _Count = npos)         basic_string<_Elem, _Traits, _Alloc> &assign(const _Elem *const _Ptr, const std::basic_string::size_type _Count)         basic_string<_Elem, _Traits, _Alloc> &assign(const _Elem *const _Ptr)         basic_string<_Elem, _Traits, _Alloc> &assign(const std::basic_string::size_type _Count, const _Elem _Ch)         template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> basic_string<_Elem, _Traits, _Alloc> &assign(const _Iter _First, const _Iter _Last)         basic_string<_Elem, _Traits, _Alloc> &insert(const std::basic_string::size_type _Off, const basic_string<_Elem, _Traits, _Alloc> &_Right)         basic_string<_Elem, _Traits, _Alloc> &insert(const std::basic_string::size_type _Off, const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Roff, std::basic_string::size_type _Count = npos)         basic_string<_Elem, _Traits, _Alloc> &insert(const std::basic_string::size_type _Off, const _Elem *const _Ptr, const std::basic_string::size_type _Count)         basic_string<_Elem, _Traits, _Alloc> &insert(const std::basic_string::size_type _Off, const _Elem *const _Ptr)         basic_string<_Elem, _Traits, _Alloc> &insert(const std::basic_string::size_type _Off, const std::basic_string::size_type _Count, const _Elem _Ch)         std::basic_string::iterator insert(const std::basic_string::const_iterator _Where, const _Elem _Ch)         std::basic_string::iterator insert(const std::basic_string::const_iterator _Where, const std::basic_string::size_type _Count, const _Elem _Ch)         template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> std::basic_string::iterator insert(const std::basic_string::const_iterator _Where, const _Iter _First, const _Iter _Last)         basic_string<_Elem, _Traits, _Alloc> &erase(const std::basic_string::size_type _Off = 0)         basic_string<_Elem, _Traits, _Alloc> &erase(const std::basic_string::size_type _Off, std::basic_string::size_type _Count)         std::basic_string::iterator erase(const std::basic_string::const_iterator _Where)         std::basic_string::iterator erase(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last)         void clear() noexcept         basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::size_type _Off, const std::basic_string::size_type _N0, const basic_string<_Elem, _Traits, _Alloc> &_Right)         basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::size_type _Off, std::basic_string::size_type _N0, const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Roff, std::basic_string::size_type _Count = npos)         basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::size_type _Off, std::basic_string::size_type _N0, const _Elem *const _Ptr, const std::basic_string::size_type _Count)         basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::size_type _Off, const std::basic_string::size_type _N0, const _Elem *const _Ptr)         basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::size_type _Off, std::basic_string::size_type _N0, const std::basic_string::size_type _Count, const _Elem _Ch)         basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last, const basic_string<_Elem, _Traits, _Alloc> &_Right)         basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last, const _Elem *const _Ptr, const std::basic_string::size_type _Count)         basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last, const _Elem *const _Ptr)         basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last, const std::basic_string::size_type _Count, const _Elem _Ch)         template <class _Iter> basic_string<_Elem, _Traits, _Alloc> &_Replace_range(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last, const _Iter _First2, const _Iter _Last2, std::false_type)         template <class _Ptr> basic_string<_Elem, _Traits, _Alloc> &_Replace_range(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last, const _Ptr _First2, const _Ptr _Last2, std::true_type)         template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> basic_string<_Elem, _Traits, _Alloc> &replace(const std::basic_string::const_iterator _First, const std::basic_string::const_iterator _Last, const _Iter _First2, const _Iter _Last2)         std::basic_string::iterator begin() noexcept         std::basic_string::const_iterator begin() const noexcept         std::basic_string::iterator end() noexcept         std::basic_string::const_iterator end() const noexcept         _Elem *_Unchecked_begin() noexcept         const _Elem *_Unchecked_begin() const noexcept         _Elem *_Unchecked_end() noexcept         const _Elem *_Unchecked_end() const noexcept         std::basic_string::reverse_iterator rbegin() noexcept         std::basic_string::const_reverse_iterator rbegin() const noexcept         std::basic_string::reverse_iterator rend() noexcept         std::basic_string::const_reverse_iterator rend() const noexcept         std::basic_string::const_iterator cbegin() const noexcept         std::basic_string::const_iterator cend() const noexcept         std::basic_string::const_reverse_iterator crbegin() const noexcept         std::basic_string::const_reverse_iterator crend() const noexcept         void shrink_to_fit()         std::basic_string::reference at(const std::basic_string::size_type _Off)         std::basic_string::const_reference at(const std::basic_string::size_type _Off) const         std::basic_string::reference operator[](const std::basic_string::size_type _Off)         std::basic_string::const_reference operator[](const std::basic_string::size_type _Off) const         void push_back(const _Elem _Ch)         void pop_back()         std::basic_string::reference front()         std::basic_string::const_reference front() const         std::basic_string::reference back()         std::basic_string::const_reference back() const         const _Elem *c_str() const noexcept         {
            return (this->_Get_data()._Myptr());
        }
        const _Elem *data() const noexcept         std::basic_string::size_type length() const noexcept         std::basic_string::size_type size() const noexcept         std::basic_string::size_type max_size() const noexcept         void resize(const std::basic_string::size_type _Newsize, const _Elem _Ch = _Elem())         std::basic_string::size_type capacity() const noexcept         void reserve(const std::basic_string::size_type _Newcap = 0)         bool empty() const noexcept         std::basic_string::size_type copy(_Elem *const _Ptr, std::basic_string::size_type _Count, const std::basic_string::size_type _Off = 0) const         std::basic_string::size_type _Copy_s(_Elem *const _Dest, const std::basic_string::size_type _Dest_size, std::basic_string::size_type _Count, const std::basic_string::size_type _Off = 0) const         void _Swap_data(basic_string<_Elem, _Traits, _Alloc> &_Right, std::true_type)         void _Swap_bx_large_with_small(std::basic_string::_Mydata_t &_Starts_large, std::basic_string::_Mydata_t &_Starts_small)         void _Swap_data(basic_string<_Elem, _Traits, _Alloc> &_Right, std::false_type)         void swap(basic_string<_Elem, _Traits, _Alloc> &_Right) noexcept         std::basic_string::size_type find(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Off = 0) const noexcept         std::basic_string::size_type find(const _Elem *const _Ptr, const std::basic_string::size_type _Off, const std::basic_string::size_type _Count) const noexcept         std::basic_string::size_type find(const _Elem *const _Ptr, const std::basic_string::size_type _Off = 0) const noexcept         std::basic_string::size_type find(const _Elem _Ch, const std::basic_string::size_type _Off = 0) const noexcept         std::basic_string::size_type rfind(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Off = npos) const noexcept         std::basic_string::size_type rfind(const _Elem *const _Ptr, const std::basic_string::size_type _Off, const std::basic_string::size_type _Count) const noexcept         std::basic_string::size_type rfind(const _Elem *const _Ptr, const std::basic_string::size_type _Off = npos) const noexcept         std::basic_string::size_type rfind(const _Elem _Ch, const std::basic_string::size_type _Off = npos) const noexcept         std::basic_string::size_type find_first_of(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Off = 0) const noexcept         std::basic_string::size_type find_first_of(const _Elem *const _Ptr, const std::basic_string::size_type _Off, const std::basic_string::size_type _Count) const noexcept         std::basic_string::size_type find_first_of(const _Elem *const _Ptr, const std::basic_string::size_type _Off = 0) const noexcept         std::basic_string::size_type find_first_of(const _Elem _Ch, const std::basic_string::size_type _Off = 0) const noexcept         std::basic_string::size_type find_last_of(const basic_string<_Elem, _Traits, _Alloc> &_Right, std::basic_string::size_type _Off = npos) const noexcept         std::basic_string::size_type find_last_of(const _Elem *const _Ptr, const std::basic_string::size_type _Off, const std::basic_string::size_type _Count) const noexcept         std::basic_string::size_type find_last_of(const _Elem *const _Ptr, const std::basic_string::size_type _Off = npos) const noexcept         std::basic_string::size_type find_last_of(const _Elem _Ch, const std::basic_string::size_type _Off = npos) const noexcept         std::basic_string::size_type find_first_not_of(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Off = 0) const noexcept         std::basic_string::size_type find_first_not_of(const _Elem *const _Ptr, const std::basic_string::size_type _Off, const std::basic_string::size_type _Count) const noexcept         std::basic_string::size_type find_first_not_of(const _Elem *const _Ptr, std::basic_string::size_type _Off = 0) const noexcept         std::basic_string::size_type find_first_not_of(const _Elem _Ch, const std::basic_string::size_type _Off = 0) const noexcept         std::basic_string::size_type find_last_not_of(const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Off = npos) const noexcept         std::basic_string::size_type find_last_not_of(const _Elem *const _Ptr, const std::basic_string::size_type _Off, const std::basic_string::size_type _Count) const noexcept         std::basic_string::size_type find_last_not_of(const _Elem *const _Ptr, const std::basic_string::size_type _Off = npos) const noexcept         std::basic_string::size_type find_last_not_of(const _Elem _Ch, const std::basic_string::size_type _Off = npos) const noexcept         basic_string<_Elem, _Traits, _Alloc> substr(const std::basic_string::size_type _Off = 0, const std::basic_string::size_type _Count = npos) const         bool _Equal(const basic_string<_Elem, _Traits, _Alloc> &_Right) const noexcept         bool _Equal(const _Elem *const _Ptr) const noexcept         int compare(const basic_string<_Elem, _Traits, _Alloc> &_Right) const noexcept         int compare(std::basic_string::size_type _Off, std::basic_string::size_type _N0, const basic_string<_Elem, _Traits, _Alloc> &_Right) const         int compare(const std::basic_string::size_type _Off, const std::basic_string::size_type _N0, const basic_string<_Elem, _Traits, _Alloc> &_Right, const std::basic_string::size_type _Roff, const std::basic_string::size_type _Count = npos) const         int compare(const _Elem *const _Ptr) const noexcept         int compare(const std::basic_string::size_type _Off, const std::basic_string::size_type _N0, const _Elem *const _Ptr) const         int compare(const std::basic_string::size_type _Off, const std::basic_string::size_type _N0, const _Elem *const _Ptr, const std::basic_string::size_type _Count) const         std::basic_string::allocator_type get_allocator() const noexcept         std::basic_string::size_type _Calculate_growth(const std::basic_string::size_type _Requested) const         template <class _Fty, class ..._ArgTys> basic_string<_Elem, _Traits, _Alloc> &_Reallocate_for(const std::basic_string::size_type _New_size, _Fty _Fn, _ArgTys ..._Args)         template <class _Fty, class ..._ArgTys> basic_string<_Elem, _Traits, _Alloc> &_Reallocate_grow_by(const std::basic_string::size_type _Size_increase, _Fty _Fn, _ArgTys ..._Args)         void _Become_small()         void _Eos(const std::basic_string::size_type _Newsize)         void _Tidy_init()         void _Tidy_deallocate()         static void _Xlen() [[noreturn]]     };
template<> class basic_string<char, std::char_traits<char>, std::allocator<char>> : public _String_alloc<_String_base_types<char, std::allocator<char> > > {
    public:
        static_assert(!0 || is_same_v<char, typename allocator<char>::value_type>, "basic_string<T, Traits, Allocator> requires that Allocator's value_type match T (See N4659 26.2.1 [container.requirements.general]/16 allocator_type) Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0 to suppress this diagnostic.");
        static_assert(is_same_v<char, typename char_traits<char>::char_type>, "N4659 24.3.2.1 [string.require]/3 requires that the supplied char_traits character type match the string's character type.");
        using _Mybase = _String_alloc<_String_base_types<char, std::allocator<char> > >;
        using traits_type = std::char_traits<char>;
        using allocator_type = std::allocator<char>;
        using _Alty = typename _Mybase::_Alty;
        using _Alty_traits = typename _Mybase::_Alty_traits;
        using _Mydata_t = typename _Mybase::_Mydata_t;
        using value_type = typename _Mybase::value_type;
        using size_type = typename _Mybase::size_type;
        using difference_type = typename _Mybase::difference_type;
        using pointer = typename _Mybase::pointer;
        using const_pointer = typename _Mybase::const_pointer;
        using reference = std::basic_string<char, std::char_traits<char>, std::allocator<char> >::value_type &;
        using const_reference = const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::value_type &;
        using iterator = typename _Mybase::iterator;
        using const_iterator = typename _Mybase::const_iterator;
        using reverse_iterator = ::std::reverse_iterator<iterator>;
        using const_reverse_iterator = ::std::reverse_iterator<const_iterator>;
        using _Use_memcpy_move = bool_constant<_Is_specialization<char_traits<char>, char_traits>::value && is_trivial_v<std::basic_string<char, std::char_traits<char>, std::allocator<char> >::pointer> >;
        static constexpr size_t _Memcpy_move_offset = _Size_after_ebco_v;
        static constexpr size_t _Memcpy_move_size = sizeof(std::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Mydata_t) - _Memcpy_move_offset;
        template <class _Iter> using _Is_elem_cptr = _Disjunction_t<is_same<_Iter, const char *const>, is_same<_Iter, char *const>, is_same<_Iter, const char *>, is_same<_Iter, char *> >;
        basic_string(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        basic_string(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::allocator<char> &_Al);
        basic_string();
        explicit basic_string(const std::allocator<char> &_Al) noexcept;
        basic_string(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Roff, const std::allocator<char> &_Al);
        basic_string(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Roff, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const std::allocator<char> &_Al);
        basic_string(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        basic_string(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const std::allocator<char> &_Al);
        basic_string(const char *const _Ptr);
        basic_string(const char *const _Ptr, const std::allocator<char> &_Al);
        basic_string(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const char _Ch);
        basic_string(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const char _Ch, const std::allocator<char> &_Al);
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> basic_string(_Iter _First, _Iter _Last, const std::allocator<char> &_Al);
        template <class _Iter> void _Construct(_Iter _First, const _Iter _Last, std::input_iterator_tag);
        template <class _Iter> void _Construct(const _Iter _First, const _Iter _Last, std::forward_iterator_tag);
        void _Construct(char *const _First, char *const _Last, std::random_access_iterator_tag);
        void _Construct(const char *const _First, const char *const _Last, std::random_access_iterator_tag);
        basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &&_Right) noexcept;
        basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &&_Right, const std::allocator<char> &_Al);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator=(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &&_Right);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &assign(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &&_Right);
        void _Assign_rv_contents(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &&_Right, std::true_type) noexcept;
        void _Assign_rv_contents(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &&_Right, std::false_type);
        void _Assign_rv_contents_with_alloc_always_equal(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &&_Right, std::true_type) noexcept;
        void _Assign_rv_contents_with_alloc_always_equal(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &&_Right, std::false_type) noexcept;
        void _Construct_lv_contents(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        basic_string(initializer_list<char> _Ilist, const std::allocator<char> &_Al);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator=(initializer_list<char> _Ilist);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator+=(initializer_list<char> _Ilist);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &assign(initializer_list<char> _Ilist);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &append(initializer_list<char> _Ilist);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Where, const initializer_list<char> _Ilist);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last, const initializer_list<char> _Ilist);
        ~basic_string<char, char_traits<char>, allocator<char> >() noexcept;
        static constexpr auto npos{static_cast<std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type>(-1)};
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator=(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator=(const char *const _Ptr);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator=(const char _Ch);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator+=(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator+=(const char *const _Ptr);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &operator+=(char _Ch);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &append(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &append(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Roff, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &append(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &append(const char *const _Ptr);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &append(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const char _Ch);
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> std::basic_string<char, std::char_traits<char>, std::allocator<char> > &append(const _Iter _First, const _Iter _Last);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &assign(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &assign(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Roff, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &assign(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &assign(const char *const _Ptr);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &assign(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const char _Ch);
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> std::basic_string<char, std::char_traits<char>, std::allocator<char> > &assign(const _Iter _First, const _Iter _Last);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Roff, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const char *const _Ptr);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const char _Ch);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Where, const char _Ch);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Where, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const char _Ch);
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> std::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator insert(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Where, const _Iter _First, const _Iter _Last);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &erase(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &erase(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator erase(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Where);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator erase(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last);
        void clear() noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Roff, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const char *const _Ptr);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const char _Ch);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last, const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last, const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last, const char *const _Ptr);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const char _Ch);
        template <class _Iter> std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Replace_range(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last, const _Iter _First2, const _Iter _Last2, std::false_type);
        template <class _Ptr> std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Replace_range(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last, const _Ptr _First2, const _Ptr _Last2, std::true_type);
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> std::basic_string<char, std::char_traits<char>, std::allocator<char> > &replace(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _First, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator _Last, const _Iter _First2, const _Iter _Last2);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator begin() noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator begin() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator end() noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator end() const noexcept;
        char *_Unchecked_begin() noexcept;
        const char *_Unchecked_begin() const noexcept;
        char *_Unchecked_end() noexcept;
        const char *_Unchecked_end() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::reverse_iterator rbegin() noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reverse_iterator rbegin() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::reverse_iterator rend() noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reverse_iterator rend() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator cbegin() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator cend() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reverse_iterator crbegin() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reverse_iterator crend() const noexcept;
        void shrink_to_fit();
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::reference at(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reference at(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::reference operator[](const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reference operator[](const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const;
        void push_back(const char _Ch);
        void pop_back();
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::reference front();
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reference front() const;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::reference back();
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reference back() const;
        const char *c_str() const noexcept         {
            return (this->_Get_data()._Myptr());
        }
        const char *data() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type length() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type size() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type max_size() const noexcept;
        void resize(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Newsize, const char _Ch);
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type capacity() const noexcept;
        void reserve(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Newcap);
        bool empty() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type copy(char *const _Ptr, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Copy_s(char *const _Dest, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Dest_size, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const;
        void _Swap_data(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, std::true_type);
        void _Swap_bx_large_with_small(std::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Mydata_t &_Starts_large, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Mydata_t &_Starts_small);
        void _Swap_data(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, std::false_type);
        void swap(std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right) noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find(const char _Ch, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type rfind(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type rfind(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type rfind(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type rfind(const char _Ch, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_of(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_of(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_of(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_of(const char _Ch, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_of(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_of(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_of(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_of(const char _Ch, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_not_of(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_not_of(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_not_of(const char *const _Ptr, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_not_of(const char _Ch, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_not_of(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_not_of(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_not_of(const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_not_of(const char _Ch, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off) const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> > substr(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const;
        bool _Equal(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right) const noexcept;
        bool _Equal(const char *const _Ptr) const noexcept;
        int compare(const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right) const noexcept;
        int compare(std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right) const;
        int compare(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Right, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Roff, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const;
        int compare(const char *const _Ptr) const noexcept;
        int compare(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const char *const _Ptr) const;
        int compare(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Off, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _N0, const char *const _Ptr, const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Count) const;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::allocator_type get_allocator() const noexcept;
        std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Calculate_growth(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Requested) const;
        template <class _Fty, class ..._ArgTys> std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Reallocate_for(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _New_size, _Fty _Fn, _ArgTys ..._Args);
        template <class _Fty, class ..._ArgTys> std::basic_string<char, std::char_traits<char>, std::allocator<char> > &_Reallocate_grow_by(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Size_increase, _Fty _Fn, _ArgTys ..._Args);
        void _Become_small();
        void _Eos(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _Newsize);
        void _Tidy_init();
        void _Tidy_deallocate();
        static void _Xlen() [[noreturn]];
    };
    constexpr size_t _Size_after_ebco_v = is_empty_v<std::_Container_base0> ? 0 : sizeof(std::_Container_base0);
    template <class _Elem, class _Traits, class _Alloc> inline void swap(basic_string<_Elem, _Traits, _Alloc> &_Left, basic_string<_Elem, _Traits, _Alloc> &_Right) noexcept     template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(const basic_string<_Elem, _Traits, _Alloc> &_Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(const _Elem *const _Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(const _Elem _Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(const basic_string<_Elem, _Traits, _Alloc> &_Left, const _Elem *const _Right)     template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(const basic_string<_Elem, _Traits, _Alloc> &_Left, const _Elem _Right)     template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(const basic_string<_Elem, _Traits, _Alloc> &_Left, basic_string<_Elem, _Traits, _Alloc> &&_Right)     template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc> &&_Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc> &&_Left, basic_string<_Elem, _Traits, _Alloc> &&_Right)     template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(const _Elem *const _Left, basic_string<_Elem, _Traits, _Alloc> &&_Right)     template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(const _Elem _Left, basic_string<_Elem, _Traits, _Alloc> &&_Right)     template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc> &&_Left, const _Elem *const _Right)     template <class _Elem, class _Traits, class _Alloc> inline basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc> &&_Left, const _Elem _Right)     template <class _Elem, class _Traits, class _Alloc> inline bool operator==(const basic_string<_Elem, _Traits, _Alloc> &_Left, const basic_string<_Elem, _Traits, _Alloc> &_Right) noexcept     template <class _Elem, class _Traits, class _Alloc> inline bool operator==(const _Elem *const _Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     template <class _Elem, class _Traits, class _Alloc> inline bool operator==(const basic_string<_Elem, _Traits, _Alloc> &_Left, const _Elem *const _Right)     template <class _Elem, class _Traits, class _Alloc> inline bool operator!=(const basic_string<_Elem, _Traits, _Alloc> &_Left, const basic_string<_Elem, _Traits, _Alloc> &_Right) noexcept     template <class _Elem, class _Traits, class _Alloc> inline bool operator!=(const _Elem *const _Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     template <class _Elem, class _Traits, class _Alloc> inline bool operator!=(const basic_string<_Elem, _Traits, _Alloc> &_Left, const _Elem *const _Right)     template <class _Elem, class _Traits, class _Alloc> inline bool operator<(const basic_string<_Elem, _Traits, _Alloc> &_Left, const basic_string<_Elem, _Traits, _Alloc> &_Right) noexcept     template <class _Elem, class _Traits, class _Alloc> inline bool operator<(const _Elem *const _Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     template <class _Elem, class _Traits, class _Alloc> inline bool operator<(const basic_string<_Elem, _Traits, _Alloc> &_Left, const _Elem *const _Right)     template <class _Elem, class _Traits, class _Alloc> inline bool operator>(const basic_string<_Elem, _Traits, _Alloc> &_Left, const basic_string<_Elem, _Traits, _Alloc> &_Right) noexcept     template <class _Elem, class _Traits, class _Alloc> inline bool operator>(const _Elem *const _Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     template <class _Elem, class _Traits, class _Alloc> inline bool operator>(const basic_string<_Elem, _Traits, _Alloc> &_Left, const _Elem *const _Right)     template <class _Elem, class _Traits, class _Alloc> inline bool operator<=(const basic_string<_Elem, _Traits, _Alloc> &_Left, const basic_string<_Elem, _Traits, _Alloc> &_Right) noexcept     template <class _Elem, class _Traits, class _Alloc> inline bool operator<=(const _Elem *const _Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     template <class _Elem, class _Traits, class _Alloc> inline bool operator<=(const basic_string<_Elem, _Traits, _Alloc> &_Left, const _Elem *const _Right)     template <class _Elem, class _Traits, class _Alloc> inline bool operator>=(const basic_string<_Elem, _Traits, _Alloc> &_Left, const basic_string<_Elem, _Traits, _Alloc> &_Right) noexcept     template <class _Elem, class _Traits, class _Alloc> inline bool operator>=(const _Elem *const _Left, const basic_string<_Elem, _Traits, _Alloc> &_Right)     template <class _Elem, class _Traits, class _Alloc> inline bool operator>=(const basic_string<_Elem, _Traits, _Alloc> &_Left, const _Elem *const _Right)     using string = basic_string<char, char_traits<char>, allocator<char> >;
    using wstring = basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >;
    using u16string = basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >;
    using u32string = basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >;
    template <class _Elem, class _Traits, class _Alloc> struct hash<basic_string<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2>> {
        typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
        typedef size_t result_type;
        size_t operator()(const basic_string<_Elem, _Traits, _Alloc> &_Keyval) const noexcept     };
}
namespace std {
    class logic_error : public std::exception {
    public:
        typedef std::exception _Mybase;
        explicit logic_error(const std::string &_Message) : std::logic_error::_Mybase(_Message.c_str())         {
        }
        explicit logic_error(const char *_Message) : std::logic_error::_Mybase(_Message)         {
        }
    };
    class domain_error : public std::logic_error {
    public:
        typedef std::logic_error _Mybase;
        explicit domain_error(const std::string &_Message) : std::domain_error::_Mybase(_Message.c_str())         {
        }
        explicit domain_error(const char *_Message) : std::domain_error::_Mybase(_Message)         {
        }
    };
    class invalid_argument : public std::logic_error {
    public:
        typedef std::logic_error _Mybase;
        explicit invalid_argument(const std::string &_Message) : std::invalid_argument::_Mybase(_Message.c_str())         {
        }
        explicit invalid_argument(const char *_Message) : std::invalid_argument::_Mybase(_Message)         {
        }
    };
    class length_error : public std::logic_error {
    public:
        typedef std::logic_error _Mybase;
        explicit length_error(const std::string &_Message) : std::length_error::_Mybase(_Message.c_str())         {
        }
        explicit length_error(const char *_Message) : std::length_error::_Mybase(_Message)         {
        }
    };
    class out_of_range : public std::logic_error {
    public:
        typedef std::logic_error _Mybase;
        explicit out_of_range(const std::string &_Message) : std::out_of_range::_Mybase(_Message.c_str())         {
        }
        explicit out_of_range(const char *_Message) : std::out_of_range::_Mybase(_Message)         {
        }
    };
    class runtime_error : public std::exception {
    public:
        typedef std::exception _Mybase;
        explicit runtime_error(const std::string &_Message) : std::runtime_error::_Mybase(_Message.c_str())         {
        }
        explicit runtime_error(const char *_Message) : std::runtime_error::_Mybase(_Message)         {
        }
    };
    class overflow_error : public std::runtime_error {
    public:
        typedef std::runtime_error _Mybase;
        explicit overflow_error(const std::string &_Message) : std::overflow_error::_Mybase(_Message.c_str())         {
        }
        explicit overflow_error(const char *_Message) : std::overflow_error::_Mybase(_Message)         {
        }
    };
    class underflow_error : public std::runtime_error {
    public:
        typedef std::runtime_error _Mybase;
        explicit underflow_error(const std::string &_Message) : std::underflow_error::_Mybase(_Message.c_str())         {
        }
        explicit underflow_error(const char *_Message) : std::underflow_error::_Mybase(_Message)         {
        }
    };
    class range_error : public std::runtime_error {
    public:
        typedef std::runtime_error _Mybase;
        explicit range_error(const std::string &_Message) : std::range_error::_Mybase(_Message.c_str())         {
        }
        explicit range_error(const char *_Message) : std::range_error::_Mybase(_Message)         {
        }
    };
}
namespace std {
    template <class _Myvec> class _Vector_const_iterator : public std::_Iterator_base {
    public:
        using iterator_category = std::random_access_iterator_tag;
        using value_type = typename _Myvec::value_type;
        using difference_type = typename _Myvec::difference_type;
        using pointer = typename _Myvec::const_pointer;
        using reference = const std::_Vector_const_iterator::value_type &;
        using _Tptr = typename _Myvec::pointer;
        _Vector_const_iterator<_Myvec>()         _Vector_const_iterator<_Myvec>(std::_Vector_const_iterator::_Tptr _Parg, const std::_Container_base *_Pvector)         using _Unchecked_type = std::_Vector_const_iterator::pointer;
        std::_Vector_const_iterator::reference operator*() const         std::_Vector_const_iterator::pointer operator->() const         _Vector_const_iterator<_Myvec> &operator++()         _Vector_const_iterator<_Myvec> operator++(int)         _Vector_const_iterator<_Myvec> &operator--()         _Vector_const_iterator<_Myvec> operator--(int)         _Vector_const_iterator<_Myvec> &operator+=(std::_Vector_const_iterator::difference_type _Off)         _Vector_const_iterator<_Myvec> operator+(std::_Vector_const_iterator::difference_type _Off) const         _Vector_const_iterator<_Myvec> &operator-=(std::_Vector_const_iterator::difference_type _Off)         _Vector_const_iterator<_Myvec> operator-(std::_Vector_const_iterator::difference_type _Off) const         std::_Vector_const_iterator::difference_type operator-(const _Vector_const_iterator<_Myvec> &_Right) const         std::_Vector_const_iterator::reference operator[](std::_Vector_const_iterator::difference_type _Off) const         bool operator==(const _Vector_const_iterator<_Myvec> &_Right) const         bool operator!=(const _Vector_const_iterator<_Myvec> &_Right) const         bool operator<(const _Vector_const_iterator<_Myvec> &_Right) const         bool operator>(const _Vector_const_iterator<_Myvec> &_Right) const         bool operator<=(const _Vector_const_iterator<_Myvec> &_Right) const         bool operator>=(const _Vector_const_iterator<_Myvec> &_Right) const         void _Compat(const _Vector_const_iterator<_Myvec> &) const         std::_Vector_const_iterator::_Tptr _Ptr;
    };
    template <class _Myvec> inline _Vector_const_iterator<_Myvec> operator+(typename _Vector_const_iterator<_Myvec>::difference_type _Off, _Vector_const_iterator<_Myvec> _Next)     template <class _Myvec> inline _Vector_const_iterator<_Myvec> &_Rechecked(_Vector_const_iterator<_Myvec> &_Iter, const typename _Vector_const_iterator<_Myvec>::_Unchecked_type _Right)     template <class _Myvec> inline typename _Vector_const_iterator<_Myvec>::_Unchecked_type _Unchecked(const _Vector_const_iterator<_Myvec> &_Iter)     template <class _Myvec> class _Vector_iterator : public _Vector_const_iterator<_Myvec> {
    public:
        using _Mybase = _Vector_const_iterator<_Myvec>;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = typename _Myvec::value_type;
        using difference_type = typename _Myvec::difference_type;
        using pointer = typename _Myvec::pointer;
        using reference = std::_Vector_iterator::value_type &;
        _Vector_iterator<_Myvec>()         _Vector_iterator<_Myvec>(std::_Vector_iterator::pointer _Parg, const std::_Container_base *_Pvector)         using _Unchecked_type = std::_Vector_iterator::pointer;
        std::_Vector_iterator::reference operator*() const         std::_Vector_iterator::pointer operator->() const         _Vector_iterator<_Myvec> &operator++()         _Vector_iterator<_Myvec> operator++(int)         _Vector_iterator<_Myvec> &operator--()         _Vector_iterator<_Myvec> operator--(int)         _Vector_iterator<_Myvec> &operator+=(std::_Vector_iterator::difference_type _Off)         _Vector_iterator<_Myvec> operator+(std::_Vector_iterator::difference_type _Off) const         _Vector_iterator<_Myvec> &operator-=(std::_Vector_iterator::difference_type _Off)         _Vector_iterator<_Myvec> operator-(std::_Vector_iterator::difference_type _Off) const         std::_Vector_iterator::difference_type operator-(const std::_Vector_iterator::_Mybase &_Right) const         std::_Vector_iterator::reference operator[](std::_Vector_iterator::difference_type _Off) const     };
    template <class _Myvec> inline _Vector_iterator<_Myvec> operator+(typename _Vector_iterator<_Myvec>::difference_type _Off, _Vector_iterator<_Myvec> _Next)     template <class _Myvec> inline _Vector_iterator<_Myvec> &_Rechecked(_Vector_iterator<_Myvec> &_Iter, const typename _Vector_iterator<_Myvec>::_Unchecked_type _Right)     template <class _Myvec> inline typename _Vector_iterator<_Myvec>::_Unchecked_type _Unchecked(const _Vector_iterator<_Myvec> &_Iter)     template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer, class _Reference, class _Const_reference> struct _Vec_iter_types {
        using value_type = _Value_type;
        using size_type = _Size_type;
        using difference_type = _Difference_type;
        using pointer = _Pointer;
        using const_pointer = _Const_pointer;
    };
    template <class _Ty, class _Alloc> struct _Vec_base_types {
        using _Alty = _Rebind_alloc_t<_Alloc, _Ty>;
        using _Alty_traits = allocator_traits<std::_Vec_base_types::_Alty>;
        using _Val_types = conditional_t<_Is_simple_alloc_v<std::_Vec_base_types::_Alty>, _Simple_types<_Ty>, _Vec_iter_types<_Ty, typename _Alty_traits::size_type, typename _Alty_traits::difference_type, typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Ty &, const _Ty &> >;
    };
    template <class _Val_types> class _Vector_val : public std::_Container_base {
    public:
        using value_type = typename _Val_types::value_type;
        using size_type = typename _Val_types::size_type;
        using difference_type = typename _Val_types::difference_type;
        using pointer = typename _Val_types::pointer;
        using const_pointer = typename _Val_types::const_pointer;
        using reference = std::_Vector_val::value_type &;
        using const_reference = const std::_Vector_val::value_type &;
        _Vector_val<_Val_types>()         std::_Vector_val::pointer _Myfirst;
        std::_Vector_val::pointer _Mylast;
        std::_Vector_val::pointer _Myend;
    };
    template <class _Alloc_types> class _Vector_alloc {
    public:
        using _Alty = typename _Alloc_types::_Alty;
        using _Alty_traits = typename _Alloc_types::_Alty_traits;
        using _Alproxy = _Rebind_alloc_t<std::_Vector_alloc::_Alty, std::_Container_proxy>;
        using _Alproxy_traits = allocator_traits<std::_Vector_alloc::_Alproxy>;
        using _Val_types = typename _Alloc_types::_Val_types;
        using size_type = typename _Val_types::size_type;
        using difference_type = typename _Val_types::difference_type;
        using pointer = typename _Val_types::pointer;
        using const_pointer = typename _Val_types::const_pointer;
        using iterator = _Vector_iterator<_Vector_val<std::_Vector_alloc::_Val_types> >;
        using const_iterator = _Vector_const_iterator<_Vector_val<std::_Vector_alloc::_Val_types> >;
        _Vector_alloc<_Alloc_types>()         template <class _Any_alloc, class  = enable_if_t<!is_same_v<remove_cv_t<remove_reference_t<_Any_alloc> >, _Vector_alloc<_Alloc_types> > >> _Vector_alloc<_Alloc_types>(_Any_alloc &&_Al)         void _Copy_alloc(const std::_Vector_alloc::_Alty &_Al)         void _Move_alloc(std::_Vector_alloc::_Alty &_Al)         void _Orphan_all()         void _Swap_all(_Vector_alloc<_Alloc_types> &_Right)         std::_Vector_alloc::_Alty &_Getal() noexcept         const std::_Vector_alloc::_Alty &_Getal() const noexcept         _Vector_val<std::_Vector_alloc::_Val_types> &_Get_data() noexcept         const _Vector_val<std::_Vector_alloc::_Val_types> &_Get_data() const noexcept         std::_Vector_alloc::iterator _Make_iterator(const std::_Vector_alloc::pointer _Ptr) noexcept         std::_Vector_alloc::iterator _Make_iterator_offset(const std::_Vector_alloc::size_type _Offset) noexcept         std::_Vector_alloc::pointer &_Myfirst() noexcept         const std::_Vector_alloc::pointer &_Myfirst() const noexcept         std::_Vector_alloc::pointer &_Mylast() noexcept         const std::_Vector_alloc::pointer &_Mylast() const noexcept         std::_Vector_alloc::pointer &_Myend() noexcept         const std::_Vector_alloc::pointer &_Myend() const noexcept     private:
        _Compressed_pair<std::_Vector_alloc::_Alty, _Vector_val<std::_Vector_alloc::_Val_types> > _Mypair;
    };
    template <class _Ptrty> inline auto _Unfancy_maybe_null(_Ptrty _Ptr)     {
        return (_Ptr ? ::std::addressof(*_Ptr) : nullptr);
    }
    template <class _Ty> inline _Ty *_Unfancy_maybe_null(_Ty *_Ptr)     template <class _Ty, class _Alloc = allocator<_Ty>> class vector : public _Vector_alloc<_Vec_base_types<_Ty, _Alloc> > {
    private:
        using _Mybase = _Vector_alloc<_Vec_base_types<_Ty, _Alloc> >;
        using _Alty = typename _Mybase::_Alty;
        using _Alty_traits = typename _Mybase::_Alty_traits;
    public:
        static_assert(!0 || is_same_v<_Ty, typename _Alloc::value_type>, "vector<T, Allocator> requires that Allocator's value_type match T (See N4659 26.2.1 [container.requirements.general]/16 allocator_type) Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0 to suppress this diagnostic.");
        using value_type = _Ty;
        using allocator_type = _Alloc;
        using pointer = typename _Mybase::pointer;
        using const_pointer = typename _Mybase::const_pointer;
        using reference = _Ty &;
        using const_reference = const _Ty &;
        using size_type = typename _Mybase::size_type;
        using difference_type = typename _Mybase::difference_type;
        using iterator = typename _Mybase::iterator;
        using const_iterator = typename _Mybase::const_iterator;
        using reverse_iterator = ::std::reverse_iterator<iterator>;
        using const_reverse_iterator = ::std::reverse_iterator<const_iterator>;
        vector<_Ty, _Alloc>() noexcept(is_nothrow_default_constructible_v<std::vector::_Alty>vector<_Ty, _Alloc>() noexcept(is_nothrow_default_constructible_v<std::vector::_Alty>)         explicit vector<_Ty, _Alloc>(const _Alloc &_Al) noexcept         explicit vector<_Ty, _Alloc>(const std::vector::size_type _Count, const _Alloc &_Al = _Alloc())         vector<_Ty, _Alloc>(const std::vector::size_type _Count, const _Ty &_Val, const _Alloc &_Al = _Alloc())     private:
        template <class _Iter> void _Range_construct_or_tidy(_Iter _First, _Iter _Last, std::input_iterator_tag)         template <class _Iter> void _Range_construct_or_tidy(_Iter _First, _Iter _Last, std::forward_iterator_tag)     public:
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> vector<_Ty, _Alloc>(_Iter _First, _Iter _Last, const _Alloc &_Al = _Alloc())         vector<_Ty, _Alloc>(initializer_list<_Ty> _Ilist, const _Alloc &_Al = _Alloc())         vector<_Ty, _Alloc>(const vector<_Ty, _Alloc> &_Right)         vector<_Ty, _Alloc>(const vector<_Ty, _Alloc> &_Right, const _Alloc &_Al)     private:
        void _Move_from(vector<_Ty, _Alloc> &&_Right, std::true_type) noexcept         void _Move_from(vector<_Ty, _Alloc> &&_Right, std::false_type)     public:
        vector<_Ty, _Alloc>(vector<_Ty, _Alloc> &&_Right) noexcept         vector<_Ty, _Alloc>(vector<_Ty, _Alloc> &&_Right, const _Alloc &_Al) noexcept(_Alty_traits::is_always_equal::valuevector<_Ty, _Alloc>(vector<_Ty, _Alloc> &&_Right, const _Alloc &_Al) noexcept(_Alty_traits::is_always_equal::value)     private:
        void _Move_assign_from(vector<_Ty, _Alloc> &&_Right, std::true_type) noexcept         void _Move_assign_from(vector<_Ty, _Alloc> &&_Right, std::false_type)     public:
        vector<_Ty, _Alloc> &operator=(vector<_Ty, _Alloc> &&_Right) noexcept(_Always_equal_after_move<std::vector::_Alty>operator=(vector<_Ty, _Alloc> &&_Right) noexcept(_Always_equal_after_move<std::vector::_Alty>)         ~vector<_Ty, _Alloc>() noexcept     private:
        template <class ..._Valty> decltype(auto) _Emplace_back_with_unused_capacity(_Valty &&..._Val)         {
            _Alty_traits::construct(this->_Getal(), _Unfancy(this->_Mylast()), ::std::forward<_Valty>(_Val)...);
            this->_Orphan_range(this->_Mylast(), this->_Mylast());
            _Ty &_Result = *this->_Mylast();
            ++this->_Mylast();
            (void)_Result;
        }
    public:
        template <class ..._Valty> decltype(auto) emplace_back(_Valty &&..._Val)         {
            if (this->_Has_unused_capacity()) {
                return (_Emplace_back_with_unused_capacity(::std::forward<_Valty>(_Val)...));
            }
            _Ty &_Result = *_Emplace_reallocate(this->_Mylast(), ::std::forward<_Valty>(_Val)...);
            (void)_Result;
        }
        void push_back(const _Ty &_Val)         void push_back(_Ty &&_Val)         template <class ..._Valty> std::vector::pointer _Emplace_reallocate(const std::vector::pointer _Whereptr, _Valty &&..._Val)         template <class ..._Valty> std::vector::iterator emplace(std::vector::const_iterator _Where, _Valty &&..._Val)         std::vector::iterator insert(std::vector::const_iterator _Where, const _Ty &_Val)         std::vector::iterator insert(std::vector::const_iterator _Where, _Ty &&_Val)         std::vector::iterator insert(std::vector::const_iterator _Where, const std::vector::size_type _Count, const _Ty &_Val)     private:
        template <class _Iter> void _Insert_range(std::vector::const_iterator _Where, _Iter _First, _Iter _Last, std::input_iterator_tag)         template <class _Iter> void _Insert_range(std::vector::const_iterator _Where, _Iter _First, _Iter _Last, std::forward_iterator_tag)     public:
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> std::vector::iterator insert(std::vector::const_iterator _Where, _Iter _First, _Iter _Last)         std::vector::iterator insert(std::vector::const_iterator _Where, initializer_list<_Ty> _Ilist)         void assign(const std::vector::size_type _Newsize, const _Ty &_Val)     private:
        template <class _Iter> void _Assign_range(_Iter _First, _Iter _Last, std::input_iterator_tag)         template <class _Iter> void _Assign_range(_Iter _First, _Iter _Last, std::forward_iterator_tag)     public:
        template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> void assign(_Iter _First, _Iter _Last)         void assign(initializer_list<_Ty> _Ilist)         vector<_Ty, _Alloc> &operator=(const vector<_Ty, _Alloc> &_Right)         vector<_Ty, _Alloc> &operator=(initializer_list<_Ty> _Ilist)     private:
        template <class _Lambda> void _Resize(const std::vector::size_type _Newsize, _Lambda _Udefault_or_fill)     public:
        void resize(const std::vector::size_type _Newsize)         void resize(const std::vector::size_type _Newsize, const _Ty &_Val)     private:
        void _Reallocate_exactly(const std::vector::size_type _Newcapacity)     public:
        void reserve(const std::vector::size_type _Newcapacity)         void shrink_to_fit()         void pop_back()         std::vector::iterator erase(std::vector::const_iterator _Where)         std::vector::iterator erase(std::vector::const_iterator _First, std::vector::const_iterator _Last)         void clear() noexcept         void swap(vector<_Ty, _Alloc> &_Right) noexcept         _Ty *data() noexcept         const _Ty *data() const noexcept         std::vector::iterator begin() noexcept         std::vector::const_iterator begin() const noexcept         std::vector::iterator end() noexcept         std::vector::const_iterator end() const noexcept         std::vector::reverse_iterator rbegin() noexcept         std::vector::const_reverse_iterator rbegin() const noexcept         std::vector::reverse_iterator rend() noexcept         std::vector::const_reverse_iterator rend() const noexcept         std::vector::const_iterator cbegin() const noexcept         std::vector::const_iterator cend() const noexcept         std::vector::const_reverse_iterator crbegin() const noexcept         std::vector::const_reverse_iterator crend() const noexcept         std::vector::pointer _Unchecked_begin() noexcept         std::vector::const_pointer _Unchecked_begin() const noexcept         std::vector::pointer _Unchecked_end() noexcept         std::vector::const_pointer _Unchecked_end() const noexcept         bool empty() const noexcept         std::vector::size_type size() const noexcept         std::vector::size_type max_size() const noexcept         std::vector::size_type capacity() const noexcept     private:
        std::vector::size_type _Unused_capacity() const noexcept         bool _Has_unused_capacity() const noexcept     public:
        _Ty &operator[](const std::vector::size_type _Pos)         const _Ty &operator[](const std::vector::size_type _Pos) const         _Ty &at(const std::vector::size_type _Pos)         const _Ty &at(const std::vector::size_type _Pos) const         _Ty &front()         const _Ty &front() const         _Ty &back()         const _Ty &back() const         std::vector::allocator_type get_allocator() const noexcept     private:
        std::vector::pointer _Udefault(std::vector::pointer _Dest, const std::vector::size_type _Count)         std::vector::pointer _Ufill(std::vector::pointer _Dest, const std::vector::size_type _Count, const _Ty &_Val)         template <class _Iter> std::vector::pointer _Ucopy(_Iter _First, _Iter _Last, std::vector::pointer _Dest)         std::vector::pointer _Umove(std::vector::pointer _First, std::vector::pointer _Last, std::vector::pointer _Dest)         void _Umove_if_noexcept1(std::vector::pointer _First, std::vector::pointer _Last, std::vector::pointer _Dest, std::true_type)         void _Umove_if_noexcept1(std::vector::pointer _First, std::vector::pointer _Last, std::vector::pointer _Dest, std::false_type)         void _Umove_if_noexcept(std::vector::pointer _First, std::vector::pointer _Last, std::vector::pointer _Dest)         void _Destroy(std::vector::pointer _First, std::vector::pointer _Last)         std::vector::size_type _Calculate_growth(const std::vector::size_type _Newsize) const         bool _Buy(const std::vector::size_type _Newcapacity)         void _Change_array(const std::vector::pointer _Newvec, const std::vector::size_type _Newsize, const std::vector::size_type _Newcapacity)         void _Tidy()         static void _Xlength() [[noreturn]]         static void _Xrange() [[noreturn]]         void _Orphan_range(std::vector::pointer, std::vector::pointer) const     };
    template <class _Ty, class _Alloc> inline void swap(vector<_Ty, _Alloc> &_Left, vector<_Ty, _Alloc> &_Right) noexcept     template <class _Ty, class _Alloc> inline bool operator==(const vector<_Ty, _Alloc> &_Left, const vector<_Ty, _Alloc> &_Right)     template <class _Ty, class _Alloc> inline bool operator!=(const vector<_Ty, _Alloc> &_Left, const vector<_Ty, _Alloc> &_Right)     template <class _Ty, class _Alloc> inline bool operator<(const vector<_Ty, _Alloc> &_Left, const vector<_Ty, _Alloc> &_Right)     template <class _Ty, class _Alloc> inline bool operator>(const vector<_Ty, _Alloc> &_Left, const vector<_Ty, _Alloc> &_Right)     template <class _Ty, class _Alloc> inline bool operator<=(const vector<_Ty, _Alloc> &_Left, const vector<_Ty, _Alloc> &_Right)     template <class _Ty, class _Alloc> inline bool operator>=(const vector<_Ty, _Alloc> &_Left, const vector<_Ty, _Alloc> &_Right)     using _Vbase = unsigned int;
    constexpr int _VBITS = 8 * sizeof(std::_Vbase);
    template <class _Alloc0> struct _Wrap_alloc {
        using _Alloc = _Alloc0;
    };
    template <class _Alvbase_wrapped> class _Vb_iter_base : public std::_Iterator_base {
    public:
        using _Alvbase = typename _Alvbase_wrapped::_Alloc;
        using _Sizet = typename allocator_traits<_Alvbase>::size_type;
        using _Difft = typename allocator_traits<_Alvbase>::difference_type;
        using _Mycont = vector<bool, _Rebind_alloc_t<std::_Vb_iter_base::_Alvbase, bool> >;
        _Vb_iter_base<_Alvbase_wrapped>()         _Vb_iter_base<_Alvbase_wrapped>(const std::_Vbase *_Ptr, std::_Vb_iter_base::_Sizet _Off, const std::_Container_base *_Mypvbool)         void _Advance(std::_Vb_iter_base::_Sizet _Off)         int _Valid(std::_Vb_iter_base::_Sizet _Inc) const         const std::_Vbase *_Myptr;
        std::_Vb_iter_base::_Sizet _Myoff;
    };
    template <class _Alvbase_wrapped> class _Vb_reference : public _Vb_iter_base<_Alvbase_wrapped> {
        using _Mybase = _Vb_iter_base<_Alvbase_wrapped>;
        _Vb_reference<_Alvbase_wrapped>() noexcept     public:
        _Vb_reference<_Alvbase_wrapped>(const std::_Vb_reference::_Mybase &_Right)         _Vb_reference<_Alvbase_wrapped> &operator=(const _Vb_reference<_Alvbase_wrapped> &_Right) noexcept         _Vb_reference<_Alvbase_wrapped> &operator=(bool _Val) noexcept         void flip() noexcept         operator bool() const noexcept         const std::_Vbase *_Getptr() const     protected:
        std::_Vbase _Mask() const     };
    template <class _Alvbase_wrapped> inline void swap(_Vb_reference<_Alvbase_wrapped> _Left, _Vb_reference<_Alvbase_wrapped> _Right) noexcept     template <class _Alvbase_wrapped> class _Vb_const_iterator : public _Vb_iter_base<_Alvbase_wrapped> {
    private:
        using _Mybase = _Vb_iter_base<_Alvbase_wrapped>;
        using _Size_type = typename _Mybase::_Sizet;
    public:
        using _Reft = _Vb_reference<_Alvbase_wrapped>;
        using const_reference = bool;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = bool;
        using difference_type = typename _Mybase::_Difft;
        using pointer = std::_Vb_const_iterator::const_reference *;
        using reference = std::_Vb_const_iterator::const_reference;
        _Vb_const_iterator<_Alvbase_wrapped>()         _Vb_const_iterator<_Alvbase_wrapped>(const std::_Vbase *_Ptr, const std::_Container_base *_Mypvbool)         std::_Vb_const_iterator::const_reference operator*() const         _Vb_const_iterator<_Alvbase_wrapped> &operator++()         _Vb_const_iterator<_Alvbase_wrapped> operator++(int)         _Vb_const_iterator<_Alvbase_wrapped> &operator--()         _Vb_const_iterator<_Alvbase_wrapped> operator--(int)         _Vb_const_iterator<_Alvbase_wrapped> &operator+=(std::_Vb_const_iterator::difference_type _Off)         _Vb_const_iterator<_Alvbase_wrapped> operator+(std::_Vb_const_iterator::difference_type _Off) const         _Vb_const_iterator<_Alvbase_wrapped> &operator-=(std::_Vb_const_iterator::difference_type _Off)         _Vb_const_iterator<_Alvbase_wrapped> operator-(std::_Vb_const_iterator::difference_type _Off) const         std::_Vb_const_iterator::difference_type operator-(const _Vb_const_iterator<_Alvbase_wrapped> &_Right) const         std::_Vb_const_iterator::const_reference operator[](std::_Vb_const_iterator::difference_type _Off) const         bool operator==(const _Vb_const_iterator<_Alvbase_wrapped> &_Right) const         bool operator!=(const _Vb_const_iterator<_Alvbase_wrapped> &_Right) const         bool operator<(const _Vb_const_iterator<_Alvbase_wrapped> &_Right) const         bool operator>(const _Vb_const_iterator<_Alvbase_wrapped> &_Right) const         bool operator<=(const _Vb_const_iterator<_Alvbase_wrapped> &_Right) const         bool operator>=(const _Vb_const_iterator<_Alvbase_wrapped> &_Right) const         void _Compat(const _Vb_const_iterator<_Alvbase_wrapped> &) const         void _Dec()         void _Inc()     };
    template <class _Alvbase_wrapped> _Vb_const_iterator<_Alvbase_wrapped> operator+(typename _Vb_const_iterator<_Alvbase_wrapped>::difference_type _Off, _Vb_const_iterator<_Alvbase_wrapped> _Right)     template <class _Alvbase_wrapped> struct _Is_checked_helper<_Vb_const_iterator<type-parameter-0-0>, void> : public std::true_type {
    };
    template <class _Alvbase_wrapped> class _Vb_iterator : public _Vb_const_iterator<_Alvbase_wrapped> {
    public:
        using _Mybase = _Vb_const_iterator<_Alvbase_wrapped>;
        using _Reft = _Vb_reference<_Alvbase_wrapped>;
        using const_reference = bool;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = bool;
        using difference_type = typename _Mybase::difference_type;
        using pointer = std::_Vb_iterator::_Reft *;
        using reference = std::_Vb_iterator::_Reft;
        _Vb_iterator<_Alvbase_wrapped>()         _Vb_iterator<_Alvbase_wrapped>(std::_Vbase *_Ptr, std::_Container_base *_Mypvbool)         std::_Vb_iterator::reference operator*() const         _Vb_iterator<_Alvbase_wrapped> &operator++()         _Vb_iterator<_Alvbase_wrapped> operator++(int)         _Vb_iterator<_Alvbase_wrapped> &operator--()         _Vb_iterator<_Alvbase_wrapped> operator--(int)         _Vb_iterator<_Alvbase_wrapped> &operator+=(std::_Vb_iterator::difference_type _Off)         _Vb_iterator<_Alvbase_wrapped> operator+(std::_Vb_iterator::difference_type _Off) const         _Vb_iterator<_Alvbase_wrapped> &operator-=(std::_Vb_iterator::difference_type _Off)         _Vb_iterator<_Alvbase_wrapped> operator-(std::_Vb_iterator::difference_type _Off) const         std::_Vb_iterator::difference_type operator-(const std::_Vb_iterator::_Mybase &_Right) const         std::_Vb_iterator::reference operator[](std::_Vb_iterator::difference_type _Off) const     };
    template <class _Alvbase_wrapped> inline _Vb_iterator<_Alvbase_wrapped> operator+(typename _Vb_iterator<_Alvbase_wrapped>::difference_type _Off, _Vb_iterator<_Alvbase_wrapped> _Right)     template <class _Alvbase_wrapped> struct _Is_checked_helper<_Vb_iterator<type-parameter-0-0>, void> : public std::true_type {
    };
    template <class _Alloc> class _Vb_val : public std::_Container_base {
    public:
        using _Alproxy = _Rebind_alloc_t<_Alloc, std::_Container_proxy>;
        using _Alproxy_traits = allocator_traits<std::_Vb_val::_Alproxy>;
        using _Alvbase = _Rebind_alloc_t<_Alloc, std::_Vbase>;
        using _Alvbase_traits = allocator_traits<std::_Vb_val::_Alvbase>;
        using _Vectype = vector<std::_Vbase, std::_Vb_val::_Alvbase>;
        using _Alvbase_wrapped = _Wrap_alloc<std::_Vb_val::_Alvbase>;
        using size_type = typename _Alvbase_traits::size_type;
        _Vb_val<_Alloc>() noexcept(is_nothrow_default_constructible_v<std::_Vb_val::_Vectype>_Vb_val<_Alloc>() noexcept(is_nothrow_default_constructible_v<std::_Vb_val::_Vectype>)         _Vb_val<_Alloc>(const _Alloc &_Al) noexcept(is_nothrow_constructible_v<std::_Vb_val::_Vectype, std::_Vb_val::_Alvbase>_Vb_val<_Alloc>(const _Alloc &_Al) noexcept(is_nothrow_constructible_v<std::_Vb_val::_Vectype, std::_Vb_val::_Alvbase>)         _Vb_val<_Alloc>(std::_Vb_val::size_type _Count, const bool &_Val)         _Vb_val<_Alloc>(std::_Vb_val::size_type _Count, const bool &_Val, const _Alloc &_Al)         _Vb_val<_Alloc>(const _Vb_val<_Alloc> &_Right)         _Vb_val<_Alloc>(const _Vb_val<_Alloc> &_Right, const _Alloc &_Al)         _Vb_val<_Alloc>(_Vb_val<_Alloc> &&_Right) noexcept(is_nothrow_move_constructible_v<std::_Vb_val::_Vectype>_Vb_val<_Alloc>(_Vb_val<_Alloc> &&_Right) noexcept(is_nothrow_move_constructible_v<std::_Vb_val::_Vectype>)         _Vb_val<_Alloc>(_Vb_val<_Alloc> &&_Right, const _Alloc &_Al) noexcept(is_nothrow_constructible_v<std::_Vb_val::_Vectype, std::_Vb_val::_Vectype, std::_Vb_val::_Alvbase>_Vb_val<_Alloc>(_Vb_val<_Alloc> &&_Right, const _Alloc &_Al) noexcept(is_nothrow_constructible_v<std::_Vb_val::_Vectype, std::_Vb_val::_Vectype, std::_Vb_val::_Alvbase>)         ~_Vb_val<_Alloc>() noexcept         void _Alloc_proxy()         void _Free_proxy()         static std::_Vb_val::size_type _Nw(std::_Vb_val::size_type _Count)         std::_Vb_val::_Vectype _Myvec;
        std::_Vb_val::size_type _Mysize;
    };
    template <class _Alloc> class vector<bool, _Alloc> : public _Vb_val<_Alloc> {
    public:
        static_assert(!0 || is_same_v<bool, typename _Alloc::value_type>, "vector<bool, Allocator> requires that Allocator's value_type match bool (See N4659 26.2.1 [container.requirements.general]/16 allocator_type) Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0 to suppress this diagnostic.");
        using _Mybase = _Vb_val<_Alloc>;
        using _Alvbase_wrapped = typename _Mybase::_Alvbase_wrapped;
        using _Alvbase = typename _Mybase::_Alvbase;
        using _Alvbase_traits = typename _Mybase::_Alvbase_traits;
        using size_type = typename _Alvbase_traits::size_type;
        using difference_type = typename _Alvbase_traits::difference_type;
        using allocator_type = _Alloc;
        using reference = _Vb_reference<std::vector<bool, type-parameter-0-0>::_Alvbase_wrapped>;
        using const_reference = bool;
        using value_type = bool;
        using _Reft = std::vector<bool, type-parameter-0-0>::reference;
        using iterator = _Vb_iterator<std::vector<bool, type-parameter-0-0>::_Alvbase_wrapped>;
        using const_iterator = _Vb_const_iterator<std::vector<bool, type-parameter-0-0>::_Alvbase_wrapped>;
        using pointer = std::vector<bool, type-parameter-0-0>::iterator;
        using const_pointer = std::vector<bool, type-parameter-0-0>::const_iterator;
        using reverse_iterator = ::std::reverse_iterator<iterator>;
        using const_reverse_iterator = ::std::reverse_iterator<const_iterator>;
        static const int _VBITS = ::std::_VBITS;
        enum  {
            _EEN_VBITS = _VBITS
        };
        vector<bool, type-parameter-0-0>() noexcept(is_nothrow_default_constructible_v<std::vector<bool, type-parameter-0-0>::_Mybase>vector<bool, type-parameter-0-0>() noexcept(is_nothrow_default_constructible_v<std::vector<bool, type-parameter-0-0>::_Mybase>)         explicit vector<bool, type-parameter-0-0>(const _Alloc &_Al) noexcept(is_nothrow_constructible_v<std::vector<bool, type-parameter-0-0>::_Mybase, const _Alloc &>vector<bool, type-parameter-0-0>(const _Alloc &_Al) noexcept(is_nothrow_constructible_v<std::vector<bool, type-parameter-0-0>::_Mybase, const _Alloc &>)         explicit vector<bool, type-parameter-0-0>(std::vector<bool, type-parameter-0-0>::size_type _Count, const _Alloc &_Al = _Alloc())         vector<bool, type-parameter-0-0>(std::vector<bool, type-parameter-0-0>::size_type _Count, const bool &_Val, const _Alloc &_Al = _Alloc())         vector<bool, type-parameter-0-0>(const vector<bool, type-parameter-0-0> &_Right)         vector<bool, type-parameter-0-0>(const vector<bool, type-parameter-0-0> &_Right, const _Alloc &_Al)         template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> vector<bool, type-parameter-0-0>(_Iter _First, _Iter _Last, const _Alloc &_Al = _Alloc())         template <class _Iter> void _BConstruct(_Iter _First, _Iter _Last)         vector<bool, type-parameter-0-0>(vector<bool, type-parameter-0-0> &&_Right) noexcept(is_nothrow_move_constructible_v<std::vector<bool, type-parameter-0-0>::_Mybase>vector<bool, type-parameter-0-0>(vector<bool, type-parameter-0-0> &&_Right) noexcept(is_nothrow_move_constructible_v<std::vector<bool, type-parameter-0-0>::_Mybase>)         vector<bool, type-parameter-0-0>(vector<bool, type-parameter-0-0> &&_Right, const _Alloc &_Al) noexcept(is_nothrow_constructible_v<std::vector<bool, type-parameter-0-0>::_Mybase, std::vector<bool, type-parameter-0-0>::_Mybase, const _Alloc &>vector<bool, type-parameter-0-0>(vector<bool, type-parameter-0-0> &&_Right, const _Alloc &_Al) noexcept(is_nothrow_constructible_v<std::vector<bool, type-parameter-0-0>::_Mybase, std::vector<bool, type-parameter-0-0>::_Mybase, const _Alloc &>)         vector<bool, type-parameter-0-0> &operator=(vector<bool, type-parameter-0-0> &&_Right) noexcept(is_nothrow_move_assignable_v<std::vector<bool, type-parameter-0-0>::_Mybase>operator=(vector<bool, type-parameter-0-0> &&_Right) noexcept(is_nothrow_move_assignable_v<std::vector<bool, type-parameter-0-0>::_Mybase>)         template <class ..._Valty> decltype(auto) emplace_back(_Valty &&..._Val)         {
            bool _Tmp(::std::forward<_Valty>(_Val)...);
            this->push_back(_Tmp);
        }
        template <class ..._Valty> std::vector<bool, type-parameter-0-0>::iterator emplace(std::vector<bool, type-parameter-0-0>::const_iterator _Where, _Valty &&..._Val)         vector<bool, type-parameter-0-0>(initializer_list<bool> _Ilist, const _Alloc &_Al = std::vector<bool, type-parameter-0-0>::allocator_type())         vector<bool, type-parameter-0-0> &operator=(initializer_list<bool> _Ilist)         void assign(initializer_list<bool> _Ilist)         std::vector<bool, type-parameter-0-0>::iterator insert(std::vector<bool, type-parameter-0-0>::const_iterator _Where, initializer_list<bool> _Ilist)         ~vector<bool, type-parameter-0-0>() noexcept         vector<bool, type-parameter-0-0> &operator=(const vector<bool, type-parameter-0-0> &_Right)         void reserve(std::vector<bool, type-parameter-0-0>::size_type _Count)         std::vector<bool, type-parameter-0-0>::size_type capacity() const noexcept         std::vector<bool, type-parameter-0-0>::iterator begin() noexcept         std::vector<bool, type-parameter-0-0>::const_iterator begin() const noexcept         std::vector<bool, type-parameter-0-0>::iterator end() noexcept         std::vector<bool, type-parameter-0-0>::const_iterator end() const noexcept         std::vector<bool, type-parameter-0-0>::const_iterator cbegin() const noexcept         std::vector<bool, type-parameter-0-0>::const_iterator cend() const noexcept         std::vector<bool, type-parameter-0-0>::const_reverse_iterator crbegin() const noexcept         std::vector<bool, type-parameter-0-0>::const_reverse_iterator crend() const noexcept         void shrink_to_fit()         std::vector<bool, type-parameter-0-0>::iterator _Make_iter(std::vector<bool, type-parameter-0-0>::const_iterator _Where)         std::vector<bool, type-parameter-0-0>::reverse_iterator rbegin() noexcept         std::vector<bool, type-parameter-0-0>::const_reverse_iterator rbegin() const noexcept         std::vector<bool, type-parameter-0-0>::reverse_iterator rend() noexcept         std::vector<bool, type-parameter-0-0>::const_reverse_iterator rend() const noexcept         void resize(std::vector<bool, type-parameter-0-0>::size_type _Newsize, bool _Val = false)         std::vector<bool, type-parameter-0-0>::size_type size() const noexcept         std::vector<bool, type-parameter-0-0>::size_type max_size() const noexcept         bool empty() const noexcept         std::vector<bool, type-parameter-0-0>::allocator_type get_allocator() const noexcept         std::vector<bool, type-parameter-0-0>::const_reference at(std::vector<bool, type-parameter-0-0>::size_type _Off) const         std::vector<bool, type-parameter-0-0>::reference at(std::vector<bool, type-parameter-0-0>::size_type _Off)         std::vector<bool, type-parameter-0-0>::const_reference operator[](std::vector<bool, type-parameter-0-0>::size_type _Off) const         std::vector<bool, type-parameter-0-0>::reference operator[](std::vector<bool, type-parameter-0-0>::size_type _Off)         std::vector<bool, type-parameter-0-0>::reference front()         std::vector<bool, type-parameter-0-0>::const_reference front() const         std::vector<bool, type-parameter-0-0>::reference back()         std::vector<bool, type-parameter-0-0>::const_reference back() const         void push_back(const bool &_Val)         void pop_back()         template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> void assign(_Iter _First, _Iter _Last)         void assign(std::vector<bool, type-parameter-0-0>::size_type _Count, const bool &_Val)         std::vector<bool, type-parameter-0-0>::iterator insert(std::vector<bool, type-parameter-0-0>::const_iterator _Where, const bool &_Val)         std::vector<bool, type-parameter-0-0>::iterator insert(std::vector<bool, type-parameter-0-0>::const_iterator _Where, std::vector<bool, type-parameter-0-0>::size_type _Count, const bool &_Val)         template <class _Iter, class  = enable_if_t<_Is_iterator_v<_Iter> >> std::vector<bool, type-parameter-0-0>::iterator insert(std::vector<bool, type-parameter-0-0>::const_iterator _Where, _Iter _First, _Iter _Last)         template <class _Iter> void _Insert(std::vector<bool, type-parameter-0-0>::const_iterator _Where, _Iter _First, _Iter _Last, std::input_iterator_tag)         template <class _Iter> void _Insert(std::vector<bool, type-parameter-0-0>::const_iterator _Where, _Iter _First, _Iter _Last, std::forward_iterator_tag)         std::vector<bool, type-parameter-0-0>::iterator erase(std::vector<bool, type-parameter-0-0>::const_iterator _Where_arg)         std::vector<bool, type-parameter-0-0>::iterator erase(std::vector<bool, type-parameter-0-0>::const_iterator _First_arg, std::vector<bool, type-parameter-0-0>::const_iterator _Last_arg)         void clear() noexcept         void flip() noexcept         void swap(vector<bool, type-parameter-0-0> &_Right) noexcept         static void swap(std::vector<bool, type-parameter-0-0>::reference _Left, std::vector<bool, type-parameter-0-0>::reference _Right) noexcept         friend  hash<vector<bool, _Alloc> >;
        std::vector<bool, type-parameter-0-0>::iterator _Insert_n(std::vector<bool, type-parameter-0-0>::const_iterator _Where, std::vector<bool, type-parameter-0-0>::size_type _Count, const bool &_Val)         std::vector<bool, type-parameter-0-0>::size_type _Insert_x(std::vector<bool, type-parameter-0-0>::const_iterator _Where, std::vector<bool, type-parameter-0-0>::size_type _Count)         void _Orphan_range(std::vector<bool, type-parameter-0-0>::size_type, std::vector<bool, type-parameter-0-0>::size_type) const         void _Trim(std::vector<bool, type-parameter-0-0>::size_type _Size)         void _Xlen() const [[noreturn]]         void _Xran() const [[noreturn]]     };
    template <class _Alloc> inline bool operator==(const vector<bool, _Alloc> &_Left, const vector<bool, _Alloc> &_Right)     template <class _Alloc> inline bool operator!=(const vector<bool, _Alloc> &_Left, const vector<bool, _Alloc> &_Right)     template <class _Alloc> struct hash<vector<bool, type-parameter-0-0>> {
        typedef vector<bool, _Alloc> argument_type;
        typedef size_t result_type;
        size_t operator()(const vector<bool, _Alloc> &_Keyval) const noexcept     };
}
namespace v8 {
    class Context;
    class Data;
    class Isolate;
    namespace internal {
        class Isolate;
        typedef uintptr_t Address;
        static const v8::internal::Address kNullAddress = 0;
        const int kApiSystemPointerSize = sizeof(void *);
        const int kApiTaggedSize = kApiSystemPointerSize;
        const int kApiDoubleSize = sizeof(double);
        const int kApiIntSize = sizeof(int);
        const int kApiInt64Size = sizeof(int64_t);
        const int kHeapObjectTag = 1;
        const int kWeakHeapObjectTag = 3;
        const int kHeapObjectTagSize = 2;
        const intptr_t kHeapObjectTagMask = (1 << kHeapObjectTagSize) - 1;
        const int kSmiTag = 0;
        const int kSmiTagSize = 1;
        const intptr_t kSmiTagMask = (1 << kSmiTagSize) - 1;
        template <size_t tagged_ptr_size> struct SmiTagging;
        template<> struct SmiTagging<4> {
            enum  {
                kSmiShiftSize = 0,
                kSmiValueSize = 31
            };
            static inline int SmiToInt(const internal::Address value) __attribute__((always_inline))             {
                int shift_bits = kSmiTagSize + kSmiShiftSize;
                return static_cast<int>(static_cast<intptr_t>(value)) >> shift_bits;
            }
            static inline constexpr bool IsValidSmi(intptr_t value) __attribute__((always_inline))             {
                return static_cast<uintptr_t>(value) + 1073741824U < 2147483648U;
            }
        };
        template<> struct SmiTagging<8> {
            enum  {
                kSmiShiftSize = 31,
                kSmiValueSize = 32
            };
            static inline int SmiToInt(const internal::Address value) __attribute__((always_inline))             {
                int shift_bits = kSmiTagSize + kSmiShiftSize;
                return static_cast<int>(static_cast<intptr_t>(value) >> shift_bits);
            }
            static inline constexpr bool IsValidSmi(intptr_t value) __attribute__((always_inline))             {
                return (value == static_cast<int32_t>(value));
            }
        };
        typedef SmiTagging<kApiSystemPointerSize> PlatformSmiTagging;
        const int kSmiShiftSize = PlatformSmiTagging::kSmiShiftSize;
        const int kSmiValueSize = PlatformSmiTagging::kSmiValueSize;
        const int kSmiMinValue = (static_cast<unsigned int>(-1)) << (kSmiValueSize - 1);
        const int kSmiMaxValue = -(kSmiMinValue + 1);
        constexpr bool SmiValuesAre31Bits()         {
            return kSmiValueSize == 31;
        }
        constexpr bool SmiValuesAre32Bits()         {
            return kSmiValueSize == 32;
        }
        static inline constexpr internal::Address IntToSmi(int value) __attribute__((always_inline))         {
            return (static_cast<v8::internal::Address>(value) << (kSmiTagSize + kSmiShiftSize)) | kSmiTag;
        }
        class Internals {
        public:
            static const int kHeapObjectMapOffset = 0;
            static const int kMapInstanceTypeOffset = 1 * kApiTaggedSize + kApiIntSize;
            static const int kStringResourceOffset = 1 * kApiTaggedSize + 2 * kApiIntSize;
            static const int kOddballKindOffset = 4 * kApiTaggedSize + kApiDoubleSize;
            static const int kForeignAddressOffset = kApiTaggedSize;
            static const int kJSObjectHeaderSize = 3 * kApiTaggedSize;
            static const int kJSObjectHeaderSizeForEmbedderFields = (kJSObjectHeaderSize + kApiSystemPointerSize - 1) & -kApiSystemPointerSize;
            static const int kFixedArrayHeaderSize = 2 * kApiTaggedSize;
            static const int kEmbedderDataArrayHeaderSize = 2 * kApiTaggedSize;
            static const int kEmbedderDataSlotSize = kApiSystemPointerSize;
            static const int kNativeContextEmbedderDataOffset = 7 * kApiTaggedSize;
            static const int kFullStringRepresentationMask = 15;
            static const int kStringEncodingMask = 8;
            static const int kExternalTwoByteRepresentationTag = 2;
            static const int kExternalOneByteRepresentationTag = 10;
            static const uint32_t kNumIsolateDataSlots = 4;
            static const int kIsolateEmbedderDataOffset = 0;
            static const int kExternalMemoryOffset = kNumIsolateDataSlots * kApiTaggedSize;
            static const int kExternalMemoryLimitOffset = kExternalMemoryOffset + kApiInt64Size;
            static const int kExternalMemoryAtLastMarkCompactOffset = kExternalMemoryLimitOffset + kApiInt64Size;
            static const int kIsolateRootsOffset = kExternalMemoryAtLastMarkCompactOffset + kApiInt64Size;
            static const int kUndefinedValueRootIndex = 4;
            static const int kTheHoleValueRootIndex = 5;
            static const int kNullValueRootIndex = 6;
            static const int kTrueValueRootIndex = 7;
            static const int kFalseValueRootIndex = 8;
            static const int kEmptyStringRootIndex = 9;
            static const int kNodeClassIdOffset = 1 * kApiTaggedSize;
            static const int kNodeFlagsOffset = 1 * kApiTaggedSize + 3;
            static const int kNodeStateMask = 7;
            static const int kNodeStateIsWeakValue = 2;
            static const int kNodeStateIsPendingValue = 3;
            static const int kNodeStateIsNearDeathValue = 4;
            static const int kNodeIsIndependentShift = 3;
            static const int kNodeIsActiveShift = 4;
            static const int kFirstNonstringType = 128;
            static const int kOddballType = 131;
            static const int kForeignType = 135;
            static const int kJSSpecialApiObjectType = 1040;
            static const int kJSApiObjectType = 1056;
            static const int kJSObjectType = 1057;
            static const int kUndefinedOddballKind = 5;
            static const int kNullOddballKind = 3;
            static const int kThrowOnError = 0;
            static const int kDontThrow = 1;
            static const int kInferShouldThrowMode = 2;
            static constexpr int kExternalAllocationSoftLimit = 64 * 1024 * 1024;
            static void CheckInitializedImpl(v8::Isolate *isolate);
            static inline void CheckInitialized(v8::Isolate *isolate) __attribute__((always_inline))             {
            }
            static inline bool HasHeapObjectTag(const internal::Address value) __attribute__((always_inline))             {
                return (value & kHeapObjectTagMask) == static_cast<v8::internal::Address>(kHeapObjectTag);
            }
            static inline int SmiValue(const internal::Address value) __attribute__((always_inline))             {
                return PlatformSmiTagging::SmiToInt(value);
            }
            static inline constexpr internal::Address IntToSmi(int value) __attribute__((always_inline))             {
                return internal::IntToSmi(value);
            }
            static inline constexpr bool IsValidSmi(intptr_t value) __attribute__((always_inline))             {
                return PlatformSmiTagging::IsValidSmi(value);
            }
            static inline int GetInstanceType(const internal::Address obj) __attribute__((always_inline))             {
                typedef internal::Address A;
                A map = ReadTaggedPointerField(obj, kHeapObjectMapOffset);
                return ReadRawField<uint16_t>(map, kMapInstanceTypeOffset);
            }
            static inline int GetOddballKind(const internal::Address obj) __attribute__((always_inline))             {
                return SmiValue(ReadTaggedSignedField(obj, kOddballKindOffset));
            }
            static inline bool IsExternalTwoByteString(int instance_type) __attribute__((always_inline))             {
                int representation = (instance_type & kFullStringRepresentationMask);
                return representation == kExternalTwoByteRepresentationTag;
            }
            static inline uint8_t GetNodeFlag(internal::Address *obj, int shift) __attribute__((always_inline))             {
                uint8_t *addr = reinterpret_cast<uint8_t *>(obj) + kNodeFlagsOffset;
                return *addr & static_cast<uint8_t>(1U << shift);
            }
            static inline void UpdateNodeFlag(internal::Address *obj, bool value, int shift) __attribute__((always_inline))             {
                uint8_t *addr = reinterpret_cast<uint8_t *>(obj) + kNodeFlagsOffset;
                uint8_t mask = static_cast<uint8_t>(1U << shift);
                *addr = static_cast<uint8_t>((*addr & ~mask) | (value << shift));
            }
            static inline uint8_t GetNodeState(internal::Address *obj) __attribute__((always_inline))             {
                uint8_t *addr = reinterpret_cast<uint8_t *>(obj) + kNodeFlagsOffset;
                return *addr & kNodeStateMask;
            }
            static inline void UpdateNodeState(internal::Address *obj, uint8_t value) __attribute__((always_inline))             {
                uint8_t *addr = reinterpret_cast<uint8_t *>(obj) + kNodeFlagsOffset;
                *addr = static_cast<uint8_t>((*addr & ~kNodeStateMask) | value);
            }
            static inline void SetEmbedderData(v8::Isolate *isolate, uint32_t slot, void *data) __attribute__((always_inline))             {
                internal::Address addr = reinterpret_cast<internal::Address>(isolate) + kIsolateEmbedderDataOffset + slot * kApiSystemPointerSize;
                *reinterpret_cast<void **>(addr) = data;
            }
            static inline void *GetEmbedderData(const v8::Isolate *isolate, uint32_t slot) __attribute__((always_inline))             {
                internal::Address addr = reinterpret_cast<internal::Address>(isolate) + kIsolateEmbedderDataOffset + slot * kApiSystemPointerSize;
                return *reinterpret_cast<void *const *>(addr);
            }
            static inline internal::Address *GetRoot(v8::Isolate *isolate, int index) __attribute__((always_inline))             {
                internal::Address addr = reinterpret_cast<internal::Address>(isolate) + kIsolateRootsOffset + index * kApiSystemPointerSize;
                return reinterpret_cast<internal::Address *>(addr);
            }
            template <typename T> static inline T ReadRawField(internal::Address heap_object_ptr, int offset) __attribute__((always_inline))             {
                internal::Address addr = heap_object_ptr + offset - kHeapObjectTag;
                return *reinterpret_cast<const T *>(addr);
            }
            template<> static inline unsigned short ReadRawField<unsigned short>(internal::Address heap_object_ptr, int offset) __attribute__((always_inline))             {
                internal::Address addr = heap_object_ptr + offset - kHeapObjectTag;
                return *reinterpret_cast<const unsigned short *>(addr);
            }
            template<> static inline unsigned long long ReadRawField<unsigned long long>(internal::Address heap_object_ptr, int offset) __attribute__((always_inline))             {
                internal::Address addr = heap_object_ptr + offset - kHeapObjectTag;
                return *reinterpret_cast<const unsigned long long *>(addr);
            }
            template<> static inline void *ReadRawField<void *>(internal::Address heap_object_ptr, int offset) __attribute__((always_inline))             {
                internal::Address addr = heap_object_ptr + offset - kHeapObjectTag;
                return *reinterpret_cast<void *const *>(addr);
            }
            static inline internal::Address ReadTaggedPointerField(internal::Address heap_object_ptr, int offset) __attribute__((always_inline))             {
                return ReadRawField<internal::Address>(heap_object_ptr, offset);
            }
            static inline internal::Address ReadTaggedSignedField(internal::Address heap_object_ptr, int offset) __attribute__((always_inline))             {
                return ReadRawField<internal::Address>(heap_object_ptr, offset);
            }
            static inline internal::Address ReadTaggedAnyField(internal::Address heap_object_ptr, int offset) __attribute__((always_inline))             {
                return ReadRawField<internal::Address>(heap_object_ptr, offset);
            }
            template <typename T> static inline T ReadEmbedderData(const v8::Context *context, int index) __attribute__((always_inline))             {
                typedef internal::Address A;
                typedef internal::Internals I;
                A ctx = *reinterpret_cast<const A *>(context);
                A embedder_data = I::ReadTaggedPointerField(ctx, I::kNativeContextEmbedderDataOffset);
                int value_offset = I::kEmbedderDataArrayHeaderSize + (I::kEmbedderDataSlotSize * index);
                return I::ReadRawField<T>(embedder_data, value_offset);
            }
            template<> static inline unsigned long long ReadEmbedderData<unsigned long long>(const v8::Context *context, int index) __attribute__((always_inline))             {
                typedef internal::Address A;
                typedef internal::Internals I;
                A ctx = *reinterpret_cast<const A *>(context);
                A embedder_data = I::ReadTaggedPointerField(ctx, I::kNativeContextEmbedderDataOffset);
                int value_offset = I::kEmbedderDataArrayHeaderSize + (I::kEmbedderDataSlotSize * index);
                return I::ReadRawField<unsigned long long>(embedder_data, value_offset);
            }
            template<> static inline void *ReadEmbedderData<void *>(const v8::Context *context, int index) __attribute__((always_inline))             {
                typedef internal::Address A;
                typedef internal::Internals I;
                A ctx = *reinterpret_cast<const A *>(context);
                A embedder_data = I::ReadTaggedPointerField(ctx, I::kNativeContextEmbedderDataOffset);
                int value_offset = I::kEmbedderDataArrayHeaderSize + (I::kEmbedderDataSlotSize * index);
                return I::ReadRawField<void *>(embedder_data, value_offset);
            }
        };
        template <bool PerformCheck> struct CastCheck {
            template <class T> static void Perform(T *data);
        };
template<> struct CastCheck<true> {
            template <class T> static void Perform(T *data);
        };
template<> struct CastCheck<false> {
            template <class T> static void Perform(T *data);
        };
        template <> template <class T> void CastCheck<true>::Perform(T *data)         template <> template <class T> void CastCheck<false>::Perform(T *data)         template <class T> inline void PerformCastCheck(T *data) __attribute__((always_inline))         internal::Isolate *IsolateFromNeverReadOnlySpaceObject(v8::internal::Address obj);
        bool ShouldThrowOnError(v8::internal::Isolate *isolate);
    }
}
namespace v8 {
    class AccessorSignature;
    class Array;
    class ArrayBuffer;
    class BigInt;
    class BigIntObject;
    class Boolean;
    class BooleanObject;
    class Context;
    class Data;
    class Date;
    class External;
    class Function;
    class FunctionTemplate;
    class HeapProfiler;
    class ImplementationUtilities;
    class Int32;
    class Integer;
    class Isolate;
    template <class T> class Maybe;
    class Name;
    class Number;
    class NumberObject;
    class Object;
    class ObjectOperationDescriptor;
    class ObjectTemplate;
    class Platform;
    class Primitive;
    class Promise;
    class PropertyDescriptor;
    class Proxy;
    class RawOperationDescriptor;
    class Script;
    class SharedArrayBuffer;
    class Signature;
    class StartupData;
    class StackFrame;
    class StackTrace;
    class String;
    class StringObject;
    class Symbol;
    class SymbolObject;
    class PrimitiveArray;
    class Private;
    class Uint32;
    class Utils;
    class Value;
    class WasmModuleObject;
    template <class T> class Local
template<> class Local<v8::Primitive> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Primitive>(Local<v8::Primitive> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Primitive *operator->() const __attribute__((always_inline));
        inline v8::Primitive *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Primitive> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Primitive> New(v8::Isolate *isolate, Local<v8::Primitive> that);
        static inline Local<v8::Primitive> New(v8::Isolate *isolate, const PersistentBase<v8::Primitive> &that);
        static inline Local<v8::Primitive> New(v8::Isolate *isolate, const TracedGlobal<v8::Primitive> &that);
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Primitive *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<v8::Primitive> New(v8::Isolate *isolate, v8::Primitive *that);
        v8::Primitive *val_;
    }
template<> class Local<v8::Boolean> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Boolean>(Local<v8::Boolean> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline))         {
            return this->val_ == nullptr;
        }
        inline void Clear() __attribute__((always_inline));
        inline v8::Boolean *operator->() const __attribute__((always_inline))         {
            return this->val_;
        }
        inline v8::Boolean *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Boolean> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, Local<v8::Boolean> that) __attribute__((always_inline));
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, const PersistentBase<v8::Boolean> &that) __attribute__((always_inline));
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, const TracedGlobal<v8::Boolean> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Boolean *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, v8::Boolean *that) __attribute__((always_inline));
        v8::Boolean *val_;
    }
template<> class Local<v8::Value> {
    public:
        inline Local() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Value>(Local<v8::Value> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Value *operator->() const __attribute__((always_inline));
        inline v8::Value *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Value> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Value> New(v8::Isolate *isolate, Local<v8::Value> that) __attribute__((always_inline));
        static inline Local<v8::Value> New(v8::Isolate *isolate, const PersistentBase<v8::Value> &that) __attribute__((always_inline));
        static inline Local<v8::Value> New(v8::Isolate *isolate, const TracedGlobal<v8::Value> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Value *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<v8::Value> New(v8::Isolate *isolate, v8::Value *that) __attribute__((always_inline));
        v8::Value *val_;
    }
template<> class Local<v8::PrimitiveArray> {
    public:
        inline Local() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::PrimitiveArray>(Local<v8::PrimitiveArray> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::PrimitiveArray *operator->() const __attribute__((always_inline));
        inline v8::PrimitiveArray *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::PrimitiveArray> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::PrimitiveArray> New(v8::Isolate *isolate, Local<v8::PrimitiveArray> that) __attribute__((always_inline));
        static inline Local<v8::PrimitiveArray> New(v8::Isolate *isolate, const PersistentBase<v8::PrimitiveArray> &that) __attribute__((always_inline));
        static inline Local<v8::PrimitiveArray> New(v8::Isolate *isolate, const TracedGlobal<v8::PrimitiveArray> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::PrimitiveArray *that) __attribute__((always_inline));
        static inline Local<v8::PrimitiveArray> New(v8::Isolate *isolate, v8::PrimitiveArray *that) __attribute__((always_inline));
        v8::PrimitiveArray *val_;
    }
template<> class Local<v8::Integer> {
    public:
        inline Local() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Integer>(Local<v8::Integer> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Integer *operator->() const __attribute__((always_inline));
        inline v8::Integer *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Integer> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Integer> New(v8::Isolate *isolate, Local<v8::Integer> that) __attribute__((always_inline));
        static inline Local<v8::Integer> New(v8::Isolate *isolate, const PersistentBase<v8::Integer> &that) __attribute__((always_inline));
        static inline Local<v8::Integer> New(v8::Isolate *isolate, const TracedGlobal<v8::Integer> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Integer *that) __attribute__((always_inline));
        static inline Local<v8::Integer> New(v8::Isolate *isolate, v8::Integer *that) __attribute__((always_inline));
        v8::Integer *val_;
    }
template<> class Local<v8::String> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::String>(Local<v8::String> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::String *operator->() const __attribute__((always_inline));
        inline v8::String *operator*() const __attribute__((always_inline))         {
            return this->val_;
        }
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::String> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::String> New(v8::Isolate *isolate, Local<v8::String> that) __attribute__((always_inline));
        static inline Local<v8::String> New(v8::Isolate *isolate, const PersistentBase<v8::String> &that) __attribute__((always_inline));
        static inline Local<v8::String> New(v8::Isolate *isolate, const TracedGlobal<v8::String> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::String *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<v8::String> New(v8::Isolate *isolate, v8::String *that) __attribute__((always_inline));
        v8::String *val_;
    }
template<> class Local<v8::Context> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Context>(Local<v8::Context> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Context *operator->() const __attribute__((always_inline))         {
            return this->val_;
        }
        inline v8::Context *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Context> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Context> New(v8::Isolate *isolate, Local<v8::Context> that) __attribute__((always_inline));
        static inline Local<v8::Context> New(v8::Isolate *isolate, const PersistentBase<v8::Context> &that) __attribute__((always_inline));
        static inline Local<v8::Context> New(v8::Isolate *isolate, const TracedGlobal<v8::Context> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Context *that) __attribute__((always_inline));
        static inline Local<v8::Context> New(v8::Isolate *isolate, v8::Context *that) __attribute__((always_inline));
        v8::Context *val_;
    }
template<> class Local<v8::UnboundScript> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::UnboundScript *operator->() const __attribute__((always_inline));
        inline v8::UnboundScript *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::UnboundScript> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::UnboundScript> New(v8::Isolate *isolate, Local<v8::UnboundScript> that) __attribute__((always_inline));
        static inline Local<v8::UnboundScript> New(v8::Isolate *isolate, const PersistentBase<v8::UnboundScript> &that) __attribute__((always_inline));
        static inline Local<v8::UnboundScript> New(v8::Isolate *isolate, const TracedGlobal<v8::UnboundScript> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::UnboundScript *that) __attribute__((always_inline));
        static inline Local<v8::UnboundScript> New(v8::Isolate *isolate, v8::UnboundScript *that) __attribute__((always_inline));
        v8::UnboundScript *val_;
    }
template<> class Local<v8::Function> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Function>(Local<v8::Function> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Function *operator->() const __attribute__((always_inline));
        inline v8::Function *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Function> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Function> New(v8::Isolate *isolate, Local<v8::Function> that) __attribute__((always_inline));
        static inline Local<v8::Function> New(v8::Isolate *isolate, const PersistentBase<v8::Function> &that) __attribute__((always_inline));
        static inline Local<v8::Function> New(v8::Isolate *isolate, const TracedGlobal<v8::Function> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Function *that) __attribute__((always_inline));
        static inline Local<v8::Function> New(v8::Isolate *isolate, v8::Function *that) __attribute__((always_inline));
        v8::Function *val_;
    }
template<> class Local<v8::StackTrace> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::StackTrace>(Local<v8::StackTrace> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::StackTrace *operator->() const __attribute__((always_inline));
        inline v8::StackTrace *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::StackTrace> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::StackTrace> New(v8::Isolate *isolate, Local<v8::StackTrace> that) __attribute__((always_inline));
        static inline Local<v8::StackTrace> New(v8::Isolate *isolate, const PersistentBase<v8::StackTrace> &that) __attribute__((always_inline));
        static inline Local<v8::StackTrace> New(v8::Isolate *isolate, const TracedGlobal<v8::StackTrace> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::StackTrace *that) __attribute__((always_inline));
        static inline Local<v8::StackTrace> New(v8::Isolate *isolate, v8::StackTrace *that) __attribute__((always_inline));
        v8::StackTrace *val_;
    }
template<> class Local<v8::Name> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::String>(Local<v8::String> that) : val_(reinterpret_cast<v8::Name *>(* that)) __attribute__((always_inline))         {
            while (false)
                {
                    *(static_cast<v8::Name *volatile *>(0)) = static_cast<v8::String *>(0);
                }
            ;
        }
;
        template<> inline Local<v8::Name>(Local<v8::Name> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Name *operator->() const __attribute__((always_inline));
        inline v8::Name *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Name> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Name> New(v8::Isolate *isolate, Local<v8::Name> that);
        static inline Local<v8::Name> New(v8::Isolate *isolate, const PersistentBase<v8::Name> &that);
        static inline Local<v8::Name> New(v8::Isolate *isolate, const TracedGlobal<v8::Name> &that);
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Name *that) __attribute__((always_inline));
        static inline Local<v8::Name> New(v8::Isolate *isolate, v8::Name *that);
        v8::Name *val_;
    }
template<> class Local<v8::FunctionTemplate> {
    public:
        inline Local() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::FunctionTemplate>(Local<v8::FunctionTemplate> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::FunctionTemplate *operator->() const __attribute__((always_inline));
        inline v8::FunctionTemplate *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::FunctionTemplate> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::FunctionTemplate> New(v8::Isolate *isolate, Local<v8::FunctionTemplate> that) __attribute__((always_inline));
        static inline Local<v8::FunctionTemplate> New(v8::Isolate *isolate, const PersistentBase<v8::FunctionTemplate> &that) __attribute__((always_inline));
        static inline Local<v8::FunctionTemplate> New(v8::Isolate *isolate, const TracedGlobal<v8::FunctionTemplate> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::FunctionTemplate *that) __attribute__((always_inline));
        static inline Local<v8::FunctionTemplate> New(v8::Isolate *isolate, v8::FunctionTemplate *that) __attribute__((always_inline));
        v8::FunctionTemplate *val_;
    }
template<> class Local<v8::Promise> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Promise>(Local<v8::Promise> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Promise *operator->() const __attribute__((always_inline));
        inline v8::Promise *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Promise> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Promise> New(v8::Isolate *isolate, Local<v8::Promise> that) __attribute__((always_inline));
        static inline Local<v8::Promise> New(v8::Isolate *isolate, const PersistentBase<v8::Promise> &that) __attribute__((always_inline));
        static inline Local<v8::Promise> New(v8::Isolate *isolate, const TracedGlobal<v8::Promise> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Promise *that) __attribute__((always_inline));
        static inline Local<v8::Promise> New(v8::Isolate *isolate, v8::Promise *that) __attribute__((always_inline));
        v8::Promise *val_;
    }
template<> class Local<v8::Data> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Data>(Local<v8::Data> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Data *operator->() const __attribute__((always_inline));
        inline v8::Data *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Data> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Data> New(v8::Isolate *isolate, Local<v8::Data> that);
        static inline Local<v8::Data> New(v8::Isolate *isolate, const PersistentBase<v8::Data> &that);
        static inline Local<v8::Data> New(v8::Isolate *isolate, const TracedGlobal<v8::Data> &that);
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Data *that) __attribute__((always_inline));
        static inline Local<v8::Data> New(v8::Isolate *isolate, v8::Data *that);
        v8::Data *val_;
    }
template<> class Local<v8::AccessorSignature> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::AccessorSignature>(Local<v8::AccessorSignature> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::AccessorSignature *operator->() const __attribute__((always_inline));
        inline v8::AccessorSignature *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::AccessorSignature> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::AccessorSignature> New(v8::Isolate *isolate, Local<v8::AccessorSignature> that) __attribute__((always_inline));
        static inline Local<v8::AccessorSignature> New(v8::Isolate *isolate, const PersistentBase<v8::AccessorSignature> &that) __attribute__((always_inline));
        static inline Local<v8::AccessorSignature> New(v8::Isolate *isolate, const TracedGlobal<v8::AccessorSignature> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::AccessorSignature *that) __attribute__((always_inline));
        static inline Local<v8::AccessorSignature> New(v8::Isolate *isolate, v8::AccessorSignature *that) __attribute__((always_inline));
        v8::AccessorSignature *val_;
    }
template<> class Local<v8::Signature> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Signature>(Local<v8::Signature> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Signature *operator->() const __attribute__((always_inline));
        inline v8::Signature *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Signature> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Signature> New(v8::Isolate *isolate, Local<v8::Signature> that) __attribute__((always_inline));
        static inline Local<v8::Signature> New(v8::Isolate *isolate, const PersistentBase<v8::Signature> &that) __attribute__((always_inline));
        static inline Local<v8::Signature> New(v8::Isolate *isolate, const TracedGlobal<v8::Signature> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Signature *that) __attribute__((always_inline));
        static inline Local<v8::Signature> New(v8::Isolate *isolate, v8::Signature *that) __attribute__((always_inline));
        v8::Signature *val_;
    };
    template <class T> class MaybeLocal
template<> class MaybeLocal<v8::Value> {
    public:
        inline MaybeLocal() __attribute__((always_inline));
        template <class S> inline MaybeLocal(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((always_inline)) __attribute__((warn_unused_result));
        inline Local<v8::Value> ToLocalChecked() __attribute__((always_inline));
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline));
    private:
        v8::Value *val_;
    }
template<> class MaybeLocal<v8::String> {
    public:
        inline MaybeLocal() __attribute__((always_inline));
        template <class S> inline MaybeLocal(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((always_inline)) __attribute__((warn_unused_result));
        inline Local<v8::String> MaybeLocal<String>::ToLocalChecked()         {
            if ((__builtin_expect(!!(this->val_ == nullptr), 0)))
                V8::ToLocalEmpty();
            return Local<v8::String>(this->val_);
        }
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline));
    private:
        v8::String *val_;
    }
template<> class MaybeLocal<v8::Object> {
    public:
        inline MaybeLocal() __attribute__((always_inline));
        template <class S> inline MaybeLocal(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((always_inline)) __attribute__((warn_unused_result));
        inline Local<v8::Object> ToLocalChecked() __attribute__((always_inline));
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline));
    private:
        v8::Object *val_;
    }
template<> class MaybeLocal<v8::ObjectTemplate> {
    public:
        inline MaybeLocal() __attribute__((always_inline));
        template <class S> inline MaybeLocal(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((always_inline)) __attribute__((warn_unused_result));
        inline Local<v8::ObjectTemplate> ToLocalChecked() __attribute__((always_inline));
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline));
    private:
        v8::ObjectTemplate *val_;
    };
    template <class T> class Eternal;
    template <class T> class NonCopyablePersistentTraits;
    template <class T> class PersistentBase
template<> class PersistentBase<v8::Object> {
    public:
        inline void Reset() __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const Local<S> &other) __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const PersistentBase<S> &other) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Empty() __attribute__((always_inline));
        inline Local<v8::Object> Get(v8::Isolate *isolate) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <typename P> inline void SetWeak(P *parameter, typename WeakCallbackInfo<P>::Callback callback, v8::WeakCallbackType type) __attribute__((always_inline));
        inline void SetWeak() __attribute__((always_inline));
        template <typename P> inline P *ClearWeak() __attribute__((always_inline));
        inline void ClearWeak() __attribute__((always_inline));
        inline void AnnotateStrongRetainer(const char *label) __attribute__((always_inline));
        inline void RegisterExternalReference(v8::Isolate *isolate) const __attribute__((always_inline));
        inline void MarkIndependent() __attribute__((always_inline));
        inline void MarkActive() __attribute__((always_inline));
        inline bool IsIndependent() const __attribute__((always_inline));
        inline bool IsNearDeath() const __attribute__((always_inline));
        inline bool IsWeak() const __attribute__((always_inline));
        inline void SetWrapperClassId(uint16_t class_id) __attribute__((always_inline));
        inline uint16_t WrapperClassId() const __attribute__((always_inline));
        PersistentBase(const v8::PersistentBase<v8::Object> &other) = delete
        void operator=(const v8::PersistentBase<v8::Object> &) = delete
    private:
        friend  class Isolate;
        friend  class Utils;
        friend template <class F> class Local;
        friend template <class F1, class F2 = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Global;
        friend template <class F> class PersistentBase;
        friend template <class F> class ReturnValue;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend  class Object;
        inline explicit PersistentBase(v8::Object *val) __attribute__((always_inline));
        static inline v8::Object *New(v8::Isolate *isolate, v8::Object *that) __attribute__((always_inline));
        v8::Object *val_;
    }
template<> class PersistentBase<v8::Promise> {
    public:
        inline void Reset() __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const Local<S> &other) __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const PersistentBase<S> &other) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Empty() __attribute__((always_inline));
        inline Local<v8::Promise> Get(v8::Isolate *isolate) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <typename P> inline void SetWeak(P *parameter, typename WeakCallbackInfo<P>::Callback callback, v8::WeakCallbackType type) __attribute__((always_inline));
        inline void SetWeak() __attribute__((always_inline));
        template <typename P> inline P *ClearWeak() __attribute__((always_inline));
        inline void ClearWeak() __attribute__((always_inline));
        inline void AnnotateStrongRetainer(const char *label) __attribute__((always_inline));
        inline void RegisterExternalReference(v8::Isolate *isolate) const __attribute__((always_inline));
        inline void MarkIndependent() __attribute__((always_inline));
        inline void MarkActive() __attribute__((always_inline));
        inline bool IsIndependent() const __attribute__((always_inline));
        inline bool IsNearDeath() const __attribute__((always_inline));
        inline bool IsWeak() const __attribute__((always_inline));
        inline void SetWrapperClassId(uint16_t class_id) __attribute__((always_inline));
        inline uint16_t WrapperClassId() const __attribute__((always_inline));
        PersistentBase(const v8::PersistentBase<v8::Promise> &other) = delete
        void operator=(const v8::PersistentBase<v8::Promise> &) = delete
    private:
        friend  class Isolate;
        friend  class Utils;
        friend template <class F> class Local;
        friend template <class F1, class F2 = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Global;
        friend template <class F> class PersistentBase;
        friend template <class F> class ReturnValue;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend  class Object;
        inline explicit PersistentBase(v8::Promise *val) __attribute__((always_inline));
        static inline v8::Promise *New(v8::Isolate *isolate, v8::Promise *that) __attribute__((always_inline));
        v8::Promise *val_;
    };
    template <class T, class M = NonCopyablePersistentTraits<T>> class Persistent
template<> class Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise>> : public PersistentBase<v8::Promise> {
    public:
        inline Persistent() __attribute__((always_inline));
        template <class S> inline Persistent(v8::Isolate *isolate, Local<S> that) __attribute__((always_inline));
        template <class S, class M2> inline Persistent(v8::Isolate *isolate, const Persistent<S, M2> &that) __attribute__((always_inline));
        inline Persistent(const v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &that) __attribute__((always_inline));
        template <class S, class M2> inline Persistent(const Persistent<S, M2> &that) __attribute__((always_inline));
        template<> inline Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise>>(const Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &that) __attribute__((always_inline));
        inline v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &operator=(const v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &that) __attribute__((always_inline));
        template <class S, class M2> inline v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &operator=(const Persistent<S, M2> &that) __attribute__((always_inline));
        template<> inline v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &operator=<v8::Promise, v8::CopyablePersistentTraits<v8::Promise>>(const Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &that) __attribute__((always_inline));
        inline ~Persistent<Promise, CopyablePersistentTraits<Promise> >() noexcept __attribute__((always_inline));
        template <class S> static inline Persistent<v8::Promise> &Cast(const Persistent<S> &that) __attribute__((always_inline));
        template <class S> inline Persistent<S> &As() const __attribute__((always_inline));
    private:
        friend  class Isolate;
        friend  class Utils;
        friend template <class F> class Local;
        friend template <class F1, class F2 = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class ReturnValue;
        inline explicit Persistent(v8::Promise *that) __attribute__((always_inline));
        inline v8::Promise *operator*() const __attribute__((always_inline));
        template <class S, class M2> inline void Copy(const Persistent<S, M2> &that) __attribute__((always_inline));
    };
    template <class T> class Global;
    template <class T> class TracedGlobal
template<> class TracedGlobal<v8::Object> {
    public:
        TracedGlobal() = default
        ~TracedGlobal<Object>();
        template <class S> TracedGlobal(v8::Isolate *isolate, Local<S> that);
        inline TracedGlobal(v8::TracedGlobal<v8::Object> &&other) __attribute__((always_inline));
        template <class S> inline v8::TracedGlobal<v8::Object> &operator=(TracedGlobal<S> &&rhs) __attribute__((always_inline));
        TracedGlobal(const v8::TracedGlobal<v8::Object> &) = delete
        void operator=(const v8::TracedGlobal<v8::Object> &) = delete
        bool IsEmpty() const;
        inline void Reset() __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const Local<S> &other) __attribute__((always_inline));
        Local<v8::Object> Get(v8::Isolate *isolate) const;
        template <class S> inline TracedGlobal<S> &As() const __attribute__((always_inline));
        template <class S> inline bool operator==(const TracedGlobal<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const TracedGlobal<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        inline void SetWrapperClassId(uint16_t class_id) __attribute__((always_inline));
        inline uint16_t WrapperClassId() const __attribute__((always_inline));
        inline void SetFinalizationCallback(void *parameter, WeakCallbackInfo<void>::Callback callback) __attribute__((always_inline));
    private:
        static inline v8::Object *New(v8::Isolate *isolate, v8::Object *that, v8::Object **slot) __attribute__((always_inline));
        v8::Object *operator*() const;
        v8::Object *val_;
        friend  class EmbedderHeapTracer;
        friend template <typename F> class Local;
        friend  class Object;
        friend template <typename F> class ReturnValue;
    };
    template <class K, class V, class T> class PersistentValueMap;
    template <class K, class V, class T> class PersistentValueMapBase;
    template <class K, class V, class T> class GlobalValueMap;
    template <class V, class T> class PersistentValueVector;
    template <class T, class P> class WeakCallbackObject;
    class FunctionTemplate;
    class ObjectTemplate;
    template <typename T> class FunctionCallbackInfo;
    template <typename T> class PropertyCallbackInfo;
    class StackTrace;
    class StackFrame;
    class Isolate;
    class CallHandlerHelper;
    class EscapableHandleScope;
    template <typename T> class ReturnValue;
    namespace internal {
        class Arguments;
        class DeferredHandles;
        class Heap;
        class HeapObject;
        class Isolate;
        class LocalEmbedderHeapTracer;
        class MicrotaskQueue;
        class NeverReadOnlySpaceObject;
        struct ScriptStreamingData;
        template <typename T> class CustomArguments;
        class PropertyCallbackArguments;
        class FunctionCallbackArguments;
        class GlobalHandles;
        class ScopedExternalStringLock;
        namespace wasm {
            class NativeModule;
            class StreamingDecoder;
        }
    }
    namespace debug {
        class ConsoleCallArguments;
    }
    template <class T> class Local {
    public:
        inline Local<T>() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local<T>(Local<S> that) : val_(reinterpret_cast<T *>(*that)) __attribute__((always_inline))         {
            while (false)
                {
                    *(static_cast<T *volatile *>(0)) = static_cast<S *>(0);
                }
            ;
        }
        inline bool IsEmpty() const __attribute__((always_inline))         {
            return this->val_ == nullptr;
        }
        inline void Clear() __attribute__((always_inline))         inline T *operator->() const __attribute__((always_inline))         {
            return this->val_;
        }
        inline T *operator*() const __attribute__((always_inline))         {
            return this->val_;
        }
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline))         template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline))         template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline))         template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline))         template <class S> static inline Local<T> Cast(Local<S> that) __attribute__((always_inline))         template <class S> inline Local<S> As() const __attribute__((always_inline))         static inline Local<T> New(v8::Isolate *isolate, Local<T> that) __attribute__((always_inline));
        static inline Local<T> New(v8::Isolate *isolate, const PersistentBase<T> &that) __attribute__((always_inline));
        static inline Local<T> New(v8::Isolate *isolate, const TracedGlobal<T> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local<T>(T *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<T> New(v8::Isolate *isolate, T *that) __attribute__((always_inline));
        T *val_;
    };
template<> class Local<v8::Primitive> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Primitive>(Local<v8::Primitive> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Primitive *operator->() const __attribute__((always_inline));
        inline v8::Primitive *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Primitive> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Primitive> New(v8::Isolate *isolate, Local<v8::Primitive> that);
        static inline Local<v8::Primitive> New(v8::Isolate *isolate, const PersistentBase<v8::Primitive> &that);
        static inline Local<v8::Primitive> New(v8::Isolate *isolate, const TracedGlobal<v8::Primitive> &that);
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Primitive *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<v8::Primitive> New(v8::Isolate *isolate, v8::Primitive *that);
        v8::Primitive *val_;
    };
template<> class Local<v8::Boolean> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Boolean>(Local<v8::Boolean> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline))         {
            return this->val_ == nullptr;
        }
        inline void Clear() __attribute__((always_inline));
        inline v8::Boolean *operator->() const __attribute__((always_inline))         {
            return this->val_;
        }
        inline v8::Boolean *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Boolean> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, Local<v8::Boolean> that) __attribute__((always_inline));
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, const PersistentBase<v8::Boolean> &that) __attribute__((always_inline));
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, const TracedGlobal<v8::Boolean> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Boolean *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, v8::Boolean *that) __attribute__((always_inline));
        v8::Boolean *val_;
    };
template<> class Local<v8::Value> {
    public:
        inline Local() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Value>(Local<v8::Value> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Value *operator->() const __attribute__((always_inline));
        inline v8::Value *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Value> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Value> New(v8::Isolate *isolate, Local<v8::Value> that) __attribute__((always_inline));
        static inline Local<v8::Value> New(v8::Isolate *isolate, const PersistentBase<v8::Value> &that) __attribute__((always_inline));
        static inline Local<v8::Value> New(v8::Isolate *isolate, const TracedGlobal<v8::Value> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Value *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<v8::Value> New(v8::Isolate *isolate, v8::Value *that) __attribute__((always_inline));
        v8::Value *val_;
    };
template<> class Local<v8::PrimitiveArray> {
    public:
        inline Local() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::PrimitiveArray>(Local<v8::PrimitiveArray> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::PrimitiveArray *operator->() const __attribute__((always_inline));
        inline v8::PrimitiveArray *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::PrimitiveArray> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::PrimitiveArray> New(v8::Isolate *isolate, Local<v8::PrimitiveArray> that) __attribute__((always_inline));
        static inline Local<v8::PrimitiveArray> New(v8::Isolate *isolate, const PersistentBase<v8::PrimitiveArray> &that) __attribute__((always_inline));
        static inline Local<v8::PrimitiveArray> New(v8::Isolate *isolate, const TracedGlobal<v8::PrimitiveArray> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::PrimitiveArray *that) __attribute__((always_inline));
        static inline Local<v8::PrimitiveArray> New(v8::Isolate *isolate, v8::PrimitiveArray *that) __attribute__((always_inline));
        v8::PrimitiveArray *val_;
    };
template<> class Local<v8::Integer> {
    public:
        inline Local() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Integer>(Local<v8::Integer> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Integer *operator->() const __attribute__((always_inline));
        inline v8::Integer *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Integer> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Integer> New(v8::Isolate *isolate, Local<v8::Integer> that) __attribute__((always_inline));
        static inline Local<v8::Integer> New(v8::Isolate *isolate, const PersistentBase<v8::Integer> &that) __attribute__((always_inline));
        static inline Local<v8::Integer> New(v8::Isolate *isolate, const TracedGlobal<v8::Integer> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Integer *that) __attribute__((always_inline));
        static inline Local<v8::Integer> New(v8::Isolate *isolate, v8::Integer *that) __attribute__((always_inline));
        v8::Integer *val_;
    };
template<> class Local<v8::String> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::String>(Local<v8::String> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::String *operator->() const __attribute__((always_inline));
        inline v8::String *operator*() const __attribute__((always_inline))         {
            return this->val_;
        }
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::String> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::String> New(v8::Isolate *isolate, Local<v8::String> that) __attribute__((always_inline));
        static inline Local<v8::String> New(v8::Isolate *isolate, const PersistentBase<v8::String> &that) __attribute__((always_inline));
        static inline Local<v8::String> New(v8::Isolate *isolate, const TracedGlobal<v8::String> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::String *that) : val_(that) __attribute__((always_inline))         {
        }
        static inline Local<v8::String> New(v8::Isolate *isolate, v8::String *that) __attribute__((always_inline));
        v8::String *val_;
    };
template<> class Local<v8::Context> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Context>(Local<v8::Context> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Context *operator->() const __attribute__((always_inline))         {
            return this->val_;
        }
        inline v8::Context *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Context> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Context> New(v8::Isolate *isolate, Local<v8::Context> that) __attribute__((always_inline));
        static inline Local<v8::Context> New(v8::Isolate *isolate, const PersistentBase<v8::Context> &that) __attribute__((always_inline));
        static inline Local<v8::Context> New(v8::Isolate *isolate, const TracedGlobal<v8::Context> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Context *that) __attribute__((always_inline));
        static inline Local<v8::Context> New(v8::Isolate *isolate, v8::Context *that) __attribute__((always_inline));
        v8::Context *val_;
    };
template<> class Local<v8::UnboundScript> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::UnboundScript *operator->() const __attribute__((always_inline));
        inline v8::UnboundScript *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::UnboundScript> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::UnboundScript> New(v8::Isolate *isolate, Local<v8::UnboundScript> that) __attribute__((always_inline));
        static inline Local<v8::UnboundScript> New(v8::Isolate *isolate, const PersistentBase<v8::UnboundScript> &that) __attribute__((always_inline));
        static inline Local<v8::UnboundScript> New(v8::Isolate *isolate, const TracedGlobal<v8::UnboundScript> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::UnboundScript *that) __attribute__((always_inline));
        static inline Local<v8::UnboundScript> New(v8::Isolate *isolate, v8::UnboundScript *that) __attribute__((always_inline));
        v8::UnboundScript *val_;
    };
template<> class Local<v8::Function> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Function>(Local<v8::Function> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Function *operator->() const __attribute__((always_inline));
        inline v8::Function *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Function> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Function> New(v8::Isolate *isolate, Local<v8::Function> that) __attribute__((always_inline));
        static inline Local<v8::Function> New(v8::Isolate *isolate, const PersistentBase<v8::Function> &that) __attribute__((always_inline));
        static inline Local<v8::Function> New(v8::Isolate *isolate, const TracedGlobal<v8::Function> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Function *that) __attribute__((always_inline));
        static inline Local<v8::Function> New(v8::Isolate *isolate, v8::Function *that) __attribute__((always_inline));
        v8::Function *val_;
    };
template<> class Local<v8::StackTrace> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::StackTrace>(Local<v8::StackTrace> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::StackTrace *operator->() const __attribute__((always_inline));
        inline v8::StackTrace *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::StackTrace> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::StackTrace> New(v8::Isolate *isolate, Local<v8::StackTrace> that) __attribute__((always_inline));
        static inline Local<v8::StackTrace> New(v8::Isolate *isolate, const PersistentBase<v8::StackTrace> &that) __attribute__((always_inline));
        static inline Local<v8::StackTrace> New(v8::Isolate *isolate, const TracedGlobal<v8::StackTrace> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::StackTrace *that) __attribute__((always_inline));
        static inline Local<v8::StackTrace> New(v8::Isolate *isolate, v8::StackTrace *that) __attribute__((always_inline));
        v8::StackTrace *val_;
    };
template<> class Local<v8::Name> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::String>(Local<v8::String> that) : val_(reinterpret_cast<v8::Name *>(* that)) __attribute__((always_inline))         {
            while (false)
                {
                    *(static_cast<v8::Name *volatile *>(0)) = static_cast<v8::String *>(0);
                }
            ;
        }
;
        template<> inline Local<v8::Name>(Local<v8::Name> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Name *operator->() const __attribute__((always_inline));
        inline v8::Name *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Name> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Name> New(v8::Isolate *isolate, Local<v8::Name> that);
        static inline Local<v8::Name> New(v8::Isolate *isolate, const PersistentBase<v8::Name> &that);
        static inline Local<v8::Name> New(v8::Isolate *isolate, const TracedGlobal<v8::Name> &that);
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Name *that) __attribute__((always_inline));
        static inline Local<v8::Name> New(v8::Isolate *isolate, v8::Name *that);
        v8::Name *val_;
    };
template<> class Local<v8::FunctionTemplate> {
    public:
        inline Local() : val_(nullptr) __attribute__((always_inline))         {
        }
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::FunctionTemplate>(Local<v8::FunctionTemplate> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::FunctionTemplate *operator->() const __attribute__((always_inline));
        inline v8::FunctionTemplate *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::FunctionTemplate> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::FunctionTemplate> New(v8::Isolate *isolate, Local<v8::FunctionTemplate> that) __attribute__((always_inline));
        static inline Local<v8::FunctionTemplate> New(v8::Isolate *isolate, const PersistentBase<v8::FunctionTemplate> &that) __attribute__((always_inline));
        static inline Local<v8::FunctionTemplate> New(v8::Isolate *isolate, const TracedGlobal<v8::FunctionTemplate> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::FunctionTemplate *that) __attribute__((always_inline));
        static inline Local<v8::FunctionTemplate> New(v8::Isolate *isolate, v8::FunctionTemplate *that) __attribute__((always_inline));
        v8::FunctionTemplate *val_;
    };
template<> class Local<v8::Promise> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Promise>(Local<v8::Promise> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Promise *operator->() const __attribute__((always_inline));
        inline v8::Promise *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Promise> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Promise> New(v8::Isolate *isolate, Local<v8::Promise> that) __attribute__((always_inline));
        static inline Local<v8::Promise> New(v8::Isolate *isolate, const PersistentBase<v8::Promise> &that) __attribute__((always_inline));
        static inline Local<v8::Promise> New(v8::Isolate *isolate, const TracedGlobal<v8::Promise> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Promise *that) __attribute__((always_inline));
        static inline Local<v8::Promise> New(v8::Isolate *isolate, v8::Promise *that) __attribute__((always_inline));
        v8::Promise *val_;
    };
template<> class Local<v8::Data> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Data>(Local<v8::Data> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Data *operator->() const __attribute__((always_inline));
        inline v8::Data *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Data> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Data> New(v8::Isolate *isolate, Local<v8::Data> that);
        static inline Local<v8::Data> New(v8::Isolate *isolate, const PersistentBase<v8::Data> &that);
        static inline Local<v8::Data> New(v8::Isolate *isolate, const TracedGlobal<v8::Data> &that);
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Data *that) __attribute__((always_inline));
        static inline Local<v8::Data> New(v8::Isolate *isolate, v8::Data *that);
        v8::Data *val_;
    };
template<> class Local<v8::AccessorSignature> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::AccessorSignature>(Local<v8::AccessorSignature> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::AccessorSignature *operator->() const __attribute__((always_inline));
        inline v8::AccessorSignature *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::AccessorSignature> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::AccessorSignature> New(v8::Isolate *isolate, Local<v8::AccessorSignature> that) __attribute__((always_inline));
        static inline Local<v8::AccessorSignature> New(v8::Isolate *isolate, const PersistentBase<v8::AccessorSignature> &that) __attribute__((always_inline));
        static inline Local<v8::AccessorSignature> New(v8::Isolate *isolate, const TracedGlobal<v8::AccessorSignature> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::AccessorSignature *that) __attribute__((always_inline));
        static inline Local<v8::AccessorSignature> New(v8::Isolate *isolate, v8::AccessorSignature *that) __attribute__((always_inline));
        v8::AccessorSignature *val_;
    };
template<> class Local<v8::Signature> {
    public:
        inline Local() __attribute__((always_inline));
        template <class S> inline Local(Local<S> that) __attribute__((always_inline));
        template<> inline Local<v8::Signature>(Local<v8::Signature> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Clear() __attribute__((always_inline));
        inline v8::Signature *operator->() const __attribute__((always_inline));
        inline v8::Signature *operator*() const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Persistent<S> &that) const __attribute__((always_inline));
        template <class S> static inline Local<v8::Signature> Cast(Local<S> that) __attribute__((always_inline));
        template <class S> inline Local<S> As() const __attribute__((always_inline));
        static inline Local<v8::Signature> New(v8::Isolate *isolate, Local<v8::Signature> that) __attribute__((always_inline));
        static inline Local<v8::Signature> New(v8::Isolate *isolate, const PersistentBase<v8::Signature> &that) __attribute__((always_inline));
        static inline Local<v8::Signature> New(v8::Isolate *isolate, const TracedGlobal<v8::Signature> &that) __attribute__((always_inline));
    private:
        friend  class Utils;
        friend template <class F> class Eternal;
        friend template <class F> class PersistentBase;
        friend template <class F, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Local;
        friend template <class F> class MaybeLocal;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend  class String;
        friend  class Object;
        friend  class Context;
        friend  class Isolate;
        friend  class Private;
        friend template <class F> class CustomArguments;
        friend Local<v8::Primitive> Undefined(v8::Isolate *isolate);
        friend Local<v8::Primitive> Null(v8::Isolate *isolate);
        friend Local<v8::Boolean> True(v8::Isolate *isolate);
        friend Local<v8::Boolean> False(v8::Isolate *isolate);
        friend  class HandleScope;
        friend  class EscapableHandleScope;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend template <class F> class ReturnValue;
        friend template <class F> class TracedGlobal;
        inline explicit Local(v8::Signature *that) __attribute__((always_inline));
        static inline Local<v8::Signature> New(v8::Isolate *isolate, v8::Signature *that) __attribute__((always_inline));
        v8::Signature *val_;
    };
    template <class T> using Handle = Local<T>;
    template <class T> class MaybeLocal {
    public:
        inline MaybeLocal<T>() __attribute__((always_inline))         template <class S> inline MaybeLocal<T>(Local<S> that) __attribute__((always_inline))         inline bool IsEmpty() const __attribute__((always_inline))         template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((always_inline)) __attribute__((warn_unused_result))         inline Local<T> ToLocalChecked() __attribute__((always_inline));
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline))     private:
        T *val_;
    };
template<> class MaybeLocal<v8::Value> {
    public:
        inline MaybeLocal() __attribute__((always_inline));
        template <class S> inline MaybeLocal(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((always_inline)) __attribute__((warn_unused_result));
        inline Local<v8::Value> ToLocalChecked() __attribute__((always_inline));
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline));
    private:
        v8::Value *val_;
    };
template<> class MaybeLocal<v8::String> {
    public:
        inline MaybeLocal() __attribute__((always_inline));
        template <class S> inline MaybeLocal(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((always_inline)) __attribute__((warn_unused_result));
        inline Local<v8::String> MaybeLocal<String>::ToLocalChecked()         {
            if ((__builtin_expect(!!(this->val_ == nullptr), 0)))
                V8::ToLocalEmpty();
            return Local<v8::String>(this->val_);
        }
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline));
    private:
        v8::String *val_;
    };
template<> class MaybeLocal<v8::Object> {
    public:
        inline MaybeLocal() __attribute__((always_inline));
        template <class S> inline MaybeLocal(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((always_inline)) __attribute__((warn_unused_result));
        inline Local<v8::Object> ToLocalChecked() __attribute__((always_inline));
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline));
    private:
        v8::Object *val_;
    };
template<> class MaybeLocal<v8::ObjectTemplate> {
    public:
        inline MaybeLocal() __attribute__((always_inline));
        template <class S> inline MaybeLocal(Local<S> that) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        template <class S> inline bool ToLocal(Local<S> *out) const __attribute__((always_inline)) __attribute__((warn_unused_result));
        inline Local<v8::ObjectTemplate> ToLocalChecked() __attribute__((always_inline));
        template <class S> inline Local<S> FromMaybe(Local<S> default_value) const __attribute__((always_inline));
    private:
        v8::ObjectTemplate *val_;
    };
    template <class T> class Eternal {
    public:
        inline Eternal<T>() __attribute__((always_inline))         template <class S> inline Eternal<T>(v8::Isolate *isolate, Local<S> handle) __attribute__((always_inline))         inline Local<T> Get(v8::Isolate *isolate) const __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline))         template <class S> inline void Set(v8::Isolate *isolate, Local<S> handle) __attribute__((always_inline));
    private:
        T *val_;
    };
    static const int kInternalFieldsInWeakCallback = 2;
    static const int kEmbedderFieldsInWeakCallback = 2;
    template <typename T> class WeakCallbackInfo {
    public:
        typedef void (*Callback)(const WeakCallbackInfo<T> &);
        WeakCallbackInfo<T>(v8::Isolate *isolate, T *parameter, void *embedder_fields[2], v8::WeakCallbackInfo::Callback *callback)         inline v8::Isolate *GetIsolate() const __attribute__((always_inline))         inline T *GetParameter() const __attribute__((always_inline))         inline void *GetInternalField(int index) const __attribute__((always_inline));
        void SetSecondPassCallback(v8::WeakCallbackInfo::Callback callback) const     private:
        v8::Isolate *isolate_;
        T *parameter_;
        v8::WeakCallbackInfo::Callback *callback_;
        void *embedder_fields_[2];
    };
template<> class WeakCallbackInfo<void> {
    public:
        typedef void (*Callback)(const WeakCallbackInfo<void> &);
        WeakCallbackInfo(v8::Isolate *isolate, void *parameter, void *embedder_fields[2], v8::WeakCallbackInfo<void>::Callback *callback);
        inline v8::Isolate *GetIsolate() const __attribute__((always_inline));
        inline void *GetParameter() const __attribute__((always_inline));
        inline void *GetInternalField(int index) const __attribute__((always_inline));
        void SetSecondPassCallback(v8::WeakCallbackInfo<void>::Callback callback) const;
    private:
        v8::Isolate *isolate_;
        void *parameter_;
        v8::WeakCallbackInfo<void>::Callback *callback_;
        void *embedder_fields_[2];
    };
    enum class WeakCallbackType : int {
        kParameter,
        kInternalFields,
        kFinalizer
    };
    template <class T> class PersistentBase {
    public:
        inline void Reset() __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const Local<S> &other) __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const PersistentBase<S> &other) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline))         inline void Empty() __attribute__((always_inline))         inline Local<T> Get(v8::Isolate *isolate) const __attribute__((always_inline))         template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline))         template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline))         template <class S> inline bool operator!=(const PersistentBase<S> &that) const __attribute__((always_inline))         template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline))         template <typename P> inline void SetWeak(P *parameter, typename WeakCallbackInfo<P>::Callback callback, v8::WeakCallbackType type) __attribute__((always_inline));
        inline void SetWeak() __attribute__((always_inline));
        template <typename P> inline P *ClearWeak() __attribute__((always_inline));
        inline void ClearWeak() __attribute__((always_inline))         inline void AnnotateStrongRetainer(const char *label) __attribute__((always_inline));
        inline void RegisterExternalReference(v8::Isolate *isolate) const __attribute__((always_inline));
        inline void MarkIndependent() __attribute__((always_inline));
        inline void MarkActive() __attribute__((always_inline));
        inline bool IsIndependent() const __attribute__((always_inline));
        inline bool IsNearDeath() const __attribute__((always_inline));
        inline bool IsWeak() const __attribute__((always_inline));
        inline void SetWrapperClassId(uint16_t class_id) __attribute__((always_inline));
        inline uint16_t WrapperClassId() const __attribute__((always_inline));
        PersistentBase<T>(const PersistentBase<T> &other) = delete
        void operator=(const PersistentBase<T> &) = delete
    private:
        friend  class Isolate;
        friend  class Utils;
        friend template <class F> class Local;
        friend template <class F1, class F2> class Persistent;
        friend template <class F> class Global;
        friend template <class F> class PersistentBase;
        friend template <class F> class ReturnValue;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend  class Object;
        inline explicit PersistentBase<T>(T *val) __attribute__((always_inline))         static inline T *New(v8::Isolate *isolate, T *that) __attribute__((always_inline));
        T *val_;
    };
template<> class PersistentBase<v8::Object> {
    public:
        inline void Reset() __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const Local<S> &other) __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const PersistentBase<S> &other) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Empty() __attribute__((always_inline));
        inline Local<v8::Object> Get(v8::Isolate *isolate) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <typename P> inline void SetWeak(P *parameter, typename WeakCallbackInfo<P>::Callback callback, v8::WeakCallbackType type) __attribute__((always_inline));
        inline void SetWeak() __attribute__((always_inline));
        template <typename P> inline P *ClearWeak() __attribute__((always_inline));
        inline void ClearWeak() __attribute__((always_inline));
        inline void AnnotateStrongRetainer(const char *label) __attribute__((always_inline));
        inline void RegisterExternalReference(v8::Isolate *isolate) const __attribute__((always_inline));
        inline void MarkIndependent() __attribute__((always_inline));
        inline void MarkActive() __attribute__((always_inline));
        inline bool IsIndependent() const __attribute__((always_inline));
        inline bool IsNearDeath() const __attribute__((always_inline));
        inline bool IsWeak() const __attribute__((always_inline));
        inline void SetWrapperClassId(uint16_t class_id) __attribute__((always_inline));
        inline uint16_t WrapperClassId() const __attribute__((always_inline));
        PersistentBase(const v8::PersistentBase<v8::Object> &other) = delete
        void operator=(const v8::PersistentBase<v8::Object> &) = delete
    private:
        friend  class Isolate;
        friend  class Utils;
        friend template <class F> class Local;
        friend template <class F1, class F2 = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Global;
        friend template <class F> class PersistentBase;
        friend template <class F> class ReturnValue;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend  class Object;
        inline explicit PersistentBase(v8::Object *val) __attribute__((always_inline));
        static inline v8::Object *New(v8::Isolate *isolate, v8::Object *that) __attribute__((always_inline));
        v8::Object *val_;
    };
template<> class PersistentBase<v8::Promise> {
    public:
        inline void Reset() __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const Local<S> &other) __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const PersistentBase<S> &other) __attribute__((always_inline));
        inline bool IsEmpty() const __attribute__((always_inline));
        inline void Empty() __attribute__((always_inline));
        inline Local<v8::Promise> Get(v8::Isolate *isolate) const __attribute__((always_inline));
        template <class S> inline bool operator==(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const PersistentBase<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        template <typename P> inline void SetWeak(P *parameter, typename WeakCallbackInfo<P>::Callback callback, v8::WeakCallbackType type) __attribute__((always_inline));
        inline void SetWeak() __attribute__((always_inline));
        template <typename P> inline P *ClearWeak() __attribute__((always_inline));
        inline void ClearWeak() __attribute__((always_inline));
        inline void AnnotateStrongRetainer(const char *label) __attribute__((always_inline));
        inline void RegisterExternalReference(v8::Isolate *isolate) const __attribute__((always_inline));
        inline void MarkIndependent() __attribute__((always_inline));
        inline void MarkActive() __attribute__((always_inline));
        inline bool IsIndependent() const __attribute__((always_inline));
        inline bool IsNearDeath() const __attribute__((always_inline));
        inline bool IsWeak() const __attribute__((always_inline));
        inline void SetWrapperClassId(uint16_t class_id) __attribute__((always_inline));
        inline uint16_t WrapperClassId() const __attribute__((always_inline));
        PersistentBase(const v8::PersistentBase<v8::Promise> &other) = delete
        void operator=(const v8::PersistentBase<v8::Promise> &) = delete
    private:
        friend  class Isolate;
        friend  class Utils;
        friend template <class F> class Local;
        friend template <class F1, class F2 = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class Global;
        friend template <class F> class PersistentBase;
        friend template <class F> class ReturnValue;
        friend template <class F1, class F2, class F3> class PersistentValueMapBase;
        friend template <class F1, class F2> class PersistentValueVector;
        friend  class Object;
        inline explicit PersistentBase(v8::Promise *val) __attribute__((always_inline));
        static inline v8::Promise *New(v8::Isolate *isolate, v8::Promise *that) __attribute__((always_inline));
        v8::Promise *val_;
    };
    template <class T> class NonCopyablePersistentTraits {
    public:
        typedef Persistent<T, NonCopyablePersistentTraits<T> > NonCopyablePersistent;
        static const bool kResetInDestructor = false;
        template <class S, class M> static inline void Copy(const Persistent<S, M> &source, v8::NonCopyablePersistentTraits::NonCopyablePersistent *dest) __attribute__((always_inline))         template <class O> static inline void Uncompilable() __attribute__((always_inline))     };
    template <class T> struct CopyablePersistentTraits {
        typedef Persistent<T, CopyablePersistentTraits<T> > CopyablePersistent;
        static const bool kResetInDestructor = true;
        template <class S, class M> static inline void Copy(const Persistent<S, M> &source, v8::CopyablePersistentTraits::CopyablePersistent *dest) __attribute__((always_inline))     };
    template <class T, class M = NonCopyablePersistentTraits<T>> class Persistent : public PersistentBase<T> {
    public:
        inline Persistent<T, M>() __attribute__((always_inline))         template <class S> inline Persistent<T, M>(v8::Isolate *isolate, Local<S> that) __attribute__((always_inline))         template <class S, class M2> inline Persistent<T, M>(v8::Isolate *isolate, const Persistent<S, M2> &that) __attribute__((always_inline))         inline Persistent<T, M>(const Persistent<T, M> &that) __attribute__((always_inline))         template <class S, class M2> inline Persistent<T, M>(const Persistent<S, M2> &that) __attribute__((always_inline))         inline Persistent<T, M> &operator=(const Persistent<T, M> &that) __attribute__((always_inline))         template <class S, class M2> inline Persistent<T, M> &operator=(const Persistent<S, M2> &that) __attribute__((always_inline))         inline ~Persistent<T, M>() __attribute__((always_inline))         template <class S> static inline Persistent<T> &Cast(const Persistent<S> &that) __attribute__((always_inline))         template <class S> inline Persistent<S> &As() const __attribute__((always_inline))     private:
        friend  class Isolate;
        friend  class Utils;
        friend template <class F> class Local;
        friend template <class F1, class F2> class Persistent;
        friend template <class F> class ReturnValue;
        inline explicit Persistent<T, M>(T *that) __attribute__((always_inline))         inline T *operator*() const __attribute__((always_inline))         template <class S, class M2> inline void Copy(const Persistent<S, M2> &that) __attribute__((always_inline));
    };
template<> class Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise>> : public PersistentBase<v8::Promise> {
    public:
        inline Persistent() __attribute__((always_inline));
        template <class S> inline Persistent(v8::Isolate *isolate, Local<S> that) __attribute__((always_inline));
        template <class S, class M2> inline Persistent(v8::Isolate *isolate, const Persistent<S, M2> &that) __attribute__((always_inline));
        inline Persistent(const v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &that) __attribute__((always_inline));
        template <class S, class M2> inline Persistent(const Persistent<S, M2> &that) __attribute__((always_inline));
        template<> inline Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise>>(const Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &that) __attribute__((always_inline));
        inline v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &operator=(const v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &that) __attribute__((always_inline));
        template <class S, class M2> inline v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &operator=(const Persistent<S, M2> &that) __attribute__((always_inline));
        template<> inline v8::Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &operator=<v8::Promise, v8::CopyablePersistentTraits<v8::Promise>>(const Persistent<v8::Promise, v8::CopyablePersistentTraits<v8::Promise> > &that) __attribute__((always_inline));
        inline ~Persistent<Promise, CopyablePersistentTraits<Promise> >() noexcept __attribute__((always_inline));
        template <class S> static inline Persistent<v8::Promise> &Cast(const Persistent<S> &that) __attribute__((always_inline));
        template <class S> inline Persistent<S> &As() const __attribute__((always_inline));
    private:
        friend  class Isolate;
        friend  class Utils;
        friend template <class F> class Local;
        friend template <class F1, class F2 = NonCopyablePersistentTraits<T>> class Persistent;
        friend template <class F> class ReturnValue;
        inline explicit Persistent(v8::Promise *that) __attribute__((always_inline));
        inline v8::Promise *operator*() const __attribute__((always_inline));
        template <class S, class M2> inline void Copy(const Persistent<S, M2> &that) __attribute__((always_inline));
    };
    template <class T> class Global : public PersistentBase<T> {
    public:
        inline Global<T>() __attribute__((always_inline))         template <class S> inline Global<T>(v8::Isolate *isolate, Local<S> that) __attribute__((always_inline))         template <class S> inline Global<T>(v8::Isolate *isolate, const PersistentBase<S> &that) __attribute__((always_inline))         inline Global<T>(Global<T> &&other) __attribute__((always_inline));
        inline ~Global<T>() __attribute__((always_inline))         template <class S> inline Global<T> &operator=(Global<S> &&rhs) __attribute__((always_inline));
        Global<T> Pass()         typedef void MoveOnlyTypeForCPP03;
        Global<T>(const Global<T> &) = delete
        void operator=(const Global<T> &) = delete
    private:
        friend template <class F> class ReturnValue;
        inline T *operator*() const __attribute__((always_inline))     };
    template <class T> using UniquePersistent = Global<T>;
    template <typename T> class TracedGlobal {
    public:
        TracedGlobal<T>() = default
        ~TracedGlobal<T>()         template <class S> TracedGlobal<T>(v8::Isolate *isolate, Local<S> that)         inline TracedGlobal<T>(TracedGlobal<T> &&other) __attribute__((always_inline));
        template <class S> inline TracedGlobal<T> &operator=(TracedGlobal<S> &&rhs) __attribute__((always_inline));
        TracedGlobal<T>(const TracedGlobal<T> &) = delete
        void operator=(const TracedGlobal<T> &) = delete
        bool IsEmpty() const         inline void Reset() __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const Local<S> &other) __attribute__((always_inline));
        Local<T> Get(v8::Isolate *isolate) const         template <class S> inline TracedGlobal<S> &As() const __attribute__((always_inline))         template <class S> inline bool operator==(const TracedGlobal<S> &that) const __attribute__((always_inline))         template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline))         template <class S> inline bool operator!=(const TracedGlobal<S> &that) const __attribute__((always_inline))         template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline))         inline void SetWrapperClassId(uint16_t class_id) __attribute__((always_inline));
        inline uint16_t WrapperClassId() const __attribute__((always_inline));
        inline void SetFinalizationCallback(void *parameter, WeakCallbackInfo<void>::Callback callback) __attribute__((always_inline));
    private:
        static inline T *New(v8::Isolate *isolate, T *that, T **slot) __attribute__((always_inline));
        T *operator*() const         T *val_ = nullptr;
        friend  class EmbedderHeapTracer;
        friend template <typename F> class Local;
        friend  class Object;
        friend template <typename F> class ReturnValue;
    };
template<> class TracedGlobal<v8::Object> {
    public:
        TracedGlobal() = default
        ~TracedGlobal<Object>();
        template <class S> TracedGlobal(v8::Isolate *isolate, Local<S> that);
        inline TracedGlobal(v8::TracedGlobal<v8::Object> &&other) __attribute__((always_inline));
        template <class S> inline v8::TracedGlobal<v8::Object> &operator=(TracedGlobal<S> &&rhs) __attribute__((always_inline));
        TracedGlobal(const v8::TracedGlobal<v8::Object> &) = delete
        void operator=(const v8::TracedGlobal<v8::Object> &) = delete
        bool IsEmpty() const;
        inline void Reset() __attribute__((always_inline));
        template <class S> inline void Reset(v8::Isolate *isolate, const Local<S> &other) __attribute__((always_inline));
        Local<v8::Object> Get(v8::Isolate *isolate) const;
        template <class S> inline TracedGlobal<S> &As() const __attribute__((always_inline));
        template <class S> inline bool operator==(const TracedGlobal<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator==(const Local<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const TracedGlobal<S> &that) const __attribute__((always_inline));
        template <class S> inline bool operator!=(const Local<S> &that) const __attribute__((always_inline));
        inline void SetWrapperClassId(uint16_t class_id) __attribute__((always_inline));
        inline uint16_t WrapperClassId() const __attribute__((always_inline));
        inline void SetFinalizationCallback(void *parameter, WeakCallbackInfo<void>::Callback callback) __attribute__((always_inline));
    private:
        static inline v8::Object *New(v8::Isolate *isolate, v8::Object *that, v8::Object **slot) __attribute__((always_inline));
        v8::Object *operator*() const;
        v8::Object *val_;
        friend  class EmbedderHeapTracer;
        friend template <typename F> class Local;
        friend  class Object;
        friend template <typename F> class ReturnValue;
    };
    class HandleScope {
    public:
        explicit HandleScope(v8::Isolate *isolate);
        ~HandleScope() noexcept;
        static int NumberOfHandles(v8::Isolate *isolate);
        inline v8::Isolate *GetIsolate() const __attribute__((always_inline))         {
            return reinterpret_cast<v8::Isolate *>(this->isolate_);
        }
        HandleScope(const v8::HandleScope &) = delete
        void operator=(const v8::HandleScope &) = delete
    protected:
        inline HandleScope() __attribute__((always_inline)) = default
        void Initialize(v8::Isolate *isolate);
        static internal::Address *CreateHandle(internal::Isolate *isolate, internal::Address value);
    private:
        void *operator new(size_t size);
        void *operator new[](size_t size);
        void operator delete(void *, size_t) noexcept;
        void operator delete[](void *, size_t) noexcept;
        internal::Isolate *isolate_;
        internal::Address *prev_next_;
        internal::Address *prev_limit_;
        friend template <class F> class Local;
        friend  class Object;
        friend  class Context;
    };
    class EscapableHandleScope : public v8::HandleScope {
    public:
        explicit EscapableHandleScope(v8::Isolate *isolate);
        inline ~EscapableHandleScope() noexcept __attribute__((always_inline)) = default
        template <class T> inline Local<T> Escape(Local<T> value) __attribute__((always_inline))         template <class T> inline MaybeLocal<T> EscapeMaybe(MaybeLocal<T> value) __attribute__((always_inline))         EscapableHandleScope(const v8::EscapableHandleScope &) = delete
        void operator=(const v8::EscapableHandleScope &) = delete
    private:
        void *operator new(size_t size);
        void *operator new[](size_t size);
        void operator delete(void *, size_t) noexcept;
        void operator delete[](void *, size_t) noexcept;
        internal::Address *Escape(internal::Address *escape_value);
        internal::Address *escape_slot_;
    };
    class SealHandleScope {
    public:
        explicit SealHandleScope(v8::Isolate *isolate);
        ~SealHandleScope();
        SealHandleScope(const v8::SealHandleScope &) = delete
        void operator=(const v8::SealHandleScope &) = delete
    private:
        void *operator new(size_t size);
        void *operator new[](size_t size);
        void operator delete(void *, size_t) noexcept;
        void operator delete[](void *, size_t) noexcept;
        internal::Isolate *const isolate_;
        internal::Address *prev_limit_;
        int prev_sealed_level_;
    };
    class Data {
    private:
        Data();
    };
    class ScriptOrModule {
    public:
        Local<v8::Value> GetResourceName();
        Local<v8::PrimitiveArray> GetHostDefinedOptions();
    };
    class PrimitiveArray {
    public:
        static Local<v8::PrimitiveArray> New(v8::Isolate *isolate, int length);
        int Length() const;
        void Set(v8::Isolate *isolate, int index, Local<v8::Primitive> item);
        Local<v8::Primitive> Get(v8::Isolate *isolate, int index);
    };
    class ScriptOriginOptions {
    public:
        inline ScriptOriginOptions(bool is_shared_cross_origin = false, bool is_opaque = false, bool is_wasm = false, bool is_module = false) : flags_((is_shared_cross_origin ? kIsSharedCrossOrigin : 0) | (is_wasm ? kIsWasm : 0) | (is_opaque ? kIsOpaque : 0) | (is_module ? kIsModule : 0)) __attribute__((always_inline))         {
        }
        inline ScriptOriginOptions(int flags) : flags_(flags & (kIsSharedCrossOrigin | kIsOpaque | kIsWasm | kIsModule)) __attribute__((always_inline))         {
        }
        bool IsSharedCrossOrigin() const         {
            return (this->flags_ & kIsSharedCrossOrigin) != 0;
        }
        bool IsOpaque() const         {
            return (this->flags_ & kIsOpaque) != 0;
        }
        bool IsWasm() const         {
            return (this->flags_ & kIsWasm) != 0;
        }
        bool IsModule() const         {
            return (this->flags_ & kIsModule) != 0;
        }
        int Flags() const         {
            return this->flags_;
        }
    private:
        enum  {
            kIsSharedCrossOrigin = 1,
            kIsOpaque = 1 << 1,
            kIsWasm = 1 << 2,
            kIsModule = 1 << 3
        };
        const int flags_;
    };
    class ScriptOrigin {
    public:
        inline ScriptOrigin(Local<v8::Value> resource_name, Local<v8::Integer> resource_line_offset = Local<v8::Integer>(), Local<v8::Integer> resource_column_offset = Local<v8::Integer>(), Local<v8::Boolean> resource_is_shared_cross_origin = Local<v8::Boolean>(), Local<v8::Integer> script_id = Local<v8::Integer>(), Local<v8::Value> source_map_url = Local<v8::Value>(), Local<v8::Boolean> resource_is_opaque = Local<v8::Boolean>(), Local<v8::Boolean> is_wasm = Local<v8::Boolean>(), Local<v8::Boolean> is_module = Local<v8::Boolean>(), Local<v8::PrimitiveArray> host_defined_options = Local<v8::PrimitiveArray>()) __attribute__((always_inline));
        inline Local<v8::Value> ResourceName() const __attribute__((always_inline));
        inline Local<v8::Integer> ResourceLineOffset() const __attribute__((always_inline));
        inline Local<v8::Integer> ResourceColumnOffset() const __attribute__((always_inline));
        inline Local<v8::Integer> ScriptID() const __attribute__((always_inline));
        inline Local<v8::Value> SourceMapUrl() const __attribute__((always_inline));
        inline Local<v8::PrimitiveArray> HostDefinedOptions() const __attribute__((always_inline));
        inline v8::ScriptOriginOptions Options() const __attribute__((always_inline))         {
            return this->options_;
        }
    private:
        Local<v8::Value> resource_name_;
        Local<v8::Integer> resource_line_offset_;
        Local<v8::Integer> resource_column_offset_;
        v8::ScriptOriginOptions options_;
        Local<v8::Integer> script_id_;
        Local<v8::Value> source_map_url_;
        Local<v8::PrimitiveArray> host_defined_options_;
    };
    class UnboundScript {
    public:
        Local<v8::Script> BindToCurrentContext();
        int GetId();
        Local<v8::Value> GetScriptName();
        Local<v8::Value> GetSourceURL();
        Local<v8::Value> GetSourceMappingURL();
        int GetLineNumber(int code_pos);
        static const int kNoScriptId = 0;
    };
    class UnboundModuleScript {
    };
    class Location {
    public:
        int GetLineNumber()         {
            return this->line_number_;
        }
        int GetColumnNumber()         {
            return this->column_number_;
        }
        Location(int line_number, int column_number) : line_number_(line_number), column_number_(column_number)         {
        }
    private:
        int line_number_;
        int column_number_;
    };
    class Module {
    public:
        enum Status {
            kUninstantiated,
            kInstantiating,
            kInstantiated,
            kEvaluating,
            kEvaluated,
            kErrored
        };
        v8::Module::Status GetStatus() const;
        Local<v8::Value> GetException() const;
        int GetModuleRequestsLength() const;
        Local<v8::String> GetModuleRequest(int i) const;
        v8::Location GetModuleRequestLocation(int i) const;
        int GetIdentityHash() const;
        typedef MaybeLocal<v8::Module> (*ResolveCallback)(Local<v8::Context>, Local<v8::String>, Local<v8::Module>);
        Maybe<bool> InstantiateModule(Local<v8::Context> context, v8::Module::ResolveCallback callback) __attribute__((warn_unused_result));
        MaybeLocal<v8::Value> Evaluate(Local<v8::Context> context) __attribute__((warn_unused_result));
        Local<v8::Value> GetModuleNamespace();
        Local<v8::UnboundModuleScript> GetUnboundModuleScript();
    };
    class Script {
    public:
        static MaybeLocal<v8::Script> Compile(Local<v8::Context> context, Local<v8::String> source, v8::ScriptOrigin *origin = nullptr) __attribute__((warn_unused_result));
        MaybeLocal<v8::Value> Run(Local<v8::Context> context) __attribute__((warn_unused_result));
        Local<v8::UnboundScript> GetUnboundScript();
    };
    class ScriptCompiler {
    public:
        struct CachedData {
            enum BufferPolicy {
                BufferNotOwned,
                BufferOwned
            };
            CachedData() : data(nullptr), length(0), rejected(false), buffer_policy(BufferNotOwned)             {
            }
            CachedData(const uint8_t *data, int length, v8::ScriptCompiler::CachedData::BufferPolicy buffer_policy = BufferNotOwned);
            ~CachedData() noexcept;
            const uint8_t *data;
            int length;
            bool rejected;
            v8::ScriptCompiler::CachedData::BufferPolicy buffer_policy;
            CachedData(const v8::ScriptCompiler::CachedData &) = delete
            v8::ScriptCompiler::CachedData &operator=(const v8::ScriptCompiler::CachedData &) = delete
        };
        class Source {
        public:
            inline Source(Local<v8::String> source_string, const v8::ScriptOrigin &origin, v8::ScriptCompiler::CachedData *cached_data = nullptr) __attribute__((always_inline));
            inline Source(Local<v8::String> source_string, v8::ScriptCompiler::CachedData *cached_data = nullptr) __attribute__((always_inline));
            inline ~Source() noexcept __attribute__((always_inline));
            inline const v8::ScriptCompiler::CachedData *GetCachedData() const __attribute__((always_inline));
            inline const v8::ScriptOriginOptions &GetResourceOptions() const __attribute__((always_inline));
            Source(const v8::ScriptCompiler::Source &) = delete
            v8::ScriptCompiler::Source &operator=(const v8::ScriptCompiler::Source &) = delete
        private:
            friend  class ScriptCompiler;
            Local<v8::String> source_string;
            Local<v8::Value> resource_name;
            Local<v8::Integer> resource_line_offset;
            Local<v8::Integer> resource_column_offset;
            v8::ScriptOriginOptions resource_options;
            Local<v8::Value> source_map_url;
            Local<v8::PrimitiveArray> host_defined_options;
            v8::ScriptCompiler::CachedData *cached_data;
        };
        class ExternalSourceStream {
        public:
            virtual ~ExternalSourceStream() noexcept = default
            virtual size_t GetMoreData(const uint8_t **src) = 0;
            virtual bool SetBookmark();
            virtual void ResetToBookmark();
        };
        class StreamedSource {
        public:
            enum Encoding {
                ONE_BYTE,
                TWO_BYTE,
                UTF8
            };
            StreamedSource(v8::ScriptCompiler::ExternalSourceStream *source_stream, v8::ScriptCompiler::StreamedSource::Encoding encoding);
            ~StreamedSource();
            internal::ScriptStreamingData *impl() const             {
                return this->impl_.get();
            }
            StreamedSource(const v8::ScriptCompiler::StreamedSource &) = delete
            v8::ScriptCompiler::StreamedSource &operator=(const v8::ScriptCompiler::StreamedSource &) = delete
        private:
            std::unique_ptr<internal::ScriptStreamingData> impl_;
        };
        class final ScriptStreamingTask {
        public:
            void Run();
        private:
            friend  class ScriptCompiler;
            explicit ScriptStreamingTask(internal::ScriptStreamingData *data) : data_(data)             {
            }
            internal::ScriptStreamingData *data_;
        };
        enum CompileOptions {
            kNoCompileOptions = 0,
            kConsumeCodeCache,
            kEagerCompile
        };
        enum NoCacheReason {
            kNoCacheNoReason = 0,
            kNoCacheBecauseCachingDisabled,
            kNoCacheBecauseNoResource,
            kNoCacheBecauseInlineScript,
            kNoCacheBecauseModule,
            kNoCacheBecauseStreamingSource,
            kNoCacheBecauseInspector,
            kNoCacheBecauseScriptTooSmall,
            kNoCacheBecauseCacheTooCold,
            kNoCacheBecauseV8Extension,
            kNoCacheBecauseExtensionModule,
            kNoCacheBecausePacScript,
            kNoCacheBecauseInDocumentWrite,
            kNoCacheBecauseResourceWithNoCacheHandler,
            kNoCacheBecauseDeferredProduceCodeCache
        };
        static MaybeLocal<v8::UnboundScript> CompileUnboundScript(v8::Isolate *isolate, v8::ScriptCompiler::Source *source, v8::ScriptCompiler::CompileOptions options = kNoCompileOptions, v8::ScriptCompiler::NoCacheReason no_cache_reason = kNoCacheNoReason) __attribute__((warn_unused_result));
        static MaybeLocal<v8::Script> Compile(Local<v8::Context> context, v8::ScriptCompiler::Source *source, v8::ScriptCompiler::CompileOptions options = kNoCompileOptions, v8::ScriptCompiler::NoCacheReason no_cache_reason = kNoCacheNoReason) __attribute__((warn_unused_result));
        static v8::ScriptCompiler::ScriptStreamingTask *StartStreamingScript(v8::Isolate *isolate, v8::ScriptCompiler::StreamedSource *source, v8::ScriptCompiler::CompileOptions options = kNoCompileOptions);
        static MaybeLocal<v8::Script> Compile(Local<v8::Context> context, v8::ScriptCompiler::StreamedSource *source, Local<v8::String> full_source_string, const v8::ScriptOrigin &origin) __attribute__((warn_unused_result));
        static uint32_t CachedDataVersionTag();
        static MaybeLocal<v8::Module> CompileModule(v8::Isolate *isolate, v8::ScriptCompiler::Source *source, v8::ScriptCompiler::CompileOptions options = kNoCompileOptions, v8::ScriptCompiler::NoCacheReason no_cache_reason = kNoCacheNoReason) __attribute__((warn_unused_result));
        static MaybeLocal<v8::Function> CompileFunctionInContext(Local<v8::Context> context, v8::ScriptCompiler::Source *source, size_t arguments_count, Local<v8::String> arguments[], size_t context_extension_count, Local<v8::Object> context_extensions[], v8::ScriptCompiler::CompileOptions options = kNoCompileOptions, v8::ScriptCompiler::NoCacheReason no_cache_reason = kNoCacheNoReason) __attribute__((warn_unused_result));
        static v8::ScriptCompiler::CachedData *CreateCodeCache(Local<v8::UnboundScript> unbound_script);
        static v8::ScriptCompiler::CachedData *CreateCodeCache(Local<v8::UnboundModuleScript> unbound_module_script);
        static v8::ScriptCompiler::CachedData *CreateCodeCacheForFunction(Local<v8::Function> function);
    private:
        static MaybeLocal<v8::UnboundScript> CompileUnboundInternal(v8::Isolate *isolate, v8::ScriptCompiler::Source *source, v8::ScriptCompiler::CompileOptions options, v8::ScriptCompiler::NoCacheReason no_cache_reason) __attribute__((warn_unused_result));
    };
    class Message {
    public:
        Local<v8::String> Get() const;
        v8::Isolate *GetIsolate() const;
        MaybeLocal<v8::String> GetSourceLine(Local<v8::Context> context) const __attribute__((warn_unused_result));
        v8::ScriptOrigin GetScriptOrigin() const;
        Local<v8::Value> GetScriptResourceName() const;
        Local<v8::StackTrace> GetStackTrace() const;
        Maybe<int> GetLineNumber(Local<v8::Context> context) const __attribute__((warn_unused_result));
        int GetStartPosition() const;
        int GetEndPosition() const;
        int ErrorLevel() const;
        int GetStartColumn() const;
        Maybe<int> GetStartColumn(Local<v8::Context> context) const __attribute__((warn_unused_result));
        int GetEndColumn() const;
        Maybe<int> GetEndColumn(Local<v8::Context> context) const __attribute__((warn_unused_result));
        bool IsSharedCrossOrigin() const;
        bool IsOpaque() const;
        static void PrintCurrentStackTrace(v8::Isolate *isolate, FILE *out);
        static const int kNoLineNumberInfo = 0;
        static const int kNoColumnInfo = 0;
        static const int kNoScriptIdInfo = 0;
    };
    class StackTrace {
    public:
        enum StackTraceOptions {
            kLineNumber = 1,
            kColumnOffset = 1 << 1 | kLineNumber,
            kScriptName = 1 << 2,
            kFunctionName = 1 << 3,
            kIsEval = 1 << 4,
            kIsConstructor = 1 << 5,
            kScriptNameOrSourceURL = 1 << 6,
            kScriptId = 1 << 7,
            kExposeFramesAcrossSecurityOrigins = 1 << 8,
            kOverview = kLineNumber | kColumnOffset | kScriptName | kFunctionName,
            kDetailed = kOverview | kIsEval | kIsConstructor | kScriptNameOrSourceURL
        };
        Local<v8::StackFrame> GetFrame(v8::Isolate *isolate, uint32_t index) const;
        int GetFrameCount() const;
        static Local<v8::StackTrace> CurrentStackTrace(v8::Isolate *isolate, int frame_limit, v8::StackTrace::StackTraceOptions options = kDetailed);
    };
    class StackFrame {
    public:
        int GetLineNumber() const;
        int GetColumn() const;
        int GetScriptId() const;
        Local<v8::String> GetScriptName() const;
        Local<v8::String> GetScriptNameOrSourceURL() const;
        Local<v8::String> GetFunctionName() const;
        bool IsEval() const;
        bool IsConstructor() const;
        bool IsWasm() const;
    };
    enum StateTag {
        JS,
        GC,
        PARSER,
        BYTECODE_COMPILER,
        COMPILER,
        OTHER,
        EXTERNAL,
        IDLE
    };
    struct RegisterState {
        RegisterState() : pc(nullptr), sp(nullptr), fp(nullptr)         {
        }
        void *pc;
        void *sp;
        void *fp;
    };
    struct SampleInfo {
        size_t frames_count;
        v8::StateTag vm_state;
        void *external_callback_entry;
    };
    struct MemoryRange {
        const void *start = nullptr;
        size_t length_in_bytes = 0;
    };
    struct JSEntryStub {
        v8::MemoryRange code;
    };
    struct UnwindState {
        v8::MemoryRange code_range;
        v8::MemoryRange embedded_code_range;
        v8::JSEntryStub js_entry_stub;
    };
    class JSON {
    public:
        static MaybeLocal<v8::Value> Parse(Local<v8::Context> context, Local<v8::String> json_string) __attribute__((warn_unused_result));
        static MaybeLocal<v8::String> Stringify(Local<v8::Context> context, Local<v8::Value> json_object, Local<v8::String> gap = Local<v8::String>()) __attribute__((warn_unused_result));
    };
    class ValueSerializer {
    public:
        class Delegate {
        public:
            virtual ~Delegate() noexcept = default
            virtual void ThrowDataCloneError(Local<v8::String> message) = 0;
            virtual Maybe<bool> WriteHostObject(v8::Isolate *isolate, Local<v8::Object> object);
            virtual Maybe<uint32_t> GetSharedArrayBufferId(v8::Isolate *isolate, Local<v8::SharedArrayBuffer> shared_array_buffer);
            virtual Maybe<uint32_t> GetWasmModuleTransferId(v8::Isolate *isolate, Local<v8::WasmModuleObject> module);
            virtual void *ReallocateBufferMemory(void *old_buffer, size_t size, size_t *actual_size);
            virtual void FreeBufferMemory(void *buffer);
        };
        explicit ValueSerializer(v8::Isolate *isolate);
        ValueSerializer(v8::Isolate *isolate, v8::ValueSerializer::Delegate *delegate);
        ~ValueSerializer();
        void WriteHeader();
        Maybe<bool> WriteValue(Local<v8::Context> context, Local<v8::Value> value) __attribute__((warn_unused_result));
        std::pair<uint8_t *, size_t> Release() __attribute__((warn_unused_result));
        void TransferArrayBuffer(uint32_t transfer_id, Local<v8::ArrayBuffer> array_buffer);
        void SetTreatArrayBufferViewsAsHostObjects(bool mode);
        void WriteUint32(uint32_t value);
        void WriteUint64(uint64_t value);
        void WriteDouble(double value);
        void WriteRawBytes(const void *source, size_t length);
    private:
        ValueSerializer(const v8::ValueSerializer &) = delete
        void operator=(const v8::ValueSerializer &) = delete
        struct PrivateData;
        v8::ValueSerializer::PrivateData *private_;
    };
    class ValueDeserializer {
    public:
        class Delegate {
        public:
            virtual ~Delegate() noexcept = default
            virtual MaybeLocal<v8::Object> ReadHostObject(v8::Isolate *isolate);
            virtual MaybeLocal<v8::WasmModuleObject> GetWasmModuleFromId(v8::Isolate *isolate, uint32_t transfer_id);
            virtual MaybeLocal<v8::SharedArrayBuffer> GetSharedArrayBufferFromId(v8::Isolate *isolate, uint32_t clone_id);
        };
        ValueDeserializer(v8::Isolate *isolate, const uint8_t *data, size_t size);
        ValueDeserializer(v8::Isolate *isolate, const uint8_t *data, size_t size, v8::ValueDeserializer::Delegate *delegate);
        ~ValueDeserializer();
        Maybe<bool> ReadHeader(Local<v8::Context> context) __attribute__((warn_unused_result));
        MaybeLocal<v8::Value> ReadValue(Local<v8::Context> context) __attribute__((warn_unused_result));
        void TransferArrayBuffer(uint32_t transfer_id, Local<v8::ArrayBuffer> array_buffer);
        void TransferSharedArrayBuffer(uint32_t id, Local<v8::SharedArrayBuffer> shared_array_buffer);
        void SetSupportsLegacyWireFormat(bool supports_legacy_wire_format);
        void SetExpectInlineWasm(bool allow_inline_wasm);
        uint32_t GetWireFormatVersion() const;
        bool ReadUint32(uint32_t *value) __attribute__((warn_unused_result));
        bool ReadUint64(uint64_t *value) __attribute__((warn_unused_result));
        bool ReadDouble(double *value) __attribute__((warn_unused_result));
        bool ReadRawBytes(size_t length, const void **data) __attribute__((warn_unused_result));
    private:
        ValueDeserializer(const v8::ValueDeserializer &) = delete
        void operator=(const v8::ValueDeserializer &) = delete
        struct PrivateData;
        v8::ValueDeserializer::PrivateData *private_;
    };
    class Value : public v8::Data {
    public:
        inline bool IsUndefined() const __attribute__((always_inline));
        inline bool IsNull() const __attribute__((always_inline));
        inline bool IsNullOrUndefined() const __attribute__((always_inline));
        bool IsTrue() const;
        bool IsFalse() const;
        bool IsName() const;
        inline bool IsString() const __attribute__((always_inline));
        bool IsSymbol() const;
        bool IsFunction() const;
        bool IsArray() const;
        bool IsObject() const;
        bool IsBigInt() const;
        bool IsBoolean() const;
        bool IsNumber() const;
        bool IsExternal() const;
        bool IsInt32() const;
        bool IsUint32() const;
        bool IsDate() const;
        bool IsArgumentsObject() const;
        bool IsBigIntObject() const;
        bool IsBooleanObject() const;
        bool IsNumberObject() const;
        bool IsStringObject() const;
        bool IsSymbolObject() const;
        bool IsNativeError() const;
        bool IsRegExp() const;
        bool IsAsyncFunction() const;
        bool IsGeneratorFunction() const;
        bool IsGeneratorObject() const;
        bool IsPromise() const;
        bool IsMap() const;
        bool IsSet() const;
        bool IsMapIterator() const;
        bool IsSetIterator() const;
        bool IsWeakMap() const;
        bool IsWeakSet() const;
        bool IsArrayBuffer() const;
        bool IsArrayBufferView() const;
        bool IsTypedArray() const;
        bool IsUint8Array() const;
        bool IsUint8ClampedArray() const;
        bool IsInt8Array() const;
        bool IsUint16Array() const;
        bool IsInt16Array() const;
        bool IsUint32Array() const;
        bool IsInt32Array() const;
        bool IsFloat32Array() const;
        bool IsFloat64Array() const;
        bool IsBigInt64Array() const;
        bool IsBigUint64Array() const;
        bool IsDataView() const;
        bool IsSharedArrayBuffer() const;
        bool IsProxy() const;
        bool IsWebAssemblyCompiledModule() const;
        bool IsModuleNamespaceObject() const;
        MaybeLocal<v8::BigInt> ToBigInt(Local<v8::Context> context) const __attribute__((warn_unused_result));
        MaybeLocal<v8::Boolean> ToBoolean(Local<v8::Context> context) const __attribute__((warn_unused_result));
        MaybeLocal<v8::Number> ToNumber(Local<v8::Context> context) const __attribute__((warn_unused_result));
        MaybeLocal<v8::String> ToString(Local<v8::Context> context) const __attribute__((warn_unused_result));
        MaybeLocal<v8::String> ToDetailString(Local<v8::Context> context) const __attribute__((warn_unused_result));
        MaybeLocal<v8::Object> ToObject(Local<v8::Context> context) const __attribute__((warn_unused_result));
        MaybeLocal<v8::Integer> ToInteger(Local<v8::Context> context) const __attribute__((warn_unused_result));
        MaybeLocal<v8::Uint32> ToUint32(Local<v8::Context> context) const __attribute__((warn_unused_result));
        MaybeLocal<v8::Int32> ToInt32(Local<v8::Context> context) const __attribute__((warn_unused_result));
        Local<v8::Boolean> ToBoolean(v8::Isolate *isolate) const;
        Local<v8::Number> ToNumber(v8::Isolate *isolate) const;
        Local<v8::String> ToString(v8::Isolate *isolate) const;
        Local<v8::Object> ToObject(v8::Isolate *isolate) const;
        Local<v8::Integer> ToInteger(v8::Isolate *isolate) const;
        Local<v8::Int32> ToInt32(v8::Isolate *isolate) const;
        MaybeLocal<v8::Uint32> ToArrayIndex(Local<v8::Context> context) const __attribute__((warn_unused_result));
        bool BooleanValue(v8::Isolate *isolate) const;
        Maybe<bool> BooleanValue(Local<v8::Context> context) const __attribute__((warn_unused_result));
        Maybe<double> NumberValue(Local<v8::Context> context) const __attribute__((warn_unused_result));
        Maybe<int64_t> IntegerValue(Local<v8::Context> context) const __attribute__((warn_unused_result));
        Maybe<uint32_t> Uint32Value(Local<v8::Context> context) const __attribute__((warn_unused_result));
        Maybe<int32_t> Int32Value(Local<v8::Context> context) const __attribute__((warn_unused_result));
        Maybe<bool> Equals(Local<v8::Context> context, Local<v8::Value> that) const __attribute__((warn_unused_result));
        bool StrictEquals(Local<v8::Value> that) const;
        bool SameValue(Local<v8::Value> that) const;
        template <class T> static inline v8::Value *Cast(T *value) __attribute__((always_inline));
        Local<v8::String> TypeOf(v8::Isolate *);
        Maybe<bool> InstanceOf(Local<v8::Context> context, Local<v8::Object> object);
    private:
        inline bool QuickIsUndefined() const __attribute__((always_inline));
        inline bool QuickIsNull() const __attribute__((always_inline));
        inline bool QuickIsNullOrUndefined() const __attribute__((always_inline));
        inline bool QuickIsString() const __attribute__((always_inline));
        bool FullIsUndefined() const;
        bool FullIsNull() const;
        bool FullIsString() const;
    };
    class Primitive : public v8::Value {
    };
    class Boolean : public v8::Primitive {
    public:
        bool Value() const;
        static inline v8::Boolean *Cast(v8::Value *obj) __attribute__((always_inline));
        static inline Local<v8::Boolean> New(v8::Isolate *isolate, bool value) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    class Name : public v8::Primitive {
    public:
        int GetIdentityHash();
        static inline v8::Name *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    enum class NewStringType : int {
        kNormal,
        kInternalized
    };
    class String : public v8::Name {
    public:
        static constexpr int kMaxLength = internal::kApiTaggedSize == 4 ? (1 << 28) - 16 : internal::kSmiMaxValue / 2 - 24;
        enum Encoding {
            UNKNOWN_ENCODING = 1,
            TWO_BYTE_ENCODING = 0,
            ONE_BYTE_ENCODING = 8
        };
        int Length() const;
        int Utf8Length(v8::Isolate *isolate) const;
        bool IsOneByte() const;
        bool ContainsOnlyOneByte() const;
        enum WriteOptions {
            NO_OPTIONS = 0,
            HINT_MANY_WRITES_EXPECTED = 1,
            NO_NULL_TERMINATION = 2,
            PRESERVE_ONE_BYTE_NULL = 4,
            REPLACE_INVALID_UTF8 = 8
        };
        int Write(v8::Isolate *isolate, uint16_t *buffer, int start = 0, int length = -1, int options = NO_OPTIONS) const;
        int WriteOneByte(v8::Isolate *isolate, uint8_t *buffer, int start = 0, int length = -1, int options = NO_OPTIONS) const;
        int WriteUtf8(v8::Isolate *isolate, char *buffer, int length = -1, int *nchars_ref = nullptr, int options = NO_OPTIONS) const;
        static inline Local<v8::String> Empty(v8::Isolate *isolate) __attribute__((always_inline));
        bool IsExternal() const;
        bool IsExternalOneByte() const;
        class ExternalStringResourceBase {
        public:
            virtual ~ExternalStringResourceBase() noexcept = default            virtual bool IsCacheable() const             {
                return true;
            }
        protected:
            ExternalStringResourceBase() = default
            virtual void Dispose()             {
                delete this;
            }
            virtual void Lock() const             {
            }
            virtual void Unlock() const             {
            }
            ExternalStringResourceBase(const v8::String::ExternalStringResourceBase &) = delete
            void operator=(const v8::String::ExternalStringResourceBase &) = delete
        private:
            friend  class internal::Heap;
            friend  class v8::String;
            friend  class internal::ScopedExternalStringLock;
        };
        class ExternalStringResource : public v8::String::ExternalStringResourceBase {
        public:
            ~ExternalStringResource() noexcept override = default
            virtual const uint16_t *data() const = 0;
            virtual size_t length() const = 0;
        protected:
            ExternalStringResource() = default
        };
        class ExternalOneByteStringResource : public v8::String::ExternalStringResourceBase {
        public:
            ~ExternalOneByteStringResource() noexcept override = default            virtual const char *data() const = 0;
            virtual size_t length() const = 0;
        protected:
            ExternalOneByteStringResource() = default
        };
        inline v8::String::ExternalStringResourceBase *GetExternalStringResourceBase(v8::String::Encoding *encoding_out) const __attribute__((always_inline));
        inline v8::String::ExternalStringResource *GetExternalStringResource() const __attribute__((always_inline));
        const v8::String::ExternalOneByteStringResource *GetExternalOneByteStringResource() const;
        static inline v8::String *Cast(v8::Value *obj) __attribute__((always_inline));
        enum NewStringType {
            kNormalString = static_cast<int>(v8::NewStringType::kNormal),
            kInternalizedString = static_cast<int>(v8::NewStringType::kInternalized)
        };
        static Local<v8::String> NewFromUtf8(v8::Isolate *isolate, const char *data, v8::String::NewStringType type = kNormalString, int length = -1);
        static MaybeLocal<v8::String> NewFromUtf8(v8::Isolate *isolate, const char *data, v8::NewStringType type, int length = -1) __attribute__((warn_unused_result));
        static MaybeLocal<v8::String> NewFromOneByte(v8::Isolate *isolate, const uint8_t *data, v8::NewStringType type, int length = -1) __attribute__((warn_unused_result));
        static Local<v8::String> NewFromTwoByte(v8::Isolate *isolate, const uint16_t *data, v8::String::NewStringType type = kNormalString, int length = -1);
        static MaybeLocal<v8::String> NewFromTwoByte(v8::Isolate *isolate, const uint16_t *data, v8::NewStringType type, int length = -1) __attribute__((warn_unused_result));
        static Local<v8::String> Concat(v8::Isolate *isolate, Local<v8::String> left, Local<v8::String> right);
        static MaybeLocal<v8::String> NewExternalTwoByte(v8::Isolate *isolate, v8::String::ExternalStringResource *resource) __attribute__((warn_unused_result));
        bool MakeExternal(v8::String::ExternalStringResource *resource);
        static Local<v8::String> NewExternal(v8::Isolate *isolate, v8::String::ExternalOneByteStringResource *resource);
        static MaybeLocal<v8::String> NewExternalOneByte(v8::Isolate *isolate, v8::String::ExternalOneByteStringResource *resource) __attribute__((warn_unused_result));
        bool MakeExternal(v8::String::ExternalOneByteStringResource *resource);
        bool CanMakeExternal();
        bool StringEquals(Local<v8::String> str);
        class Utf8Value {
        public:
            Utf8Value(v8::Isolate *isolate, Local<v8::Value> obj);
            ~Utf8Value();
            char *operator*()             {
                return this->str_;
            }
            const char *operator*() const             {
                return this->str_;
            }
            int length() const             {
                return this->length_;
            }
            Utf8Value(const v8::String::Utf8Value &) = delete
            void operator=(const v8::String::Utf8Value &) = delete
        private:
            char *str_;
            int length_;
        };
        class Value {
        public:
            Value(v8::Isolate *isolate, Local<v8::Value> obj);
            ~Value();
            uint16_t *operator*()             {
                return this->str_;
            }
            const uint16_t *operator*() const             {
                return this->str_;
            }
            int length() const             {
                return this->length_;
            }
            Value(const v8::String::Value &) = delete
            void operator=(const v8::String::Value &) = delete
        private:
            uint16_t *str_;
            int length_;
        };
    private:
        void VerifyExternalStringResourceBase(v8::String::ExternalStringResourceBase *v, v8::String::Encoding encoding) const;
        void VerifyExternalStringResource(v8::String::ExternalStringResource *val) const;
        v8::String::ExternalStringResource *GetExternalStringResourceSlow() const;
        v8::String::ExternalStringResourceBase *GetExternalStringResourceBaseSlow(String::Encoding *encoding_out) const;
        static void CheckCast(v8::Value *obj);
    };
    class Symbol : public v8::Name {
    public:
        Local<v8::Value> Name() const;
        static Local<v8::Symbol> New(v8::Isolate *isolate, Local<v8::String> name = Local<v8::String>());
        static Local<v8::Symbol> For(v8::Isolate *isolate, Local<v8::String> name);
        static Local<v8::Symbol> ForApi(v8::Isolate *isolate, Local<v8::String> name);
        static Local<v8::Symbol> GetAsyncIterator(v8::Isolate *isolate);
        static Local<v8::Symbol> GetHasInstance(v8::Isolate *isolate);
        static Local<v8::Symbol> GetIsConcatSpreadable(v8::Isolate *isolate);
        static Local<v8::Symbol> GetIterator(v8::Isolate *isolate);
        static Local<v8::Symbol> GetMatch(v8::Isolate *isolate);
        static Local<v8::Symbol> GetReplace(v8::Isolate *isolate);
        static Local<v8::Symbol> GetSearch(v8::Isolate *isolate);
        static Local<v8::Symbol> GetSplit(v8::Isolate *isolate);
        static Local<v8::Symbol> GetToPrimitive(v8::Isolate *isolate);
        static Local<v8::Symbol> GetToStringTag(v8::Isolate *isolate);
        static Local<v8::Symbol> GetUnscopables(v8::Isolate *isolate);
        static inline v8::Symbol *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Symbol();
        static void CheckCast(v8::Value *obj);
    };
    class Private : public v8::Data {
    public:
        Local<v8::Value> Name() const;
        static Local<v8::Private> New(v8::Isolate *isolate, Local<v8::String> name = Local<v8::String>());
        static Local<v8::Private> ForApi(v8::Isolate *isolate, Local<v8::String> name);
        static inline v8::Private *Cast(v8::Data *data) __attribute__((always_inline));
    private:
        Private();
        static void CheckCast(v8::Data *that);
    };
    class Number : public v8::Primitive {
    public:
        double Value() const;
        static Local<v8::Number> New(v8::Isolate *isolate, double value);
        static inline v8::Number *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Number();
        static void CheckCast(v8::Value *obj);
    };
    class Integer : public v8::Number {
    public:
        static Local<v8::Integer> New(v8::Isolate *isolate, int32_t value);
        static Local<v8::Integer> NewFromUnsigned(v8::Isolate *isolate, uint32_t value);
        int64_t Value() const;
        static inline v8::Integer *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Integer();
        static void CheckCast(v8::Value *obj);
    };
    class Int32 : public v8::Integer {
    public:
        int32_t Value() const;
        static inline v8::Int32 *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Int32();
        static void CheckCast(v8::Value *obj);
    };
    class Uint32 : public v8::Integer {
    public:
        uint32_t Value() const;
        static inline v8::Uint32 *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Uint32();
        static void CheckCast(v8::Value *obj);
    };
    class BigInt : public v8::Primitive {
    public:
        static Local<v8::BigInt> New(v8::Isolate *isolate, int64_t value);
        static Local<v8::BigInt> NewFromUnsigned(v8::Isolate *isolate, uint64_t value);
        static MaybeLocal<v8::BigInt> NewFromWords(Local<v8::Context> context, int sign_bit, int word_count, const uint64_t *words);
        uint64_t Uint64Value(bool *lossless = nullptr) const;
        int64_t Int64Value(bool *lossless = nullptr) const;
        int WordCount() const;
        void ToWordsArray(int *sign_bit, int *word_count, uint64_t *words) const;
        static inline v8::BigInt *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        BigInt();
        static void CheckCast(v8::Value *obj);
    };
    enum PropertyAttribute {
        None = 0,
        ReadOnly = 1 << 0,
        DontEnum = 1 << 1,
        DontDelete = 1 << 2
    };
    typedef void (*AccessorGetterCallback)(Local<v8::String>, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*AccessorNameGetterCallback)(Local<v8::Name>, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*AccessorSetterCallback)(Local<v8::String>, Local<v8::Value>, const PropertyCallbackInfo<void> &);
    typedef void (*AccessorNameSetterCallback)(Local<v8::Name>, Local<v8::Value>, const PropertyCallbackInfo<void> &);
    enum AccessControl {
        DEFAULT = 0,
        ALL_CAN_READ = 1,
        ALL_CAN_WRITE = 1 << 1,
        PROHIBITS_OVERWRITING = 1 << 2
    };
    enum PropertyFilter {
        ALL_PROPERTIES = 0,
        ONLY_WRITABLE = 1,
        ONLY_ENUMERABLE = 2,
        ONLY_CONFIGURABLE = 4,
        SKIP_STRINGS = 8,
        SKIP_SYMBOLS = 16
    };
    enum class SideEffectType : int {
        kHasSideEffect,
        kHasNoSideEffect,
        kHasSideEffectToReceiver
    };
    enum class KeyCollectionMode : int {
        kOwnOnly,
        kIncludePrototypes
    };
    enum class IndexFilter : int {
        kIncludeIndices,
        kSkipIndices
    };
    enum class KeyConversionMode : int {
        kConvertToString,
        kKeepNumbers
    };
    enum class IntegrityLevel : int {
        kFrozen,
        kSealed
    };
    class Object : public v8::Value {
    public:
        bool Set(Local<v8::Value> key, Local<v8::Value> value);
        Maybe<bool> Set(Local<v8::Context> context, Local<v8::Value> key, Local<v8::Value> value) __attribute__((warn_unused_result));
        bool Set(uint32_t index, Local<v8::Value> value);
        Maybe<bool> Set(Local<v8::Context> context, uint32_t index, Local<v8::Value> value) __attribute__((warn_unused_result));
        Maybe<bool> CreateDataProperty(Local<v8::Context> context, Local<v8::Name> key, Local<v8::Value> value) __attribute__((warn_unused_result));
        Maybe<bool> CreateDataProperty(Local<v8::Context> context, uint32_t index, Local<v8::Value> value) __attribute__((warn_unused_result));
        Maybe<bool> DefineOwnProperty(Local<v8::Context> context, Local<v8::Name> key, Local<v8::Value> value, v8::PropertyAttribute attributes = None) __attribute__((warn_unused_result));
        Maybe<bool> DefineProperty(Local<v8::Context> context, Local<v8::Name> key, v8::PropertyDescriptor &descriptor) __attribute__((warn_unused_result));
        Local<v8::Value> Get(Local<v8::Value> key);
        MaybeLocal<v8::Value> Get(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        Local<v8::Value> Get(uint32_t index);
        MaybeLocal<v8::Value> Get(Local<v8::Context> context, uint32_t index) __attribute__((warn_unused_result));
        Maybe<v8::PropertyAttribute> GetPropertyAttributes(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        MaybeLocal<v8::Value> GetOwnPropertyDescriptor(Local<v8::Context> context, Local<v8::Name> key) __attribute__((warn_unused_result));
        Maybe<bool> Has(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        Maybe<bool> Delete(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        Maybe<bool> Has(Local<v8::Context> context, uint32_t index) __attribute__((warn_unused_result));
        Maybe<bool> Delete(Local<v8::Context> context, uint32_t index) __attribute__((warn_unused_result));
        Maybe<bool> SetAccessor(Local<v8::Context> context, Local<v8::Name> name, v8::AccessorNameGetterCallback getter, v8::AccessorNameSetterCallback setter = nullptr, MaybeLocal<v8::Value> data = MaybeLocal<v8::Value>(), v8::AccessControl settings = DEFAULT, v8::PropertyAttribute attribute = None, v8::SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect, v8::SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect) __attribute__((warn_unused_result));
        void SetAccessorProperty(Local<v8::Name> name, Local<v8::Function> getter, Local<v8::Function> setter = Local<v8::Function>(), v8::PropertyAttribute attribute = None, v8::AccessControl settings = DEFAULT);
        Maybe<bool> SetNativeDataProperty(Local<v8::Context> context, Local<v8::Name> name, v8::AccessorNameGetterCallback getter, v8::AccessorNameSetterCallback setter = nullptr, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyAttribute attributes = None, v8::SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect, v8::SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect) __attribute__((warn_unused_result));
        Maybe<bool> SetLazyDataProperty(Local<v8::Context> context, Local<v8::Name> name, v8::AccessorNameGetterCallback getter, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyAttribute attributes = None, v8::SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect, v8::SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect) __attribute__((warn_unused_result));
        Maybe<bool> HasPrivate(Local<v8::Context> context, Local<v8::Private> key);
        Maybe<bool> SetPrivate(Local<v8::Context> context, Local<v8::Private> key, Local<v8::Value> value);
        Maybe<bool> DeletePrivate(Local<v8::Context> context, Local<v8::Private> key);
        MaybeLocal<v8::Value> GetPrivate(Local<v8::Context> context, Local<v8::Private> key);
        MaybeLocal<v8::Array> GetPropertyNames(Local<v8::Context> context) __attribute__((warn_unused_result));
        MaybeLocal<v8::Array> GetPropertyNames(Local<v8::Context> context, v8::KeyCollectionMode mode, v8::PropertyFilter property_filter, v8::IndexFilter index_filter, v8::KeyConversionMode key_conversion = KeyConversionMode::kKeepNumbers) __attribute__((warn_unused_result));
        MaybeLocal<v8::Array> GetOwnPropertyNames(Local<v8::Context> context) __attribute__((warn_unused_result));
        MaybeLocal<v8::Array> GetOwnPropertyNames(Local<v8::Context> context, v8::PropertyFilter filter, v8::KeyConversionMode key_conversion = KeyConversionMode::kKeepNumbers) __attribute__((warn_unused_result));
        Local<v8::Value> GetPrototype();
        Maybe<bool> SetPrototype(Local<v8::Context> context, Local<v8::Value> prototype) __attribute__((warn_unused_result));
        Local<v8::Object> FindInstanceInPrototypeChain(Local<v8::FunctionTemplate> tmpl);
        MaybeLocal<v8::String> ObjectProtoToString(Local<v8::Context> context) __attribute__((warn_unused_result));
        Local<v8::String> GetConstructorName();
        Maybe<bool> SetIntegrityLevel(Local<v8::Context> context, v8::IntegrityLevel level);
        int InternalFieldCount();
        static inline int InternalFieldCount(const PersistentBase<v8::Object> &object) __attribute__((always_inline))         {
            return object.val_->InternalFieldCount();
        }
        static inline int InternalFieldCount(const TracedGlobal<v8::Object> &object) __attribute__((always_inline))         {
            return object.val_->InternalFieldCount();
        }
        inline Local<v8::Value> GetInternalField(int index) __attribute__((always_inline));
        void SetInternalField(int index, Local<v8::Value> value);
        inline void *GetAlignedPointerFromInternalField(int index) __attribute__((always_inline));
        static inline void *GetAlignedPointerFromInternalField(const PersistentBase<v8::Object> &object, int index) __attribute__((always_inline))         {
            return object.val_->GetAlignedPointerFromInternalField(index);
        }
        static inline void *GetAlignedPointerFromInternalField(const TracedGlobal<v8::Object> &object, int index) __attribute__((always_inline))         {
            return object.val_->GetAlignedPointerFromInternalField(index);
        }
        void SetAlignedPointerInInternalField(int index, void *value);
        void SetAlignedPointerInInternalFields(int argc, int indices[], void *values[]);
        Maybe<bool> HasOwnProperty(Local<v8::Context> context, Local<v8::Name> key) __attribute__((warn_unused_result));
        Maybe<bool> HasOwnProperty(Local<v8::Context> context, uint32_t index) __attribute__((warn_unused_result));
        Maybe<bool> HasRealNamedProperty(Local<v8::Context> context, Local<v8::Name> key) __attribute__((warn_unused_result));
        Maybe<bool> HasRealIndexedProperty(Local<v8::Context> context, uint32_t index) __attribute__((warn_unused_result));
        Maybe<bool> HasRealNamedCallbackProperty(Local<v8::Context> context, Local<v8::Name> key) __attribute__((warn_unused_result));
        MaybeLocal<v8::Value> GetRealNamedPropertyInPrototypeChain(Local<v8::Context> context, Local<v8::Name> key) __attribute__((warn_unused_result));
        Maybe<v8::PropertyAttribute> GetRealNamedPropertyAttributesInPrototypeChain(Local<v8::Context> context, Local<v8::Name> key) __attribute__((warn_unused_result));
        MaybeLocal<v8::Value> GetRealNamedProperty(Local<v8::Context> context, Local<v8::Name> key) __attribute__((warn_unused_result));
        Maybe<v8::PropertyAttribute> GetRealNamedPropertyAttributes(Local<v8::Context> context, Local<v8::Name> key) __attribute__((warn_unused_result));
        bool HasNamedLookupInterceptor();
        bool HasIndexedLookupInterceptor();
        int GetIdentityHash();
        Local<v8::Object> Clone();
        Local<v8::Context> CreationContext();
        static inline Local<v8::Context> CreationContext(const PersistentBase<v8::Object> &object) __attribute__((always_inline))         {
            return object.val_->CreationContext();
        }
        bool IsCallable();
        bool IsConstructor();
        MaybeLocal<v8::Value> CallAsFunction(Local<v8::Context> context, Local<v8::Value> recv, int argc, Local<v8::Value> argv[]) __attribute__((warn_unused_result));
        MaybeLocal<v8::Value> CallAsConstructor(Local<v8::Context> context, int argc, Local<v8::Value> argv[]) __attribute__((warn_unused_result));
        v8::Isolate *GetIsolate();
        MaybeLocal<v8::Array> PreviewEntries(bool *is_key_value);
        static Local<v8::Object> New(v8::Isolate *isolate);
        static Local<v8::Object> New(v8::Isolate *isolate, Local<v8::Value> prototype_or_null, Local<v8::Name> *names, Local<v8::Value> *values, size_t length);
        static inline v8::Object *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Object();
        static void CheckCast(v8::Value *obj);
        Local<v8::Value> SlowGetInternalField(int index);
        void *SlowGetAlignedPointerFromInternalField(int index);
    };
    class Array : public v8::Object {
    public:
        uint32_t Length() const;
        static Local<v8::Array> New(v8::Isolate *isolate, int length = 0);
        static Local<v8::Array> New(v8::Isolate *isolate, Local<v8::Value> *elements, size_t length);
        static inline v8::Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Array();
        static void CheckCast(v8::Value *obj);
    };
    class Map : public v8::Object {
    public:
        size_t Size() const;
        void Clear();
        MaybeLocal<v8::Value> Get(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        MaybeLocal<v8::Map> Set(Local<v8::Context> context, Local<v8::Value> key, Local<v8::Value> value) __attribute__((warn_unused_result));
        Maybe<bool> Has(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        Maybe<bool> Delete(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        Local<v8::Array> AsArray() const;
        static Local<v8::Map> New(v8::Isolate *isolate);
        static inline v8::Map *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Map();
        static void CheckCast(v8::Value *obj);
    };
    class Set : public v8::Object {
    public:
        size_t Size() const;
        void Clear();
        MaybeLocal<v8::Set> Add(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        Maybe<bool> Has(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        Maybe<bool> Delete(Local<v8::Context> context, Local<v8::Value> key) __attribute__((warn_unused_result));
        Local<v8::Array> AsArray() const;
        static Local<v8::Set> New(v8::Isolate *isolate);
        static inline v8::Set *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Set();
        static void CheckCast(v8::Value *obj);
    };
    template <typename T> class ReturnValue {
    public:
        template <class S> inline ReturnValue<T>(const ReturnValue<S> &that) __attribute__((always_inline))         template <typename S> inline void Set(const Persistent<S> &handle) __attribute__((always_inline));
        template <typename S> inline void Set(const Global<S> &handle) __attribute__((always_inline));
        template <typename S> inline void Set(const TracedGlobal<S> &handle) __attribute__((always_inline));
        template <typename S> inline void Set(const Local<S> handle) __attribute__((always_inline));
        inline void Set(bool value) __attribute__((always_inline));
        inline void Set(double i) __attribute__((always_inline));
        inline void Set(int32_t i) __attribute__((always_inline));
        inline void Set(uint32_t i) __attribute__((always_inline));
        inline void SetNull() __attribute__((always_inline));
        inline void SetUndefined() __attribute__((always_inline));
        inline void SetEmptyString() __attribute__((always_inline));
        inline v8::Isolate *GetIsolate() const __attribute__((always_inline));
        template <typename S> inline void Set(S *whatever) __attribute__((always_inline));
        inline Local<v8::Value> Get() const __attribute__((always_inline));
    private:
        friend template <class F> class ReturnValue;
        friend template <class F> class FunctionCallbackInfo;
        friend template <class F> class PropertyCallbackInfo;
        friend template <class F, class G, class H> class PersistentValueMapBase;
        inline void SetInternal(internal::Address value) __attribute__((always_inline))         inline internal::Address GetDefaultValue() __attribute__((always_inline));
        inline explicit ReturnValue<T>(internal::Address *slot) __attribute__((always_inline));
        internal::Address *value_;
    };
    template <typename T> class FunctionCallbackInfo {
    public:
        inline int Length() const __attribute__((always_inline));
        inline Local<v8::Value> operator[](int i) const __attribute__((always_inline));
        inline Local<v8::Object> This() const __attribute__((always_inline));
        inline Local<v8::Object> Holder() const __attribute__((always_inline));
        inline Local<v8::Value> NewTarget() const __attribute__((always_inline));
        inline bool IsConstructCall() const __attribute__((always_inline));
        inline Local<v8::Value> Data() const __attribute__((always_inline));
        inline v8::Isolate *GetIsolate() const __attribute__((always_inline));
        inline ReturnValue<T> GetReturnValue() const __attribute__((always_inline));
        static const int kArgsLength = 6;
    protected:
        friend  class internal::FunctionCallbackArguments;
        friend  class internal::CustomArguments<FunctionCallbackInfo<T> >;
        friend  class debug::ConsoleCallArguments;
        static const int kHolderIndex = 0;
        static const int kIsolateIndex = 1;
        static const int kReturnValueDefaultValueIndex = 2;
        static const int kReturnValueIndex = 3;
        static const int kDataIndex = 4;
        static const int kNewTargetIndex = 5;
        inline FunctionCallbackInfo<T>(internal::Address *implicit_args, internal::Address *values, int length) __attribute__((always_inline));
        internal::Address *implicit_args_;
        internal::Address *values_;
        int length_;
    };
    template <typename T> class PropertyCallbackInfo {
    public:
        inline v8::Isolate *GetIsolate() const __attribute__((always_inline));
        inline Local<v8::Value> Data() const __attribute__((always_inline));
        inline Local<v8::Object> This() const __attribute__((always_inline));
        inline Local<v8::Object> Holder() const __attribute__((always_inline));
        inline ReturnValue<T> GetReturnValue() const __attribute__((always_inline));
        inline bool ShouldThrowOnError() const __attribute__((always_inline));
        static const int kArgsLength = 7;
    protected:
        friend  class MacroAssembler;
        friend  class internal::PropertyCallbackArguments;
        friend  class internal::CustomArguments<PropertyCallbackInfo<T> >;
        static const int kShouldThrowOnErrorIndex = 0;
        static const int kHolderIndex = 1;
        static const int kIsolateIndex = 2;
        static const int kReturnValueDefaultValueIndex = 3;
        static const int kReturnValueIndex = 4;
        static const int kDataIndex = 5;
        static const int kThisIndex = 6;
        inline PropertyCallbackInfo<T>(internal::Address *args) __attribute__((always_inline))         internal::Address *args_;
    };
    typedef void (*FunctionCallback)(const FunctionCallbackInfo<v8::Value> &);
    enum class ConstructorBehavior : int {
        kThrow,
        kAllow
    };
    class Function : public v8::Object {
    public:
        static MaybeLocal<v8::Function> New(Local<v8::Context> context, v8::FunctionCallback callback, Local<v8::Value> data = Local<v8::Value>(), int length = 0, v8::ConstructorBehavior behavior = ConstructorBehavior::kAllow, v8::SideEffectType side_effect_type = SideEffectType::kHasSideEffect);
        MaybeLocal<v8::Object> NewInstance(Local<v8::Context> context, int argc, Local<v8::Value> argv[]) const __attribute__((warn_unused_result));
        MaybeLocal<v8::Object> NewInstance(Local<v8::Context> context) const __attribute__((warn_unused_result))         {
            return this->NewInstance(context, 0, nullptr);
        }
        MaybeLocal<v8::Object> NewInstanceWithSideEffectType(Local<v8::Context> context, int argc, Local<v8::Value> argv[], v8::SideEffectType side_effect_type = SideEffectType::kHasSideEffect) const __attribute__((warn_unused_result));
        MaybeLocal<v8::Value> Call(Local<v8::Context> context, Local<v8::Value> recv, int argc, Local<v8::Value> argv[]) __attribute__((warn_unused_result));
        void SetName(Local<v8::String> name);
        Local<v8::Value> GetName() const;
        Local<v8::Value> GetInferredName() const;
        Local<v8::Value> GetDebugName() const;
        Local<v8::Value> GetDisplayName() const;
        int GetScriptLineNumber() const;
        int GetScriptColumnNumber() const;
        int ScriptId() const;
        Local<v8::Value> GetBoundFunction() const;
        v8::ScriptOrigin GetScriptOrigin() const;
        static inline v8::Function *Cast(v8::Value *obj) __attribute__((always_inline));
        static const int kLineOffsetNotFound;
    private:
        Function();
        static void CheckCast(v8::Value *obj);
    };
    class Promise : public v8::Object {
    public:
        enum PromiseState {
            kPending,
            kFulfilled,
            kRejected
        };
        class Resolver : public v8::Object {
        public:
            static MaybeLocal<v8::Promise::Resolver> New(Local<v8::Context> context) __attribute__((warn_unused_result));
            Local<v8::Promise> GetPromise();
            Maybe<bool> Resolve(Local<v8::Context> context, Local<v8::Value> value) __attribute__((warn_unused_result));
            Maybe<bool> Reject(Local<v8::Context> context, Local<v8::Value> value) __attribute__((warn_unused_result));
            static inline v8::Promise::Resolver *Cast(v8::Value *obj) __attribute__((always_inline));
        private:
            Resolver();
            static void CheckCast(v8::Value *obj);
        };
        MaybeLocal<v8::Promise> Catch(Local<v8::Context> context, Local<v8::Function> handler) __attribute__((warn_unused_result));
        MaybeLocal<v8::Promise> Then(Local<v8::Context> context, Local<v8::Function> handler) __attribute__((warn_unused_result));
        MaybeLocal<v8::Promise> Then(Local<v8::Context> context, Local<v8::Function> on_fulfilled, Local<v8::Function> on_rejected) __attribute__((warn_unused_result));
        bool HasHandler();
        Local<v8::Value> Result();
        v8::Promise::PromiseState State();
        void MarkAsHandled();
        static inline v8::Promise *Cast(v8::Value *obj) __attribute__((always_inline));
        static const int kEmbedderFieldCount = 0;
    private:
        Promise();
        static void CheckCast(v8::Value *obj);
    };
    class PropertyDescriptor {
    public:
        PropertyDescriptor();
        explicit PropertyDescriptor(Local<v8::Value> value);
        PropertyDescriptor(Local<v8::Value> value, bool writable);
        PropertyDescriptor(Local<v8::Value> get, Local<v8::Value> set);
        ~PropertyDescriptor();
        Local<v8::Value> value() const;
        bool has_value() const;
        Local<v8::Value> get() const;
        bool has_get() const;
        Local<v8::Value> set() const;
        bool has_set() const;
        void set_enumerable(bool enumerable);
        bool enumerable() const;
        bool has_enumerable() const;
        void set_configurable(bool configurable);
        bool configurable() const;
        bool has_configurable() const;
        bool writable() const;
        bool has_writable() const;
        struct PrivateData;
        v8::PropertyDescriptor::PrivateData *get_private() const         {
            return this->private_;
        }
        PropertyDescriptor(const v8::PropertyDescriptor &) = delete
        void operator=(const v8::PropertyDescriptor &) = delete
    private:
        v8::PropertyDescriptor::PrivateData *private_;
    };
    class Proxy : public v8::Object {
    public:
        Local<v8::Value> GetTarget();
        Local<v8::Value> GetHandler();
        bool IsRevoked();
        void Revoke();
        static MaybeLocal<v8::Proxy> New(Local<v8::Context> context, Local<v8::Object> local_target, Local<v8::Object> local_handler);
        static inline v8::Proxy *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Proxy();
        static void CheckCast(v8::Value *obj);
    };
    template <typename T> class MemorySpan {
    public:
        MemorySpan<T>() = default
        constexpr MemorySpan<T>(T *data, size_t size) : data_(data), size_(size)         {
        }
        constexpr T *data() const         {
            return this->data_;
        }
        constexpr size_t size() const         {
            return this->size_;
        }
    private:
        T *data_ = nullptr;
        size_t size_ = 0;
    };
template<> class MemorySpan<const unsigned char> {
    public:
        MemorySpan() = default
        constexpr MemorySpan(const unsigned char *data, size_t size) : data_(data), size_(size)         {
        }
        constexpr const unsigned char *data() const;
        constexpr size_t size() const;
    private:
        const unsigned char *data_;
        size_t size_;
    };
    struct OwnedBuffer {
        std::unique_ptr<const uint8_t []> buffer;
        size_t size = 0;
        OwnedBuffer(std::unique_ptr<const uint8_t []> buffer, size_t size) : buffer(std::move(buffer)), size(size)         {
        }
        OwnedBuffer() = default
    };
    class CompiledWasmModule {
    public:
        v8::OwnedBuffer Serialize();
        MemorySpan<const uint8_t> GetWireBytesRef();
    private:
        explicit CompiledWasmModule(std::shared_ptr<internal::wasm::NativeModule>);
        friend  class Utils;
        const std::shared_ptr<internal::wasm::NativeModule> native_module_;
    };
    class WasmModuleObject : public v8::Object {
    public:
        class final TransferrableModule {
        public:
            TransferrableModule(v8::WasmModuleObject::TransferrableModule &&src) = default
            TransferrableModule(const v8::WasmModuleObject::TransferrableModule &src) = delete
            v8::WasmModuleObject::TransferrableModule &operator=(v8::WasmModuleObject::TransferrableModule &&src) = default
            v8::WasmModuleObject::TransferrableModule &operator=(const v8::WasmModuleObject::TransferrableModule &src) = delete
        private:
            typedef std::shared_ptr<internal::wasm::NativeModule> SharedModule;
            friend  class WasmModuleObject;
            explicit TransferrableModule(v8::WasmModuleObject::TransferrableModule::SharedModule shared_module) : shared_module_(std::move(shared_module))             {
            }
            TransferrableModule(v8::OwnedBuffer serialized, v8::OwnedBuffer bytes) : shared_module_(), serialized_(std::move(serialized)), wire_bytes_(std::move(bytes))             {
            }
            v8::WasmModuleObject::TransferrableModule::SharedModule shared_module_;
            v8::OwnedBuffer serialized_ = {nullptr, 0};
            v8::OwnedBuffer wire_bytes_ = {nullptr, 0};
        };
        v8::WasmModuleObject::TransferrableModule GetTransferrableModule();
        static MaybeLocal<v8::WasmModuleObject> FromTransferrableModule(v8::Isolate *isolate, const v8::WasmModuleObject::TransferrableModule &);
        v8::CompiledWasmModule GetCompiledModule();
        static MaybeLocal<v8::WasmModuleObject> DeserializeOrCompile(v8::Isolate *isolate, MemorySpan<const uint8_t> serialized_module, MemorySpan<const uint8_t> wire_bytes);
        static inline v8::WasmModuleObject *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static MaybeLocal<v8::WasmModuleObject> Deserialize(v8::Isolate *isolate, MemorySpan<const uint8_t> serialized_module, MemorySpan<const uint8_t> wire_bytes);
        static MaybeLocal<v8::WasmModuleObject> Compile(v8::Isolate *isolate, const uint8_t *start, size_t length);
        static MemorySpan<const uint8_t> AsReference(const v8::OwnedBuffer &buff)         {
            return {buff.buffer.get(), buff.size};
        }
        WasmModuleObject();
        static void CheckCast(v8::Value *obj);
    };
    typedef v8::WasmModuleObject WasmCompiledModule;
    class final WasmStreaming {
    public:
        class WasmStreamingImpl;
        class Client {
        public:
            virtual ~Client() noexcept = default
            virtual void OnModuleCompiled(v8::CompiledWasmModule compiled_module) = 0;
        };
        explicit WasmStreaming(std::unique_ptr<WasmStreamingImpl> impl);
        ~WasmStreaming();
        void OnBytesReceived(const uint8_t *bytes, size_t size);
        void Finish();
        void Abort(MaybeLocal<v8::Value> exception);
        bool SetCompiledModuleBytes(const uint8_t *bytes, size_t size);
        void SetClient(std::shared_ptr<Client> client);
        static std::shared_ptr<WasmStreaming> Unpack(v8::Isolate *isolate, Local<v8::Value> value);
    private:
        std::unique_ptr<WasmStreamingImpl> impl_;
    };
    class final WasmModuleObjectBuilderStreaming {
    public:
        explicit WasmModuleObjectBuilderStreaming(v8::Isolate *isolate);
        void OnBytesReceived(const uint8_t *, size_t size);
        void Finish();
        void Abort(MaybeLocal<v8::Value> exception);
        Local<v8::Promise> GetPromise();
        ~WasmModuleObjectBuilderStreaming() noexcept = default
    private:
        WasmModuleObjectBuilderStreaming(const v8::WasmModuleObjectBuilderStreaming &) = delete
        WasmModuleObjectBuilderStreaming(v8::WasmModuleObjectBuilderStreaming &&) = default
        v8::WasmModuleObjectBuilderStreaming &operator=(const v8::WasmModuleObjectBuilderStreaming &) = delete
        v8::WasmModuleObjectBuilderStreaming &operator=(v8::WasmModuleObjectBuilderStreaming &&) = default
        v8::Isolate *isolate_ = nullptr;
        Persistent<v8::Promise, CopyablePersistentTraits<v8::Promise> > promise_;
        std::shared_ptr<internal::wasm::StreamingDecoder> streaming_decoder_;
    };
    enum class ArrayBufferCreationMode : int {
        kInternalized,
        kExternalized
    };
    class ArrayBuffer : public v8::Object {
    public:
        class Allocator {
        public:
            virtual ~Allocator() noexcept = default
            virtual void *Allocate(size_t length) = 0;
            virtual void *AllocateUninitialized(size_t length) = 0;
            virtual void Free(void *data, size_t length) = 0;
            enum class AllocationMode : int {
                kNormal,
                kReservation
            };
            static v8::ArrayBuffer::Allocator *NewDefaultAllocator();
        };
        class Contents {
        public:
            using DeleterCallback = void (*)(void *, size_t, void *);
            Contents() : data_(nullptr), byte_length_(0), allocation_base_(nullptr), allocation_length_(0), allocation_mode_(Allocator::AllocationMode::kNormal), deleter_(nullptr), deleter_data_(nullptr)             {
            }
            void *AllocationBase() const             {
                return this->allocation_base_;
            }
            size_t AllocationLength() const             {
                return this->allocation_length_;
            }
            Allocator::AllocationMode AllocationMode() const             {
                return this->allocation_mode_;
            }
            void *Data() const             {
                return this->data_;
            }
            size_t ByteLength() const             {
                return this->byte_length_;
            }
            v8::ArrayBuffer::Contents::DeleterCallback Deleter() const             {
                return this->deleter_;
            }
            void *DeleterData() const             {
                return this->deleter_data_;
            }
        private:
            Contents(void *data, size_t byte_length, void *allocation_base, size_t allocation_length, Allocator::AllocationMode allocation_mode, v8::ArrayBuffer::Contents::DeleterCallback deleter, void *deleter_data);
            void *data_;
            size_t byte_length_;
            void *allocation_base_;
            size_t allocation_length_;
            Allocator::AllocationMode allocation_mode_;
            v8::ArrayBuffer::Contents::DeleterCallback deleter_;
            void *deleter_data_;
            friend  class ArrayBuffer;
        };
        size_t ByteLength() const;
        static Local<v8::ArrayBuffer> New(v8::Isolate *isolate, size_t byte_length);
        static Local<v8::ArrayBuffer> New(v8::Isolate *isolate, void *data, size_t byte_length, v8::ArrayBufferCreationMode mode = ArrayBufferCreationMode::kExternalized);
        bool IsExternal() const;
        bool IsDetachable() const;
        inline bool IsNeuterable() const         {
            return this->IsDetachable();
        }
        void Detach();
        inline void Neuter()         {
            this->Detach();
        }
        v8::ArrayBuffer::Contents Externalize();
        v8::ArrayBuffer::Contents GetContents();
        static inline v8::ArrayBuffer *Cast(v8::Value *obj) __attribute__((always_inline));
        static const int kInternalFieldCount = 2;
        static const int kEmbedderFieldCount = 2;
    private:
        ArrayBuffer();
        static void CheckCast(v8::Value *obj);
    };
    class ArrayBufferView : public v8::Object {
    public:
        Local<v8::ArrayBuffer> Buffer();
        size_t ByteOffset();
        size_t ByteLength();
        size_t CopyContents(void *dest, size_t byte_length);
        bool HasBuffer() const;
        static inline v8::ArrayBufferView *Cast(v8::Value *obj) __attribute__((always_inline));
        static const int kInternalFieldCount = 2;
        static const int kEmbedderFieldCount = 2;
    private:
        ArrayBufferView();
        static void CheckCast(v8::Value *obj);
    };
    class TypedArray : public v8::ArrayBufferView {
    public:
        static constexpr size_t kMaxLength = internal::kSmiMaxValue;
        size_t Length();
        static inline v8::TypedArray *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        TypedArray();
        static void CheckCast(v8::Value *obj);
    };
    class Uint8Array : public v8::TypedArray {
    public:
        static Local<v8::Uint8Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Uint8Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Uint8Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Uint8Array();
        static void CheckCast(v8::Value *obj);
    };
    class Uint8ClampedArray : public v8::TypedArray {
    public:
        static Local<v8::Uint8ClampedArray> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Uint8ClampedArray> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Uint8ClampedArray *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Uint8ClampedArray();
        static void CheckCast(v8::Value *obj);
    };
    class Int8Array : public v8::TypedArray {
    public:
        static Local<v8::Int8Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Int8Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Int8Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Int8Array();
        static void CheckCast(v8::Value *obj);
    };
    class Uint16Array : public v8::TypedArray {
    public:
        static Local<v8::Uint16Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Uint16Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Uint16Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Uint16Array();
        static void CheckCast(v8::Value *obj);
    };
    class Int16Array : public v8::TypedArray {
    public:
        static Local<v8::Int16Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Int16Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Int16Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Int16Array();
        static void CheckCast(v8::Value *obj);
    };
    class Uint32Array : public v8::TypedArray {
    public:
        static Local<v8::Uint32Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Uint32Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Uint32Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Uint32Array();
        static void CheckCast(v8::Value *obj);
    };
    class Int32Array : public v8::TypedArray {
    public:
        static Local<v8::Int32Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Int32Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Int32Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Int32Array();
        static void CheckCast(v8::Value *obj);
    };
    class Float32Array : public v8::TypedArray {
    public:
        static Local<v8::Float32Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Float32Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Float32Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Float32Array();
        static void CheckCast(v8::Value *obj);
    };
    class Float64Array : public v8::TypedArray {
    public:
        static Local<v8::Float64Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::Float64Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::Float64Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        Float64Array();
        static void CheckCast(v8::Value *obj);
    };
    class BigInt64Array : public v8::TypedArray {
    public:
        static Local<v8::BigInt64Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::BigInt64Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::BigInt64Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        BigInt64Array();
        static void CheckCast(v8::Value *obj);
    };
    class BigUint64Array : public v8::TypedArray {
    public:
        static Local<v8::BigUint64Array> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::BigUint64Array> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::BigUint64Array *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        BigUint64Array();
        static void CheckCast(v8::Value *obj);
    };
    class DataView : public v8::ArrayBufferView {
    public:
        static Local<v8::DataView> New(Local<v8::ArrayBuffer> array_buffer, size_t byte_offset, size_t length);
        static Local<v8::DataView> New(Local<v8::SharedArrayBuffer> shared_array_buffer, size_t byte_offset, size_t length);
        static inline v8::DataView *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        DataView();
        static void CheckCast(v8::Value *obj);
    };
    class SharedArrayBuffer : public v8::Object {
    public:
        class Contents {
        public:
            using Allocator = v8::ArrayBuffer::Allocator;
            using DeleterCallback = void (*)(void *, size_t, void *);
            Contents() : data_(nullptr), byte_length_(0), allocation_base_(nullptr), allocation_length_(0), allocation_mode_(Allocator::AllocationMode::kNormal), deleter_(nullptr), deleter_data_(nullptr), is_growable_(false)             {
            }
            void *AllocationBase() const             {
                return this->allocation_base_;
            }
            size_t AllocationLength() const             {
                return this->allocation_length_;
            }
            Allocator::AllocationMode AllocationMode() const             {
                return this->allocation_mode_;
            }
            void *Data() const             {
                return this->data_;
            }
            size_t ByteLength() const             {
                return this->byte_length_;
            }
            v8::SharedArrayBuffer::Contents::DeleterCallback Deleter() const             {
                return this->deleter_;
            }
            void *DeleterData() const             {
                return this->deleter_data_;
            }
            bool IsGrowable() const             {
                return this->is_growable_;
            }
        private:
            Contents(void *data, size_t byte_length, void *allocation_base, size_t allocation_length, Allocator::AllocationMode allocation_mode, v8::SharedArrayBuffer::Contents::DeleterCallback deleter, void *deleter_data, bool is_growable);
            void *data_;
            size_t byte_length_;
            void *allocation_base_;
            size_t allocation_length_;
            Allocator::AllocationMode allocation_mode_;
            v8::SharedArrayBuffer::Contents::DeleterCallback deleter_;
            void *deleter_data_;
            bool is_growable_;
            friend  class SharedArrayBuffer;
        };
        size_t ByteLength() const;
        static Local<v8::SharedArrayBuffer> New(v8::Isolate *isolate, size_t byte_length);
        static Local<v8::SharedArrayBuffer> New(v8::Isolate *isolate, void *data, size_t byte_length, v8::ArrayBufferCreationMode mode = ArrayBufferCreationMode::kExternalized);
        static Local<v8::SharedArrayBuffer> New(v8::Isolate *isolate, const SharedArrayBuffer::Contents &, v8::ArrayBufferCreationMode mode = ArrayBufferCreationMode::kExternalized);
        bool IsExternal() const;
        v8::SharedArrayBuffer::Contents Externalize();
        v8::SharedArrayBuffer::Contents GetContents();
        static inline v8::SharedArrayBuffer *Cast(v8::Value *obj) __attribute__((always_inline));
        static const int kInternalFieldCount = 2;
    private:
        SharedArrayBuffer();
        static void CheckCast(v8::Value *obj);
    };
    class Date : public v8::Object {
    public:
        static MaybeLocal<v8::Value> New(Local<v8::Context> context, double time) __attribute__((warn_unused_result));
        double ValueOf() const;
        static inline v8::Date *Cast(v8::Value *obj) __attribute__((always_inline));
        enum class TimeZoneDetection : int {
            kSkip,
            kRedetect
        };
        static void DateTimeConfigurationChangeNotification(v8::Isolate *isolate, v8::Date::TimeZoneDetection time_zone_detection = TimeZoneDetection::kSkip);
    private:
        static void CheckCast(v8::Value *obj);
    };
    class NumberObject : public v8::Object {
    public:
        static Local<v8::Value> New(v8::Isolate *isolate, double value);
        double ValueOf() const;
        static inline v8::NumberObject *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    class BigIntObject : public v8::Object {
    public:
        static Local<v8::Value> New(v8::Isolate *isolate, int64_t value);
        Local<v8::BigInt> ValueOf() const;
        static inline v8::BigIntObject *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    class BooleanObject : public v8::Object {
    public:
        static Local<v8::Value> New(v8::Isolate *isolate, bool value);
        bool ValueOf() const;
        static inline v8::BooleanObject *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    class StringObject : public v8::Object {
    public:
        static Local<v8::Value> New(v8::Isolate *isolate, Local<v8::String> value);
        Local<v8::String> ValueOf() const;
        static inline v8::StringObject *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    class SymbolObject : public v8::Object {
    public:
        static Local<v8::Value> New(v8::Isolate *isolate, Local<v8::Symbol> value);
        Local<v8::Symbol> ValueOf() const;
        static inline v8::SymbolObject *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    class RegExp : public v8::Object {
    public:
        enum Flags {
            kNone = 0,
            kGlobal = 1 << 0,
            kIgnoreCase = 1 << 1,
            kMultiline = 1 << 2,
            kSticky = 1 << 3,
            kUnicode = 1 << 4,
            kDotAll = 1 << 5
        };
        static MaybeLocal<v8::RegExp> New(Local<v8::Context> context, Local<v8::String> pattern, v8::RegExp::Flags flags) __attribute__((warn_unused_result));
        Local<v8::String> GetSource() const;
        v8::RegExp::Flags GetFlags() const;
        static inline v8::RegExp *Cast(v8::Value *obj) __attribute__((always_inline));
    private:
        static void CheckCast(v8::Value *obj);
    };
    class External : public v8::Value {
    public:
        static Local<v8::External> New(v8::Isolate *isolate, void *value);
        static inline v8::External *Cast(v8::Value *obj) __attribute__((always_inline));
        void *Value() const;
    private:
        static void CheckCast(v8::Value *obj);
    };
    enum Intrinsic {
        kArrayProto_entries,
        kArrayProto_forEach,
        kArrayProto_keys,
        kArrayProto_values,
        kErrorPrototype,
        kIteratorPrototype
    };
    class Template : public v8::Data {
    public:
        void Set(Local<v8::Name> name, Local<v8::Data> value, v8::PropertyAttribute attributes = None);
        void SetPrivate(Local<v8::Private> name, Local<v8::Data> value, v8::PropertyAttribute attributes = None);
        inline void Set(v8::Isolate *isolate, const char *name, Local<v8::Data> value) __attribute__((always_inline));
        void SetAccessorProperty(Local<v8::Name> name, Local<v8::FunctionTemplate> getter = Local<v8::FunctionTemplate>(), Local<v8::FunctionTemplate> setter = Local<v8::FunctionTemplate>(), v8::PropertyAttribute attribute = None, v8::AccessControl settings = DEFAULT);
        void SetNativeDataProperty(Local<v8::String> name, v8::AccessorGetterCallback getter, v8::AccessorSetterCallback setter = nullptr, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyAttribute attribute = None, Local<v8::AccessorSignature> signature = Local<v8::AccessorSignature>(), v8::AccessControl settings = DEFAULT, v8::SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect, v8::SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect);
        void SetNativeDataProperty(Local<v8::Name> name, v8::AccessorNameGetterCallback getter, v8::AccessorNameSetterCallback setter = nullptr, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyAttribute attribute = None, Local<v8::AccessorSignature> signature = Local<v8::AccessorSignature>(), v8::AccessControl settings = DEFAULT, v8::SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect, v8::SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect);
        void SetLazyDataProperty(Local<v8::Name> name, v8::AccessorNameGetterCallback getter, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyAttribute attribute = None, v8::SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect, v8::SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect);
        void SetIntrinsicDataProperty(Local<v8::Name> name, v8::Intrinsic intrinsic, v8::PropertyAttribute attribute = None);
    private:
        Template();
        friend  class ObjectTemplate;
        friend  class FunctionTemplate;
    };
    typedef void (*GenericNamedPropertyGetterCallback)(Local<v8::Name>, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*GenericNamedPropertySetterCallback)(Local<v8::Name>, Local<v8::Value>, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*GenericNamedPropertyQueryCallback)(Local<v8::Name>, const PropertyCallbackInfo<v8::Integer> &);
    typedef void (*GenericNamedPropertyDeleterCallback)(Local<v8::Name>, const PropertyCallbackInfo<v8::Boolean> &);
    typedef void (*GenericNamedPropertyEnumeratorCallback)(const PropertyCallbackInfo<v8::Array> &);
    typedef void (*GenericNamedPropertyDefinerCallback)(Local<v8::Name>, const v8::PropertyDescriptor &, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*GenericNamedPropertyDescriptorCallback)(Local<v8::Name>, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*IndexedPropertyGetterCallback)(uint32_t, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*IndexedPropertySetterCallback)(uint32_t, Local<v8::Value>, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*IndexedPropertyQueryCallback)(uint32_t, const PropertyCallbackInfo<v8::Integer> &);
    typedef void (*IndexedPropertyDeleterCallback)(uint32_t, const PropertyCallbackInfo<v8::Boolean> &);
    typedef void (*IndexedPropertyEnumeratorCallback)(const PropertyCallbackInfo<v8::Array> &);
    typedef void (*IndexedPropertyDefinerCallback)(uint32_t, const v8::PropertyDescriptor &, const PropertyCallbackInfo<v8::Value> &);
    typedef void (*IndexedPropertyDescriptorCallback)(uint32_t, const PropertyCallbackInfo<v8::Value> &);
    enum AccessType {
        ACCESS_GET,
        ACCESS_SET,
        ACCESS_HAS,
        ACCESS_DELETE,
        ACCESS_KEYS
    };
    typedef bool (*AccessCheckCallback)(Local<v8::Context>, Local<v8::Object>, Local<v8::Value>);
    class FunctionTemplate : public v8::Template {
    public:
        static Local<v8::FunctionTemplate> New(v8::Isolate *isolate, v8::FunctionCallback callback = nullptr, Local<v8::Value> data = Local<v8::Value>(), Local<v8::Signature> signature = Local<v8::Signature>(), int length = 0, v8::ConstructorBehavior behavior = ConstructorBehavior::kAllow, v8::SideEffectType side_effect_type = SideEffectType::kHasSideEffect);
        static MaybeLocal<v8::FunctionTemplate> FromSnapshot(v8::Isolate *isolate, size_t index);
        static Local<v8::FunctionTemplate> NewWithCache(v8::Isolate *isolate, v8::FunctionCallback callback, Local<v8::Private> cache_property, Local<v8::Value> data = Local<v8::Value>(), Local<v8::Signature> signature = Local<v8::Signature>(), int length = 0, v8::SideEffectType side_effect_type = SideEffectType::kHasSideEffect);
        MaybeLocal<v8::Function> GetFunction(Local<v8::Context> context) __attribute__((warn_unused_result));
        MaybeLocal<v8::Object> NewRemoteInstance() __attribute__((warn_unused_result));
        void SetCallHandler(v8::FunctionCallback callback, Local<v8::Value> data = Local<v8::Value>(), v8::SideEffectType side_effect_type = SideEffectType::kHasSideEffect);
        void SetLength(int length);
        Local<v8::ObjectTemplate> InstanceTemplate();
        void Inherit(Local<v8::FunctionTemplate> parent);
        Local<v8::ObjectTemplate> PrototypeTemplate();
        void SetPrototypeProviderTemplate(Local<v8::FunctionTemplate> prototype_provider);
        void SetClassName(Local<v8::String> name);
        void SetAcceptAnyReceiver(bool value);
        void SetHiddenPrototype(bool value);
        void ReadOnlyPrototype();
        void RemovePrototype();
        bool HasInstance(Local<v8::Value> object);
        static inline v8::FunctionTemplate *Cast(v8::Data *data) __attribute__((always_inline));
    private:
        FunctionTemplate();
        static void CheckCast(v8::Data *that);
        friend  class Context;
        friend  class ObjectTemplate;
    };
    enum class PropertyHandlerFlags : int {
        kNone = 0,
        kAllCanRead = 1,
        kNonMasking = 1 << 1,
        kOnlyInterceptStrings = 1 << 2,
        kHasNoSideEffect = 1 << 3
    };
    struct NamedPropertyHandlerConfiguration {
        NamedPropertyHandlerConfiguration(v8::GenericNamedPropertyGetterCallback getter, v8::GenericNamedPropertySetterCallback setter, v8::GenericNamedPropertyQueryCallback query, v8::GenericNamedPropertyDeleterCallback deleter, v8::GenericNamedPropertyEnumeratorCallback enumerator, v8::GenericNamedPropertyDefinerCallback definer, v8::GenericNamedPropertyDescriptorCallback descriptor, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyHandlerFlags flags = PropertyHandlerFlags::kNone) : getter(getter), setter(setter), query(query), deleter(deleter), enumerator(enumerator), definer(definer), descriptor(descriptor), data(data), flags(flags)         {
        }
        NamedPropertyHandlerConfiguration(v8::GenericNamedPropertyGetterCallback getter = nullptr, v8::GenericNamedPropertySetterCallback setter = nullptr, v8::GenericNamedPropertyQueryCallback query = nullptr, v8::GenericNamedPropertyDeleterCallback deleter = nullptr, v8::GenericNamedPropertyEnumeratorCallback enumerator = nullptr, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyHandlerFlags flags = PropertyHandlerFlags::kNone) : getter(getter), setter(setter), query(query), deleter(deleter), enumerator(enumerator), definer(nullptr), descriptor(nullptr), data(data), flags(flags)         {
        }
        NamedPropertyHandlerConfiguration(v8::GenericNamedPropertyGetterCallback getter, v8::GenericNamedPropertySetterCallback setter, v8::GenericNamedPropertyDescriptorCallback descriptor, v8::GenericNamedPropertyDeleterCallback deleter, v8::GenericNamedPropertyEnumeratorCallback enumerator, v8::GenericNamedPropertyDefinerCallback definer, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyHandlerFlags flags = PropertyHandlerFlags::kNone) : getter(getter), setter(setter), query(nullptr), deleter(deleter), enumerator(enumerator), definer(definer), descriptor(descriptor), data(data), flags(flags)         {
        }
        v8::GenericNamedPropertyGetterCallback getter;
        v8::GenericNamedPropertySetterCallback setter;
        v8::GenericNamedPropertyQueryCallback query;
        v8::GenericNamedPropertyDeleterCallback deleter;
        v8::GenericNamedPropertyEnumeratorCallback enumerator;
        v8::GenericNamedPropertyDefinerCallback definer;
        v8::GenericNamedPropertyDescriptorCallback descriptor;
        Local<v8::Value> data;
        v8::PropertyHandlerFlags flags;
    };
    struct IndexedPropertyHandlerConfiguration {
        IndexedPropertyHandlerConfiguration(v8::IndexedPropertyGetterCallback getter, v8::IndexedPropertySetterCallback setter, v8::IndexedPropertyQueryCallback query, v8::IndexedPropertyDeleterCallback deleter, v8::IndexedPropertyEnumeratorCallback enumerator, v8::IndexedPropertyDefinerCallback definer, v8::IndexedPropertyDescriptorCallback descriptor, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyHandlerFlags flags = PropertyHandlerFlags::kNone) : getter(getter), setter(setter), query(query), deleter(deleter), enumerator(enumerator), definer(definer), descriptor(descriptor), data(data), flags(flags)         {
        }
        IndexedPropertyHandlerConfiguration(v8::IndexedPropertyGetterCallback getter = nullptr, v8::IndexedPropertySetterCallback setter = nullptr, v8::IndexedPropertyQueryCallback query = nullptr, v8::IndexedPropertyDeleterCallback deleter = nullptr, v8::IndexedPropertyEnumeratorCallback enumerator = nullptr, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyHandlerFlags flags = PropertyHandlerFlags::kNone) : getter(getter), setter(setter), query(query), deleter(deleter), enumerator(enumerator), definer(nullptr), descriptor(nullptr), data(data), flags(flags)         {
        }
        IndexedPropertyHandlerConfiguration(v8::IndexedPropertyGetterCallback getter, v8::IndexedPropertySetterCallback setter, v8::IndexedPropertyDescriptorCallback descriptor, v8::IndexedPropertyDeleterCallback deleter, v8::IndexedPropertyEnumeratorCallback enumerator, v8::IndexedPropertyDefinerCallback definer, Local<v8::Value> data = Local<v8::Value>(), v8::PropertyHandlerFlags flags = PropertyHandlerFlags::kNone) : getter(getter), setter(setter), query(nullptr), deleter(deleter), enumerator(enumerator), definer(definer), descriptor(descriptor), data(data), flags(flags)         {
        }
        v8::IndexedPropertyGetterCallback getter;
        v8::IndexedPropertySetterCallback setter;
        v8::IndexedPropertyQueryCallback query;
        v8::IndexedPropertyDeleterCallback deleter;
        v8::IndexedPropertyEnumeratorCallback enumerator;
        v8::IndexedPropertyDefinerCallback definer;
        v8::IndexedPropertyDescriptorCallback descriptor;
        Local<v8::Value> data;
        v8::PropertyHandlerFlags flags;
    };
    class ObjectTemplate : public v8::Template {
    public:
        static Local<v8::ObjectTemplate> New(v8::Isolate *isolate, Local<v8::FunctionTemplate> constructor = Local<v8::FunctionTemplate>());
        static MaybeLocal<v8::ObjectTemplate> FromSnapshot(v8::Isolate *isolate, size_t index);
        MaybeLocal<v8::Object> NewInstance(Local<v8::Context> context) __attribute__((warn_unused_result));
        void SetAccessor(Local<v8::String> name, v8::AccessorGetterCallback getter, v8::AccessorSetterCallback setter = nullptr, Local<v8::Value> data = Local<v8::Value>(), v8::AccessControl settings = DEFAULT, v8::PropertyAttribute attribute = None, Local<v8::AccessorSignature> signature = Local<v8::AccessorSignature>(), v8::SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect, v8::SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect);
        void SetAccessor(Local<v8::Name> name, v8::AccessorNameGetterCallback getter, v8::AccessorNameSetterCallback setter = nullptr, Local<v8::Value> data = Local<v8::Value>(), v8::AccessControl settings = DEFAULT, v8::PropertyAttribute attribute = None, Local<v8::AccessorSignature> signature = Local<v8::AccessorSignature>(), v8::SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect, v8::SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect);
        void SetHandler(const v8::NamedPropertyHandlerConfiguration &configuration);
        void SetIndexedPropertyHandler(v8::IndexedPropertyGetterCallback getter, v8::IndexedPropertySetterCallback setter = nullptr, v8::IndexedPropertyQueryCallback query = nullptr, v8::IndexedPropertyDeleterCallback deleter = nullptr, v8::IndexedPropertyEnumeratorCallback enumerator = nullptr, Local<v8::Value> data = Local<v8::Value>())         {
            this->SetHandler(v8::IndexedPropertyHandlerConfiguration(getter, setter, query, deleter, enumerator, data));
        }
        void SetHandler(const v8::IndexedPropertyHandlerConfiguration &configuration);
        void SetCallAsFunctionHandler(v8::FunctionCallback callback, Local<v8::Value> data = Local<v8::Value>());
        void MarkAsUndetectable();
        void SetAccessCheckCallback(v8::AccessCheckCallback callback, Local<v8::Value> data = Local<v8::Value>());
        void SetAccessCheckCallbackAndHandler(v8::AccessCheckCallback callback, const v8::NamedPropertyHandlerConfiguration &named_handler, const v8::IndexedPropertyHandlerConfiguration &indexed_handler, Local<v8::Value> data = Local<v8::Value>());
        int InternalFieldCount();
        void SetInternalFieldCount(int value);
        bool IsImmutableProto();
        void SetImmutableProto();
        static inline v8::ObjectTemplate *Cast(v8::Data *data) __attribute__((always_inline));
    private:
        ObjectTemplate();
        static Local<v8::ObjectTemplate> New(internal::Isolate *isolate, Local<v8::FunctionTemplate> constructor);
        static void CheckCast(v8::Data *that);
        friend  class FunctionTemplate;
    };
    class Signature : public v8::Data {
    public:
        static Local<v8::Signature> New(v8::Isolate *isolate, Local<v8::FunctionTemplate> receiver = Local<v8::FunctionTemplate>());
        static inline v8::Signature *Cast(v8::Data *data) __attribute__((always_inline));
    private:
        Signature();
        static void CheckCast(v8::Data *that);
    };
    class AccessorSignature : public v8::Data {
    public:
        static Local<v8::AccessorSignature> New(v8::Isolate *isolate, Local<v8::FunctionTemplate> receiver = Local<v8::FunctionTemplate>());
        static inline v8::AccessorSignature *Cast(v8::Data *data) __attribute__((always_inline));
    private:
        AccessorSignature();
        static void CheckCast(v8::Data *that);
    };
    class Extension {
    public:
        Extension(const char *name, const char *source = nullptr, int dep_count = 0, const char **deps = nullptr, int source_length = -1);
        virtual ~Extension() noexcept         {
            delete this->source_;
        }
        virtual Local<v8::FunctionTemplate> GetNativeFunctionTemplate(v8::Isolate *isolate, Local<v8::String> name)         {
            return Local<v8::FunctionTemplate>();
        }
        const char *name() const         {
            return this->name_;
        }
        size_t source_length() const         {
            return this->source_length_;
        }
        const String::ExternalOneByteStringResource *source() const         {
            return this->source_;
        }
        int dependency_count() const         {
            return this->dep_count_;
        }
        const char **dependencies() const         {
            return this->deps_;
        }
        void set_auto_enable(bool value)         {
            this->auto_enable_ = value;
        }
        bool auto_enable()         {
            return this->auto_enable_;
        }
        Extension(const v8::Extension &) = delete
        void operator=(const v8::Extension &) = delete
    private:
        const char *name_;
        size_t source_length_;
        String::ExternalOneByteStringResource *source_;
        int dep_count_;
        const char **deps_;
        bool auto_enable_;
    };
    void RegisterExtension(v8::Extension *extension);
    void RegisterExtension(std::unique_ptr<Extension>);
    inline Local<v8::Primitive> Undefined(v8::Isolate *isolate) __attribute__((always_inline));
    inline Local<v8::Primitive> Null(v8::Isolate *isolate) __attribute__((always_inline));
    inline Local<v8::Boolean> True(v8::Isolate *isolate) __attribute__((always_inline));
    inline Local<v8::Boolean> False(v8::Isolate *isolate) __attribute__((always_inline));
    class ResourceConstraints {
    public:
        ResourceConstraints();
        void ConfigureDefaults(uint64_t physical_memory, uint64_t virtual_memory_limit);
        size_t max_semi_space_size_in_kb() const         {
            return this->max_semi_space_size_in_kb_;
        }
        void set_max_semi_space_size_in_kb(size_t limit_in_kb)         {
            this->max_semi_space_size_in_kb_ = limit_in_kb;
        }
        size_t max_old_space_size() const         {
            return this->max_old_space_size_;
        }
        void set_max_old_space_size(size_t limit_in_mb)         {
            this->max_old_space_size_ = limit_in_mb;
        }
        uint32_t *stack_limit() const         {
            return this->stack_limit_;
        }
        void set_stack_limit(uint32_t *value)         {
            this->stack_limit_ = value;
        }
        size_t code_range_size() const         {
            return this->code_range_size_;
        }
        void set_code_range_size(size_t limit_in_mb)         {
            this->code_range_size_ = limit_in_mb;
        }
        size_t max_zone_pool_size() const         {
            return this->max_zone_pool_size_;
        }
        void set_max_zone_pool_size(size_t bytes)         {
            this->max_zone_pool_size_ = bytes;
        }
    private:
        size_t max_semi_space_size_in_kb_;
        size_t max_old_space_size_;
        uint32_t *stack_limit_;
        size_t code_range_size_;
        size_t max_zone_pool_size_;
    };
    typedef void (*FatalErrorCallback)(const char *, const char *);
    typedef void (*OOMErrorCallback)(const char *, bool);
    typedef void (*DcheckErrorCallback)(const char *, int, const char *);
    typedef void (*MessageCallback)(Local<v8::Message>, Local<v8::Value>);
    typedef void (*LogEventCallback)(const char *, int);
    class Exception {
    public:
        static Local<v8::Value> RangeError(Local<v8::String> message);
        static Local<v8::Value> ReferenceError(Local<v8::String> message);
        static Local<v8::Value> SyntaxError(Local<v8::String> message);
        static Local<v8::Value> TypeError(Local<v8::String> message);
        static Local<v8::Value> Error(Local<v8::String> message);
        static Local<v8::Message> CreateMessage(v8::Isolate *isolate, Local<v8::Value> exception);
        static Local<v8::StackTrace> GetStackTrace(Local<v8::Value> exception);
    };
    typedef int *(*CounterLookupCallback)(const char *);
    typedef void *(*CreateHistogramCallback)(const char *, int, int, size_t);
    typedef void (*AddHistogramSampleCallback)(void *, int);
    typedef void (*BeforeCallEnteredCallback)(v8::Isolate *);
    typedef void (*CallCompletedCallback)(v8::Isolate *);
    typedef MaybeLocal<v8::Promise> (*HostImportModuleDynamicallyCallback)(Local<v8::Context>, Local<v8::ScriptOrModule>, Local<v8::String>);
    typedef void (*HostInitializeImportMetaObjectCallback)(Local<v8::Context>, Local<v8::Module>, Local<v8::Object>);
    typedef MaybeLocal<v8::Value> (*PrepareStackTraceCallback)(Local<v8::Context>, Local<v8::Value>, Local<v8::Array>);
    enum class PromiseHookType : int {
        kInit,
        kResolve,
        kBefore,
        kAfter
    };
    typedef void (*PromiseHook)(v8::PromiseHookType, Local<v8::Promise>, Local<v8::Value>);
    enum PromiseRejectEvent {
        kPromiseRejectWithNoHandler = 0,
        kPromiseHandlerAddedAfterReject = 1,
        kPromiseRejectAfterResolved = 2,
        kPromiseResolveAfterResolved = 3
    };
    class PromiseRejectMessage {
    public:
        PromiseRejectMessage(Local<v8::Promise> promise, v8::PromiseRejectEvent event, Local<v8::Value> value, Local<v8::StackTrace> stack_trace) : promise_(promise), event_(event), value_(value), stack_trace_(stack_trace)         {
        }
        inline Local<v8::Promise> GetPromise() const __attribute__((always_inline))         {
            return this->promise_;
        }
        inline v8::PromiseRejectEvent GetEvent() const __attribute__((always_inline))         {
            return this->event_;
        }
        inline Local<v8::Value> GetValue() const __attribute__((always_inline))         {
            return this->value_;
        }
    private:
        Local<v8::Promise> promise_;
        v8::PromiseRejectEvent event_;
        Local<v8::Value> value_;
        Local<v8::StackTrace> stack_trace_;
    };
    typedef void (*PromiseRejectCallback)(v8::PromiseRejectMessage);
    typedef void (*MicrotasksCompletedCallback)(v8::Isolate *);
    typedef void (*MicrotaskCallback)(void *);
    enum class MicrotasksPolicy : int {
        kExplicit,
        kScoped,
        kAuto
    };
    class MicrotasksScope {
    public:
        enum Type {
            kRunMicrotasks,
            kDoNotRunMicrotasks
        };
        MicrotasksScope(v8::Isolate *isolate, v8::MicrotasksScope::Type type);
        ~MicrotasksScope();
        static void PerformCheckpoint(v8::Isolate *isolate);
        static int GetCurrentDepth(v8::Isolate *isolate);
        static bool IsRunningMicrotasks(v8::Isolate *isolate);
        MicrotasksScope(const v8::MicrotasksScope &) = delete
        v8::MicrotasksScope &operator=(const v8::MicrotasksScope &) = delete
    private:
        internal::Isolate *const isolate_;
        internal::MicrotaskQueue *const microtask_queue_;
        bool run_;
    };
    typedef void (*FailedAccessCheckCallback)(Local<v8::Object>, v8::AccessType, Local<v8::Value>);
    typedef bool (*AllowCodeGenerationFromStringsCallback)(Local<v8::Context>, Local<v8::String>);
    typedef bool (*ExtensionCallback)(const FunctionCallbackInfo<v8::Value> &);
    typedef bool (*AllowWasmCodeGenerationCallback)(Local<v8::Context>, Local<v8::String>);
    typedef void (*ApiImplementationCallback)(const FunctionCallbackInfo<v8::Value> &);
    typedef void (*WasmStreamingCallback)(const FunctionCallbackInfo<v8::Value> &);
    typedef bool (*WasmThreadsEnabledCallback)(Local<v8::Context>);
    enum GCType {
        kGCTypeScavenge = 1 << 0,
        kGCTypeMarkSweepCompact = 1 << 1,
        kGCTypeIncrementalMarking = 1 << 2,
        kGCTypeProcessWeakCallbacks = 1 << 3,
        kGCTypeAll = kGCTypeScavenge | kGCTypeMarkSweepCompact | kGCTypeIncrementalMarking | kGCTypeProcessWeakCallbacks
    };
    enum GCCallbackFlags {
        kNoGCCallbackFlags = 0,
        kGCCallbackFlagConstructRetainedObjectInfos = 1 << 1,
        kGCCallbackFlagForced = 1 << 2,
        kGCCallbackFlagSynchronousPhantomCallbackProcessing = 1 << 3,
        kGCCallbackFlagCollectAllAvailableGarbage = 1 << 4,
        kGCCallbackFlagCollectAllExternalMemory = 1 << 5,
        kGCCallbackScheduleIdleGarbageCollection = 1 << 6
    };
    typedef void (*GCCallback)(v8::GCType, v8::GCCallbackFlags);
    typedef void (*InterruptCallback)(v8::Isolate *, void *);
    typedef size_t (*NearHeapLimitCallback)(void *, size_t, size_t);
    class HeapStatistics {
    public:
        HeapStatistics();
        size_t total_heap_size()         {
            return this->total_heap_size_;
        }
        size_t total_heap_size_executable()         {
            return this->total_heap_size_executable_;
        }
        size_t total_physical_size()         {
            return this->total_physical_size_;
        }
        size_t total_available_size()         {
            return this->total_available_size_;
        }
        size_t used_heap_size()         {
            return this->used_heap_size_;
        }
        size_t heap_size_limit()         {
            return this->heap_size_limit_;
        }
        size_t malloced_memory()         {
            return this->malloced_memory_;
        }
        size_t external_memory()         {
            return this->external_memory_;
        }
        size_t peak_malloced_memory()         {
            return this->peak_malloced_memory_;
        }
        size_t number_of_native_contexts()         {
            return this->number_of_native_contexts_;
        }
        size_t number_of_detached_contexts()         {
            return this->number_of_detached_contexts_;
        }
        size_t does_zap_garbage()         {
            return this->does_zap_garbage_;
        }
    private:
        size_t total_heap_size_;
        size_t total_heap_size_executable_;
        size_t total_physical_size_;
        size_t total_available_size_;
        size_t used_heap_size_;
        size_t heap_size_limit_;
        size_t malloced_memory_;
        size_t external_memory_;
        size_t peak_malloced_memory_;
        bool does_zap_garbage_;
        size_t number_of_native_contexts_;
        size_t number_of_detached_contexts_;
        friend  class V8;
        friend  class Isolate;
    };
    class HeapSpaceStatistics {
    public:
        HeapSpaceStatistics();
        const char *space_name()         {
            return this->space_name_;
        }
        size_t space_size()         {
            return this->space_size_;
        }
        size_t space_used_size()         {
            return this->space_used_size_;
        }
        size_t space_available_size()         {
            return this->space_available_size_;
        }
        size_t physical_space_size()         {
            return this->physical_space_size_;
        }
    private:
        const char *space_name_;
        size_t space_size_;
        size_t space_used_size_;
        size_t space_available_size_;
        size_t physical_space_size_;
        friend  class Isolate;
    };
    class HeapObjectStatistics {
    public:
        HeapObjectStatistics();
        const char *object_type()         {
            return this->object_type_;
        }
        const char *object_sub_type()         {
            return this->object_sub_type_;
        }
        size_t object_count()         {
            return this->object_count_;
        }
        size_t object_size()         {
            return this->object_size_;
        }
    private:
        const char *object_type_;
        const char *object_sub_type_;
        size_t object_count_;
        size_t object_size_;
        friend  class Isolate;
    };
    class HeapCodeStatistics {
    public:
        HeapCodeStatistics();
        size_t code_and_metadata_size()         {
            return this->code_and_metadata_size_;
        }
        size_t bytecode_and_metadata_size()         {
            return this->bytecode_and_metadata_size_;
        }
        size_t external_script_source_size()         {
            return this->external_script_source_size_;
        }
    private:
        size_t code_and_metadata_size_;
        size_t bytecode_and_metadata_size_;
        size_t external_script_source_size_;
        friend  class Isolate;
    };
    struct JitCodeEvent {
        enum EventType {
            CODE_ADDED,
            CODE_MOVED,
            CODE_REMOVED,
            CODE_ADD_LINE_POS_INFO,
            CODE_START_LINE_INFO_RECORDING,
            CODE_END_LINE_INFO_RECORDING
        };
        enum PositionType {
            POSITION,
            STATEMENT_POSITION
        };
        enum CodeType {
            BYTE_CODE,
            JIT_CODE
        };
        v8::JitCodeEvent::EventType type;
        v8::JitCodeEvent::CodeType code_type;
        void *code_start;
        size_t code_len;
        Local<v8::UnboundScript> script;
        void *user_data;
        struct name_t {
            const char *str;
            size_t len;
        };
        struct line_info_t {
            size_t offset;
            size_t pos;
            v8::JitCodeEvent::PositionType position_type;
        };
        union {
            struct name_t name;
            struct line_info_t line_info;
            void *new_code_start;
        };
        v8::Isolate *isolate;
    };
    enum RAILMode : unsigned int {
        PERFORMANCE_RESPONSE,
        PERFORMANCE_ANIMATION,
        PERFORMANCE_IDLE,
        PERFORMANCE_LOAD
    };
    enum JitCodeEventOptions {
        kJitCodeEventDefault = 0,
        kJitCodeEventEnumExisting = 1
    };
    typedef void (*JitCodeEventHandler)(const v8::JitCodeEvent *);
    class ExternalResourceVisitor {
    public:
        virtual ~ExternalResourceVisitor() noexcept = default
        virtual void VisitExternalString(Local<v8::String> string)         {
        }
    };
    class PersistentHandleVisitor {
    public:
        virtual ~PersistentHandleVisitor() noexcept = default
        virtual void VisitPersistentHandle(Persistent<v8::Value> *value, uint16_t class_id)         {
        }
    };
    enum class MemoryPressureLevel : int {
        kNone,
        kModerate,
        kCritical
    };
    class EmbedderHeapTracer {
    public:
        enum EmbedderStackState {
            kUnknown,
            kNonEmpty,
            kEmpty
        };
        class TracedGlobalHandleVisitor {
        public:
            virtual ~TracedGlobalHandleVisitor() noexcept = default
            virtual void VisitTracedGlobalHandle(const TracedGlobal<v8::Value> &value) = 0;
        };
        virtual ~EmbedderHeapTracer() noexcept = default
        void IterateTracedGlobalHandles(v8::EmbedderHeapTracer::TracedGlobalHandleVisitor *visitor);
        virtual void RegisterV8References(const std::vector<std::pair<void *, void *> > &embedder_fields) = 0;
        void RegisterEmbedderReference(const TracedGlobal<v8::Value> &ref);
        virtual void TracePrologue() = 0;
        virtual bool AdvanceTracing(double deadline_in_ms) = 0;
        virtual bool IsTracingDone() = 0;
        virtual void TraceEpilogue() = 0;
        virtual void EnterFinalPause(v8::EmbedderHeapTracer::EmbedderStackState stack_state) = 0;
        void FinalizeTracing();
        virtual bool IsRootForNonTracingGC(const v8::TracedGlobal<v8::Value> &handle)         {
            return true;
        }
        void GarbageCollectionForTesting(v8::EmbedderHeapTracer::EmbedderStackState stack_state);
        v8::Isolate *isolate() const         {
            return this->isolate_;
        }
    protected:
        v8::Isolate *isolate_ = nullptr;
        friend  class internal::LocalEmbedderHeapTracer;
    };
    struct SerializeInternalFieldsCallback {
        typedef v8::StartupData (*CallbackFunction)(Local<v8::Object>, int, void *);
        SerializeInternalFieldsCallback(v8::SerializeInternalFieldsCallback::CallbackFunction function = nullptr, void *data_arg = nullptr) : callback(function), data(data_arg)         {
        }
        v8::SerializeInternalFieldsCallback::CallbackFunction callback;
        void *data;
    };
    typedef v8::SerializeInternalFieldsCallback SerializeEmbedderFieldsCallback;
    struct DeserializeInternalFieldsCallback {
        typedef void (*CallbackFunction)(Local<v8::Object>, int, v8::StartupData, void *);
        DeserializeInternalFieldsCallback(v8::DeserializeInternalFieldsCallback::CallbackFunction function = nullptr, void *data_arg = nullptr) : callback(function), data(data_arg)         {
        }
        void (*callback)(Local<v8::Object>, int, v8::StartupData, void *);
        void *data;
    };
    typedef v8::DeserializeInternalFieldsCallback DeserializeEmbedderFieldsCallback;
    class Isolate {
    public:
        struct CreateParams {
            CreateParams() : code_event_handler(nullptr), constraints(), snapshot_blob(nullptr), counter_lookup_callback(nullptr), create_histogram_callback(nullptr), add_histogram_sample_callback(nullptr), array_buffer_allocator(nullptr), external_references(nullptr), allow_atomics_wait(true), only_terminate_in_safe_scope(false)             {
            }
            v8::JitCodeEventHandler code_event_handler;
            v8::ResourceConstraints constraints;
            v8::StartupData *snapshot_blob;
            v8::CounterLookupCallback counter_lookup_callback;
            v8::CreateHistogramCallback create_histogram_callback;
            v8::AddHistogramSampleCallback add_histogram_sample_callback;
            ArrayBuffer::Allocator *array_buffer_allocator;
            const intptr_t *external_references;
            bool allow_atomics_wait;
            bool only_terminate_in_safe_scope;
        };
        class Scope {
        public:
            explicit Scope(v8::Isolate *isolate) : isolate_(isolate)             {
                isolate->Enter();
            }
            ~Scope() noexcept             {
                this->isolate_->Exit();
            }
            Scope(const v8::Isolate::Scope &) = delete
            v8::Isolate::Scope &operator=(const v8::Isolate::Scope &) = delete
        private:
            v8::Isolate *const isolate_;
        };
        class DisallowJavascriptExecutionScope {
        public:
            enum OnFailure {
                CRASH_ON_FAILURE,
                THROW_ON_FAILURE,
                DUMP_ON_FAILURE
            };
            DisallowJavascriptExecutionScope(v8::Isolate *isolate, v8::Isolate::DisallowJavascriptExecutionScope::OnFailure on_failure);
            ~DisallowJavascriptExecutionScope();
            DisallowJavascriptExecutionScope(const v8::Isolate::DisallowJavascriptExecutionScope &) = delete
            v8::Isolate::DisallowJavascriptExecutionScope &operator=(const v8::Isolate::DisallowJavascriptExecutionScope &) = delete
        private:
            v8::Isolate::DisallowJavascriptExecutionScope::OnFailure on_failure_;
            void *internal_;
        };
        class AllowJavascriptExecutionScope {
        public:
            explicit AllowJavascriptExecutionScope(v8::Isolate *isolate);
            ~AllowJavascriptExecutionScope();
            AllowJavascriptExecutionScope(const v8::Isolate::AllowJavascriptExecutionScope &) = delete
            v8::Isolate::AllowJavascriptExecutionScope &operator=(const v8::Isolate::AllowJavascriptExecutionScope &) = delete
        private:
            void *internal_throws_;
            void *internal_assert_;
            void *internal_dump_;
        };
        class SuppressMicrotaskExecutionScope {
        public:
            explicit SuppressMicrotaskExecutionScope(v8::Isolate *isolate);
            ~SuppressMicrotaskExecutionScope();
            SuppressMicrotaskExecutionScope(const v8::Isolate::SuppressMicrotaskExecutionScope &) = delete
            v8::Isolate::SuppressMicrotaskExecutionScope &operator=(const v8::Isolate::SuppressMicrotaskExecutionScope &) = delete
        private:
            internal::Isolate *const isolate_;
            internal::MicrotaskQueue *const microtask_queue_;
        };
        class SafeForTerminationScope {
        public:
            explicit SafeForTerminationScope(v8::Isolate *isolate);
            ~SafeForTerminationScope();
            SafeForTerminationScope(const v8::Isolate::SafeForTerminationScope &) = delete
            v8::Isolate::SafeForTerminationScope &operator=(const v8::Isolate::SafeForTerminationScope &) = delete
        private:
            internal::Isolate *isolate_;
            bool prev_value_;
        };
        enum GarbageCollectionType {
            kFullGarbageCollection,
            kMinorGarbageCollection
        };
        enum UseCounterFeature {
            kUseAsm = 0,
            kBreakIterator = 1,
            kLegacyConst = 2,
            kMarkDequeOverflow = 3,
            kStoreBufferOverflow = 4,
            kSlotsBufferOverflow = 5,
            kObjectObserve = 6,
            kForcedGC = 7,
            kSloppyMode = 8,
            kStrictMode = 9,
            kStrongMode = 10,
            kRegExpPrototypeStickyGetter = 11,
            kRegExpPrototypeToString = 12,
            kRegExpPrototypeUnicodeGetter = 13,
            kIntlV8Parse = 14,
            kIntlPattern = 15,
            kIntlResolved = 16,
            kPromiseChain = 17,
            kPromiseAccept = 18,
            kPromiseDefer = 19,
            kHtmlCommentInExternalScript = 20,
            kHtmlComment = 21,
            kSloppyModeBlockScopedFunctionRedefinition = 22,
            kForInInitializer = 23,
            kArrayProtectorDirtied = 24,
            kArraySpeciesModified = 25,
            kArrayPrototypeConstructorModified = 26,
            kArrayInstanceProtoModified = 27,
            kArrayInstanceConstructorModified = 28,
            kLegacyFunctionDeclaration = 29,
            kRegExpPrototypeSourceGetter = 30,
            kRegExpPrototypeOldFlagGetter = 31,
            kDecimalWithLeadingZeroInStrictMode = 32,
            kLegacyDateParser = 33,
            kDefineGetterOrSetterWouldThrow = 34,
            kFunctionConstructorReturnedUndefined = 35,
            kAssigmentExpressionLHSIsCallInSloppy = 36,
            kAssigmentExpressionLHSIsCallInStrict = 37,
            kPromiseConstructorReturnedUndefined = 38,
            kConstructorNonUndefinedPrimitiveReturn = 39,
            kLabeledExpressionStatement = 40,
            kLineOrParagraphSeparatorAsLineTerminator = 41,
            kIndexAccessor = 42,
            kErrorCaptureStackTrace = 43,
            kErrorPrepareStackTrace = 44,
            kErrorStackTraceLimit = 45,
            kWebAssemblyInstantiation = 46,
            kDeoptimizerDisableSpeculation = 47,
            kArrayPrototypeSortJSArrayModifiedPrototype = 48,
            kFunctionTokenOffsetTooLongForToString = 49,
            kWasmSharedMemory = 50,
            kWasmThreadOpcodes = 51,
            kAtomicsNotify = 52,
            kAtomicsWake = 53,
            kCollator = 54,
            kNumberFormat = 55,
            kDateTimeFormat = 56,
            kPluralRules = 57,
            kRelativeTimeFormat = 58,
            kLocale = 59,
            kListFormat = 60,
            kSegmenter = 61,
            kStringLocaleCompare = 62,
            kStringToLocaleUpperCase = 63,
            kStringToLocaleLowerCase = 64,
            kNumberToLocaleString = 65,
            kDateToLocaleString = 66,
            kDateToLocaleDateString = 67,
            kDateToLocaleTimeString = 68,
            kAttemptOverrideReadOnlyOnPrototypeSloppy = 69,
            kAttemptOverrideReadOnlyOnPrototypeStrict = 70,
            kOptimizedFunctionWithOneShotBytecode = 71,
            kRegExpMatchIsTrueishOnNonJSRegExp = 72,
            kRegExpMatchIsFalseishOnJSRegExp = 73,
            kDateGetTimezoneOffset = 74,
            kStringNormalize = 75,
            kUseCounterFeatureCount
        };
        enum MessageErrorLevel {
            kMessageLog = (1 << 0),
            kMessageDebug = (1 << 1),
            kMessageInfo = (1 << 2),
            kMessageError = (1 << 3),
            kMessageWarning = (1 << 4),
            kMessageAll = kMessageLog | kMessageDebug | kMessageInfo | kMessageError | kMessageWarning
        };
        typedef void (*UseCounterCallback)(v8::Isolate *, v8::Isolate::UseCounterFeature);
        static v8::Isolate *Allocate();
        static void Initialize(v8::Isolate *isolate, const v8::Isolate::CreateParams &params);
        static v8::Isolate *New(const v8::Isolate::CreateParams &params);
        static v8::Isolate *GetCurrent();
        typedef bool (*AbortOnUncaughtExceptionCallback)(v8::Isolate *);
        void SetAbortOnUncaughtExceptionCallback(v8::Isolate::AbortOnUncaughtExceptionCallback callback);
        void SetHostImportModuleDynamicallyCallback(v8::HostImportModuleDynamicallyCallback callback);
        void SetHostInitializeImportMetaObjectCallback(v8::HostInitializeImportMetaObjectCallback callback);
        void SetPrepareStackTraceCallback(v8::PrepareStackTraceCallback callback);
        void MemoryPressureNotification(v8::MemoryPressureLevel level);
        void Enter();
        void Exit();
        void Dispose();
        void DumpAndResetStats();
        void DiscardThreadSpecificMetadata();
        inline void SetData(uint32_t slot, void *data) __attribute__((always_inline));
        inline void *GetData(uint32_t slot) __attribute__((always_inline));
        static inline uint32_t GetNumberOfDataSlots() __attribute__((always_inline));
        template <class T> inline MaybeLocal<T> GetDataFromSnapshotOnce(size_t index) __attribute__((always_inline));
        void GetHeapStatistics(v8::HeapStatistics *heap_statistics);
        size_t NumberOfHeapSpaces();
        bool GetHeapSpaceStatistics(v8::HeapSpaceStatistics *space_statistics, size_t index);
        size_t NumberOfTrackedHeapObjectTypes();
        bool GetHeapObjectStatisticsAtLastGC(v8::HeapObjectStatistics *object_statistics, size_t type_index);
        bool GetHeapCodeAndMetadataStatistics(v8::HeapCodeStatistics *object_statistics);
        void GetStackSample(const v8::RegisterState &state, void **frames, size_t frames_limit, v8::SampleInfo *sample_info);
        inline int64_t AdjustAmountOfExternalAllocatedMemory(int64_t change_in_bytes) __attribute__((always_inline));
        size_t NumberOfPhantomHandleResetsSinceLastCall();
        v8::HeapProfiler *GetHeapProfiler();
        void SetIdle(bool is_idle);
        ArrayBuffer::Allocator *GetArrayBufferAllocator();
        bool InContext();
        Local<v8::Context> GetCurrentContext();
        Local<v8::Context> GetEnteredContext();
        Local<v8::Context> GetEnteredOrMicrotaskContext();
        Local<v8::Context> GetIncumbentContext();
        Local<v8::Value> ThrowException(Local<v8::Value> exception);
        typedef void (*GCCallback)(v8::Isolate *, v8::GCType, v8::GCCallbackFlags);
        typedef void (*GCCallbackWithData)(v8::Isolate *, v8::GCType, v8::GCCallbackFlags, void *);
        void AddGCPrologueCallback(v8::Isolate::GCCallbackWithData callback, void *data = nullptr, v8::GCType gc_type_filter = kGCTypeAll);
        void AddGCPrologueCallback(v8::Isolate::GCCallback callback, v8::GCType gc_type_filter = kGCTypeAll);
        void RemoveGCPrologueCallback(v8::Isolate::GCCallbackWithData, void *data = nullptr);
        void RemoveGCPrologueCallback(v8::Isolate::GCCallback callback);
        void SetEmbedderHeapTracer(v8::EmbedderHeapTracer *tracer);
        v8::EmbedderHeapTracer *GetEmbedderHeapTracer();
        enum class AtomicsWaitEvent : int {
            kStartWait,
            kWokenUp,
            kTimedOut,
            kTerminatedExecution,
            kAPIStopped,
            kNotEqual
        };
        class AtomicsWaitWakeHandle {
        public:
            void Wake();
        };
        typedef void (*AtomicsWaitCallback)(v8::Isolate::AtomicsWaitEvent, Local<v8::SharedArrayBuffer>, size_t, int64_t, double, v8::Isolate::AtomicsWaitWakeHandle *, void *);
        void SetAtomicsWaitCallback(v8::Isolate::AtomicsWaitCallback callback, void *data);
        void AddGCEpilogueCallback(v8::Isolate::GCCallbackWithData callback, void *data = nullptr, v8::GCType gc_type_filter = kGCTypeAll);
        void AddGCEpilogueCallback(v8::Isolate::GCCallback callback, v8::GCType gc_type_filter = kGCTypeAll);
        void RemoveGCEpilogueCallback(v8::Isolate::GCCallbackWithData callback, void *data = nullptr);
        void RemoveGCEpilogueCallback(v8::Isolate::GCCallback callback);
        typedef size_t (*GetExternallyAllocatedMemoryInBytesCallback)();
        void SetGetExternallyAllocatedMemoryInBytesCallback(v8::Isolate::GetExternallyAllocatedMemoryInBytesCallback callback);
        void TerminateExecution();
        bool IsExecutionTerminating();
        void CancelTerminateExecution();
        void RequestInterrupt(v8::InterruptCallback callback, void *data);
        void RequestGarbageCollectionForTesting(v8::Isolate::GarbageCollectionType type);
        void SetEventLogger(v8::LogEventCallback that);
        void AddBeforeCallEnteredCallback(v8::BeforeCallEnteredCallback callback);
        void RemoveBeforeCallEnteredCallback(v8::BeforeCallEnteredCallback callback);
        void AddCallCompletedCallback(v8::CallCompletedCallback callback);
        void RemoveCallCompletedCallback(v8::CallCompletedCallback callback);
        void SetPromiseHook(v8::PromiseHook hook);
        void SetPromiseRejectCallback(v8::PromiseRejectCallback callback);
        void RunMicrotasks();
        void EnqueueMicrotask(Local<v8::Function> microtask);
        void EnqueueMicrotask(v8::MicrotaskCallback callback, void *data = nullptr);
        void SetMicrotasksPolicy(v8::MicrotasksPolicy policy);
        v8::MicrotasksPolicy GetMicrotasksPolicy() const;
        void AddMicrotasksCompletedCallback(v8::MicrotasksCompletedCallback callback);
        void RemoveMicrotasksCompletedCallback(v8::MicrotasksCompletedCallback callback);
        void SetUseCounterCallback(v8::Isolate::UseCounterCallback callback);
        void SetCounterFunction(v8::CounterLookupCallback);
        void SetCreateHistogramFunction(v8::CreateHistogramCallback);
        void SetAddHistogramSampleFunction(v8::AddHistogramSampleCallback);
        bool IdleNotificationDeadline(double deadline_in_seconds);
        void LowMemoryNotification();
        int ContextDisposedNotification(bool dependant_context = true);
        void IsolateInForegroundNotification();
        void IsolateInBackgroundNotification();
        void EnableMemorySavingsMode();
        void DisableMemorySavingsMode();
        void SetRAILMode(v8::RAILMode rail_mode);
        void IncreaseHeapLimitForDebugging();
        void RestoreOriginalHeapLimit();
        bool IsHeapLimitIncreasedForDebugging();
        void SetJitCodeEventHandler(v8::JitCodeEventOptions options, v8::JitCodeEventHandler event_handler);
        void SetStackLimit(uintptr_t stack_limit);
        void GetCodeRange(void **start, size_t *length_in_bytes);
        v8::UnwindState GetUnwindState();
        void SetFatalErrorHandler(v8::FatalErrorCallback that);
        void SetOOMErrorHandler(v8::OOMErrorCallback that);
        void AddNearHeapLimitCallback(v8::NearHeapLimitCallback callback, void *data);
        void RemoveNearHeapLimitCallback(v8::NearHeapLimitCallback callback, size_t heap_limit);
        void AutomaticallyRestoreInitialHeapLimit(double threshold_percent = 0.5);
        void SetAllowCodeGenerationFromStringsCallback(v8::AllowCodeGenerationFromStringsCallback callback);
        void SetAllowWasmCodeGenerationCallback(v8::AllowWasmCodeGenerationCallback callback);
        void SetWasmModuleCallback(v8::ExtensionCallback callback);
        void SetWasmInstanceCallback(v8::ExtensionCallback callback);
        void SetWasmStreamingCallback(v8::WasmStreamingCallback callback);
        void SetWasmThreadsEnabledCallback(v8::WasmThreadsEnabledCallback callback);
        bool IsDead();
        bool AddMessageListener(v8::MessageCallback that, Local<v8::Value> data = Local<v8::Value>());
        bool AddMessageListenerWithErrorLevel(v8::MessageCallback that, int message_levels, Local<v8::Value> data = Local<v8::Value>());
        void RemoveMessageListeners(v8::MessageCallback that);
        void SetFailedAccessCheckCallbackFunction(v8::FailedAccessCheckCallback);
        void SetCaptureStackTraceForUncaughtExceptions(bool capture, int frame_limit = 10, StackTrace::StackTraceOptions options = StackTrace::kOverview);
        void VisitExternalResources(v8::ExternalResourceVisitor *visitor);
        void VisitHandlesWithClassIds(v8::PersistentHandleVisitor *visitor);
        void VisitHandlesForPartialDependence(v8::PersistentHandleVisitor *visitor);
        void VisitWeakHandles(v8::PersistentHandleVisitor *visitor);
        bool IsInUse();
        void SetAllowAtomicsWait(bool allow);
        Isolate() = delete
        ~Isolate() = delete
        Isolate(const v8::Isolate &) = delete
        v8::Isolate &operator=(const v8::Isolate &) = delete
        void *operator new(size_t size) = delete
        void *operator new[](size_t size) = delete
        void operator delete(void *, size_t) noexcept = delete
        void operator delete[](void *, size_t) noexcept = delete
    private:
        friend template <class K, class V, class Traits> class PersistentValueMapBase;
        internal::Address *GetDataFromSnapshotOnce(size_t index);
        void ReportExternalAllocationLimitReached();
        void CheckMemoryPressure();
    };
    class StartupData {
    public:
        const char *data;
        int raw_size;
    };
    typedef bool (*EntropySource)(unsigned char *, size_t);
    typedef uintptr_t (*ReturnAddressLocationResolver)(uintptr_t);
    class V8 {
    public:
        static void SetNativesDataBlob(v8::StartupData *startup_blob);
        static void SetSnapshotDataBlob(v8::StartupData *startup_blob);
        static void SetDcheckErrorHandler(v8::DcheckErrorCallback that);
        static void SetFlagsFromString(const char *str, int length);
        static void SetFlagsFromCommandLine(int *argc, char **argv, bool remove_flags);
        static const char *GetVersion();
        static bool Initialize();
        static void SetEntropySource(v8::EntropySource source);
        static void SetReturnAddressLocationResolver(v8::ReturnAddressLocationResolver return_address_resolver);
        static bool Dispose();
        static bool InitializeICU(const char *icu_data_file = nullptr);
        static bool InitializeICUDefaultLocation(const char *exec_path, const char *icu_data_file = nullptr);
        static void InitializeExternalStartupData(const char *directory_path);
        static void InitializeExternalStartupData(const char *natives_blob, const char *snapshot_blob);
        static void InitializePlatform(v8::Platform *platform);
        static void ShutdownPlatform();
        static bool EnableWebAssemblyTrapHandler(bool use_v8_signal_handler);
    private:
        V8();
        static internal::Address *GlobalizeReference(internal::Isolate *isolate, internal::Address *handle);
        static internal::Address *GlobalizeTracedReference(internal::Isolate *isolate, internal::Address *handle, internal::Address *slot);
        static void MoveGlobalReference(internal::Address **from, internal::Address **to);
        static void MoveTracedGlobalReference(internal::Address **from, internal::Address **to);
        static internal::Address *CopyGlobalReference(internal::Address *from);
        static void DisposeGlobal(internal::Address *global_handle);
        static void DisposeTracedGlobal(internal::Address *global_handle);
        static void MakeWeak(internal::Address *location, void *data, WeakCallbackInfo<void>::Callback weak_callback, v8::WeakCallbackType type);
        static void MakeWeak(internal::Address **location_addr);
        static void *ClearWeak(internal::Address *location);
        static void SetFinalizationCallbackTraced(internal::Address *location, void *parameter, WeakCallbackInfo<void>::Callback callback);
        static void AnnotateStrongRetainer(internal::Address *location, const char *label);
        static v8::Value *Eternalize(v8::Isolate *isolate, v8::Value *handle);
        static void RegisterExternallyReferencedObject(internal::Address *location, internal::Isolate *isolate);
        friend template <class K, class V, class T> class PersistentValueMapBase;
        static void FromJustIsNothing();
        static void ToLocalEmpty();
        static void InternalFieldOutOfBounds(int index);
        friend template <class T> class Global;
        friend template <class T> class Local;
        friend template <class T> class MaybeLocal;
        friend template <class T> class Maybe;
        friend template <class T> class TracedGlobal;
        friend template <class T> class WeakCallbackInfo;
        friend template <class T> class Eternal;
        friend template <class T> class PersistentBase;
        friend template <class T, class M = NonCopyablePersistentTraits<T>> class Persistent;
        friend  class Context;
    };
    class SnapshotCreator {
    public:
        enum class FunctionCodeHandling : int {
            kClear,
            kKeep
        };
        SnapshotCreator(v8::Isolate *isolate, const intptr_t *external_references = nullptr, v8::StartupData *existing_blob = nullptr);
        SnapshotCreator(const intptr_t *external_references = nullptr, v8::StartupData *existing_blob = nullptr);
        ~SnapshotCreator();
        v8::Isolate *GetIsolate();
        void SetDefaultContext(Local<v8::Context> context, v8::SerializeInternalFieldsCallback callback = v8::SerializeInternalFieldsCallback());
        size_t AddContext(Local<v8::Context> context, v8::SerializeInternalFieldsCallback callback = v8::SerializeInternalFieldsCallback());
        size_t AddTemplate(Local<v8::Template> template_obj);
        template <class T> inline size_t AddData(Local<v8::Context> context, Local<T> object) __attribute__((always_inline));
        template <class T> inline size_t AddData(Local<T> object) __attribute__((always_inline));
        v8::StartupData CreateBlob(v8::SnapshotCreator::FunctionCodeHandling function_code_handling);
        SnapshotCreator(const v8::SnapshotCreator &) = delete
        void operator=(const v8::SnapshotCreator &) = delete
    private:
        size_t AddData(Local<v8::Context> context, internal::Address object);
        size_t AddData(internal::Address object);
        void *data_;
    };
    template <class T> class Maybe {
    public:
        inline bool IsNothing() const __attribute__((always_inline))         inline bool IsJust() const __attribute__((always_inline))         inline T ToChecked() const __attribute__((always_inline))         inline void Check() const __attribute__((always_inline))         inline bool To(T *out) const __attribute__((always_inline)) __attribute__((warn_unused_result))         inline T FromJust() const __attribute__((always_inline))         inline T FromMaybe(const T &default_value) const __attribute__((always_inline))         inline bool operator==(const Maybe<T> &other) const __attribute__((always_inline))         inline bool operator!=(const Maybe<T> &other) const __attribute__((always_inline))     private:
        Maybe<T>()         explicit Maybe<T>(const T &t)         bool has_value_;
        T value_;
        friend template <class U> Maybe<U> Nothing();
        friend template <class U> Maybe<U> Just(const U &u);
    };
    template <class T> inline Maybe<T> Nothing()     template <class T> inline Maybe<T> Just(const T &t)     template<> class Maybe<void> {
    public:
        inline bool IsNothing() const __attribute__((always_inline))         {
            return !this->is_valid_;
        }
        inline bool IsJust() const __attribute__((always_inline))         {
            return this->is_valid_;
        }
        inline bool operator==(const v8::Maybe<void> &other) const __attribute__((always_inline))         {
            return this->IsJust() == other.IsJust();
        }
        inline bool operator!=(const v8::Maybe<void> &other) const __attribute__((always_inline))         {
            return !this->operator==(other);
        }
    private:
        struct JustTag {
        };
        Maybe() : is_valid_(false)         {
        }
        explicit Maybe(v8::Maybe<void>::JustTag) : is_valid_(true)         {
        }
        bool is_valid_;
        friend template <class U> Maybe<U> Nothing();
        friend Maybe<void> JustVoid();
    };
    inline Maybe<void> JustVoid()     {
        return Maybe<void>(Maybe<void>::JustTag());
    }
    class TryCatch {
    public:
        explicit TryCatch(v8::Isolate *isolate);
        ~TryCatch();
        bool HasCaught() const;
        bool CanContinue() const;
        bool HasTerminated() const;
        Local<v8::Value> ReThrow();
        Local<v8::Value> Exception() const;
        MaybeLocal<v8::Value> StackTrace(Local<v8::Context> context) const __attribute__((warn_unused_result));
        Local<v8::Message> Message() const;
        void Reset();
        void SetVerbose(bool value);
        bool IsVerbose() const;
        void SetCaptureMessage(bool value);
        static void *JSStackComparableAddress(v8::TryCatch *handler)         {
            if (handler == nullptr)
                return nullptr;
            return handler->js_stack_comparable_address_;
        }
        TryCatch(const v8::TryCatch &) = delete
        void operator=(const v8::TryCatch &) = delete
    private:
        void *operator new(size_t size);
        void *operator new[](size_t size);
        void operator delete(void *, size_t) noexcept;
        void operator delete[](void *, size_t) noexcept;
        void ResetInternal();
        internal::Isolate *isolate_;
        v8::TryCatch *next_;
        void *exception_;
        void *message_obj_;
        void *js_stack_comparable_address_;
        bool is_verbose_ : 1;
        bool can_continue_ : 1;
        bool capture_message_ : 1;
        bool rethrow_ : 1;
        bool has_terminated_ : 1;
        friend  class internal::Isolate;
    };
    class ExtensionConfiguration {
    public:
        ExtensionConfiguration() : name_count_(0), names_(nullptr)         {
        }
        ExtensionConfiguration(int name_count, const char *names[]) : name_count_(name_count), names_(names)         {
        }
        const char **begin() const         {
            return &this->names_[0];
        }
        const char **end() const         {
            return &this->names_[this->name_count_];
        }
    private:
        const int name_count_;
        const char **names_;
    };
    class Context {
    public:
        Local<v8::Object> Global();
        void DetachGlobal();
        static Local<v8::Context> New(v8::Isolate *isolate, v8::ExtensionConfiguration *extensions = nullptr, MaybeLocal<v8::ObjectTemplate> global_template = MaybeLocal<v8::ObjectTemplate>(), MaybeLocal<v8::Value> global_object = MaybeLocal<v8::Value>(), v8::DeserializeInternalFieldsCallback internal_fields_deserializer = v8::DeserializeInternalFieldsCallback());
        static MaybeLocal<v8::Context> FromSnapshot(v8::Isolate *isolate, size_t context_snapshot_index, v8::DeserializeInternalFieldsCallback embedder_fields_deserializer = v8::DeserializeInternalFieldsCallback(), v8::ExtensionConfiguration *extensions = nullptr, MaybeLocal<v8::Value> global_object = MaybeLocal<v8::Value>());
        static MaybeLocal<v8::Object> NewRemoteContext(v8::Isolate *isolate, Local<v8::ObjectTemplate> global_template, MaybeLocal<v8::Value> global_object = MaybeLocal<v8::Value>());
        void SetSecurityToken(Local<v8::Value> token);
        void UseDefaultSecurityToken();
        Local<v8::Value> GetSecurityToken();
        void Enter();
        void Exit();
        v8::Isolate *GetIsolate();
        enum EmbedderDataFields {
            kDebugIdIndex = 0
        };
        uint32_t GetNumberOfEmbedderDataFields();
        inline Local<v8::Value> GetEmbedderData(int index) __attribute__((always_inline));
        Local<v8::Object> GetExtrasBindingObject();
        void SetEmbedderData(int index, Local<v8::Value> value);
        inline void *GetAlignedPointerFromEmbedderData(int index) __attribute__((always_inline));
        void SetAlignedPointerInEmbedderData(int index, void *value);
        void AllowCodeGenerationFromStrings(bool allow);
        bool IsCodeGenerationFromStringsAllowed();
        void SetErrorMessageForCodeGenerationFromStrings(Local<v8::String> message);
        template <class T> inline MaybeLocal<T> GetDataFromSnapshotOnce(size_t index) __attribute__((always_inline));
        class Scope {
        public:
            inline explicit Scope(Local<v8::Context> context) : context_(context) __attribute__((always_inline))             {
                this->context_->Enter();
            }
            inline ~Scope() noexcept __attribute__((always_inline))             {
                this->context_->Exit();
            }
        private:
            Local<v8::Context> context_;
        };
        class final BackupIncumbentScope {
        public:
            explicit BackupIncumbentScope(Local<v8::Context> backup_incumbent_context);
            ~BackupIncumbentScope();
            uintptr_t JSStackComparableAddress() const             {
                return this->js_stack_comparable_address_;
            }
        private:
            friend  class internal::Isolate;
            Local<v8::Context> backup_incumbent_context_;
            uintptr_t js_stack_comparable_address_ = 0;
            const v8::Context::BackupIncumbentScope *prev_ = nullptr;
        };
    private:
        friend  class Value;
        friend  class Script;
        friend  class Object;
        friend  class Function;
        internal::Address *GetDataFromSnapshotOnce(size_t index);
        Local<v8::Value> SlowGetEmbedderData(int index);
        void *SlowGetAlignedPointerFromEmbedderData(int index);
    };
    class Unlocker {
    public:
        inline explicit Unlocker(v8::Isolate *isolate) __attribute__((always_inline))         {
            this->Initialize(isolate);
        }
        ~Unlocker();
    private:
        void Initialize(v8::Isolate *isolate);
        internal::Isolate *isolate_;
    };
    class Locker {
    public:
        inline explicit Locker(v8::Isolate *isolate) __attribute__((always_inline))         {
            this->Initialize(isolate);
        }
        ~Locker();
        static bool IsLocked(v8::Isolate *isolate);
        static bool IsActive();
        Locker(const v8::Locker &) = delete
        void operator=(const v8::Locker &) = delete
    private:
        void Initialize(v8::Isolate *isolate);
        bool has_lock_;
        bool top_level_;
        internal::Isolate *isolate_;
    };
    class Unwinder {
    public:
        static bool TryUnwindV8Frames(const v8::UnwindState &unwind_state, v8::RegisterState *register_state, const void *stack_base);
        static bool PCIsInV8(const v8::UnwindState &unwind_state, void *pc);
    };
    template <class T> Local<T> Local<T>::New(v8::Isolate *isolate, Local<T> that)     template <class T> Local<T> Local<T>::New(v8::Isolate *isolate, const PersistentBase<T> &that)     template <class T> Local<T> Local<T>::New(v8::Isolate *isolate, const TracedGlobal<T> &that)     template <class T> Local<T> Local<T>::New(v8::Isolate *isolate, T *that)     template <class T> template <class S> void Eternal<T>::Set(v8::Isolate *isolate, Local<S> handle)     template <class T> Local<T> Eternal<T>::Get(v8::Isolate *isolate) const     template <class T> Local<T> MaybeLocal<T>::ToLocalChecked()     {
        if ((__builtin_expect(!!(this->val_ == nullptr), 0)))
            V8::ToLocalEmpty();
        return Local<T>(this->val_);
    }
    template <class T> void *WeakCallbackInfo<T>::GetInternalField(int index) const     template <class T> T *PersistentBase<T>::New(v8::Isolate *isolate, T *that)     template <class T, class M> template <class S, class M2> void Persistent<T, M>::Copy(const Persistent<S, M2> &that)     template <class T> bool PersistentBase<T>::IsIndependent() const     template <class T> bool PersistentBase<T>::IsNearDeath() const     template <class T> bool PersistentBase<T>::IsWeak() const     template <class T> void PersistentBase<T>::Reset()     template <class T> template <class S> void PersistentBase<T>::Reset(v8::Isolate *isolate, const Local<S> &other)     template <class T> template <class S> void PersistentBase<T>::Reset(v8::Isolate *isolate, const PersistentBase<S> &other)     template <class T> template <typename P> inline void PersistentBase<T>::SetWeak(P *parameter, typename WeakCallbackInfo<P>::Callback callback, v8::WeakCallbackType type) __attribute__((always_inline))     template <class T> void PersistentBase<T>::SetWeak()     template <class T> template <typename P> P *PersistentBase<T>::ClearWeak()     template <class T> void PersistentBase<T>::AnnotateStrongRetainer(const char *label)     template <class T> void PersistentBase<T>::RegisterExternalReference(v8::Isolate *isolate) const     template <class T> void PersistentBase<T>::MarkIndependent()     template <class T> void PersistentBase<T>::MarkActive()     template <class T> void PersistentBase<T>::SetWrapperClassId(uint16_t class_id)     template <class T> uint16_t PersistentBase<T>::WrapperClassId() const     template <class T> Global<T>::Global<T>(Global<T> &&other)     template <class T> template <class S> Global<T> &Global<T>::operator=(Global<S> &&rhs)     template <class T> T *TracedGlobal<T>::New(v8::Isolate *isolate, T *that, T **slot)     template <class T> void TracedGlobal<T>::Reset()     template <class T> template <class S> void TracedGlobal<T>::Reset(v8::Isolate *isolate, const Local<S> &other)     template <class T> TracedGlobal<T>::TracedGlobal<T>(TracedGlobal<T> &&other)     template <class T> template <class S> TracedGlobal<T> &TracedGlobal<T>::operator=(TracedGlobal<S> &&rhs)     template <class T> void TracedGlobal<T>::SetWrapperClassId(uint16_t class_id)     template <class T> uint16_t TracedGlobal<T>::WrapperClassId() const     template <class T> void TracedGlobal<T>::SetFinalizationCallback(void *parameter, typename WeakCallbackInfo<void>::Callback callback)     template <typename T> ReturnValue<T>::ReturnValue<T>(internal::Address *slot)     template <typename T> template <typename S> void ReturnValue<T>::Set(const Persistent<S> &handle)     template <typename T> template <typename S> void ReturnValue<T>::Set(const Global<S> &handle)     template <typename T> template <typename S> void ReturnValue<T>::Set(const TracedGlobal<S> &handle)     template <typename T> template <typename S> void ReturnValue<T>::Set(const Local<S> handle)     template <typename T> void ReturnValue<T>::Set(double i)     template <typename T> void ReturnValue<T>::Set(int32_t i)     template <typename T> void ReturnValue<T>::Set(uint32_t i)     template <typename T> void ReturnValue<T>::Set(bool value)     template <typename T> void ReturnValue<T>::SetNull()     template <typename T> void ReturnValue<T>::SetUndefined()     template <typename T> void ReturnValue<T>::SetEmptyString()     template <typename T> v8::Isolate *ReturnValue<T>::GetIsolate() const     template <typename T> Local<v8::Value> ReturnValue<T>::Get() const     template <typename T> template <typename S> void ReturnValue<T>::Set(S *whatever)     template <typename T> internal::Address ReturnValue<T>::GetDefaultValue()     template <typename T> FunctionCallbackInfo<T>::FunctionCallbackInfo<T>(internal::Address *implicit_args, internal::Address *values, int length)     template <typename T> Local<v8::Value> FunctionCallbackInfo<T>::operator[](int i) const     template <typename T> Local<v8::Object> FunctionCallbackInfo<T>::This() const     template <typename T> Local<v8::Object> FunctionCallbackInfo<T>::Holder() const     template <typename T> Local<v8::Value> FunctionCallbackInfo<T>::NewTarget() const     template <typename T> Local<v8::Value> FunctionCallbackInfo<T>::Data() const     template <typename T> v8::Isolate *FunctionCallbackInfo<T>::GetIsolate() const     template <typename T> ReturnValue<T> FunctionCallbackInfo<T>::GetReturnValue() const     template <typename T> bool FunctionCallbackInfo<T>::IsConstructCall() const     template <typename T> int FunctionCallbackInfo<T>::Length() const     ScriptOrigin::ScriptOrigin(Local<v8::Value> resource_name, Local<v8::Integer> resource_line_offset = Local<v8::Integer>(), Local<v8::Integer> resource_column_offset = Local<v8::Integer>(), Local<v8::Boolean> resource_is_shared_cross_origin = Local<v8::Boolean>(), Local<v8::Integer> script_id = Local<v8::Integer>(), Local<v8::Value> source_map_url = Local<v8::Value>(), Local<v8::Boolean> resource_is_opaque = Local<v8::Boolean>(), Local<v8::Boolean> is_wasm = Local<v8::Boolean>(), Local<v8::Boolean> is_module = Local<v8::Boolean>(), Local<v8::PrimitiveArray> host_defined_options = Local<v8::PrimitiveArray>()) : resource_name_(resource_name), resource_line_offset_(resource_line_offset), resource_column_offset_(resource_column_offset), options_(!resource_is_shared_cross_origin.IsEmpty() && resource_is_shared_cross_origin->IsTrue(), !resource_is_opaque.IsEmpty() && resource_is_opaque->IsTrue(), !is_wasm.IsEmpty() && is_wasm->IsTrue(), !is_module.IsEmpty() && is_module->IsTrue()), script_id_(script_id), source_map_url_(source_map_url), host_defined_options_(host_defined_options)     {
    }
    Local<v8::Value> ScriptOrigin::ResourceName() const     {
        return this->resource_name_;
    }
    Local<v8::PrimitiveArray> ScriptOrigin::HostDefinedOptions() const     {
        return this->host_defined_options_;
    }
    Local<v8::Integer> ScriptOrigin::ResourceLineOffset() const     {
        return this->resource_line_offset_;
    }
    Local<v8::Integer> ScriptOrigin::ResourceColumnOffset() const     {
        return this->resource_column_offset_;
    }
    Local<v8::Integer> ScriptOrigin::ScriptID() const     {
        return this->script_id_;
    }
    Local<v8::Value> ScriptOrigin::SourceMapUrl() const     {
        return this->source_map_url_;
    }
    ScriptCompiler::Source::Source(Local<v8::String> string, const v8::ScriptOrigin &origin, v8::ScriptCompiler::CachedData *data = nullptr) : source_string(string), resource_name(origin.ResourceName()), resource_line_offset(origin.ResourceLineOffset()), resource_column_offset(origin.ResourceColumnOffset()), resource_options(origin.Options()), source_map_url(origin.SourceMapUrl()), host_defined_options(origin.HostDefinedOptions()), cached_data(data)     {
    }
    ScriptCompiler::Source::Source(Local<v8::String> string, v8::ScriptCompiler::CachedData *data = nullptr) : source_string(string), resource_name(), resource_line_offset(), resource_column_offset(), resource_options(), source_map_url(), host_defined_options(), cached_data(data)     {
    }
    ScriptCompiler::Source::~Source() noexcept     {
        delete this->cached_data;
    }
    const ScriptCompiler::CachedData *ScriptCompiler::Source::GetCachedData() const     {
        return this->cached_data;
    }
    const v8::ScriptOriginOptions &ScriptCompiler::Source::GetResourceOptions() const     {
        return this->resource_options;
    }
    Local<v8::Boolean> Boolean::New(v8::Isolate *isolate, bool value)     {
        return value ? True(isolate) : False(isolate);
    }
    void Template::Set(v8::Isolate *isolate, const char *name, Local<v8::Data> value)     {
        this->Set(String::NewFromUtf8(isolate, name, NewStringType::kInternalized).ToLocalChecked(), value);
    }
    v8::FunctionTemplate *FunctionTemplate::Cast(v8::Data *data)     {
        return reinterpret_cast<v8::FunctionTemplate *>(data);
    }
    v8::ObjectTemplate *ObjectTemplate::Cast(v8::Data *data)     {
        return reinterpret_cast<v8::ObjectTemplate *>(data);
    }
    v8::Signature *Signature::Cast(v8::Data *data)     {
        return reinterpret_cast<v8::Signature *>(data);
    }
    v8::AccessorSignature *AccessorSignature::Cast(v8::Data *data)     {
        return reinterpret_cast<v8::AccessorSignature *>(data);
    }
    Local<v8::Value> Object::GetInternalField(int index)     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A obj = *reinterpret_cast<A *>(this);
        auto instance_type = I::GetInstanceType(obj);
        if (instance_type == I::kJSObjectType || instance_type == I::kJSApiObjectType || instance_type == I::kJSSpecialApiObjectType) {
            int offset = I::kJSObjectHeaderSizeForEmbedderFields + (I::kEmbedderDataSlotSize * index);
            A value = I::ReadTaggedAnyField(obj, offset);
            internal::Isolate *isolate = internal::IsolateFromNeverReadOnlySpaceObject(obj);
            A *result = HandleScope::CreateHandle(isolate, value);
            return Local<v8::Value>(reinterpret_cast<v8::Value *>(result));
        }
        return this->SlowGetInternalField(index);
    }
    void *Object::GetAlignedPointerFromInternalField(int index)     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A obj = *reinterpret_cast<A *>(this);
        auto instance_type = I::GetInstanceType(obj);
        if ((__builtin_expect(!!(instance_type == I::kJSObjectType || instance_type == I::kJSApiObjectType || instance_type == I::kJSSpecialApiObjectType), 1))) {
            int offset = I::kJSObjectHeaderSizeForEmbedderFields + (I::kEmbedderDataSlotSize * index);
            return I::ReadRawField<void *>(obj, offset);
        }
        return this->SlowGetAlignedPointerFromInternalField(index);
    }
    v8::String *String::Cast(v8::Value *value)     {
        return static_cast<v8::String *>(value);
    }
    Local<v8::String> String::Empty(v8::Isolate *isolate)     {
        typedef internal::Address S;
        typedef internal::Internals I;
        I::CheckInitialized(isolate);
        S *slot = I::GetRoot(isolate, I::kEmptyStringRootIndex);
        return Local<v8::String>(reinterpret_cast<v8::String *>(slot));
    }
    String::ExternalStringResource *String::GetExternalStringResource() const     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A obj = *reinterpret_cast<const A *>(this);
        v8::String::ExternalStringResource *result;
        if (I::IsExternalTwoByteString(I::GetInstanceType(obj))) {
            void *value = I::ReadRawField<void *>(obj, I::kStringResourceOffset);
            result = reinterpret_cast<String::ExternalStringResource *>(value);
        } else {
            result = this->GetExternalStringResourceSlow();
        }
        return result;
    }
    String::ExternalStringResourceBase *String::GetExternalStringResourceBase(String::Encoding *encoding_out) const     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A obj = *reinterpret_cast<const A *>(this);
        int type = I::GetInstanceType(obj) & I::kFullStringRepresentationMask;
        *encoding_out = static_cast<v8::String::Encoding>(type & I::kStringEncodingMask);
        v8::String::ExternalStringResourceBase *resource;
        if (type == I::kExternalOneByteRepresentationTag || type == I::kExternalTwoByteRepresentationTag) {
            void *value = I::ReadRawField<void *>(obj, I::kStringResourceOffset);
            resource = static_cast<v8::String::ExternalStringResourceBase *>(value);
        } else {
            resource = this->GetExternalStringResourceBaseSlow(encoding_out);
        }
        return resource;
    }
    bool Value::IsUndefined() const     {
        return this->QuickIsUndefined();
    }
    bool Value::QuickIsUndefined() const     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A obj = *reinterpret_cast<const A *>(this);
        if (!I::HasHeapObjectTag(obj))
            return false;
        if (I::GetInstanceType(obj) != I::kOddballType)
            return false;
        return (I::GetOddballKind(obj) == I::kUndefinedOddballKind);
    }
    bool Value::IsNull() const     {
        return this->QuickIsNull();
    }
    bool Value::QuickIsNull() const     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A obj = *reinterpret_cast<const A *>(this);
        if (!I::HasHeapObjectTag(obj))
            return false;
        if (I::GetInstanceType(obj) != I::kOddballType)
            return false;
        return (I::GetOddballKind(obj) == I::kNullOddballKind);
    }
    bool Value::IsNullOrUndefined() const     {
        return this->QuickIsNullOrUndefined();
    }
    bool Value::QuickIsNullOrUndefined() const     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A obj = *reinterpret_cast<const A *>(this);
        if (!I::HasHeapObjectTag(obj))
            return false;
        if (I::GetInstanceType(obj) != I::kOddballType)
            return false;
        int kind = I::GetOddballKind(obj);
        return kind == I::kNullOddballKind || kind == I::kUndefinedOddballKind;
    }
    bool Value::IsString() const     {
        return this->QuickIsString();
    }
    bool Value::QuickIsString() const     {
        typedef internal::Address A;
        typedef internal::Internals I;
        A obj = *reinterpret_cast<const A *>(this);
        if (!I::HasHeapObjectTag(obj))
            return false;
        return (I::GetInstanceType(obj) < I::kFirstNonstringType);
    }
    template <class T> v8::Value *Value::Cast(T *value)     v8::Boolean *Boolean::Cast(v8::Value *value)     {
        return static_cast<v8::Boolean *>(value);
    }
    v8::Name *Name::Cast(v8::Value *value)     {
        return static_cast<v8::Name *>(value);
    }
    v8::Symbol *Symbol::Cast(v8::Value *value)     {
        return static_cast<v8::Symbol *>(value);
    }
    v8::Private *Private::Cast(v8::Data *data)     {
        return reinterpret_cast<v8::Private *>(data);
    }
    v8::Number *Number::Cast(v8::Value *value)     {
        return static_cast<v8::Number *>(value);
    }
    v8::Integer *Integer::Cast(v8::Value *value)     {
        return static_cast<v8::Integer *>(value);
    }
    v8::Int32 *Int32::Cast(v8::Value *value)     {
        return static_cast<v8::Int32 *>(value);
    }
    v8::Uint32 *Uint32::Cast(v8::Value *value)     {
        return static_cast<v8::Uint32 *>(value);
    }
    v8::BigInt *BigInt::Cast(v8::Value *value)     {
        return static_cast<v8::BigInt *>(value);
    }
    v8::Date *Date::Cast(v8::Value *value)     {
        return static_cast<v8::Date *>(value);
    }
    v8::StringObject *StringObject::Cast(v8::Value *value)     {
        return static_cast<v8::StringObject *>(value);
    }
    v8::SymbolObject *SymbolObject::Cast(v8::Value *value)     {
        return static_cast<v8::SymbolObject *>(value);
    }
    v8::NumberObject *NumberObject::Cast(v8::Value *value)     {
        return static_cast<v8::NumberObject *>(value);
    }
    v8::BigIntObject *BigIntObject::Cast(v8::Value *value)     {
        return static_cast<v8::BigIntObject *>(value);
    }
    v8::BooleanObject *BooleanObject::Cast(v8::Value *value)     {
        return static_cast<v8::BooleanObject *>(value);
    }
    v8::RegExp *RegExp::Cast(v8::Value *value)     {
        return static_cast<v8::RegExp *>(value);
    }
    v8::Object *Object::Cast(v8::Value *value)     {
        return static_cast<v8::Object *>(value);
    }
    v8::Array *Array::Cast(v8::Value *value)     {
        return static_cast<v8::Array *>(value);
    }
    v8::Map *Map::Cast(v8::Value *value)     {
        return static_cast<v8::Map *>(value);
    }
    v8::Set *Set::Cast(v8::Value *value)     {
        return static_cast<v8::Set *>(value);
    }
    v8::Promise *Promise::Cast(v8::Value *value)     {
        return static_cast<v8::Promise *>(value);
    }
    v8::Proxy *Proxy::Cast(v8::Value *value)     {
        return static_cast<v8::Proxy *>(value);
    }
    v8::WasmModuleObject *WasmModuleObject::Cast(v8::Value *value)     {
        return static_cast<v8::WasmModuleObject *>(value);
    }
    Promise::Resolver *Promise::Resolver::Cast(v8::Value *value)     {
        return static_cast<Promise::Resolver *>(value);
    }
    v8::ArrayBuffer *ArrayBuffer::Cast(v8::Value *value)     {
        return static_cast<v8::ArrayBuffer *>(value);
    }
    v8::ArrayBufferView *ArrayBufferView::Cast(v8::Value *value)     {
        return static_cast<v8::ArrayBufferView *>(value);
    }
    v8::TypedArray *TypedArray::Cast(v8::Value *value)     {
        return static_cast<v8::TypedArray *>(value);
    }
    v8::Uint8Array *Uint8Array::Cast(v8::Value *value)     {
        return static_cast<v8::Uint8Array *>(value);
    }
    v8::Int8Array *Int8Array::Cast(v8::Value *value)     {
        return static_cast<v8::Int8Array *>(value);
    }
    v8::Uint16Array *Uint16Array::Cast(v8::Value *value)     {
        return static_cast<v8::Uint16Array *>(value);
    }
    v8::Int16Array *Int16Array::Cast(v8::Value *value)     {
        return static_cast<v8::Int16Array *>(value);
    }
    v8::Uint32Array *Uint32Array::Cast(v8::Value *value)     {
        return static_cast<v8::Uint32Array *>(value);
    }
    v8::Int32Array *Int32Array::Cast(v8::Value *value)     {
        return static_cast<v8::Int32Array *>(value);
    }
    v8::Float32Array *Float32Array::Cast(v8::Value *value)     {
        return static_cast<v8::Float32Array *>(value);
    }
    v8::Float64Array *Float64Array::Cast(v8::Value *value)     {
        return static_cast<v8::Float64Array *>(value);
    }
    v8::BigInt64Array *BigInt64Array::Cast(v8::Value *value)     {
        return static_cast<v8::BigInt64Array *>(value);
    }
    v8::BigUint64Array *BigUint64Array::Cast(v8::Value *value)     {
        return static_cast<v8::BigUint64Array *>(value);
    }
    v8::Uint8ClampedArray *Uint8ClampedArray::Cast(v8::Value *value)     {
        return static_cast<v8::Uint8ClampedArray *>(value);
    }
    v8::DataView *DataView::Cast(v8::Value *value)     {
        return static_cast<v8::DataView *>(value);
    }
    v8::SharedArrayBuffer *SharedArrayBuffer::Cast(v8::Value *value)     {
        return static_cast<v8::SharedArrayBuffer *>(value);
    }
    v8::Function *Function::Cast(v8::Value *value)     {
        return static_cast<v8::Function *>(value);
    }
    v8::External *External::Cast(v8::Value *value)     {
        return static_cast<v8::External *>(value);
    }
    template <typename T> v8::Isolate *PropertyCallbackInfo<T>::GetIsolate() const     template <typename T> Local<v8::Value> PropertyCallbackInfo<T>::Data() const     template <typename T> Local<v8::Object> PropertyCallbackInfo<T>::This() const     template <typename T> Local<v8::Object> PropertyCallbackInfo<T>::Holder() const     template <typename T> ReturnValue<T> PropertyCallbackInfo<T>::GetReturnValue() const     template <typename T> bool PropertyCallbackInfo<T>::ShouldThrowOnError() const     Local<v8::Primitive> Undefined(v8::Isolate *isolate)     {
        typedef internal::Address S;
        typedef internal::Internals I;
        I::CheckInitialized(isolate);
        S *slot = I::GetRoot(isolate, I::kUndefinedValueRootIndex);
        return Local<v8::Primitive>(reinterpret_cast<v8::Primitive *>(slot));
    }
    Local<v8::Primitive> Null(v8::Isolate *isolate)     {
        typedef internal::Address S;
        typedef internal::Internals I;
        I::CheckInitialized(isolate);
        S *slot = I::GetRoot(isolate, I::kNullValueRootIndex);
        return Local<v8::Primitive>(reinterpret_cast<v8::Primitive *>(slot));
    }
    Local<v8::Boolean> True(v8::Isolate *isolate)     {
        typedef internal::Address S;
        typedef internal::Internals I;
        I::CheckInitialized(isolate);
        S *slot = I::GetRoot(isolate, I::kTrueValueRootIndex);
        return Local<v8::Boolean>(reinterpret_cast<v8::Boolean *>(slot));
    }
    Local<v8::Boolean> False(v8::Isolate *isolate)     {
        typedef internal::Address S;
        typedef internal::Internals I;
        I::CheckInitialized(isolate);
        S *slot = I::GetRoot(isolate, I::kFalseValueRootIndex);
        return Local<v8::Boolean>(reinterpret_cast<v8::Boolean *>(slot));
    }
    void Isolate::SetData(uint32_t slot, void *data)     {
        typedef internal::Internals I;
        I::SetEmbedderData(this, slot, data);
    }
    void *Isolate::GetData(uint32_t slot)     {
        typedef internal::Internals I;
        return I::GetEmbedderData(this, slot);
    }
    uint32_t Isolate::GetNumberOfDataSlots()     {
        typedef internal::Internals I;
        return I::kNumIsolateDataSlots;
    }
    template <class T> MaybeLocal<T> Isolate::GetDataFromSnapshotOnce(size_t index)     int64_t Isolate::AdjustAmountOfExternalAllocatedMemory(int64_t change_in_bytes)     {
        typedef internal::Internals I;
        constexpr int64_t kMemoryReducerActivationLimit = 32 * 1024 * 1024;
        int64_t *external_memory = reinterpret_cast<int64_t *>(reinterpret_cast<uint8_t *>(this) + I::kExternalMemoryOffset);
        int64_t *external_memory_limit = reinterpret_cast<int64_t *>(reinterpret_cast<uint8_t *>(this) + I::kExternalMemoryLimitOffset);
        int64_t *external_memory_at_last_mc = reinterpret_cast<int64_t *>(reinterpret_cast<uint8_t *>(this) + I::kExternalMemoryAtLastMarkCompactOffset);
        const int64_t amount = *external_memory + change_in_bytes;
        *external_memory = amount;
        int64_t allocation_diff_since_last_mc = *external_memory - *external_memory_at_last_mc;
        if (allocation_diff_since_last_mc > kMemoryReducerActivationLimit) {
            this->CheckMemoryPressure();
        }
        if (change_in_bytes < 0) {
            const int64_t lower_limit = *external_memory_limit + change_in_bytes;
            if (lower_limit > I::kExternalAllocationSoftLimit)
                *external_memory_limit = lower_limit;
        } else if (change_in_bytes > 0 && amount > *external_memory_limit) {
            this->ReportExternalAllocationLimitReached();
        }
        return *external_memory;
    }
    Local<v8::Value> Context::GetEmbedderData(int index)     {
        typedef internal::Address A;
        typedef internal::Internals I;
        internal::Isolate *isolate = internal::IsolateFromNeverReadOnlySpaceObject(*reinterpret_cast<A *>(this));
        A *result = HandleScope::CreateHandle(isolate, I::ReadEmbedderData<A>(this, index));
        return Local<v8::Value>(reinterpret_cast<v8::Value *>(result));
    }
    void *Context::GetAlignedPointerFromEmbedderData(int index)     {
        typedef internal::Internals I;
        return I::ReadEmbedderData<void *>(this, index);
    }
    template <class T> MaybeLocal<T> Context::GetDataFromSnapshotOnce(size_t index)     template <class T> size_t SnapshotCreator::AddData(Local<v8::Context> context, Local<T> object)     template <class T> size_t SnapshotCreator::AddData(Local<T> object) }
